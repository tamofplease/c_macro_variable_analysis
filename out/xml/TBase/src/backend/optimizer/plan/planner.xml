<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/optimizer/plan/planner.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * planner.c
 *      The query optimizer external interface.
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/optimizer/plan/planner.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAgg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/bipartite_match.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/knapsack.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>OPTIMIZER_DEBUG</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/print.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/plancat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/subselect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/dsm_impl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/prepare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/planner.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/selfuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/distribution.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* GUC parameters */</comment>
<decl_stmt><decl><type><name>double</name></type>        <name>cursor_tuple_fraction</name> <init>= <expr><name>DEFAULT_CURSOR_TUPLE_FRACTION</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>            <name>force_parallel_mode</name> <init>= <expr><name>FORCE_PARALLEL_OFF</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Hook for plugins to get control in planner() */</comment>
<decl_stmt><decl><type><name>planner_hook_type</name></type> <name>planner_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Hook for plugins to get control when grouping_planner() plans upper rels */</comment>
<decl_stmt><decl><type><name>create_upper_paths_hook_type</name></type> <name>create_upper_paths_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><name>bool</name></type> <name>olap_optimizer</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>enable_distinct_optimizer</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Expression kind codes for preprocess_expression */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_QUAL</name></cpp:macro>                <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_TARGET</name></cpp:macro>                <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_RTFUNC</name></cpp:macro>                <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_RTFUNC_LATERAL</name></cpp:macro>        <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_VALUES</name></cpp:macro>                <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_VALUES_LATERAL</name></cpp:macro>        <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_LIMIT</name></cpp:macro>                <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_APPINFO</name></cpp:macro>            <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_PHV</name></cpp:macro>                <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_TABLESAMPLE</name></cpp:macro>        <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_ARBITER_ELEM</name></cpp:macro>        <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_TABLEFUNC</name></cpp:macro>            <cpp:value>11</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPRKIND_TABLEFUNC_LATERAL</name></cpp:macro>    <cpp:value>12</cpp:value></cpp:define>

<comment type="block">/* Passthrough data for standard_qp_callback */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>            <comment type="block">/* preprocessed query targetlist */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>activeWindows</name></decl>;</decl_stmt>    <comment type="block">/* active windows, if any */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>groupClause</name></decl>;</decl_stmt>    <comment type="block">/* overrides parse-&gt;groupClause */</comment>
}</block></struct></type> <name>standard_qp_extra</name>;</typedef>

<comment type="block">/*
 * Data specific to grouping sets
 */</comment>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>rollups</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>hash_sets_idx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>dNumHashGroups</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>any_hashable</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>unsortable_refs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>unhashable_refs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>unsortable_sets</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name>           <modifier>*</modifier></type><name>tleref_to_colnum_map</name></decl>;</decl_stmt>
}</block></struct></type> <name>grouping_sets_data</name>;</typedef>

<comment type="block">/* Local functions */</comment>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>preprocess_expression</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>preprocess_qual_conditions</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>inheritance_planner</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>grouping_planner</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inheritance_update</name></decl></parameter>,
                 <parameter><decl><type><name>double</name></type> <name>tuple_fraction</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>grouping_sets_data</name> <modifier>*</modifier></type><name>preprocess_grouping_sets</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>remap_to_groupclause_idx</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>gsets</name></decl></parameter>,
                         <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tleref_to_colnum_map</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>preprocess_limit</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                 <parameter><decl><type><name>double</name></type> <name>tuple_fraction</name></decl></parameter>,
                 <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>offset_est</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>count_est</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>limit_needed</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>remove_useless_groupby_columns</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>preprocess_groupclause</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>force</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>extract_rollup_sets</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupingSets</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>reorder_grouping_sets</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupingSets</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortclause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>standard_qp_callback</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>get_number_of_groups</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                     <parameter><decl><type><name>double</name></type> <name>path_rows</name></decl></parameter>,
					 <parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>target_list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type> <name>estimate_hashagg_tablesize</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
                           <parameter><decl><type><name>double</name></type> <name>dNumGroups</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>create_grouping_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                      <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
                      <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>target_parallel_safe</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
                      <parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_degenerate_grouping</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_degenerate_grouping_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
								 <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_ordinary_grouping_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
							   <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
							   <parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>consider_groupingsets_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                            <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>,
                            <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
                            <parameter><decl><type><name>bool</name></type> <name>is_sorted</name></decl></parameter>,
                            <parameter><decl><type><name>bool</name></type> <name>can_hash</name></decl></parameter>,
                            <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
                            <parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
                            <parameter><decl><type><name>double</name></type> <name>dNumGroups</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>create_window_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                    <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
                    <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>input_target</name></decl></parameter>,
                    <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>output_target</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>output_target_parallel_safe</name></decl></parameter>,
                    <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
                    <parameter><decl><type><name>WindowFuncLists</name> <modifier>*</modifier></type><name>wflists</name></decl></parameter>,
                    <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>activeWindows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_one_window_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                       <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>window_rel</name></decl></parameter>,
                       <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
                       <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>input_target</name></decl></parameter>,
                       <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>output_target</name></decl></parameter>,
                       <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
                       <parameter><decl><type><name>WindowFuncLists</name> <modifier>*</modifier></type><name>wflists</name></decl></parameter>,
                       <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>activeWindows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>create_distinct_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                      <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>create_ordered_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                     <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
                     <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>target_parallel_safe</name></decl></parameter>,
                     <parameter><decl><type><name>double</name></type> <name>limit_tuples</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PathTarget</name> <modifier>*</modifier></type><name>make_group_input_target</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                        <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>final_target</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PathTarget</name> <modifier>*</modifier></type><name>make_partial_grouping_target</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							 <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>grouping_target</name></decl></parameter>,
							 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>havingQual</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>postprocess_setop_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>new_tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>orig_tlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>select_active_windows</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>WindowFuncLists</name> <modifier>*</modifier></type><name>wflists</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PathTarget</name> <modifier>*</modifier></type><name>make_window_input_target</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                         <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>final_target</name></decl></parameter>,
                         <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>activeWindows</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>make_pathkeys_for_window</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name></decl></parameter>,
                         <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PathTarget</name> <modifier>*</modifier></type><name>make_sort_input_target</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					   <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>final_target</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>have_postponed_srfs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>grouping_distribution_match</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>,
					  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>groupingsets_distribution_match</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>,
                      <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Path</name> <modifier>*</modifier></type><name>adjust_path_distribution</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>,
                      <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>can_push_down_grouping</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>can_push_down_window</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>adjust_paths_for_srfs</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targets</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targets_contain_srfs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_paths_to_grouping_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
                         <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>, <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
                         <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>partial_grouping_target</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_final_costs</name></decl></parameter>,
                         <parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>can_sort</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>can_hash</name></decl></parameter>,
                         <parameter><decl><type><name>double</name></type> <name>dNumGroups</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>havingQual</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>try_distributed_aggregation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_partial_paths_to_grouping_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                                 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
                                 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>,
                                 <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
                                 <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>partial_grouping_target</name></decl></parameter>,
                                 <parameter><decl><type><name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_partial_costs</name></decl></parameter>,
                                 <parameter><decl><type><name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_final_costs</name></decl></parameter>,
                                 <parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>,
                                 <parameter><decl><type><name>bool</name></type> <name>can_sort</name></decl></parameter>,
                                 <parameter><decl><type><name>bool</name></type> <name>can_hash</name></decl></parameter>,
                                 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>havingQual</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>can_parallel_agg</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
                <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>Path</name> <modifier>*</modifier></type><name>adjust_modifytable_subpath</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>can_distinct_agg_optimize</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
                                      <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>, <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>pathtarget</name></decl></parameter>,
                                      <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/*****************************************************************************
 *
 *       Query optimizer entry point
 *
 * To support loadable plugins that monitor or modify planner behavior,
 * we provide a hook variable that lets a plugin get control before and
 * after the standard planning process.  The plugin would normally call
 * standard_planner().
 *
 * Note to plugin authors: standard_planner() scribbles on its Query input,
 * so you'd better copy that data structure if you want to plan more than once.
 *
 *****************************************************************************/</comment>
<function><type><name>PlannedStmt</name> <modifier>*</modifier></type>
<name>planner</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>planner_hook</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>planner_hook</name>) <argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <comment type="block">/*
         * A Coordinator receiving a query from another Coordinator
         * is not allowed to go into PGXC planner.
         */</comment>
        if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pgxc_planner</name><argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>standard_planner</name><argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>PlannedStmt</name> <modifier>*</modifier></type>
<name>standard_planner</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>tuple_fraction</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>final_rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>best_path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>top_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lp</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>lr</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name> <operator>&amp;&amp;</operator> <name><name>parse</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>&amp;&amp;</operator>
            <call><name>IsA</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>pgxc_direct_planner</name><argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Set up global state for this planner invocation.  This data is needed
     * across all levels of sub-Query that might exist in the given command,
     * so we keep it in a separate struct that's linked to by each per-Query
     * PlannerInfo.
     */</comment>
    <expr_stmt><expr><name>glob</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerGlobal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>boundParams</name></name> <operator>=</operator> <name>boundParams</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>subplans</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>subroots</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>rewindPlanIDs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>finalrowmarks</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>resultRelations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>nonleafResultRelations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>rootResultRelations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>relationOids</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>invalItems</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>nParamExec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>lastPHId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>lastRowMarkId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>lastPlanNodeId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>transientPlan</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>dependsOnRole</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name>groupOids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>min_workers_of_hashjon_gather</name> <operator>=</operator> <name>PG_INT32_MAX</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <expr_stmt><expr><name>has_cold_hot_table</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Assess whether it's feasible to use parallel mode for this query. We
     * can't do this in a standalone backend, or if the command will try to
     * modify any data, or if this is a cursor operation, or if GUCs are set
     * to values that don't permit parallelism, or if parallel-unsafe
     * functions are present in the query tree.
     *
     * For now, we don't try to use parallel mode if we're running inside a
     * parallel worker.  We might eventually be able to relax this
     * restriction, but for now it seems best not to have parallel workers
     * trying to create their own parallel workers.
     *
     * We can't use parallelism in serializable mode because the predicate
     * locking code is not parallel-aware.  It's not catastrophic if someone
     * tries to run a parallel plan in serializable mode; it just won't get
     * any workers and will run serially.  But it seems like a good heuristic
     * to assume that the same serialization level will be in effect at plan
     * time and execution time, so don't generate a parallel plan if we're in
     * serializable mode.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>cursorOptions</name> <operator>&amp;</operator> <name>CURSOR_OPT_PARALLEL_OK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator>
        <name>dynamic_shared_memory_type</name> <operator>!=</operator> <name>DSM_IMPL_NONE</name> <operator>&amp;&amp;</operator>
        <name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator>
        <operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>&amp;&amp;</operator>
        <name>max_parallel_workers_per_gather</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>IsParallelWorker</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>IsolationIsSerializable</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* all the cheap tests pass, so scan the query tree */</comment>
        <expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>maxParallelHazard</name></name> <operator>=</operator> <call><name>max_parallel_hazard</name><argument_list>(<argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>parallelModeOK</name></name> <operator>=</operator> <operator>(</operator><name><name>glob</name><operator>-&gt;</operator><name>maxParallelHazard</name></name> <operator>!=</operator> <name>PROPARALLEL_UNSAFE</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* skip the query tree scan, just assume it's unsafe */</comment>
        <expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>maxParallelHazard</name></name> <operator>=</operator> <name>PROPARALLEL_UNSAFE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>parallelModeOK</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * glob-&gt;parallelModeNeeded should tell us whether it's necessary to
     * impose the parallel mode restrictions, but we don't actually want to
     * impose them unless we choose a parallel plan, so it is normally set
     * only if a parallel plan is chosen (see create_gather_plan).  That way,
     * people who mislabel their functions but don't use parallelism anyway
     * aren't harmed.  But when force_parallel_mode is set, we enable the
     * restrictions whenever possible for testing purposes.
     */</comment>
    <expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>parallelModeOK</name></name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>force_parallel_mode</name> <operator>!=</operator> <name>FORCE_PARALLEL_OFF</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Determine what fraction of the plan is likely to be scanned */</comment>
    <if_stmt><if>if <condition>(<expr><name>cursorOptions</name> <operator>&amp;</operator> <name>CURSOR_OPT_FAST_PLAN</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We have no real idea how many tuples the user will ultimately FETCH
         * from a cursor, but it is often the case that he doesn't want 'em
         * all, or would prefer a fast-start plan anyway so that he can
         * process some of the tuples sooner.  Use a GUC parameter to decide
         * what fraction to optimize for.
         */</comment>
        <expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <name>cursor_tuple_fraction</name></expr>;</expr_stmt>

        <comment type="block">/*
         * We document cursor_tuple_fraction as simply being a fraction, which
         * means the edge cases 0 and 1 have to be treated specially here.  We
         * convert 1 to 0 ("all the tuples") and 0 to a very small fraction.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>tuple_fraction</name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>tuple_fraction</name> <operator>&lt;=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <literal type="number">1e-10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Default assumption is we need all the tuples */</comment>
        <expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* primary planning entry point (may recurse for subqueries) */</comment>
    <expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>subquery_planner</name><argument_list>(<argument><expr><name>glob</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><name>false</name></expr></argument>, <argument><expr><name>tuple_fraction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Select best Path and turn it into a Plan */</comment>
    <expr_stmt><expr><name>final_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>best_path</name> <operator>=</operator> <call><name>get_cheapest_fractional_path</name><argument_list>(<argument><expr><name>final_rel</name></expr></argument>, <argument><expr><name>tuple_fraction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>distribution</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>distribution</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>distribution</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>distribution</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>hasUnshippableTriggers</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>remote_subplan_depth</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>top_plan</name> <operator>=</operator> <call><name>create_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>distribution</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>hasUnshippableTriggers</name></name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>distribution</name></name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
        <comment type="block">/*
         * FIXME, this keeps adding RemoteSubplan at a top of queries that
         * don't really need it (e.g above a MergeAppend with subplans pushed
         * to remote nodes). Not sure why it's happening, though ...
         */</comment>
        <expr_stmt><expr><name>top_plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_remotesubplan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>top_plan</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                               <argument><expr><name><name>root</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>,
                                               <argument><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SS_remote_attach_initplans</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>top_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>remote_subplan_depth</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If creating a plan for a scrollable cursor, make sure it can run
     * backwards on demand.  Add a Material node at the top at need.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>cursorOptions</name> <operator>&amp;</operator> <name>CURSOR_OPT_SCROLL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecSupportsBackwardScan</name><argument_list>(<argument><expr><name>top_plan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>top_plan</name> <operator>=</operator> <call><name>materialize_finished_plan</name><argument_list>(<argument><expr><name>top_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Optionally add a Gather node for testing purposes, provided this is
     * actually a safe thing to do.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>force_parallel_mode</name> <operator>!=</operator> <name>FORCE_PARALLEL_OFF</name> <operator>&amp;&amp;</operator> <name><name>top_plan</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Gather</name>       <modifier>*</modifier></type><name>gather</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Gather</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name><name>top_plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name> <operator>=</operator> <name>top_plan</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>single_copy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>invisible</name></name> <operator>=</operator> <operator>(</operator><name>force_parallel_mode</name> <operator>==</operator> <name>FORCE_PARALLEL_REGRESS</name><operator>)</operator></expr>;</expr_stmt>

        <comment type="block">/*
         * Ideally we'd use cost_gather here, but setting up dummy path data
         * to satisfy it doesn't seem much cleaner than knowing what it does.
         */</comment>
        <expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>top_plan</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+</operator>
            <name>parallel_setup_cost</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>top_plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+</operator>
            <name>parallel_setup_cost</name> <operator>+</operator> <name>parallel_tuple_cost</name> <operator>*</operator> <name><name>top_plan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>plan_rows</name></name> <operator>=</operator> <name><name>top_plan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>plan_width</name></name> <operator>=</operator> <name><name>top_plan</name><operator>-&gt;</operator><name>plan_width</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <comment type="block">/* use parallel mode for parallel plans. */</comment>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>top_plan</name> <operator>=</operator> <operator>&amp;</operator><name><name>gather</name><operator>-&gt;</operator><name>plan</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If any Params were generated, run through the plan tree and compute
     * each plan node's extParam/allParam sets.  Ideally we'd merge this into
     * set_plan_references' tree traversal, but for now it has to be separate
     * because we need to visit subplans before not after main plan.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>glob</name><operator>-&gt;</operator><name>nParamExec</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>subroots</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>forboth</name><argument_list>(<argument>lp</argument>, <argument>glob-&gt;subplans</argument>, <argument>lr</argument>, <argument>glob-&gt;subroots</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name> <init>= <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>SS_finalize_plan</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>SS_finalize_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>top_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* final cleanup of the plan */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>finalrowmarks</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>resultRelations</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>nonleafResultRelations</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>rootResultRelations</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>top_plan</name> <operator>=</operator> <call><name>set_plan_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>top_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* ... and the subplans (both regular subplans and initplans) */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>subroots</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>forboth</name><argument_list>(<argument>lp</argument>, <argument>glob-&gt;subplans</argument>, <argument>lr</argument>, <argument>glob-&gt;subroots</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name> <init>= <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>set_plan_references</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* build the PlannedStmt result */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>queryId</name></name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>queryId</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>hasReturning</name></name> <operator>=</operator> <operator>(</operator><name><name>parse</name><operator>-&gt;</operator><name>returningList</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>transientPlan</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>transientPlan</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dependsOnRole</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>dependsOnRole</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>planTree</name></name> <operator>=</operator> <name>top_plan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>resultRelations</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>resultRelations</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nonleafResultRelations</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>nonleafResultRelations</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rootResultRelations</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>rootResultRelations</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>subplans</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rewindPlanIDs</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>rewindPlanIDs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>finalrowmarks</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>relationOids</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>relationOids</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>invalItems</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>invalItems</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>=</operator> <name>LOCATOR_TYPE_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>distributionKey</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>distributionNodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nParamExec</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>nParamExec</name></name></expr>;</expr_stmt>
    <comment type="block">/* utilityStmt should be null, but we might as well copy it */</comment>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>stmt_location</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>stmt_len</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>haspart_tobe_modify</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>haspart_tobe_modify</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>partrelindex</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>partrelindex</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>partpruning</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>partpruning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*--------------------
 * subquery_planner
 *      Invokes the planner on a subquery.  We recurse to here for each
 *      sub-SELECT found in the query tree.
 *
 * glob is the global state for the current planner run.
 * parse is the querytree produced by the parser &amp; rewriter.
 * parent_root is the immediate parent Query's info (NULL at the top level).
 * hasRecursion is true if this is a recursive WITH query.
 * tuple_fraction is the fraction of tuples we expect will be retrieved.
 * tuple_fraction is interpreted as explained for grouping_planner, below.
 *
 * Basically, this routine does the stuff that should only be done once
 * per Query object.  It then calls grouping_planner.  At one time,
 * grouping_planner could be invoked recursively on the same Query object;
 * that's not currently true, but we keep the separation between the two
 * routines anyway, in case we need it again someday.
 *
 * subquery_planner will be called recursively to handle sub-Query nodes
 * found within the query's expressions and rangetable.
 *
 * Returns the PlannerInfo struct ("root") that contains all data generated
 * while planning the subquery.  In particular, the Path(s) attached to
 * the (UPPERREL_FINAL, NULL) upperrel represent our conclusions about the
 * cheapest way(s) to implement the query.  The top level will select the
 * best Path and pass it through createplan.c to produce a finished Plan.
 *--------------------
 */</comment>
<function><type><name>PlannerInfo</name> <modifier>*</modifier></type>
<name>subquery_planner</name><parameter_list>(<parameter><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>,
                 <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>parent_root</name></decl></parameter>,
                 <parameter><decl><type><name>bool</name></type> <name>hasRecursion</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>tuple_fraction</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>newWithCheckOptions</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>newHaving</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>hasOuterJoins</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>final_rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>recursiveOk</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <comment type="block">/* XL currently does not support DML in subqueries. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>(</operator><operator>(</operator><ternary><condition><expr><name>parent_root</name></expr> ?</condition><then> <expr><name><name>parent_root</name><operator>-&gt;</operator><name>query_level</name></name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"INSERT/UPDATE/DELETE is not supported in subquery"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Create a PlannerInfo data structure for this subquery */</comment>
    <expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name> <operator>=</operator> <name>parse</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name> <operator>=</operator> <name>glob</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>query_level</name></name> <operator>=</operator> <ternary><condition><expr><name>parent_root</name></expr> ?</condition><then> <expr><name><name>parent_root</name><operator>-&gt;</operator><name>query_level</name></name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parent_root</name></name> <operator>=</operator> <name>parent_root</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>outer_params</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>planner_cxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>init_plans</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>cte_plan_ids</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>multiexpr_params</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>eq_classes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>upper_rels</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>upper_rels</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>upper_targets</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>upper_targets</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>grouping_map</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>recursiveOk</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>minmax_aggs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>qual_security_level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasClsPolicy</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasInheritedTarget</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasRecursion</name></name> <operator>=</operator> <name>hasRecursion</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>hasRecursion</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>wt_param_id</name></name> <operator>=</operator> <call><name>SS_assign_special_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>wt_param_id</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>non_recursive_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>partColsUpdated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there is a WITH list, process each WITH query and either convert it
	 * to RTE_SUBQUERY RTE(s) or build an initplan SubPlan structure for it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>cteList</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SS_process_ctes</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Look for ANY and EXISTS SubLinks in WHERE and JOIN/ON clauses, and try
	 * to transform them into joins.  Note that this step does not descend
	 * into subqueries; if we pull up any subqueries below, their SubLinks are
	 * processed just before pulling them up.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pull_up_sublinks</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Scan the rangetable for set-returning functions, and inline them if
	 * possible (producing subqueries that might get pulled up next).
	 * Recursion issues here are handled in the same way as for SubLinks.
	 */</comment>
	<expr_stmt><expr><call><name>inline_set_returning_functions</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check to see if any subqueries in the jointree can be merged into this
	 * query.
	 */</comment>
	<expr_stmt><expr><call><name>pull_up_subqueries</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this is a simple UNION ALL query, flatten it into an appendrel. We
	 * do this now because it requires applying pull_up_subqueries to the leaf
	 * queries of the UNION ALL, which weren't touched above because they
	 * weren't referenced by the jointree (they will be after we do this).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>flatten_simple_union_all</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Detect whether any rangetable entries are RTE_JOIN kind; if not, we can
	 * avoid the expense of doing flatten_join_alias_vars().  Also check for
	 * outer joins --- if none, we can skip reduce_outer_joins().  And check
	 * for LATERAL RTEs, too.  This must be done after we have done
	 * pull_up_subqueries(), of course.
	 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasJoinRTEs</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasLateralRTEs</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hasOuterJoins</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>parse-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasJoinRTEs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>hasOuterJoins</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasLateralRTEs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Preprocess RowMark information.  We need to do this after subquery
	 * pullup (so that all non-inherited RTEs are present) and before
	 * inheritance expansion (so that the info is available for
	 * expand_inherited_tables to examine and modify).
	 */</comment>
	<expr_stmt><expr><call><name>preprocess_rowmarks</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Expand any rangetable entries that are inheritance sets into "append
	 * relations".  This can add entries to the rangetable, but they must be
	 * plain base relations not joins, so it's OK (and marginally more
	 * efficient) to do it after checking for join RTEs.  We must do it after
	 * pulling up subqueries, else we'd fail to handle inherited tables in
	 * subqueries.
	 */</comment>
	<expr_stmt><expr><call><name>expand_inherited_tables</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set hasHavingQual to remember if HAVING clause is present.  Needed
	 * because preprocess_expression will reduce a constant-true condition to
	 * an empty qual list ... but "HAVING TRUE" is not a semantic no-op.
	 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasHavingQual</name></name> <operator>=</operator> <operator>(</operator><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Clear this flag; might get set in distribute_qual_to_rels */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasPseudoConstantQuals</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do expression preprocessing on targetlist and quals, as well as other
	 * random expressions in the querytree.  Note that we do not need to
	 * handle sort/group expressions explicitly, because they are actually
	 * part of the targetlist.
	 */</comment>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
		<call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
							  <argument><expr><name>EXPRKIND_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Constant-folding might have removed all set-returning functions */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>=</operator> <call><name>expression_returns_set</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>newWithCheckOptions</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>parse-&gt;withCheckOptions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WithCheckOption</name> <modifier>*</modifier></type><name>wco</name> <init>= <expr><operator>(</operator><name>WithCheckOption</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>wco</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>wco</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>,
										  <argument><expr><name>EXPRKIND_QUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>wco</name><operator>-&gt;</operator><name>qual</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newWithCheckOptions</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newWithCheckOptions</name></expr></argument>, <argument><expr><name>wco</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>withCheckOptions</name></name> <operator>=</operator> <name>newWithCheckOptions</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>returningList</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
		<call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>,
							  <argument><expr><name>EXPRKIND_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>preprocess_qual_conditions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>=</operator> <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
											  <argument><expr><name>EXPRKIND_QUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>parse-&gt;windowClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><operator>(</operator><name>WindowClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* partitionClause/orderClause are sort/group expressions */</comment>
		<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>startOffset</name></name> <operator>=</operator> <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>,
												<argument><expr><name>EXPRKIND_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>endOffset</name></name> <operator>=</operator> <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>,
											  <argument><expr><name>EXPRKIND_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>,
											   <argument><expr><name>EXPRKIND_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>,
											  <argument><expr><name>EXPRKIND_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>arbiterElems</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>arbiterElems</name></name></expr></argument>,
								  <argument><expr><name>EXPRKIND_ARBITER_ELEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>arbiterWhere</name></name> <operator>=</operator>
			<call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								  <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>arbiterWhere</name></name></expr></argument>,
								  <argument><expr><name>EXPRKIND_QUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictSet</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>,
								  <argument><expr><name>EXPRKIND_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictWhere</name></name> <operator>=</operator>
			<call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								  <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></argument>,
								  <argument><expr><name>EXPRKIND_QUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
        <block>{<block_content>   
            <decl_stmt><decl><type><name>int</name></type>             <name>rt_index</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type> <name>rte</name></decl>;</decl_stmt>
            
            <expr_stmt><expr><name>rt_index</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>rt_index</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>rt_index</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>cls_expr</name></name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictWhere</name></name> <operator>=</operator> 
                            <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                              <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>cls_expr</name></name></expr></argument>,
                                              <argument><expr><name>EXPRKIND_QUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictWhere</name></name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><call><name>lappend</name><argument_list>(<argument><expr><operator>(</operator><name>List</name><operator>*</operator><operator>)</operator><operator>(</operator><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictWhere</name></name><operator>)</operator></expr></argument>, 
                                                                            <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>cls_expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>rt_index</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        
        <comment type="block">/* exclRelTlist contains only Vars, so no preprocessing needed */</comment>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
        <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>root</name><operator>-&gt;</operator><name>append_rel_list</name></name></expr></argument>,
                              <argument><expr><name>EXPRKIND_APPINFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Also need to preprocess expressions within RTEs */</comment>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>parse-&gt;rtable</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>kind</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcsq</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name> <operator>=</operator> <operator>(</operator><name>TableSampleClause</name> <operator>*</operator><operator>)</operator>
                    <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                          <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name></expr></argument>,
                                          <argument><expr><name>EXPRKIND_TABLESAMPLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We don't want to do all preprocessing yet on the subquery's
             * expressions, since that will happen when we plan it.  But if it
             * contains any join aliases of our level, those have to get
             * expanded now, because planning of the subquery won't do it.
             * That's only possible if the subquery is LATERAL.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>hasJoinRTEs</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator>
                    <call><name>flatten_join_alias_vars</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_FUNCTION</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Preprocess the function expression(s) fully */</comment>
            <expr_stmt><expr><name>kind</name> <operator>=</operator> <ternary><condition><expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name></expr> ?</condition><then> <expr><name>EXPRKIND_RTFUNC_LATERAL</name></expr> </then><else>: <expr><name>EXPRKIND_RTFUNC</name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
                <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_TABLEFUNC</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Preprocess the function expression(s) fully */</comment>
            <expr_stmt><expr><name>kind</name> <operator>=</operator> <ternary><condition><expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name></expr> ?</condition><then> <expr><name>EXPRKIND_TABLEFUNC_LATERAL</name></expr> </then><else>: <expr><name>EXPRKIND_TABLEFUNC</name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>tablefunc</name></name> <operator>=</operator> <operator>(</operator><name>TableFunc</name> <operator>*</operator><operator>)</operator>
                <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablefunc</name></name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Preprocess the values lists fully */</comment>
            <expr_stmt><expr><name>kind</name> <operator>=</operator> <ternary><condition><expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name></expr> ?</condition><then> <expr><name>EXPRKIND_VALUES_LATERAL</name></expr> </then><else>: <expr><name>EXPRKIND_VALUES</name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
                <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Process each element of the securityQuals list as if it were a
         * separate qual expression (as indeed it is).  We need to do it this
         * way to get proper canonicalization of AND/OR structure.  Note that
         * this converts each element into an implicit-AND sublist.
         */</comment>
        <macro><name>foreach</name><argument_list>(<argument>lcsq</argument>, <argument>rte-&gt;securityQuals</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcsq</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcsq</name></expr></argument>)</argument_list></call></expr></argument>,
                                                 <argument><expr><name>EXPRKIND_QUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block>

    <comment type="block">/*
     * In some cases we may want to transfer a HAVING clause into WHERE. We
     * cannot do so if the HAVING clause contains aggregates (obviously) or
     * volatile functions (since a HAVING clause is supposed to be executed
     * only once per group).  We also can't do this if there are any nonempty
     * grouping sets; moving such a clause into WHERE would potentially change
     * the results, if any referenced column isn't present in all the grouping
     * sets.  (If there are only empty grouping sets, then the HAVING clause
     * must be degenerate as discussed below.)
     *
     * Also, it may be that the clause is so expensive to execute that we're
     * better off doing it only once per group, despite the loss of
     * selectivity.  This is hard to estimate short of doing the entire
     * planning process twice, so we use a heuristic: clauses containing
     * subplans are left in HAVING.  Otherwise, we move or copy the HAVING
     * clause into WHERE, in hopes of eliminating tuples before aggregation
     * instead of after.
     *
     * If the query has explicit grouping then we can simply move such a
     * clause into WHERE; any group that fails the clause will not be in the
     * output because none of its tuples will reach the grouping or
     * aggregation stage.  Otherwise we must have a degenerate (variable-free)
     * HAVING clause, which we put in WHERE so that query_planner() can use it
     * in a gating Result node, but also keep in HAVING to ensure that we
     * don't emit a bogus aggregated row. (This could be done better, but it
     * seems not worth optimizing.)
     *
     * Note that both havingQual and parse-&gt;jointree-&gt;quals are in
     * implicitly-ANDed-list form at this point, even though they are declared
     * as Node *.
     */</comment>
    <expr_stmt><expr><name>newHaving</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>(List *) parse-&gt;havingQual</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>havingclause</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>&amp;&amp;</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name><operator>)</operator> <operator>||</operator>
            <call><name>contain_agg_clause</name><argument_list>(<argument><expr><name>havingclause</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>havingclause</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>contain_subplans</name><argument_list>(<argument><expr><name>havingclause</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* keep it in HAVING */</comment>
            <expr_stmt><expr><name>newHaving</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newHaving</name></expr></argument>, <argument><expr><name>havingclause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* move it to WHERE */</comment>
            <expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
                <call><name>lappend</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>havingclause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* put a copy in WHERE, keep it in HAVING */</comment>
            <expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
                <call><name>lappend</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>,
                        <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>havingclause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>newHaving</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newHaving</name></expr></argument>, <argument><expr><name>havingclause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newHaving</name></expr>;</expr_stmt>

    <comment type="block">/* Remove any redundant GROUP BY columns */</comment>
    <expr_stmt><expr><call><name>remove_useless_groupby_columns</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we have any outer joins, try to reduce them to plain inner joins.
     * This step is most easily done after we've done expression
     * preprocessing.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>hasOuterJoins</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>reduce_outer_joins</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Do the main planning.  If we have an inherited target relation, that
     * needs special processing, else go straight to grouping_planner.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>&amp;&amp;</operator>
        <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>inh</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>inheritance_planner</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>grouping_planner</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>tuple_fraction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <comment type="block">/*
     * Capture the set of outer-level param IDs we have access to, for use in
     * extParam/allParam calculations later.
     */</comment>
    <expr_stmt><expr><call><name>SS_identify_outer_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If any initPlans were created in this query level, adjust the surviving
     * Paths' costs and parallel-safety flags to account for them.  The
     * initPlans won't actually get attached to the plan tree till
     * create_plan() runs, but we must include their effects now.
     */</comment>
    <expr_stmt><expr><name>final_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SS_charge_for_initplans</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>final_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Make sure we've identified the cheapest Path for the final rel.  (By
     * doing this here not in grouping_planner, we include initPlan costs in
     * the decision, though it's unlikely that will change anything.)
     */</comment>
    <expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>final_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* 
     * XCPTODO    
     * Temporarily block WITH RECURSIVE for most cases 
     * until we can fix. Allow for pg_catalog tables and replicated tables.
     */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>recursiveOk</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <comment type="block">/* seems to start at 1... */</comment>
        <for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name> <operator>&amp;&amp;</operator> <name>recursiveOk</name></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>rte</name></expr>)</condition><block type="pseudo"><block_content>
               <continue>continue;</continue></block_content></block></if></if_stmt>
        
            <switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>RTE_JOIN</name></expr>:</case>
                <case>case <expr><name>RTE_VALUES</name></expr>:</case>
                <case>case <expr><name>RTE_CTE</name></expr>:</case>
                <case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
                    <continue>continue;</continue>
                <case>case <expr><name>RTE_RELATION</name></expr>:</case>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>char</name></type> <name>loc_type</name></decl>;</decl_stmt>

                        <expr_stmt><expr><name>loc_type</name> <operator>=</operator> <call><name>GetRelationLocType</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/* skip pg_catalog */</comment>
                        <if_stmt><if>if <condition>(<expr><name>loc_type</name> <operator>==</operator> <name>LOCATOR_TYPE_NONE</name></expr>)</condition><block type="pseudo"><block_content>
                            <continue>continue;</continue></block_content></block></if></if_stmt>

                        <comment type="block">/* If replicated, allow */</comment>
                        <if_stmt><if>if <condition>(<expr><call><name>IsLocatorReplicated</name><argument_list>(<argument><expr><name>loc_type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <continue>continue;</continue></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><name>recursiveOk</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                        <break>break;</break>
                    </block_content>}</block> 
                <case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>relOptInfo</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                        <if_stmt><if>if <condition>(<expr><name>relOptInfo</name> <operator>&amp;&amp;</operator> <name><name>relOptInfo</name><operator>-&gt;</operator><name>subroot</name></name> <operator>&amp;&amp;</operator>
                                <operator>!</operator><name><name>relOptInfo</name><operator>-&gt;</operator><name>subroot</name><operator>-&gt;</operator><name>recursiveOk</name></name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>recursiveOk</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <break>break;</break>
                    </block_content>}</block>
                <default>default:</default>    
                    <expr_stmt><expr><name>recursiveOk</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></switch>
        </block_content>}</block></for>
    </block_content>}</block>

    <comment type="block">/*
     * XXX This is a bit strange. root-&gt;recursiveOk is set to true explicitly,
     * and now we check it. Harmless, but confusing.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>recursiveOk</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>recursiveOk</name></name> <operator>=</operator> <name>recursiveOk</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>hasRecursion</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>recursiveOk</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"WITH RECURSIVE currently not supported on distributed tables."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>root</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * preprocess_expression
 *        Do subquery_planner's preprocessing work for an expression,
 *        which can be a targetlist, a WHERE clause (including JOIN/ON
 *        conditions), a HAVING clause, or a few other things.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>preprocess_expression</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/*
     * Fall out quickly if expression is empty.  This occurs often enough to
     * be worth checking.  Note that null-&gt;null is the correct conversion for
     * implicit-AND result format, too.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If the query has any join RTEs, replace join alias variables with
     * base-relation variables.  We must do this before sublink processing,
     * else sublinks expanded out from join aliases would not get processed.
     * We can skip it in non-lateral RTE functions, VALUES lists, and
     * TABLESAMPLE clauses, however, since they can't contain any Vars of the
     * current query level.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>hasJoinRTEs</name></name> <operator>&amp;&amp;</operator>
        <operator>!</operator><operator>(</operator><name>kind</name> <operator>==</operator> <name>EXPRKIND_RTFUNC</name> <operator>||</operator>
          <name>kind</name> <operator>==</operator> <name>EXPRKIND_VALUES</name> <operator>||</operator>
          <name>kind</name> <operator>==</operator> <name>EXPRKIND_TABLESAMPLE</name> <operator>||</operator>
          <name>kind</name> <operator>==</operator> <name>EXPRKIND_TABLEFUNC</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>flatten_join_alias_vars</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Simplify constant expressions.
     *
     * Note: an essential effect of this is to convert named-argument function
     * calls to positional notation and insert the current actual values of
     * any default arguments for functions.  To ensure that happens, we *must*
     * process all expressions here.  Previous PG versions sometimes skipped
     * const-simplification if it didn't seem worth the trouble, but we can't
     * do that anymore.
     *
     * Note: this also flattens nested AND and OR expressions into N-argument
     * form.  All processing of a qual expression after this point must be
     * careful to maintain AND/OR flatness --- that is, do not generate a tree
     * with AND directly under AND, nor OR directly under OR.
     */</comment>
    <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If it's a qual or havingQual, canonicalize it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>EXPRKIND_QUAL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>canonicalize_qual</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>OPTIMIZER_DEBUG</name></cpp:ifdef>
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"After canonicalize_qual()\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pprint</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Expand SubLinks to SubPlans */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>SS_process_sublinks</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><operator>(</operator><name>kind</name> <operator>==</operator> <name>EXPRKIND_QUAL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * XXX do not insert anything here unless you have grokked the comments in
     * SS_replace_correlation_vars ...
     */</comment>

    <comment type="block">/* Replace uplevel vars with Param nodes (this IS possible in VALUES) */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>query_level</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>SS_replace_correlation_vars</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If it's a qual or havingQual, convert it to implicit-AND format. (We
     * don't want to do this before eval_const_expressions, since the latter
     * would be unable to simplify a top-level AND correctly. Also,
     * SS_process_sublinks expects explicit-AND format.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>EXPRKIND_QUAL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>expr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * preprocess_qual_conditions
 *        Recursively scan the query's jointree and do subquery_planner's
 *        preprocessing work on each qual condition found therein.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>preprocess_qual_conditions</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>jtnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* nothing to do here */</comment>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>f-&gt;fromlist</argument>)</argument_list></macro>
            <expr_stmt><expr><call><name>preprocess_qual_conditions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>EXPRKIND_QUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>preprocess_qual_conditions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>preprocess_qual_conditions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>EXPRKIND_QUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
             <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * preprocess_phv_expression
 *      Do preprocessing on a PlaceHolderVar expression that's been pulled up.
 *
 * If a LATERAL subquery references an output of another subquery, and that
 * output must be wrapped in a PlaceHolderVar because of an intermediate outer
 * join, then we'll push the PlaceHolderVar expression down into the subquery
 * and later pull it back up during find_lateral_references, which runs after
 * subquery_planner has preprocessed all the expressions that were in the
 * current query level to start with.  So we need to preprocess it then.
 */</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type>
<name>preprocess_phv_expression</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>preprocess_expression</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>EXPRKIND_PHV</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * inheritance_planner
 *      Generate Paths in the case where the result relation is an
 *      inheritance set.
 *
 * We have to handle this case differently from cases where a source relation
 * is an inheritance set. Source inheritance is expanded at the bottom of the
 * plan tree (see allpaths.c), but target inheritance has to be expanded at
 * the top.  The reason is that for UPDATE, each target relation needs a
 * different targetlist matching its own column set.  Fortunately,
 * the UPDATE/DELETE target can never be the nullable side of an outer join,
 * so it's OK to generate the plan this way.
 *
 * Returns nothing; the useful output is in the Paths we attach to
 * the (UPPERREL_FINAL, NULL) upperrel stored in *root.
 *
 * Note that we have not done set_cheapest() on the final rel; it's convenient
 * to leave this to the caller.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>inheritance_planner</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>top_parentRTindex</name> <init>= <expr><name><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>subqueryRTindexes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>modifiableARIindexes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nominalRelation</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>final_rtable</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_rel_array_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>save_rel_array</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subpaths</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subroots</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>resultRelations</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>withCheckOptionLists</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>returningLists</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>rowMarks</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>final_rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name></type>        <name>rti</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>parent_rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>partitioned_relids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>partitioned_rels</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>parent_root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parent_parse</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>parent_relids</name> <init>= <expr><call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>top_parentRTindex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>parent_roots</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We generate a modified instance of the original Query for each target
     * relation, plan that, and put all the plans into a list that will be
     * controlled by a single ModifyTable node.  All the instances share the
     * same rangetable, but each instance must have its own set of subquery
     * RTEs within the finished rangetable because (1) they are likely to get
     * scribbled on during planning, and (2) it's not inconceivable that
     * subqueries could get planned differently in different cases.  We need
     * not create duplicate copies of other RTE kinds, in particular not the
     * target relations, because they don't have either of those issues.  Not
     * having to duplicate the target relations is important because doing so
     * (1) would result in a rangetable of length O(N^2) for N targets, with
     * at least O(N^3) work expended here; and (2) would greatly complicate
     * management of the rowMarks list.
     *
     * To begin with, generate a bitmapset of the relids of the subquery RTEs.
     */</comment>
    <expr_stmt><expr><name>subqueryRTindexes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rti</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parse-&gt;rtable</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>subqueryRTindexes</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>subqueryRTindexes</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>rti</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Next, we want to identify which AppendRelInfo items contain references
     * to any of the aforesaid subquery RTEs.  These items will need to be
     * copied and modified to adjust their subquery references; whereas the
     * other ones need not be touched.  It's worth being tense over this
     * because we can usually avoid processing most of the AppendRelInfo
     * items, thereby saving O(N^2) space and time when the target is a large
     * inheritance tree.  We can identify AppendRelInfo items by their
     * child_relid, since that should be unique within the list.
     */</comment>
    <expr_stmt><expr><name>modifiableARIindexes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>subqueryRTindexes</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;append_rel_list</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><operator>(</operator><name>AppendRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>, <argument><expr><name>subqueryRTindexes</name></expr></argument>)</argument_list></call> <operator>||</operator>
                <call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr></argument>, <argument><expr><name>subqueryRTindexes</name></expr></argument>)</argument_list></call> <operator>||</operator>
                <call><name>bms_overlap</name><argument_list>(<argument><expr><call><name>pull_varnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>translated_vars</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>subqueryRTindexes</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>modifiableARIindexes</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>modifiableARIindexes</name></expr></argument>,
                                                      <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If the parent RTE is a partitioned table, we should use that as the
     * nominal relation, because the RTEs added for partitioned tables
     * (including the root parent) as child members of the inheritance set do
     * not appear anywhere else in the plan.  The situation is exactly the
     * opposite in the case of non-partitioned inheritance parent as described
	 * below. For the same reason, collect the list of descendant partitioned
	 * tables to be saved in ModifyTable node, so that executor can lock those
	 * as well.
     */</comment>
	<expr_stmt><expr><name>parent_rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>top_parentRTindex</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>parent_rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nominalRelation</name> <operator>=</operator> <name>top_parentRTindex</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Root parent's RT index is always present in the partitioned_rels of
		 * the ModifyTable node, if one is needed at all.
		 */</comment>
		<expr_stmt><expr><name>partitioned_relids</name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>top_parentRTindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The PlannerInfo for each child is obtained by translating the relevant
	 * members of the PlannerInfo for its immediate parent, which we find
	 * using the parent_relid in its AppendRelInfo.  We save the PlannerInfo
	 * for each parent in an array indexed by relid for fast retrieval. Since
	 * the maximum number of parents is limited by the number of RTEs in the
	 * query, we use that number to allocate the array. An extra entry is
	 * needed since relids start from 1.
	 */</comment>
	<expr_stmt><expr><name>parent_roots</name> <operator>=</operator> <operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator>
											<sizeof>sizeof<argument_list>(<argument><expr><name>PlannerInfo</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parent_roots</name><index>[<expr><name>top_parentRTindex</name></expr>]</index></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>

    <comment type="block">/*
     * And now we can get on with generating a plan for each child table.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;append_rel_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo</name> <init>= <expr><operator>(</operator><name>AppendRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>child_rte</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>sub_final_rel</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>subpath</name></decl>;</decl_stmt>

        <comment type="block">/* append_rel_list contains all append rels; ignore others */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>, <argument><expr><name>parent_relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
		 * expand_inherited_rtentry() always processes a parent before any of
		 * that parent's children, so the parent_root for this relation should
		 * already be available.
		 */</comment>
		<expr_stmt><expr><name>parent_root</name> <operator>=</operator> <name><name>parent_roots</name><index>[<expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parent_root</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parent_parse</name> <operator>=</operator> <name><name>parent_root</name><operator>-&gt;</operator><name>parse</name></name></expr>;</expr_stmt>

		<comment type="block">/*
         * We need a working copy of the PlannerInfo so that we can control
         * propagation of information back to the main copy.
         */</comment>
        <expr_stmt><expr><name>subroot</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>parent_root</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Generate modified query with this rel as target.  We first apply
         * adjust_appendrel_attrs, which copies the Query and changes
         * references to the parent RTE to refer to the current child RTE,
         * then fool around with subquery RTEs.
         */</comment>
        <expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name></name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator>
			<call><name>adjust_appendrel_attrs</name><argument_list>(<argument><expr><name>parent_root</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>parent_parse</name></expr></argument>,
								   <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>appinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If there are securityQuals attached to the parent, move them to the
         * child rel (they've already been transformed properly for that).
         */</comment>
		<expr_stmt><expr><name>parent_rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>, <argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>child_rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr></argument>, <argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>child_rte</name><operator>-&gt;</operator><name>securityQuals</name></name> <operator>=</operator> <name><name>parent_rte</name><operator>-&gt;</operator><name>securityQuals</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>parent_rte</name><operator>-&gt;</operator><name>securityQuals</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

        <comment type="block">/*
         * The rowMarks list might contain references to subquery RTEs, so
         * make a copy that we can apply ChangeVarNodes to.  (Fortunately, the
         * executor doesn't need to see the modified copies --- we can just
         * pass it the original rowMarks list.)
         */</comment>
		<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>parent_root</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * The append_rel_list likewise might contain references to subquery
         * RTEs (if any subqueries were flattenable UNION ALLs).  So prepare
         * to apply ChangeVarNodes to that, too.  As explained above, we only
         * want to copy items that actually contain such references; the rest
         * can just get linked into the subroot's append_rel_list.
         *
         * If we know there are no such references, we can just use the outer
         * append_rel_list unmodified.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>modifiableARIindexes</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>append_rel_list</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>parent_root-&gt;append_rel_list</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo2</name> <init>= <expr><operator>(</operator><name>AppendRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>appinfo2</name><operator>-&gt;</operator><name>child_relid</name></name></expr></argument>, <argument><expr><name>modifiableARIindexes</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>appinfo2</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>appinfo2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>append_rel_list</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>append_rel_list</name></name></expr></argument>,
                                                   <argument><expr><name>appinfo2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Add placeholders to the child Query's rangetable list to fill the
         * RT indexes already reserved for subqueries in previous children.
         * These won't be referenced, so there's no need to make them very
         * valid-looking.
         */</comment>
        <while>while <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>final_rtable</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>,
                                             <argument><expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

        <comment type="block">/*
         * If this isn't the first child Query, generate duplicates of all
         * subquery RTEs, and adjust Var numbering to reference the
         * duplicates. To simplify the loop logic, we scan the original rtable
         * not the copy just made by adjust_appendrel_attrs; that should be OK
         * since subquery RTEs couldn't contain any references to the target
         * rel.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>final_rtable</name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>subqueryRTindexes</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lr</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>rti</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lr</argument>, <argument>parent_parse-&gt;rtable</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>rti</name></expr></argument>, <argument><expr><name>subqueryRTindexes</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Index</name></type>        <name>newrti</name></decl>;</decl_stmt>

                    <comment type="block">/*
                     * The RTE can't contain any references to its own RT
                     * index, except in its securityQuals, so we can save a
                     * few cycles by applying ChangeVarNodes to the rest of
                     * the rangetable before we append the RTE to it.
                     */</comment>
                    <expr_stmt><expr><name>newrti</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subroot</name><operator>-&gt;</operator><name>parse</name></name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>newrti</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subroot</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>newrti</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* Skip processing unchanging parts of append_rel_list */</comment>
                    <if_stmt><if>if <condition>(<expr><name>modifiableARIindexes</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

                        <macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>subroot-&gt;append_rel_list</argument>)</argument_list></macro>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appinfo2</name> <init>= <expr><operator>(</operator><name>AppendRelInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>appinfo2</name><operator>-&gt;</operator><name>child_relid</name></name></expr></argument>,
                                              <argument><expr><name>modifiableARIindexes</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>appinfo2</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>newrti</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        </block_content>}</block>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>securityQuals</name></name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>newrti</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>,
                                                     <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>rti</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* There shouldn't be any OJ info to translate, as yet */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>join_info_list</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* and we haven't created PlaceHolderInfos, either */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>placeholder_list</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* hack to mark target relation as an inheritance partition */</comment>
        <expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>hasInheritedTarget</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the child is further partitioned, remember it as a parent. Since
		 * a partitioned table does not have any data, we don't need to create
		 * a plan for it. We do, however, need to remember the PlannerInfo for
		 * use when processing its children.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>child_rte</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>child_rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>parent_relids</name> <operator>=</operator>
				<call><name>bms_add_member</name><argument_list>(<argument><expr><name>parent_relids</name></expr></argument>, <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>parent_roots</name><index>[<expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr>]</index></name> <operator>=</operator> <name>subroot</name></expr>;</expr_stmt>

			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

        <comment type="block">/* Generate Path(s) for accessing this result relation */</comment>
        <expr_stmt><expr><call><name>grouping_planner</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument> <comment type="block">/* retrieve all tuples */</comment> )</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Set the nomimal target relation of the ModifyTable node if not
         * already done.  We use the inheritance parent RTE as the nominal
         * target relation if it's a partitioned table (see just above this
         * loop).  In the non-partitioned parent case, we'll use the first
         * child relation (even if it's excluded) as the nominal target
         * relation.  Because of the way expand_inherited_rtentry works, the
         * latter should be the RTE representing the parent table in its role
         * as a simple member of the inheritance set.
         *
         * It would be logically cleaner to *always* use the inheritance
         * parent RTE as the nominal relation; but that RTE is not otherwise
         * referenced in the plan in the non-partitioned inheritance case.
         * Instead the duplicate child RTE created by expand_inherited_rtentry
         * is used elsewhere in the plan, so using the original parent RTE
         * would give rise to confusing use of multiple aliases in EXPLAIN
         * output for what the user will think is the "same" table.  OTOH,
         * it's not a problem in the partitioned inheritance case, because the
         * duplicate child RTE added for the parent does not appear anywhere
         * else in the plan tree.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>nominalRelation</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>nominalRelation</name> <operator>=</operator> <name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Select cheapest path in case there's more than one.  We always run
         * modification queries to conclusion, so we care only for the
         * cheapest-total path.
         */</comment>
        <expr_stmt><expr><name>sub_final_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>sub_final_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>subpath</name> <operator>=</operator> <name><name>sub_final_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * If this child rel was excluded by constraint exclusion, exclude it
         * from the result plan.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IS_DUMMY_PATH</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		* Add the current parent's RT index to the partitione_rels set if
		* we're going to create the ModifyTable path for a partitioned root
		* table.
		*/</comment>
		<if_stmt><if>if <condition>(<expr><name>partitioned_relids</name></expr>)</condition><block type="pseudo"><block_content>
		   <expr_stmt><expr><name>partitioned_relids</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>partitioned_relids</name></expr></argument>,
		                                       <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        <comment type="block">/*
         * All subplans should have the same distribution, except may be
         * restriction. At the moment this is always the case but if this
         * is changed we should handle inheritance differently.
         * Effectively we want to push the modify table down to data nodes, if
         * it is running against distributed inherited tables. To achieve this
         * we are building up distribution of the query from distributions of
         * the subplans.
         * If subplans are restricted to different nodes we should union these
         * restrictions, if at least one subplan is not restricted we should
         * not restrict parent plan.
         * After returning a plan from the function valid root-&gt;distribution
         * value will force proper RemoteSubplan node on top of it.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>distribution</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>distribution</name></name> <operator>=</operator> <name><name>subroot</name><operator>-&gt;</operator><name>distribution</name></name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <call><name>bms_join</name><argument_list>(
                        <argument><expr><name><name>root</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>,
                        <argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * If this is the first non-excluded child, its post-planning rtable
         * becomes the initial contents of final_rtable; otherwise, append
         * just its modified subquery RTEs to final_rtable.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>final_rtable</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>final_rtable</name> <operator>=</operator> <name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>final_rtable</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>final_rtable</name></expr></argument>,
                                       <argument><expr><call><name>list_copy_tail</name><argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>,
                                                      <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>final_rtable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*
         * We need to collect all the RelOptInfos from all child plans into
         * the main PlannerInfo, since setrefs.c will need them.  We use the
         * last child's simple_rel_array (previous ones are too short), so we
         * have to propagate forward the RelOptInfos that were already built
         * in previous children.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name> <operator>&gt;=</operator> <name>save_rel_array_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>rti</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>rti</name> <operator>&lt;</operator> <name>save_rel_array_size</name></expr>;</condition> <incr><expr><name>rti</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>brel</name> <init>= <expr><name><name>save_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>brel</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name> <operator>=</operator> <name>brel</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name>save_rel_array_size</name> <operator>=</operator> <name><name>subroot</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>save_rel_array</name> <operator>=</operator> <name><name>subroot</name><operator>-&gt;</operator><name>simple_rel_array</name></name></expr>;</expr_stmt>

        <comment type="block">/* Make sure any initplans from this rel get into the outer list */</comment>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>init_plans</name></name> <operator>=</operator> <name><name>subroot</name><operator>-&gt;</operator><name>init_plans</name></name></expr>;</expr_stmt>

        <comment type="block">/* Build list of sub-paths */</comment>
        <expr_stmt><expr><name>subpaths</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Build list of modified subroots, too */</comment>
        <expr_stmt><expr><name>subroots</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subroots</name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Build list of target-relation RT indexes */</comment>
        <expr_stmt><expr><name>resultRelations</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>, <argument><expr><name><name>appinfo</name><operator>-&gt;</operator><name>child_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Build lists of per-relation WCO and RETURNING targetlists */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>withCheckOptions</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>withCheckOptionLists</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>withCheckOptionLists</name></expr></argument>,
                                           <argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>withCheckOptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>returningLists</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>returningLists</name></expr></argument>,
                                     <argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Result path must go into outer query's FINAL upperrel */</comment>
    <expr_stmt><expr><name>final_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We don't currently worry about setting final_rel's consider_parallel
     * flag in this case, nor about allowing FDWs or create_upper_paths_hook
     * to get control here.
     */</comment>

    <comment type="block">/*
     * If we managed to exclude every child rel, return a dummy plan; it
     * doesn't even need a ModifyTable node.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>subpaths</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>set_dummy_rel_pathlist</name><argument_list>(<argument><expr><name>final_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Put back the final adjusted rtable into the master copy of the Query.
     * (We mustn't do this if we found no non-excluded children.)
     */</comment>
    <expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name>final_rtable</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name> <operator>=</operator> <name>save_rel_array_size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name></name> <operator>=</operator> <name>save_rel_array</name></expr>;</expr_stmt>
    <comment type="block">/* Must reconstruct master's simple_rte_array, too */</comment>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name></name> <operator>=</operator> <operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>*</operator><operator>)</operator>
        <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name>final_rtable</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RangeTblEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rti</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>final_rtable</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>rti</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * If there was a FOR [KEY] UPDATE/SHARE clause, the LockRows node will
     * have dealt with fetching non-locked marked rows, else we need to have
     * ModifyTable do that.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>rowMarks</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>rowMarks</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>rowMarks</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>partitioned_relids</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>partitioned_relids</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>partitioned_rels</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>partitioned_rels</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

		<comment type="block">/*
		 * If we're going to create ModifyTable at all, the list should
		 * contain at least one member, that is, the root parent's index.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>partitioned_rels</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/* Create Path representing a ModifyTable to do the UPDATE/DELETE work */</comment>
    <expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>final_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
             <call><name>create_modifytable_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>final_rel</name></expr></argument>,
                                     <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>,
                                     <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>,
                                     <argument><expr><name>nominalRelation</name></expr></argument>,
                                     <argument><expr><name>partitioned_rels</name></expr></argument>,
									 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>partColsUpdated</name></name></expr></argument>,
                                     <argument><expr><name>resultRelations</name></expr></argument>,
                                     <argument><expr><name>subpaths</name></expr></argument>,
                                     <argument><expr><name>subroots</name></expr></argument>,
                                     <argument><expr><name>withCheckOptionLists</name></expr></argument>,
                                     <argument><expr><name>returningLists</name></expr></argument>,
                                     <argument><expr><name>rowMarks</name></expr></argument>,
                                     <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><call><name>SS_assign_special_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*--------------------
 * grouping_planner
 *      Perform planning steps related to grouping, aggregation, etc.
 *
 * This function adds all required top-level processing to the scan/join
 * Path(s) produced by query_planner.
 *
 * If inheritance_update is true, we're being called from inheritance_planner
 * and should not include a ModifyTable step in the resulting Path(s).
 * (inheritance_planner will create a single ModifyTable node covering all the
 * target tables.)
 *
 * tuple_fraction is the fraction of tuples we expect will be retrieved.
 * tuple_fraction is interpreted as follows:
 *      0: expect all tuples to be retrieved (normal case)
 *      0 &lt; tuple_fraction &lt; 1: expect the given fraction of tuples available
 *        from the plan to be retrieved
 *      tuple_fraction &gt;= 1: tuple_fraction is the absolute number of tuples
 *        expected to be retrieved (ie, a LIMIT specification)
 *
 * Returns nothing; the useful output is in the Paths we attach to the
 * (UPPERREL_FINAL, NULL) upperrel in *root.  In addition,
 * root-&gt;processed_tlist contains the final processed targetlist.
 *
 * Note that we have not done set_cheapest() on the final rel; it's convenient
 * to leave this to the caller.
 *--------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>grouping_planner</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inheritance_update</name></decl></parameter>,
                 <parameter><decl><type><name>double</name></type> <name>tuple_fraction</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>offset_est</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>count_est</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>limit_tuples</name> <init>= <expr><operator>-</operator><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>have_postponed_srfs</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>final_target</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>final_targets</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>final_targets_contain_srfs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>final_target_parallel_safe</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>current_rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>final_rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* Tweak caller-supplied tuple_fraction if have LIMIT/OFFSET */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>limitOffset</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <call><name>preprocess_limit</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tuple_fraction</name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name>offset_est</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count_est</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If we have a known LIMIT, and don't have an unknown OFFSET, we can
         * estimate the effects of using a bounded sort.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>count_est</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>offset_est</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>limit_tuples</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>count_est</name> <operator>+</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>offset_est</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Make tuple_fraction accessible to lower-level routines */</comment>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name> <operator>=</operator> <name>tuple_fraction</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If there's a top-level ORDER BY, assume we have to fetch all the
         * tuples.  This might be too simplistic given all the hackery below
         * to possibly avoid the sort; but the odds of accurate estimates here
         * are pretty low anyway.  XXX try to get rid of this in favor of
         * letting plan_set_operations generate both fast-start and
         * cheapest-total paths.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>sortClause</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Construct Paths for set operations.  The results will not need any
         * work except perhaps a top-level sort and/or LIMIT.  Note that any
         * special work for recursive unions is the responsibility of
         * plan_set_operations.
         */</comment>
        <expr_stmt><expr><name>current_rel</name> <operator>=</operator> <call><name>plan_set_operations</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We should not need to call preprocess_targetlist, since we must be
         * in a SELECT query node.  Instead, use the targetlist returned by
         * plan_set_operations (since this tells whether it returned any
         * resjunk columns!), and transfer any sort key information from the
         * original tlist.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>tlist</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name></expr>;</expr_stmt>    <comment type="block">/* from plan_set_operations */</comment>

        <comment type="block">/* for safety, copy processed_tlist instead of modifying in-place */</comment>
        <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>postprocess_setop_tlist</name><argument_list>(<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Save aside the final decorated tlist */</comment>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>

        <comment type="block">/* Also extract the PathTarget form of the setop result tlist */</comment>
        <expr_stmt><expr><name>final_target</name> <operator>=</operator> <name><name>current_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name><operator>-&gt;</operator><name>pathtarget</name></name></expr>;</expr_stmt>

		<comment type="block">/* And check whether it's parallel safe */</comment>
		<expr_stmt><expr><name>final_target_parallel_safe</name> <operator>=</operator>
			<call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>final_target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* The setop result tlist couldn't contain any SRFs */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>final_targets</name> <operator>=</operator> <name>final_targets_contain_srfs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Can't handle FOR [KEY] UPDATE/SHARE here (parser should have
         * checked already, but let's make sure).
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
            <comment type="block">/*------
              translator: %s is a SQL row locking clause such as FOR UPDATE */</comment>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed with UNION/INTERSECT/EXCEPT"</literal></expr></argument>,
                            <argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RowMarkClause</name> <operator>*</operator><operator>)</operator>
                                          <call><name>linitial</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Calculate pathkeys that represent result ordering requirements
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name> <operator>=</operator> <call><name>make_pathkeys_for_sortclauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                            <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>,
                                                            <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* No set operations, do regular planning */</comment>
        <decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>sort_input_target</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>sort_input_targets</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>sort_input_targets_contain_srfs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>sort_input_target_parallel_safe</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>grouping_target</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>grouping_targets</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>grouping_targets_contain_srfs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>grouping_target_parallel_safe</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>scanjoin_target</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>scanjoin_targets</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>scanjoin_targets_contain_srfs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>scanjoin_target_parallel_safe</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>have_grouping</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AggClauseCosts</name></type> <name>agg_costs</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>WindowFuncLists</name> <modifier>*</modifier></type><name>wflists</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>activeWindows</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gset_data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>standard_qp_extra</name></type> <name>qp_extra</name></decl>;</decl_stmt>

        <comment type="block">/* A recursive query should always have setOperations */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>hasRecursion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Preprocess grouping sets and GROUP BY clause, if any */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>gset_data</name> <operator>=</operator> <call><name>preprocess_grouping_sets</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Preprocess regular GROUP BY clause, if any */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <call><name>preprocess_groupclause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Preprocess targetlist */</comment>
        <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>preprocess_targetlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictSet</name></name> <operator>=</operator>
                <call><name>preprocess_onconflict_targetlist</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>,
                                                 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>,
                                                 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * We are now done hacking up the query's targetlist.  Most of the
         * remaining planning work will be done with the PathTarget
         * representation of tlists, but save aside the full representation so
         * that we can transfer its decoration (resnames etc) to the topmost
         * tlist of the finished Plan.
         */</comment>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Collect statistics about aggregates for estimating costs, and mark
         * all the aggregates with resolved aggtranstypes.  We must do this
         * before slicing and dicing the tlist into various pathtargets, else
         * some copies of the Aggref nodes might escape being marked with the
         * correct transtypes.
         *
         * Note: currently, we do not detect duplicate aggregates here.  This
         * may result in somewhat-overestimated cost, which is fine for our
         * purposes since all Paths will get charged the same.  But at some
         * point we might wish to do that detection in the planner, rather
         * than during executor startup.
         */</comment>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agg_costs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggClauseCosts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>get_agg_clause_costs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tlist</name></expr></argument>, <argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>agg_costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>get_agg_clause_costs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>, <argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>agg_costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Locate any window functions in the tlist.  (We don't need to look
         * anywhere else, since expressions used in ORDER BY will be in there
         * too.)  Note that they could all have been eliminated by constant
         * folding, in which case we don't need to do any more work.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>wflists</name> <operator>=</operator> <call><name>find_window_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tlist</name></expr></argument>,
                                            <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>windowClause</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>wflists</name><operator>-&gt;</operator><name>numWindowFuncs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>activeWindows</name> <operator>=</operator> <call><name>select_active_windows</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>wflists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Preprocess MIN/MAX aggregates, if any.  Note: be careful about
         * adding logic between here and the query_planner() call.  Anything
         * that is needed in MIN/MAX-optimizable cases will have to be
         * duplicated in planagg.c.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>preprocess_minmax_aggregates</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Figure out whether there's a hard limit on the number of rows that
         * query_planner's result subplan needs to return.  Even if we know a
         * hard limit overall, it doesn't apply if the query has any
         * grouping/aggregation operations, or SRFs in the tlist.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator>
            <name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator>
            <name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>||</operator>
            <name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator>
            <name><name>parse</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>||</operator>
            <name><name>parse</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>||</operator>
            <name><name>root</name><operator>-&gt;</operator><name>hasHavingQual</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>limit_tuples</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>limit_tuples</name></name> <operator>=</operator> <name>limit_tuples</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* Set up data needed by standard_qp_callback */</comment>
        <expr_stmt><expr><name><name>qp_extra</name><operator>.</operator><name>tlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qp_extra</name><operator>.</operator><name>activeWindows</name></name> <operator>=</operator> <name>activeWindows</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qp_extra</name><operator>.</operator><name>groupClause</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>gset_data</name></expr>
                                ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><name><name>gset_data</name><operator>-&gt;</operator><name>rollups</name></name></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>RollupData</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>gset_data</name><operator>-&gt;</operator><name>rollups</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>groupClause</name></expr> </then><else>: <expr><name>NIL</name></expr></else></ternary><operator>)</operator></expr>
                                </then><else>: <expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

        <comment type="block">/*
         * Generate the best unsorted and presorted paths for the scan/join
         * portion of this Query, ie the processing represented by the
         * FROM/WHERE clauses.  (Note there may not be any presorted paths.)
         * We also generate (in standard_qp_callback) pathkey representations
         * of the query's sort clause, distinct clause, etc.
         */</comment>
        <expr_stmt><expr><name>current_rel</name> <operator>=</operator> <call><name>query_planner</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>,
                                    <argument><expr><name>standard_qp_callback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qp_extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Convert the query's result tlist into PathTarget format.
         *
         * Note: it's desirable to not do this till after query_planner(),
         * because the target width estimates can use per-Var width numbers
         * that were obtained within query_planner().
         */</comment>
        <expr_stmt><expr><name>final_target</name> <operator>=</operator> <call><name>create_pathtarget</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>final_target_parallel_safe</name> <operator>=</operator>
			<call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>final_target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If ORDER BY was given, consider whether we should use a post-sort
         * projection, and compute the adjusted target for preceding steps if
         * so.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>sortClause</name></name></expr>)</condition>
		<block>{<block_content>
            <expr_stmt><expr><name>sort_input_target</name> <operator>=</operator> <call><name>make_sort_input_target</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                       <argument><expr><name>final_target</name></expr></argument>,
                                                       <argument><expr><operator>&amp;</operator><name>have_postponed_srfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sort_input_target_parallel_safe</name> <operator>=</operator>
				<call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sort_input_target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
        <else>else
		<block>{<block_content>
            <expr_stmt><expr><name>sort_input_target</name> <operator>=</operator> <name>final_target</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>sort_input_target_parallel_safe</name> <operator>=</operator> <name>final_target_parallel_safe</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * If we have window functions to deal with, the output from any
         * grouping step needs to be what the window functions want;
         * otherwise, it should be sort_input_target.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>activeWindows</name></expr>)</condition>
		<block>{<block_content>
            <expr_stmt><expr><name>grouping_target</name> <operator>=</operator> <call><name>make_window_input_target</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                       <argument><expr><name>final_target</name></expr></argument>,
                                                       <argument><expr><name>activeWindows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>grouping_target_parallel_safe</name> <operator>=</operator>
				<call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>grouping_target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
        <else>else
		<block>{<block_content>
            <expr_stmt><expr><name>grouping_target</name> <operator>=</operator> <name>sort_input_target</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>grouping_target_parallel_safe</name> <operator>=</operator> <name>sort_input_target_parallel_safe</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * If we have grouping or aggregation to do, the topmost scan/join
         * plan node must emit what the grouping step wants; otherwise, it
         * should emit grouping_target.
         */</comment>
        <expr_stmt><expr><name>have_grouping</name> <operator>=</operator> <operator>(</operator><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator>
                         <name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>hasHavingQual</name></name><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>have_grouping</name></expr>)</condition>
		<block>{<block_content>
            <expr_stmt><expr><name>scanjoin_target</name> <operator>=</operator> <call><name>make_group_input_target</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>final_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>scanjoin_target_parallel_safe</name> <operator>=</operator>
				<call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>grouping_target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
        <else>else
		<block>{<block_content>
            <expr_stmt><expr><name>scanjoin_target</name> <operator>=</operator> <name>grouping_target</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>scanjoin_target_parallel_safe</name> <operator>=</operator> <name>grouping_target_parallel_safe</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * If there are any SRFs in the targetlist, we must separate each of
         * these PathTargets into SRF-computing and SRF-free targets.  Replace
         * each of the named targets with a SRF-free version, and remember the
         * list of additional projection steps we need to add afterwards.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* final_target doesn't recompute any SRFs in sort_input_target */</comment>
            <expr_stmt><expr><call><name>split_pathtarget_at_srfs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>final_target</name></expr></argument>, <argument><expr><name>sort_input_target</name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name>final_targets</name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name>final_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>final_target</name> <operator>=</operator> <operator>(</operator><name>PathTarget</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>final_targets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>linitial_int</name><argument_list>(<argument><expr><name>final_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* likewise for sort_input_target vs. grouping_target */</comment>
            <expr_stmt><expr><call><name>split_pathtarget_at_srfs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sort_input_target</name></expr></argument>, <argument><expr><name>grouping_target</name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name>sort_input_targets</name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name>sort_input_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>sort_input_target</name> <operator>=</operator> <operator>(</operator><name>PathTarget</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>sort_input_targets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>linitial_int</name><argument_list>(<argument><expr><name>sort_input_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* likewise for grouping_target vs. scanjoin_target */</comment>
            <expr_stmt><expr><call><name>split_pathtarget_at_srfs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouping_target</name></expr></argument>, <argument><expr><name>scanjoin_target</name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name>grouping_targets</name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name>grouping_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>grouping_target</name> <operator>=</operator> <operator>(</operator><name>PathTarget</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>grouping_targets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>linitial_int</name><argument_list>(<argument><expr><name>grouping_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* scanjoin_target will not have any SRFs precomputed for it */</comment>
            <expr_stmt><expr><call><name>split_pathtarget_at_srfs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scanjoin_target</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name>scanjoin_targets</name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name>scanjoin_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>scanjoin_target</name> <operator>=</operator> <operator>(</operator><name>PathTarget</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>scanjoin_targets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>linitial_int</name><argument_list>(<argument><expr><name>scanjoin_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* initialize lists, just to keep compiler quiet */</comment>
            <expr_stmt><expr><name>final_targets</name> <operator>=</operator> <name>final_targets_contain_srfs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>sort_input_targets</name> <operator>=</operator> <name>sort_input_targets_contain_srfs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>grouping_targets</name> <operator>=</operator> <name>grouping_targets_contain_srfs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>scanjoin_targets</name> <operator>=</operator> <name>scanjoin_targets_contain_srfs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
		 * Generate Gather or Gather Merge paths for the topmost scan/join
		 * relation.  Once that's done, we must re-determine which paths are
		 * cheapest.  (The previously-cheapest path might even have been
		 * pfree'd!)
		 */</comment>
		<expr_stmt><expr><call><name>generate_gather_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>current_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>current_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
         * Forcibly apply SRF-free scan/join target to all the Paths for the
         * scan/join rel.
         *
         * In principle we should re-run set_cheapest() here to identify the
         * cheapest path, but it seems unlikely that adding the same tlist
         * eval costs to all the paths would change that, so we don't bother.
         * Instead, just assume that the cheapest-startup and cheapest-total
         * paths remain so.  (There should be no parameterized paths anymore,
         * so we needn't worry about updating cheapest_parameterized_paths.)
         */</comment>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>current_rel-&gt;pathlist</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>apply_projection_to_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>current_rel</name></expr></argument>,
                                            <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>scanjoin_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* If we had to add a Result, path is different from subpath */</comment>
            <if_stmt><if>if <condition>(<expr><name>path</name> <operator>!=</operator> <name>subpath</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>subpath</name> <operator>==</operator> <name><name>current_rel</name><operator>-&gt;</operator><name>cheapest_startup_path</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>current_rel</name><operator>-&gt;</operator><name>cheapest_startup_path</name></name> <operator>=</operator> <name>path</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>subpath</name> <operator>==</operator> <name><name>current_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>current_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name> <operator>=</operator> <name>path</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <comment type="block">/*
         * Upper planning steps which make use of the top scan/join rel's
         * partial pathlist will expect partial paths for that rel to produce
         * the same output as complete paths ... and we just changed the
         * output for the complete paths, so we'll need to do the same thing
         * for partial paths.  But only parallel-safe expressions can be
         * computed by partial paths.
         */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>current_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>&amp;&amp;</operator> <name>scanjoin_target_parallel_safe</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Apply the scan/join target to each partial path */</comment>
            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>current_rel-&gt;partial_pathlist</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>newpath</name></decl>;</decl_stmt>

                <comment type="block">/* Shouldn't have any parameterized paths anymore */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Don't use apply_projection_to_path() here, because there
                 * could be other pointers to these paths, and therefore we
                 * mustn't modify them in place.
                 */</comment>
                <expr_stmt><expr><name>newpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_projection_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                          <argument><expr><name>current_rel</name></expr></argument>,
                                                          <argument><expr><name>subpath</name></expr></argument>,
                                                          <argument><expr><name>scanjoin_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>newpath</name></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * In the unfortunate event that scanjoin_target is not
             * parallel-safe, we can't apply it to the partial paths; in that
             * case, we'll need to forget about the partial paths, which
             * aren't valid input for upper planning steps.
             */</comment>
            <expr_stmt><expr><name><name>current_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Now fix things up if scan/join target contains SRFs */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>adjust_paths_for_srfs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>current_rel</name></expr></argument>,
                                  <argument><expr><name>scanjoin_targets</name></expr></argument>,
                                  <argument><expr><name>scanjoin_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Save the various upper-rel PathTargets we just computed into
         * root-&gt;upper_targets[].  The core code doesn't use this, but it
         * provides a convenient place for extensions to get at the info.  For
         * consistency, we save all the intermediate targets, even though some
         * of the corresponding upperrels might not be needed for this query.
         */</comment>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>upper_targets</name><index>[<expr><name>UPPERREL_FINAL</name></expr>]</index></name> <operator>=</operator> <name>final_target</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>upper_targets</name><index>[<expr><name>UPPERREL_WINDOW</name></expr>]</index></name> <operator>=</operator> <name>sort_input_target</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>upper_targets</name><index>[<expr><name>UPPERREL_GROUP_AGG</name></expr>]</index></name> <operator>=</operator> <name>grouping_target</name></expr>;</expr_stmt>

        <comment type="block">/*
         * If we have grouping and/or aggregation, consider ways to implement
         * that.  We build a new upperrel representing the output of this
         * phase.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>have_grouping</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>current_rel</name> <operator>=</operator> <call><name>create_grouping_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                <argument><expr><name>current_rel</name></expr></argument>,
                                                <argument><expr><name>grouping_target</name></expr></argument>,
												<argument><expr><name>grouping_target_parallel_safe</name></expr></argument>,
                                                <argument><expr><operator>&amp;</operator><name>agg_costs</name></expr></argument>,
                                                <argument><expr><name>gset_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Fix things up if grouping_target contains SRFs */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>adjust_paths_for_srfs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>current_rel</name></expr></argument>,
                                      <argument><expr><name>grouping_targets</name></expr></argument>,
                                      <argument><expr><name>grouping_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If we have window functions, consider ways to implement those.  We
         * build a new upperrel representing the output of this phase.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>activeWindows</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>current_rel</name> <operator>=</operator> <call><name>create_window_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                              <argument><expr><name>current_rel</name></expr></argument>,
                                              <argument><expr><name>grouping_target</name></expr></argument>,
                                              <argument><expr><name>sort_input_target</name></expr></argument>,
											  <argument><expr><name>sort_input_target_parallel_safe</name></expr></argument>,
                                              <argument><expr><name>tlist</name></expr></argument>,
                                              <argument><expr><name>wflists</name></expr></argument>,
                                              <argument><expr><name>activeWindows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Fix things up if sort_input_target contains SRFs */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>adjust_paths_for_srfs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>current_rel</name></expr></argument>,
                                      <argument><expr><name>sort_input_targets</name></expr></argument>,
                                      <argument><expr><name>sort_input_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If there is a DISTINCT clause, consider ways to implement that. We
         * build a new upperrel representing the output of this phase.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>current_rel</name> <operator>=</operator> <call><name>create_distinct_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                <argument><expr><name>current_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>                            <comment type="block">/* end of if (setOperations) */</comment>

    <comment type="block">/*
     * If ORDER BY was given, consider ways to implement that, and generate a
     * new upperrel containing only paths that emit the correct ordering and
     * project the correct final_target.  We can apply the original
     * limit_tuples limit in sort costing here, but only if there are no
     * postponed SRFs.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>sortClause</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>current_rel</name> <operator>=</operator> <call><name>create_ordered_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                           <argument><expr><name>current_rel</name></expr></argument>,
                                           <argument><expr><name>final_target</name></expr></argument>,
										   <argument><expr><name>final_target_parallel_safe</name></expr></argument>,
                                           <argument><expr><ternary><condition><expr><name>have_postponed_srfs</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1.0</literal></expr> </then><else>:
                                           <expr><name>limit_tuples</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Fix things up if final_target contains SRFs */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>adjust_paths_for_srfs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>current_rel</name></expr></argument>,
                                  <argument><expr><name>final_targets</name></expr></argument>,
                                  <argument><expr><name>final_targets_contain_srfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Now we are prepared to build the final-output upperrel.
     */</comment>
    <expr_stmt><expr><name>final_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If the input rel is marked consider_parallel and there's nothing that's
     * not parallel-safe in the LIMIT clause, then the final_rel can be marked
     * consider_parallel as well.  Note that if the query has rowMarks or is
     * not a SELECT, consider_parallel will be false for every relation in the
     * query.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>current_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
        <call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>final_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If the current_rel belongs to a single FDW, so does the final_rel.
     */</comment>
    <expr_stmt><expr><name><name>final_rel</name><operator>-&gt;</operator><name>serverid</name></name> <operator>=</operator> <name><name>current_rel</name><operator>-&gt;</operator><name>serverid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>final_rel</name><operator>-&gt;</operator><name>userid</name></name> <operator>=</operator> <name><name>current_rel</name><operator>-&gt;</operator><name>userid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>final_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name> <operator>=</operator> <name><name>current_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>final_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>=</operator> <name><name>current_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Generate paths for the final_rel.  Insert all surviving paths, with
     * LockRows, Limit, and/or ModifyTable steps added if needed.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>current_rel-&gt;pathlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * If there is a FOR [KEY] UPDATE/SHARE clause, add the LockRows node.
         * (Note: we intentionally test parse-&gt;rowMarks not root-&gt;rowMarks
         * here.  If there are only non-locking rowmarks, they should be
         * handled by the ModifyTable node instead.  However, root-&gt;rowMarks
         * is what goes into the LockRows node.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_lockrows_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>final_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                                 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>,
                                                 <argument><expr><call><name>SS_assign_special_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If there is a LIMIT/OFFSET clause, add the LIMIT node.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>limit_needed</name><argument_list>(<argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>pushDown</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* If needed, add a LimitPath on top of a RemoteSubplan. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>distribution</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Try to push down LIMIT clause to the remote node, in order
                 * to limit the number of rows that get shipped over network.
                 * This can be done even if there is an ORDER BY clause, as
                 * long as we fetch at least (limit + offset) rows from all the
                 * nodes and then do a local sort and apply the original limit.
                 *
                 * We can only push down the LIMIT clause when it's a constant.
                 * Similarly, if the OFFSET is specified, then it must be constant
                 * too.
                 *
                 * Simple expressions get folded into constants by the time we come
                 * here. So this works well in case of constant expressions such as
                 *
                 *     SELECT .. LIMIT (1024 * 1024);
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                    <operator>(</operator><operator>(</operator><name><name>parse</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>limitCount</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                                                   <argument><expr><name>InvalidOid</name></expr></argument>,
                                                   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                       <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>offset_est</name> <operator>+</operator> <name>count_est</name></expr></argument>)</argument_list></call></expr></argument>,
                                                   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>FLOAT8PASSBYVAL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_limit_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>final_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                              <argument><expr><name>NULL</name></expr></argument>,
                                              <argument><expr><name>limitCount</name></expr></argument>, <comment type="block">/* LIMIT + OFFSET */</comment>
											  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>offset_est</name> <operator>+</operator> <name>count_est</name></expr></argument>,
											  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<comment type="block">/*
					 * Upper level limit node could skip early ExecFinishNode to save
					 * 2~3ms of meaningless communication, since we've already push
					 * down the limit.
					 */</comment>
					<expr_stmt><expr><name>pushDown</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_limit_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>final_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                              <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>,
                                              <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>,
											  <argument><expr><name>offset_est</name></expr></argument>, <argument><expr><name>count_est</name></expr></argument>,
											  <argument><expr><name>pushDown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If this is an INSERT/UPDATE/DELETE, and we're not being called from
         * inheritance_planner, add the ModifyTable node.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>inheritance_update</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>withCheckOptionLists</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>returningLists</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>rowMarks</name></decl>;</decl_stmt>

            <comment type="block">/*
             * Set up the WITH CHECK OPTION and RETURNING lists-of-lists, if
             * needed.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>withCheckOptions</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>withCheckOptionLists</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>withCheckOptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>withCheckOptionLists</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>returningLists</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>returningLists</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="block">/*
             * If there was a FOR [KEY] UPDATE/SHARE clause, the LockRows node
             * will have dealt with fetching non-locked marked rows, else we
             * need to have ModifyTable do that.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>rowMarks</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>rowMarks</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>rowMarks</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="block">/*
             * Adjust path by injecting a remote subplan, if appropriate, so
             * that the ModifyTablePath gets properly distributed data.
             */</comment>
            <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>adjust_path_distribution</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <comment type="block">/*
             * unshippable triggers found on target relation, we have to do DML
             * on coordinator.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasUnshippableTriggers</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>distribution</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>adjust_modifytable_subpath</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
                <call><name>create_modifytable_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>final_rel</name></expr></argument>,
                                        <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>,
                                        <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>,
                                        <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>,
                                        <argument><expr><name>NIL</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>,
                                        <argument><expr><call><name>list_make1_int</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><name>withCheckOptionLists</name></expr></argument>,
                                        <argument><expr><name>returningLists</name></expr></argument>,
                                        <argument><expr><name>rowMarks</name></expr></argument>,
                                        <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>onConflict</name></name></expr></argument>,
                                        <argument><expr><call><name>SS_assign_special_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <comment type="block">/* Adjust path by injecting a remote subplan, if appropriate. */</comment>
            <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>adjust_path_distribution</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* And shove it into final_rel */</comment>
        <expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>final_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
	 * Generate partial paths for final_rel, too, if outer query levels might
	 * be able to make use of them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>final_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>query_level</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>limit_needed</name><argument_list>(<argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>&amp;&amp;</operator> <name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>current_rel-&gt;partial_pathlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>partial_path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>add_partial_path</name><argument_list>(<argument><expr><name>final_rel</name></expr></argument>, <argument><expr><name>partial_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
     * If there is an FDW that's responsible for all baserels of the query,
     * let it consider adding ForeignPaths.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>final_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>&amp;&amp;</operator>
        <name><name>final_rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignUpperPaths</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name><name>final_rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignUpperPaths</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>,
                                                    <argument><expr><name>current_rel</name></expr></argument>, <argument><expr><name>final_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Let extensions possibly add some more paths */</comment>
    <if_stmt><if>if <condition>(<expr><name>create_upper_paths_hook</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call>(<modifier>*</modifier><name>create_upper_paths_hook</name>) <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>,
                                    <argument><expr><name>current_rel</name></expr></argument>, <argument><expr><name>final_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Note: currently, we leave it to callers to do set_cheapest() */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Do preprocessing for groupingSets clause and related data.  This handles the
 * preliminary steps of expanding the grouping sets, organizing them into lists
 * of rollups, and preparing annotations which will later be filled in with
 * size estimates.
 */</comment>
<function><type><specifier>static</specifier> <name>grouping_sets_data</name> <modifier>*</modifier></type>
<name>preprocess_grouping_sets</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>sets</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>maxref</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc_set</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>grouping_sets_data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>=</operator> <call><name>expand_grouping_sets</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>any_hashable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>unhashable_refs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_refs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_sets</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parse-&gt;groupClause</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>gc</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Index</name></type>        <name>ref</name> <init>= <expr><name><name>gc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>ref</name> <operator>&gt;</operator> <name>maxref</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>maxref</name> <operator>=</operator> <name>ref</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>gc</name><operator>-&gt;</operator><name>hashable</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>unhashable_refs</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>unhashable_refs</name></name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_refs</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_refs</name></name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Allocate workspace array for remapping */</comment>
    <expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>tleref_to_colnum_map</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>maxref</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we have any unsortable sets, we must extract them before trying to
     * prepare rollups. Unsortable sets don't go through
     * reorder_grouping_sets, so we must apply the GroupingSetData annotation
     * here.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_refs</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>sortable_sets</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parse-&gt;groupingSets</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>gset</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>bms_overlap_list</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_refs</name></name></expr></argument>, <argument><expr><name>gset</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>GroupingSetData</name> <modifier>*</modifier></type><name>gs</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>GroupingSetData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>set</name></name> <operator>=</operator> <name>gset</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_sets</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_sets</name></name></expr></argument>, <argument><expr><name>gs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * We must enforce here that an unsortable set is hashable;
                 * later code assumes this.  Parse analysis only checks that
                 * every individual column is either hashable or sortable.
                 *
                 * Note that passing this test doesn't guarantee we can
                 * generate a plan; there might be other showstoppers.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>bms_overlap_list</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>unhashable_refs</name></name></expr></argument>, <argument><expr><name>gset</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not implement GROUP BY"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Some of the datatypes only support hashing, while others only support sorting."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>sortable_sets</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>sortable_sets</name></expr></argument>, <argument><expr><name>gset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block>

        <if_stmt><if>if <condition>(<expr><name>sortable_sets</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>sets</name> <operator>=</operator> <call><name>extract_rollup_sets</name><argument_list>(<argument><expr><name>sortable_sets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>sets</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>sets</name> <operator>=</operator> <call><name>extract_rollup_sets</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc_set</argument>, <argument>sets</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>current_sets</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc_set</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RollupData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GroupingSetData</name> <modifier>*</modifier></type><name>gs</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Reorder the current list of grouping sets into correct prefix
         * order.  If only one aggregation pass is needed, try to make the
         * list match the ORDER BY clause; if more than one pass is needed, we
         * don't bother with that.
         *
         * Note that this reorders the sets from smallest-member-first to
         * largest-member-first, and applies the GroupingSetData annotations,
         * though the data will be filled in later.
         */</comment>
        <expr_stmt><expr><name>current_sets</name> <operator>=</operator> <call><name>reorder_grouping_sets</name><argument_list>(<argument><expr><name>current_sets</name></expr></argument>,
                                             <argument><expr><operator>(</operator><ternary><condition><expr><call><name>list_length</name><argument_list>(<argument><expr><name>sets</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>
                                              ?</condition><then> <expr><name><name>parse</name><operator>-&gt;</operator><name>sortClause</name></name></expr>
                                              </then><else>: <expr><name>NIL</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Get the initial (and therefore largest) grouping set.
         */</comment>
        <expr_stmt><expr><name>gs</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>current_sets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Order the groupClause appropriately.  If the first grouping set is
         * empty, then the groupClause must also be empty; otherwise we have
         * to force the groupClause to match that grouping set's order.
         *
         * (The first grouping set can be empty even though parse-&gt;groupClause
         * is not empty only if all non-empty grouping sets are unsortable.
         * The groupClauses for hashed grouping sets are built later on.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>gs</name><operator>-&gt;</operator><name>set</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <call><name>preprocess_groupclause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>gs</name><operator>-&gt;</operator><name>set</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*
         * Is it hashable? We pretend empty sets are hashable even though we
         * actually force them not to be hashed later. But don't bother if
         * there's nothing but empty sets (since in that case we can't hash
         * anything).
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>gs</name><operator>-&gt;</operator><name>set</name></name> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name>bms_overlap_list</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>unhashable_refs</name></name></expr></argument>, <argument><expr><name><name>gs</name><operator>-&gt;</operator><name>set</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>any_hashable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Now that we've pinned down an order for the groupClause for this
         * list of grouping sets, we need to remap the entries in the grouping
         * sets from sortgrouprefs to plain indices (0-based) into the
         * groupClause for this collection of grouping sets. We keep the
         * original form for later use, though.
         */</comment>
        <expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets</name></name> <operator>=</operator> <call><name>remap_to_groupclause_idx</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
                                                 <argument><expr><name>current_sets</name></expr></argument>,
                                                 <argument><expr><name><name>gd</name><operator>-&gt;</operator><name>tleref_to_colnum_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets_data</name></name> <operator>=</operator> <name>current_sets</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>rollups</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>rollups</name></name></expr></argument>, <argument><expr><name>rollup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <if_stmt><if>if <condition>(<expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_sets</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We have not yet pinned down a groupclause for this, but we will
         * need index-based lists for estimation purposes. Construct
         * hash_sets_idx based on the entire original groupclause for now.
         */</comment>
        <expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>hash_sets_idx</name></name> <operator>=</operator> <call><name>remap_to_groupclause_idx</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
                                                     <argument><expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_sets</name></name></expr></argument>,
                                                     <argument><expr><name><name>gd</name><operator>-&gt;</operator><name>tleref_to_colnum_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>any_hashable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>gd</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a groupclause and a list of GroupingSetData, return equivalent sets
 * (without annotation) mapped to indexes into the given groupclause.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>remap_to_groupclause_idx</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>,
                         <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>gsets</name></decl></parameter>,
                         <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tleref_to_colnum_map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>ref</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>groupClause</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>gc</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>tleref_to_colnum_map</name><index>[<expr><name><name>gc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr>]</index></name> <operator>=</operator> <name>ref</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>gsets</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>set</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GroupingSetData</name> <modifier>*</modifier></type><name>gs</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>gs-&gt;set</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>set</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><name><name>tleref_to_colnum_map</name><index>[<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
 * Detect whether a plan node is a "dummy" plan created when a relation
 * is deemed not to need scanning due to constraint exclusion.
 *
 * Currently, such dummy plans are Result nodes with constant FALSE
 * filter quals (see set_dummy_rel_pathlist and create_append_plan).
 *
 * XXX this probably ought to be somewhere else, but not clear where.
 */</comment>
<function><type><name>bool</name></type>
<name>is_dummy_plan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>rcqual</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>Result</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>resconstantqual</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>rcqual</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Const</name>       <modifier>*</modifier></type><name>constqual</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>rcqual</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>constqual</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>constqual</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>constqual</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>&amp;&amp;</operator>
                    <operator>!</operator><call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>constqual</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * preprocess_rowmarks - set up PlanRowMarks if needed
 */</comment>
<function><type><name>void</name></type>
<name>preprocess_rowmarks</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>rels</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>prowmarks</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We've got trouble if FOR [KEY] UPDATE/SHARE appears inside
         * grouping, since grouping renders a reference to individual tuple
         * CTIDs invalid.  This is also checked at parse time, but that's
         * insufficient because of rule substitution, query pullup, etc.
         */</comment>
        <expr_stmt><expr><call><name>CheckSelectLocking</name><argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>RowMarkClause</name> <operator>*</operator><operator>)</operator>
                                   <call><name>linitial</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>strength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>baserels</name> <init>= <expr><call><name>get_relids_in_jointree</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
                    <name><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>num_rels</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>dist_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr><operator>(</operator><name>x</name> <operator>=</operator> <call><name>bms_first_member</name><argument_list>(<argument><expr><name>baserels</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>locinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>locinfo</name> <operator>=</operator> <call><name>GetRelationLocInfo</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>locinfo</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsRelationReplicated</name><argument_list>(<argument><expr><name>locinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>dist_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>num_rels</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>

            <if_stmt><if>if <condition>(<expr><name>dist_found</name> <operator>&amp;&amp;</operator> <name>num_rels</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s is not allowed with joins"</literal></expr></argument>,
                             <argument><expr><call><name>LCS_asString</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RowMarkClause</name> <operator>*</operator><operator>)</operator>
                                     <call><name>linitial</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>strength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * We only need rowmarks for UPDATE, DELETE, or FOR [KEY]
         * UPDATE/SHARE.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator>
            <name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_DELETE</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * We need to have rowmarks for all base relations except the target. We
     * make a bitmapset of all base rels and then remove the items we don't
     * need or have FOR [KEY] UPDATE/SHARE marks for.
     */</comment>
    <expr_stmt><expr><name>rels</name> <operator>=</operator> <call><name>get_relids_in_jointree</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>rels</name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Convert RowMarkClauses to PlanRowMark representation.
     */</comment>
    <expr_stmt><expr><name>prowmarks</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>parse-&gt;rowMarks</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RowMarkClause</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><operator>(</operator><name>RowMarkClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>newrc</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Currently, it is syntactically impossible to have FOR UPDATE et al
         * applied to an update/delete target rel.  If that ever becomes
         * possible, we should drop the target from the PlanRowMark list.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name> <operator>!=</operator> <name><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Ignore RowMarkClauses for subqueries; they aren't real tables and
         * can't support true locking.  Subqueries that got flattened into the
         * main query should be ignored completely.  Any that didn't will get
         * ROW_MARK_COPY items in the next loop.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>rels</name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name>rels</name></expr></argument>, <argument><expr><name><name>rc</name><operator>-&gt;</operator><name>rti</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>newrc</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlanRowMark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>rti</name></name> <operator>=</operator> <name><name>newrc</name><operator>-&gt;</operator><name>prti</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>rti</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>rowmarkId</name></name> <operator>=</operator> <operator>++</operator><operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>lastRowMarkId</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>markType</name></name> <operator>=</operator> <call><name>select_rowmark_type</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name><name>rc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>allMarkTypes</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>newrc</name><operator>-&gt;</operator><name>markType</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>strength</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>strength</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>waitPolicy</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>waitPolicy</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>isParent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>prowmarks</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>prowmarks</name></expr></argument>, <argument><expr><name>newrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>


    <comment type="block">/*
     * Now, add rowmarks for any non-target, non-locked base relations.
     */</comment>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>parse-&gt;rtable</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PlanRowMark</name> <modifier>*</modifier></type><name>newrc</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>rels</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>newrc</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlanRowMark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>rti</name></name> <operator>=</operator> <name><name>newrc</name><operator>-&gt;</operator><name>prti</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>rowmarkId</name></name> <operator>=</operator> <operator>++</operator><operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>lastRowMarkId</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>markType</name></name> <operator>=</operator> <call><name>select_rowmark_type</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>LCS_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>allMarkTypes</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>newrc</name><operator>-&gt;</operator><name>markType</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>strength</name></name> <operator>=</operator> <name>LCS_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>waitPolicy</name></name> <operator>=</operator> <name>LockWaitBlock</name></expr>;</expr_stmt>    <comment type="block">/* doesn't matter */</comment>
        <expr_stmt><expr><name><name>newrc</name><operator>-&gt;</operator><name>isParent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>prowmarks</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>prowmarks</name></expr></argument>, <argument><expr><name>newrc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <name>prowmarks</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Select RowMarkType to use for a given table
 */</comment>
<function><type><name>RowMarkType</name></type>
<name>select_rowmark_type</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>LockClauseStrength</name></type> <name>strength</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* If it's not a table at all, use ROW_MARK_COPY */</comment>
        <return>return <expr><name>ROW_MARK_COPY</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Let the FDW select the rowmark type, if it wants to */</comment>
        <decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name> <init>= <expr><call><name>GetFdwRoutineByRelId</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignRowMarkType</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignRowMarkType</name></name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>strength</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <comment type="block">/* Otherwise, use ROW_MARK_COPY by default */</comment>
        <return>return <expr><name>ROW_MARK_COPY</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Regular table, apply the appropriate lock type */</comment>
        <switch>switch <condition>(<expr><name>strength</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>LCS_NONE</name></expr>:</case>

                <comment type="block">/*
                 * We don't need a tuple lock, only the ability to re-fetch
                 * the row.
                 */</comment>
                <return>return <expr><name>ROW_MARK_REFERENCE</name></expr>;</return>
                <break>break;</break>
            <case>case <expr><name>LCS_FORKEYSHARE</name></expr>:</case>
                <return>return <expr><name>ROW_MARK_KEYSHARE</name></expr>;</return>
                <break>break;</break>
            <case>case <expr><name>LCS_FORSHARE</name></expr>:</case>
                <return>return <expr><name>ROW_MARK_SHARE</name></expr>;</return>
                <break>break;</break>
            <case>case <expr><name>LCS_FORNOKEYUPDATE</name></expr>:</case>
                <return>return <expr><name>ROW_MARK_NOKEYEXCLUSIVE</name></expr>;</return>
                <break>break;</break>
            <case>case <expr><name>LCS_FORUPDATE</name></expr>:</case>
                <return>return <expr><name>ROW_MARK_EXCLUSIVE</name></expr>;</return>
                <break>break;</break>
        </block_content>}</block></switch>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized LockClauseStrength %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>strength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ROW_MARK_EXCLUSIVE</name></expr>;</return>    <comment type="block">/* keep compiler quiet */</comment>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * preprocess_limit - do pre-estimation for LIMIT and/or OFFSET clauses
 *
 * We try to estimate the values of the LIMIT/OFFSET clauses, and pass the
 * results back in *count_est and *offset_est.  These variables are set to
 * 0 if the corresponding clause is not present, and -1 if it's present
 * but we couldn't estimate the value for it.  (The "0" convention is OK
 * for OFFSET but a little bit bogus for LIMIT: effectively we estimate
 * LIMIT 0 as though it were LIMIT 1.  But this is in line with the planner's
 * usual practice of never estimating less than one row.)  These values will
 * be passed to create_limit_path, which see if you change this code.
 *
 * The return value is the suitably adjusted tuple_fraction to use for
 * planning the query.  This adjustment is not overridable, since it reflects
 * plan actions that grouping_planner() will certainly take, not assumptions
 * about context.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>preprocess_limit</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>tuple_fraction</name></decl></parameter>,
                 <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>offset_est</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>count_est</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>est</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>limit_fraction</name></decl>;</decl_stmt>

    <comment type="block">/* Should not be called unless LIMIT or OFFSET */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Try to obtain the clause values.  We use estimate_expression_value
     * primarily because it can sometimes do something useful with Params.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>limitCount</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>est</name> <operator>=</operator> <call><name>estimate_expression_value</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>est</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>est</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>est</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* NULL indicates LIMIT ALL, ie, no limit */</comment>
                <expr_stmt><expr><operator>*</operator><name>count_est</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* treat as not present */</comment>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>count_est</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>est</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>*</operator><name>count_est</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>count_est</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* force to at least 1 */</comment>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>count_est</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>    <comment type="block">/* can't estimate */</comment>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>count_est</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>            <comment type="block">/* not present */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>limitOffset</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>est</name> <operator>=</operator> <call><name>estimate_expression_value</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>est</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>est</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>est</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Treat NULL as no offset; the executor will too */</comment>
                <expr_stmt><expr><operator>*</operator><name>offset_est</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    <comment type="block">/* treat as not present */</comment>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>offset_est</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>est</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>*</operator><name>offset_est</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>offset_est</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* treat as not present */</comment>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>offset_est</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>    <comment type="block">/* can't estimate */</comment>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>offset_est</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>        <comment type="block">/* not present */</comment>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>count_est</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * A LIMIT clause limits the absolute number of tuples returned.
         * However, if it's not a constant LIMIT then we have to guess; for
         * lack of a better idea, assume 10% of the plan's result is wanted.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>count_est</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>offset_est</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* LIMIT or OFFSET is an expression ... punt ... */</comment>
            <expr_stmt><expr><name>limit_fraction</name> <operator>=</operator> <literal type="number">0.10</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* LIMIT (plus OFFSET, if any) is max number of tuples needed */</comment>
            <expr_stmt><expr><name>limit_fraction</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>*</operator><name>count_est</name> <operator>+</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>*</operator><name>offset_est</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * If we have absolute limits from both caller and LIMIT, use the
         * smaller value; likewise if they are both fractional.  If one is
         * fractional and the other absolute, we can't easily determine which
         * is smaller, but we use the heuristic that the absolute will usually
         * be smaller.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>tuple_fraction</name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>limit_fraction</name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* both absolute */</comment>
                <expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>tuple_fraction</name></expr></argument>, <argument><expr><name>limit_fraction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* caller absolute, limit fractional; use caller's value */</comment>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>tuple_fraction</name> <operator>&gt;</operator> <literal type="number">0.0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>limit_fraction</name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* caller fractional, limit absolute; use limit */</comment>
                <expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <name>limit_fraction</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* both fractional */</comment>
                <expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>tuple_fraction</name></expr></argument>, <argument><expr><name>limit_fraction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* no info from caller, just use limit */</comment>
            <expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <name>limit_fraction</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>*</operator><name>offset_est</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tuple_fraction</name> <operator>&gt;</operator> <literal type="number">0.0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We have an OFFSET but no LIMIT.  This acts entirely differently
         * from the LIMIT case: here, we need to increase rather than decrease
         * the caller's tuple_fraction, because the OFFSET acts to cause more
         * tuples to be fetched instead of fewer.  This only matters if we got
         * a tuple_fraction &gt; 0, however.
         *
         * As above, use 10% if OFFSET is present but unestimatable.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>offset_est</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>limit_fraction</name> <operator>=</operator> <literal type="number">0.10</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>limit_fraction</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>*</operator><name>offset_est</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*
         * If we have absolute counts from both caller and OFFSET, add them
         * together; likewise if they are both fractional.  If one is
         * fractional and the other absolute, we want to take the larger, and
         * we heuristically assume that's the fractional one.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>tuple_fraction</name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>limit_fraction</name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* both absolute, so add them together */</comment>
                <expr_stmt><expr><name>tuple_fraction</name> <operator>+=</operator> <name>limit_fraction</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* caller absolute, limit fractional; use limit */</comment>
                <expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <name>limit_fraction</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>limit_fraction</name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* caller fractional, limit absolute; use caller's value */</comment>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* both fractional, so add them together */</comment>
                <expr_stmt><expr><name>tuple_fraction</name> <operator>+=</operator> <name>limit_fraction</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>tuple_fraction</name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* assume fetch all */</comment>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>tuple_fraction</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * limit_needed - do we actually need a Limit plan node?
 *
 * If we have constant-zero OFFSET and constant-null LIMIT, we can skip adding
 * a Limit node.  This is worth checking for because "OFFSET 0" is a common
 * locution for an optimization fence.  (Because other places in the planner
 * merely check whether parse-&gt;limitOffset isn't NULL, it will still work as
 * an optimization fence --- we're just suppressing unnecessary run-time
 * overhead.)
 *
 * This might look like it could be merged into preprocess_limit, but there's
 * a key distinction: here we need hard constants in OFFSET/LIMIT, whereas
 * in preprocess_limit it's good enough to consider estimated values.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>limit_needed</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>limitCount</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>node</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* NULL indicates LIMIT ALL, ie, no limit */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* LIMIT with a constant value */</comment>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>        <comment type="block">/* non-constant LIMIT */</comment>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>limitOffset</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>node</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Treat NULL as no offset; the executor would too */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int64</name></type>        <name>offset</name> <init>= <expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* OFFSET with a nonzero value */</comment>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>        <comment type="block">/* non-constant OFFSET */</comment>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>                <comment type="block">/* don't need a Limit plan node */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * remove_useless_groupby_columns
 *        Remove any columns in the GROUP BY clause that are redundant due to
 *        being functionally dependent on other GROUP BY columns.
 *
 * Since some other DBMSes do not allow references to ungrouped columns, it's
 * not unusual to find all columns listed in GROUP BY even though listing the
 * primary-key columns would be sufficient.  Deleting such excess columns
 * avoids redundant sorting work, so it's worth doing.  When we do this, we
 * must mark the plan as dependent on the pkey constraint (compare the
 * parser's check_ungrouped_columns() and check_functional_grouping()).
 *
 * In principle, we could treat any NOT-NULL columns appearing in a UNIQUE
 * index as the determining columns.  But as with check_functional_grouping(),
 * there's currently no way to represent dependency on a NOT NULL constraint,
 * so we consider only the pkey for now.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>remove_useless_groupby_columns</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>groupbyattnos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>surplusvars</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>relid</name></decl>;</decl_stmt>

    <comment type="block">/* No chance to do anything if there are less than two GROUP BY items */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Don't fiddle with the GROUP BY clause if the query has grouping sets */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Scan the GROUP BY clause to find GROUP BY items that are simple Vars.
     * Fill groupbyattnos[k] with a bitmapset of the column attnos of RTE k
     * that are GROUP BY items.
     */</comment>
    <expr_stmt><expr><name>groupbyattnos</name> <operator>=</operator> <operator>(</operator><name>Bitmapset</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Bitmapset</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator>
                                           <operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parse-&gt;groupClause</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgc</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sgc</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Var</name>           <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Ignore non-Vars and Vars from other query levels.
         *
         * XXX in principle, stable expressions containing Vars could also be
         * removed, if all the Vars are functionally dependent on other GROUP
         * BY items.  But it's not clear that such cases occur often enough to
         * be worth troubling over.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* OK, remember we have this Var */</comment>
        <expr_stmt><expr><name>relid</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relid</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>groupbyattnos</name><index>[<expr><name>relid</name></expr>]</index></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>groupbyattnos</name><index>[<expr><name>relid</name></expr>]</index></name></expr></argument>,
                                              <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Consider each relation and see if it is possible to remove some of its
     * Vars from GROUP BY.  For simplicity and speed, we do the actual removal
     * in a separate pass.  Here, we just fill surplusvars[k] with a bitmapset
     * of the column attnos of RTE k that are removable GROUP BY items.
     */</comment>
    <expr_stmt><expr><name>surplusvars</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>            <comment type="block">/* don't allocate array unless required */</comment>
    <expr_stmt><expr><name>relid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parse-&gt;rtable</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>relattnos</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>pkattnos</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>constraintOid</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>relid</name><operator>++</operator></expr>;</expr_stmt>

        <comment type="block">/* Only plain relations could have primary-key constraints */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Nothing to do unless this rel has multiple Vars in GROUP BY */</comment>
        <expr_stmt><expr><name>relattnos</name> <operator>=</operator> <name><name>groupbyattnos</name><index>[<expr><name>relid</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>bms_membership</name><argument_list>(<argument><expr><name>relattnos</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>BMS_MULTIPLE</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Can't remove any columns for this rel if there is no suitable
         * (i.e., nondeferrable) primary key constraint.
         */</comment>
        <expr_stmt><expr><name>pkattnos</name> <operator>=</operator> <call><name>get_primary_key_attnos</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>pkattnos</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * If the primary key is a proper subset of relattnos then we have
         * some items in the GROUP BY that can be removed.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>bms_subset_compare</name><argument_list>(<argument><expr><name>pkattnos</name></expr></argument>, <argument><expr><name>relattnos</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BMS_SUBSET1</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * To easily remember whether we've found anything to do, we don't
             * allocate the surplusvars[] array until we find something.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>surplusvars</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>surplusvars</name> <operator>=</operator> <operator>(</operator><name>Bitmapset</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Bitmapset</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator>
                                                     <operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* Remember the attnos of the removable columns */</comment>
            <expr_stmt><expr><name><name>surplusvars</name><index>[<expr><name>relid</name></expr>]</index></name> <operator>=</operator> <call><name>bms_difference</name><argument_list>(<argument><expr><name>relattnos</name></expr></argument>, <argument><expr><name>pkattnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Also, mark the resulting plan as dependent on this constraint */</comment>
            <expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>constraintDeps</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>constraintDeps</name></name></expr></argument>,
                                                <argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * If we found any surplus Vars, build a new GROUP BY clause without them.
     * (Note: this may leave some TLEs with unreferenced ressortgroupref
     * markings, but that's harmless.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>surplusvars</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>new_groupby</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parse-&gt;groupClause</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgc</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sgc</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Var</name>           <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * New list must include non-Vars, outer Vars, and anything not
             * marked as surplus.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>||</operator>
                <name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
                <operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>,
                               <argument><expr><name><name>surplusvars</name><index>[<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>new_groupby</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_groupby</name></expr></argument>, <argument><expr><name>sgc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>

        <expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <name>new_groupby</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * preprocess_groupclause - do preparatory work on GROUP BY clause
 *
 * The idea here is to adjust the ordering of the GROUP BY elements
 * (which in itself is semantically insignificant) to match ORDER BY,
 * thereby allowing a single sort operation to both implement the ORDER BY
 * requirement and set up for a Unique step that implements GROUP BY.
 *
 * In principle it might be interesting to consider other orderings of the
 * GROUP BY elements, which could match the sort ordering of other
 * possible plans (eg an indexscan) and thereby reduce cost.  We don't
 * bother with that, though.  Hashed grouping will frequently win anyway.
 *
 * Note: we need no comparable processing of the distinctClause because
 * the parser already enforced that that matches ORDER BY.
 *
 * For grouping sets, the order of items is instead forced to agree with that
 * of the grouping set (and items not in the grouping set are skipped). The
 * work of sorting the order of grouping set elements to match the ORDER BY if
 * possible is done elsewhere.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>preprocess_groupclause</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>new_groupclause</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>partial_match</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>sl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>gl</name></decl>;</decl_stmt>

    <comment type="block">/* For grouping sets, we need to force the ordering */</comment>
    <if_stmt><if>if <condition>(<expr><name>force</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>foreach</name><argument_list>(<argument>sl</argument>, <argument>force</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Index</name></type>        <name>ref</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>sl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>cl</name> <init>= <expr><call><name>get_sortgroupref_clause</name><argument_list>(<argument><expr><name>ref</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>new_groupclause</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_groupclause</name></expr></argument>, <argument><expr><name>cl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <return>return <expr><name>new_groupclause</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If no ORDER BY, nothing useful to do here */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Scan the ORDER BY clause and construct a list of matching GROUP BY
     * items, but only as far as we can make a matching prefix.
     *
     * This code assumes that the sortClause contains no duplicate items.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>sl</argument>, <argument>parse-&gt;sortClause</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sc</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>sl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>gl</argument>, <argument>parse-&gt;groupClause</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>gc</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>gl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name>sc</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>new_groupclause</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_groupclause</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <if_stmt><if>if <condition>(<expr><name>gl</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>                <comment type="block">/* no match, so stop scanning */</comment>
    </block_content>}</block>

    <comment type="block">/* Did we match all of the ORDER BY list, or just some of it? */</comment>
    <expr_stmt><expr><name>partial_match</name> <operator>=</operator> <operator>(</operator><name>sl</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* If no match at all, no point in reordering GROUP BY */</comment>
    <if_stmt><if>if <condition>(<expr><name>new_groupclause</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Add any remaining GROUP BY items to the new list, but only if we were
     * able to make a complete match.  In other words, we only rearrange the
     * GROUP BY list if the result is that one list is a prefix of the other
     * --- otherwise there's no possibility of a common sort.  Also, give up
     * if there are any non-sortable GROUP BY items, since then there's no
     * hope anyway.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>gl</argument>, <argument>parse-&gt;groupClause</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>gc</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>gl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>list_member_ptr</name><argument_list>(<argument><expr><name>new_groupclause</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* it matched an ORDER BY item */</comment>
        <if_stmt><if>if <condition>(<expr><name>partial_match</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* give up, no common sort possible */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>gc</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* give up, GROUP BY can't be sorted */</comment>
        <expr_stmt><expr><name>new_groupclause</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_groupclause</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Success --- install the rearranged GROUP BY list */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>new_groupclause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>new_groupclause</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Extract lists of grouping sets that can be implemented using a single
 * rollup-type aggregate pass each. Returns a list of lists of grouping sets.
 *
 * Input must be sorted with smallest sets first. Result has each sublist
 * sorted with smallest sets first.
 *
 * We want to produce the absolute minimum possible number of lists here to
 * avoid excess sorts. Fortunately, there is an algorithm for this; the problem
 * of finding the minimal partition of a partially-ordered set into chains
 * (which is what we need, taking the list of grouping sets as a poset ordered
 * by set inclusion) can be mapped to the problem of finding the maximum
 * cardinality matching on a bipartite graph, which is solvable in polynomial
 * time with a worst case of no worse than O(n^2.5) and usually much
 * better. Since our N is at most 4096, we don't need to consider fallbacks to
 * heuristic or approximate methods.  (Planning time for a 12-d cube is under
 * half a second on my modest system even with optimization off and assertions
 * on.)
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>extract_rollup_sets</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupingSets</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_sets_raw</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>groupingSets</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_empty</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_sets</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* distinct sets */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>num_chains</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>      <modifier>*</modifier><modifier>*</modifier></type><name>results</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>      <modifier>*</modifier><modifier>*</modifier></type><name>orig_sets</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>set_masks</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name>           <modifier>*</modifier></type><name>chains</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>short</name>      <modifier>*</modifier><modifier>*</modifier></type><name>adjacency</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>short</name>       <modifier>*</modifier></type><name>adjacency_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BipartiteMatchState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>j_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name>groupingSets</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Start by stripping out empty sets.  The algorithm doesn't require this,
     * but the planner currently needs all empty sets to be returned in the
     * first list, so we strip them here and add them back after.
     */</comment>
    <while>while <condition>(<expr><name>lc1</name> <operator>&amp;&amp;</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>++</operator><name>num_empty</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lc1</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* bail out now if it turns out that all we had were empty sets. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lc1</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>groupingSets</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*----------
     * We don't strictly need to remove duplicate sets here, but if we don't,
     * they tend to become scattered through the result, which is a bit
     * confusing (and irritating if we ever decide to optimize them out).
     * So we remove them here and add them back after.
     *
     * For each non-duplicate set, we fill in the following:
     *
     * orig_sets[i] = list of the original set lists
     * set_masks[i] = bitmapset for testing inclusion
     * adjacency[i] = array [n, v1, v2, ... vn] of adjacency indices
     *
     * chains[i] will be the result group this set is assigned to.
     *
     * We index all of these from 1 rather than 0 because it is convenient
     * to leave 0 free for the NIL node in the graph algorithm.
     *----------
     */</comment>
    <expr_stmt><expr><name>orig_sets</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name>num_sets_raw</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>set_masks</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name>num_sets_raw</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Bitmapset</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>adjacency</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name>num_sets_raw</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>short</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>adjacency_buf</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>num_sets_raw</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>short</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>j_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>lc1</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>candidate</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>candidate_set</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>dup_of</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>candidate</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>candidate_set</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>candidate_set</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <comment type="block">/* we can only be a dup if we're the same length as a previous set */</comment>
        <if_stmt><if>if <condition>(<expr><name>j_size</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>k</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name>j</name></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><operator>++</operator><name>k</name></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>set_masks</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name>candidate_set</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>dup_of</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>j_size</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>j_size</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>dup_of</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>orig_sets</name><index>[<expr><name>dup_of</name></expr>]</index></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>orig_sets</name><index>[<expr><name>dup_of</name></expr>]</index></name></expr></argument>, <argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>candidate_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>k</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>n_adj</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>orig_sets</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>set_masks</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>candidate_set</name></expr>;</expr_stmt>

            <comment type="block">/* fill in adjacency list; no need to compare equal-size sets */</comment>

            <for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>k</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>k</name></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>set_masks</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name>candidate_set</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>adjacency_buf</name><index>[<expr><operator>++</operator><name>n_adj</name></expr>]</index></name> <operator>=</operator> <name>k</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>

            <if_stmt><if>if <condition>(<expr><name>n_adj</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>adjacency_buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>n_adj</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>adjacency</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>n_adj</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>short</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>adjacency</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>adjacency_buf</name></expr></argument>, <argument><expr><operator>(</operator><name>n_adj</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>short</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>adjacency</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name>num_sets</name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Apply the graph matching algorithm to do the work.
     */</comment>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>BipartiteMatch</name><argument_list>(<argument><expr><name>num_sets</name></expr></argument>, <argument><expr><name>num_sets</name></expr></argument>, <argument><expr><name>adjacency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now, the state-&gt;pair* fields have the info we need to assign sets to
     * chains. Two sets (u,v) belong to the same chain if pair_uv[u] = v or
     * pair_vu[v] = u (both will be true, but we check both so that we can do
     * it in one pass)
     */</comment>
    <expr_stmt><expr><name>chains</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name>num_sets</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num_sets</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>u</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>pair_vu</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>v</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>pair_uv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>u</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>u</name> <operator>&lt;</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>chains</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>chains</name><index>[<expr><name>u</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>v</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>v</name> <operator>&lt;</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>chains</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>chains</name><index>[<expr><name>v</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>chains</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>++</operator><name>num_chains</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* build result lists. */</comment>
    <expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name>num_chains</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num_sets</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>c</name> <init>= <expr><name><name>chains</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>c</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>results</name><index>[<expr><name>c</name></expr>]</index></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>results</name><index>[<expr><name>c</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>orig_sets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* push any empty sets back on the first list. */</comment>
    <while>while <condition>(<expr><name>num_empty</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>results</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>, <argument><expr><name><name>results</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

    <comment type="block">/* make result list */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num_chains</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>results</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/*
     * Free all the things.
     *
     * (This is over-fussy for small sets but for large sets we could have
     * tied up a nontrivial amount of memory.)
     */</comment>
    <expr_stmt><expr><call><name>BipartiteMatchFree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>chains</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num_sets</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><name><name>adjacency</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>adjacency</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>adjacency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>adjacency_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>orig_sets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num_sets</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>set_masks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>set_masks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Reorder the elements of a list of grouping sets such that they have correct
 * prefix relationships. Also inserts the GroupingSetData annotations.
 *
 * The input must be ordered with smallest sets first; the result is returned
 * with largest sets first.  Note that the result shares no list substructure
 * with the input, so it's safe for the caller to modify it later.
 *
 * If we're passed in a sortclause, we follow its order of columns to the
 * extent possible, to minimize the chance that we add unnecessary sorts.
 * (We're trying here to ensure that GROUPING SETS ((a,b,c),(c)) ORDER BY c,b,a
 * gets implemented in one pass.)
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>reorder_grouping_sets</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupingsets</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortclause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>previous</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>groupingsets</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>candidate</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>new_elems</name> <init>= <expr><call><name>list_difference_int</name><argument_list>(<argument><expr><name>candidate</name></expr></argument>, <argument><expr><name>previous</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GroupingSetData</name> <modifier>*</modifier></type><name>gs</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>GroupingSetData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>new_elems</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <while>while <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>sortclause</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>previous</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sc</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>sortclause</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>previous</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>ref</name> <init>= <expr><name><name>sc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>list_member_int</name><argument_list>(<argument><expr><name>new_elems</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>previous</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>previous</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>new_elems</name> <operator>=</operator> <call><name>list_delete_int</name><argument_list>(<argument><expr><name>new_elems</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* diverged from the sortclause; give up on it */</comment>
                    <expr_stmt><expr><name>sortclause</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></while>

            <macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>new_elems</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>previous</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>previous</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>set</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>previous</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>gs</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>new_elems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>previous</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compute query_pathkeys and other pathkeys during plan generation
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>standard_qp_callback</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>standard_qp_extra</name> <modifier>*</modifier></type><name>qp_extra</name> <init>= <expr><operator>(</operator><name>standard_qp_extra</name> <operator>*</operator><operator>)</operator> <name>extra</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name><name>qp_extra</name><operator>-&gt;</operator><name>tlist</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>activeWindows</name> <init>= <expr><name><name>qp_extra</name><operator>-&gt;</operator><name>activeWindows</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Calculate pathkeys that represent grouping/ordering requirements.  The
     * sortClause is certainly sort-able, but GROUP BY and DISTINCT might not
     * be, in which case we just leave their pathkeys empty.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>qp_extra</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>&amp;&amp;</operator>
        <call><name>grouping_is_sortable</name><argument_list>(<argument><expr><name><name>qp_extra</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name> <operator>=</operator>
            <call><name>make_pathkeys_for_sortclauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                          <argument><expr><name><name>qp_extra</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
                                          <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* We consider only the first (bottom) window in pathkeys logic */</comment>
    <if_stmt><if>if <condition>(<expr><name>activeWindows</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><operator>(</operator><name>WindowClause</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>activeWindows</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>window_pathkeys</name></name> <operator>=</operator> <call><name>make_pathkeys_for_window</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                         <argument><expr><name>wc</name></expr></argument>,
                                                         <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>window_pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>&amp;&amp;</operator>
        <call><name>grouping_is_sortable</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name> <operator>=</operator>
            <call><name>make_pathkeys_for_sortclauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                          <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>,
                                          <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name> <operator>=</operator>
        <call><name>make_pathkeys_for_sortclauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                      <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>,
                                      <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Figure out whether we want a sorted result from query_planner.
     *
     * If we have a sortable GROUP BY clause, then we want a result sorted
     * properly for grouping.  Otherwise, if we have window functions to
     * evaluate, we try to sort for the first window.  Otherwise, if there's a
     * sortable DISTINCT clause that's more rigorous than the ORDER BY clause,
     * we try to produce output that's sufficiently well sorted for the
     * DISTINCT.  Otherwise, if there is an ORDER BY clause, we want to sort
     * by the ORDER BY clause.
     *
     * Note: if we have both ORDER BY and GROUP BY, and ORDER BY is a superset
     * of GROUP BY, it would be tempting to request sort by ORDER BY --- but
     * that might just leave us failing to exploit an available sort order at
     * all.  Needs more thought.  The choice for DISTINCT versus ORDER BY is
     * much easier, since we know that the parser ensured that one is a
     * superset of the other.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>window_pathkeys</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>window_pathkeys</name></name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator>
             <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>query_pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate number of groups produced by grouping clauses (1 if not grouping)
 *
 * path_rows: number of output rows from scan/join step
 * gd: grouping sets data including list of grouping sets and their clauses
 * target_list: target list containing group clause references
 *
 * If doing grouping sets, we also annotate the gsets data with the estimates
 * for each set and each individual rollup list, with a view to later
 * determining whether some combination of them could be hashed instead.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>get_number_of_groups</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                     <parameter><decl><type><name>double</name></type> <name>path_rows</name></decl></parameter>,
					 <parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>,
					 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>target_list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>dNumGroups</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>groupExprs</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Add up the estimates for each grouping set */</comment>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>gd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* keep Coverity happy */</comment>

            <expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>gd-&gt;rollups</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>groupExprs</name> <operator>=</operator> <call><name>get_sortgrouplist_exprs</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
													 <argument><expr><name>target_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>

                <macro><name>forboth</name><argument_list>(<argument>lc</argument>, <argument>rollup-&gt;gsets</argument>, <argument>lc2</argument>, <argument>rollup-&gt;gsets_data</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>gset</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>GroupingSetData</name> <modifier>*</modifier></type><name>gs</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>double</name></type>        <name>numGroups</name> <init>= <expr><call><name>estimate_num_groups</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                                <argument><expr><name>groupExprs</name></expr></argument>,
                                                                <argument><expr><name>path_rows</name></expr></argument>,
                                                                <argument><expr><operator>&amp;</operator><name>gset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <name>numGroups</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>+=</operator> <name>numGroups</name></expr>;</expr_stmt>
                </block_content>}</block>

                <expr_stmt><expr><name>dNumGroups</name> <operator>+=</operator> <name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name></expr>;</expr_stmt>
            </block_content>}</block>

            <if_stmt><if>if <condition>(<expr><name><name>gd</name><operator>-&gt;</operator><name>hash_sets_idx</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>dNumHashGroups</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

                <expr_stmt><expr><name>groupExprs</name> <operator>=</operator> <call><name>get_sortgrouplist_exprs</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
													 <argument><expr><name>target_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <macro><name>forboth</name><argument_list>(<argument>lc</argument>, <argument>gd-&gt;hash_sets_idx</argument>, <argument>lc2</argument>, <argument>gd-&gt;unsortable_sets</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>gset</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>GroupingSetData</name> <modifier>*</modifier></type><name>gs</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>double</name></type>        <name>numGroups</name> <init>= <expr><call><name>estimate_num_groups</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                                <argument><expr><name>groupExprs</name></expr></argument>,
                                                                <argument><expr><name>path_rows</name></expr></argument>,
                                                                <argument><expr><operator>&amp;</operator><name>gset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name><name>gs</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <name>numGroups</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>gd</name><operator>-&gt;</operator><name>dNumHashGroups</name></name> <operator>+=</operator> <name>numGroups</name></expr>;</expr_stmt>
                </block_content>}</block>

                <expr_stmt><expr><name>dNumGroups</name> <operator>+=</operator> <name><name>gd</name><operator>-&gt;</operator><name>dNumHashGroups</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Plain GROUP BY */</comment>
            <expr_stmt><expr><name>groupExprs</name> <operator>=</operator> <call><name>get_sortgrouplist_exprs</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
												 <argument><expr><name>target_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <call><name>estimate_num_groups</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>groupExprs</name></expr></argument>, <argument><expr><name>path_rows</name></expr></argument>,
                                             <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Empty grouping sets ... one result row for each one */</comment>
        <expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>hasHavingQual</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Plain aggregation, one result row */</comment>
        <expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Not grouping */</comment>
        <expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>dNumGroups</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * estimate_hashagg_tablesize
 *      estimate the number of bytes that a hash aggregate hashtable will
 *      require based on the agg_costs, path width and dNumGroups.
 *
 * XXX this may be over-estimating the size now that hashagg knows to omit
 * unneeded columns from the hashtable. Also for mixed-mode grouping sets,
 * grouping columns not in the hashed set are counted here even though hashagg
 * won't store them. Is this a problem?
 */</comment>
<function><type><specifier>static</specifier> <name>Size</name></type>
<name>estimate_hashagg_tablesize</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
                           <parameter><decl><type><name>double</name></type> <name>dNumGroups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type>        <name>hashentrysize</name></decl>;</decl_stmt>

    <comment type="block">/* Estimate per-hash-entry space at tuple width... */</comment>
    <expr_stmt><expr><name>hashentrysize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call> <operator>+</operator>
        <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofMinimalTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* plus space for pass-by-ref transition values... */</comment>
    <expr_stmt><expr><name>hashentrysize</name> <operator>+=</operator> <name><name>agg_costs</name><operator>-&gt;</operator><name>transitionSpace</name></name></expr>;</expr_stmt>
    <comment type="block">/* plus the per-hash-entry overhead */</comment>
    <expr_stmt><expr><name>hashentrysize</name> <operator>+=</operator> <call><name>hash_agg_entry_size</name><argument_list>(<argument><expr><name><name>agg_costs</name><operator>-&gt;</operator><name>numAggs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Note that this disregards the effect of fill-factor and growth policy
     * of the hash-table. That's probably ok, given default the default
     * fill-factor is relatively high. It'd be hard to meaningfully factor in
     * "double-in-size" growth policies here.
     */</comment>
    <return>return <expr><name>hashentrysize</name> <operator>*</operator> <name>dNumGroups</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>Size</name></type>
<name>estimate_hashagg_entrysize</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
						   <parameter><decl><type><name>double</name></type> <name>dNumGroups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>hashentrysize</name></decl>;</decl_stmt>

	<comment type="block">/* Estimate per-hash-entry space at tuple width... */</comment>
	<expr_stmt><expr><name>hashentrysize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call> <operator>+</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofMinimalTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* plus space for pass-by-ref transition values... */</comment>
	<if_stmt><if>if <condition>(<expr><name>agg_costs</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>hashentrysize</name> <operator>+=</operator> <name><name>agg_costs</name><operator>-&gt;</operator><name>transitionSpace</name></name></expr>;</expr_stmt>
		<comment type="block">/* plus the per-hash-entry overhead */</comment>
		<expr_stmt><expr><name>hashentrysize</name> <operator>+=</operator> <call><name>hash_agg_entry_size</name><argument_list>(<argument><expr><name><name>agg_costs</name><operator>-&gt;</operator><name>numAggs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>hashentrysize</name> <operator>+=</operator> <call><name>hash_agg_entry_size</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	
	<return>return <expr><name>hashentrysize</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * create_grouping_paths
 *
 * Build a new upperrel containing Paths for grouping and/or aggregation.
 *
 * input_rel: contains the source-data Paths
 * target: the pathtarget for the result Paths to compute
 * agg_costs: cost info about all aggregates in query (in AGGSPLIT_SIMPLE mode)
 * rollup_lists: list of grouping sets, or NIL if not doing grouping sets
 * rollup_groupclauses: list of grouping clauses for grouping sets,
 *        or NIL if not doing grouping sets
 *
 * Note: all Paths in input_rel are expected to return the target computed
 * by make_group_input_target.
 */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>create_grouping_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                      <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
                      <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>target_parallel_safe</name></decl></parameter>,
                      <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
                      <parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl>;</decl_stmt>


    <comment type="block">/* For now, do all work in the (GROUP_AGG, NULL) upperrel */</comment>
    <expr_stmt><expr><name>grouped_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_GROUP_AGG</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If the input relation is not parallel-safe, then the grouped relation
     * can't be parallel-safe, either.  Otherwise, it's parallel-safe if the
     * target list and HAVING quals are parallel-safe.
     */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>input_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator> <name>target_parallel_safe</name> <operator>&amp;&amp;</operator>
        <call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If the input rel belongs to a single FDW, so does the grouped rel.
     */</comment>
    <expr_stmt><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>serverid</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>serverid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>userid</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>userid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name></expr>;</expr_stmt>

    <comment type="block">/*
	 *  Create either paths for a degenerate grouping or paths for ordinary
     * grouping, as appropriate.
     */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>is_degenerate_grouping</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
	       <expr_stmt><expr><call><name>create_degenerate_grouping_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	       <comment type="block">/* No need to consider any other alternatives. */</comment>
	       <expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	       <return>return <expr><name>grouped_rel</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
    <block>{<block_content>
	       <expr_stmt><expr><call><name>create_ordinary_grouping_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>,
	    		    <argument><expr><name>agg_costs</name></expr></argument>, <argument><expr><name>gd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	       <comment type="block">/* Now choose the best path(s) */</comment>
	       <expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	       <comment type="block">/*
	        * We've been using the partial pathlist for the grouped relation to hold
	        * partially aggregated paths, but that's actually a little bit bogus
	        * because it's unsafe for later planning stages -- like ordered_rel ---
	        * to get the idea that they can use these partial paths as if they didn't
	        * need a FinalizeAggregate step.  Zap the partial pathlist at this stage
	        * so we don't get confused.
	        */</comment>
	       <expr_stmt><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	       <return>return <expr><name>grouped_rel</name></expr>;</return>

	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * is_degenerate_grouping
 *
 * A degenerate grouping is one in which the query has a HAVING qual and/or
 * grouping sets, but no aggregates and no GROUP BY (which implies that the
 * grouping sets are all empty).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_degenerate_grouping</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <decl_stmt><decl><type><name>Query</name>      <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>

   <return>return <expr><operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>hasHavingQual</name></name> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
       <operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>&amp;&amp;</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>==</operator> <name>NIL</name></expr>;</return>
</block_content>}</block></function>

        <comment type="block">/*
 * create_degenerate_grouping_paths
         *
 * When the grouping is degenerate (see is_degenerate_grouping), we are
 * supposed to emit either zero or one row for each grouping set depending on
 * whether HAVING succeeds.  Furthermore, there cannot be any variables in
 * either HAVING or the targetlist, so we actually do not need the FROM table
 * at all! We can just throw away the plan-so-far and generate a Result node.
 * This is a sufficiently unusual corner case that it's not worth contorting
 * the structure of this module to avoid having to generate the earlier paths
 * in the first place.
         */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_degenerate_grouping_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
                                <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Query</name>      <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>nrows</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>nrows</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nrows</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
		 * Doesn't seem worthwhile writing code to cons up a generate_series
         * or a values scan to emit multiple rows. Instead just make N clones
         * and append them.  (With a volatile HAVING clause, this means you
         * might get between 0 and N output rows. Offhand I think that's
         * desired.)
             */</comment>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>paths</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr><operator>--</operator><name>nrows</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
                    <call><name>create_result_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>,
                                       <argument><expr><name>target</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>paths</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>paths</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
                <call><name>create_append_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>,
                                   <argument><expr><name>paths</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>,
                                   <argument><expr><literal type="number">0</literal></expr></argument>,
	                           <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* No grouping sets, or just one, so one output row */</comment>
            <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
                <call><name>create_result_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>,
                                   <argument><expr><name>target</name></expr></argument>,
                                   <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></function>

    <comment type="block">/*
 * create_ordinary_grouping_paths
 *
 * Create grouping paths for the ordinary (that is, non-degenerate) case.
 *
 * We need to consider sorted and hashed aggregation in the same function,
 * because otherwise (1) it would be harder to throw an appropriate error
 * message if neither way works, and (2) we should not allow hashtable size
 * considerations to dissuade us from using hashing if sorting is not possible.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_ordinary_grouping_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
                              <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
                              <parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
   <decl_stmt><decl><type><name>Query</name>      <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>cheapest_path</name> <init>= <expr><name><name>input_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></init></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>AggClauseCosts</name></type> <name>agg_partial_costs</name></decl>;</decl_stmt>   <comment type="block">/* parallel only */</comment>
   <decl_stmt><decl><type><name>AggClauseCosts</name></type> <name>agg_final_costs</name></decl>;</decl_stmt> <comment type="block">/* parallel only */</comment>
    <decl_stmt><decl><type><name>Size</name></type>		<name>hashaggtablesize</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>double</name></type>      <name>dNumGroups</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>		<name>dNumPartialGroups</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>bool</name></type>        <name>can_hash</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>bool</name></type>        <name>can_sort</name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>bool</name></type>        <name>try_parallel_aggregation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>		<name>try_distributed_aggregation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>try_distributed_distinct_agg_optimize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>partial_grouping_target</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
     * Estimate number of groups.
     */</comment>
    <expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <call><name>get_number_of_groups</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                      <argument><expr><name><name>cheapest_path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
									  <argument><expr><name>gd</name></expr></argument>,
									  <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Determine whether it's possible to perform sort-based implementations
     * of grouping.  (Note that if groupClause is empty,
     * grouping_is_sortable() is trivially true, and all the
     * pathkeys_contained_in() tests will succeed too, so that we'll consider
     * every surviving input path.)
     *
     * If we have grouping sets, we might be able to sort some but not all of
     * them; in this case, we need can_sort to be true as long as we must
     * consider any sorted-input plan.
     */</comment>
    <expr_stmt><expr><name>can_sort</name> <operator>=</operator> <operator>(</operator><name>gd</name> <operator>&amp;&amp;</operator> <name><name>gd</name><operator>-&gt;</operator><name>rollups</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator>
        <operator>||</operator> <call><name>grouping_is_sortable</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Determine whether we should consider hash-based implementations of
     * grouping.
     *
     * Hashed aggregation only applies if we're grouping. If we have grouping
     * sets, some groups might be hashable but others not; in this case we set
     * can_hash true as long as there is nothing globally preventing us from
     * hashing (and we should therefore consider plans with hashes).
     *
     * Executor doesn't support hashed aggregation with DISTINCT or ORDER BY
     * aggregates.  (Doing so would imply storing *all* the input values in
     * the hash table, and/or running many sorts in parallel, either of which
     * seems like a certain loser.)  We similarly don't support ordered-set
     * aggregates in hashed aggregation, but that case is also included in the
     * numOrderedAggs count.
     *
     * Note: grouping_is_hashable() is much more expensive to check than the
     * other gating conditions, so we want to do it last.
     */</comment>
    <expr_stmt><expr><name>can_hash</name> <operator>=</operator> <operator>(</operator><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
                <name><name>agg_costs</name><operator>-&gt;</operator><name>numOrderedAggs</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                <operator>(</operator><ternary><condition><expr><name>gd</name></expr> ?</condition><then> <expr><name><name>gd</name><operator>-&gt;</operator><name>any_hashable</name></name></expr> </then><else>: <expr><call><name>grouping_is_hashable</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/*
     * Figure out whether a PartialAggregate/Finalize Aggregate execution
     * strategy is viable.
         */</comment>
	 <expr_stmt><expr><name>try_parallel_aggregation</name> <operator>=</operator> <call><name>can_parallel_agg</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>,
                                                 <argument><expr><name>agg_costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The distributed aggregation however works even if there are no partial
     * paths (when the distribution key is included in the grouping keys, we
     * may simply push down the whole aggregate).
     *
     * XXX We currently don't even try to push down grouping sets, although we
     * might do that when all grouping sets include the distribution key. But
     * that seems like a fairly rare case, as in most cases there will be
     * empty grouping set () aggregating all the data. So let's look into this
     * optimization later.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>grouped_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Not even parallel-safe. */</comment>
        <expr_stmt><expr><name>try_distributed_aggregation</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>try_distributed_distinct_agg_optimize</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>&amp;&amp;</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We don't know how to do parallel aggregation unless we have either
         * some aggregates or a grouping clause.
         */</comment>
        <expr_stmt><expr><name>try_distributed_aggregation</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>try_distributed_distinct_agg_optimize</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We don't know how to do grouping sets in parallel. */</comment>
        <expr_stmt><expr><name>try_distributed_aggregation</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>try_distributed_distinct_agg_optimize</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>agg_costs</name><operator>-&gt;</operator><name>hasNonSerial</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Insufficient support for partial mode. */</comment>
		<expr_stmt><expr><name>try_distributed_aggregation</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>try_distributed_distinct_agg_optimize</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>agg_costs</name><operator>-&gt;</operator><name>hasNonPartial</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Insufficient support for partial mode. */</comment>
        <expr_stmt><expr><name>try_distributed_aggregation</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <comment type="block">/* Ignore by distint agg optimize */</comment>
		<expr_stmt><expr><name>try_distributed_distinct_agg_optimize</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Everything looks good. */</comment>
        <expr_stmt><expr><name>try_distributed_aggregation</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>try_distributed_distinct_agg_optimize</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Whenever parallel aggregation is allowed, distributed should be too. */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>try_parallel_aggregation</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>try_distributed_aggregation</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>try_distributed_distinct_agg_optimize</name> <operator>&amp;&amp;</operator>
	    <operator>!</operator><call><name>can_distinct_agg_optimize</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>,
	                               <argument><expr><name>target</name></expr></argument> ,<argument><expr><name>agg_costs</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>try_distributed_distinct_agg_optimize</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Before generating paths for grouped_rel, we first generate any possible
     * partial paths; that way, later code can easily consider both parallel
     * and non-parallel approaches to grouping.  Note that the partial paths
     * we generate here are also partially aggregated, so simply pushing a
     * Gather node on top is insufficient to create a final path, as would be
     * the case for a scan/join rel.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>try_parallel_aggregation</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Build target list for partial aggregate paths.  These paths cannot
         * just emit the same tlist as regular aggregate paths, because (1) we
         * must include Vars and Aggrefs needed in HAVING, which might not
         * appear in the result tlist, and (2) the Aggrefs must be set in
         * partial mode.
         */</comment>
		<expr_stmt><expr><name>partial_grouping_target</name> <operator>=</operator> <call><name>make_partial_grouping_target</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
				                                               <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Collect statistics about aggregates for estimating costs of
         * performing aggregation in parallel.
         */</comment>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agg_partial_costs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggClauseCosts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agg_final_costs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggClauseCosts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* partial phase */</comment>
            <expr_stmt><expr><call><name>get_agg_clause_costs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>partial_grouping_target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
                                 <argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>agg_partial_costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* final phase */</comment>
            <expr_stmt><expr><call><name>get_agg_clause_costs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
                                 <argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>agg_final_costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>get_agg_clause_costs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
                                 <argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>agg_final_costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

	    <expr_stmt><expr><call><name>add_partial_paths_to_grouping_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
                                                 <argument><expr><name>partial_grouping_target</name></expr></argument>,
	                                      <argument><expr><operator>&amp;</operator><name>agg_partial_costs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agg_final_costs</name></expr></argument>,
	                                      <argument><expr><name>gd</name></expr></argument>, <argument><expr><name>can_sort</name></expr></argument>, <argument><expr><name>can_hash</name></expr></argument>,
	                                      <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>g_hybrid_hash_agg</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>agg_partial_costs</name> <operator>=</operator> <operator>*</operator><name>agg_costs</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>agg_final_costs</name> <operator>=</operator> <operator>*</operator><name>agg_costs</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * XL: To minimize the code complexity in general (and diff compared to
     * PostgreSQL code base), XL generates the paths in two phases.
     *
     * First, we generate the "regular" aggregate paths, and either push them
     * down as a whole, if possible, or inject a RemoteSubplan below them if.
     * We may produce 2-phase aggregate paths (partial+finalize), but only if
     * PostgreSQL itself generates them, and if we can push down the whole
     * aggregation to datanodes (we don't want to run parallel aggregate on
     * coordinators). That is, we don't generate paths with 2-phase distributed
     * aggregate like 'FinalizeAgg -&gt; RemoteSubplan -&gt; PartialAgg' here.
     *
     * This block is intentionally keps as close to core PostgreSQL as possible,
     * and is guaranteed to generate at least one valid aggregate path (plain
     * aggregate on top of RemoteSubplan). Unless even stock PostgreSQL fail
     * to generate any paths.
     *
     * Then, in the second phase, we generage custom XL paths, with distributed
     * 2-phase aggregation. We don't do this if we've been able to push the
     * whole aggregation down, as we assume the full push down is the best
     * possible plan.
     *
     * Note: The grouping set variants are currently disabled by a check in
     * transformGroupClause. Perhaps we could lift that restriction now.
     */</comment>

    <comment type="block">/* Build final grouping paths */</comment>
	<expr_stmt><expr><call><name>add_paths_to_grouping_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
	                          <argument><expr><name>partial_grouping_target</name></expr></argument>, <argument><expr><name>agg_costs</name></expr></argument>,
	                          <argument><expr><operator>&amp;</operator><name>agg_final_costs</name></expr></argument>, <argument><expr><name>gd</name></expr></argument>, <argument><expr><name>can_sort</name></expr></argument>, <argument><expr><name>can_hash</name></expr></argument>,
	                          <argument><expr><name>dNumGroups</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>try_distributed_aggregation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Generate XL aggregate paths, with distributed 2-phase aggregation. */</comment>

	<comment type="block">/*
	 * If there were no partial paths, we did not initialize any of the
	 * partial paths above. If that's the case, initialize here.
	 *
	 * XXX The reason why the initialization block at the beginning is not
	 * simply performed unconditionally is that we may skip it if we've been
	 * successful in fully pushing down any of the aggregates, and entirely
	 * skip generating the XL paths.
	 *
	 * XXX Can we simply use the same estimates as regular partial aggregates,
	 * or do we need to invent something else? It might be a better idea to
	 * use estimates for the whole result here (e.g. total number of groups)
	 * instead of the partial ones. Underestimates often have more severe
	 * consequences (e.g. OOM with HashAggregate) than overestimates, so this
	 * seems like a more defensive approach.
	 *
	 * XXX After thinking a bit more about the estimation, it may depend on
	 * pushdown - if the aggregate is fully pushed down (as above, we can
	 * probably use dNumGroups/numberOfNodes as a cardinality estimate, as
	 * we know the per-node groupings won't overlap. But here we need to be
	 * more careful.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>try_distributed_aggregation</name> <operator>||</operator> <name>try_distributed_distinct_agg_optimize</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>partial_grouping_target</name> <operator>=</operator> <call><name>make_partial_grouping_target</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
				                                               <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Estimate number of partial groups. */</comment>
		<expr_stmt><expr><name>dNumPartialGroups</name> <operator>=</operator> <call><name>get_number_of_groups</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><name><name>cheapest_path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
												 <argument><expr><name>gd</name></expr></argument>,
												 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Collect statistics about aggregates for estimating costs of
		 * performing aggregation in parallel.
		 */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agg_partial_costs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggClauseCosts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agg_final_costs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggClauseCosts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* partial phase */</comment>
			<expr_stmt><expr><call><name>get_agg_clause_costs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>partial_grouping_target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
								 <argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>agg_partial_costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* final phase */</comment>
			<expr_stmt><expr><call><name>get_agg_clause_costs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
								 <argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>agg_final_costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_agg_clause_costs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
								 <argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>agg_final_costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>try_distributed_aggregation</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Build final XL grouping paths */</comment>
    <if_stmt><if>if <condition>(<expr><name>can_sort</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Use any available suitably-sorted path as input, and also consider
         * sorting the cheapest-total path.
         */</comment>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>input_rel-&gt;pathlist</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>is_sorted</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>is_sorted</name> <operator>=</operator> <call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
                                              <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * XL: Can it happen that the cheapest path can't be pushed down,
             * while some other path could be? Perhaps we should move the check
             * if a path can be pushed down up, and add another OR condition
             * to consider all paths that can be pushed down?
             *
             * if (path == cheapest_path || is_sorted || can_push_down)
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>cheapest_path</name> <operator>||</operator> <name>is_sorted</name></expr>)</condition>
            <block>{<block_content>
					<comment type="block">/*
					 * We can't really beat paths that we managed to fully push
					 * down above, so we can skip them entirely.
					 *
					 * XXX Not constructing any paths, so we can do this before
					 * adding the Sort path.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>can_push_down_grouping</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<comment type="block">/* Sort the cheapest-total path if it isn't already sorted */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_sorted</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                         <argument><expr><name>grouped_rel</name></expr></argument>,
                                                         <argument><expr><name>path</name></expr></argument>,
                                                         <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
                                                         <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* Now decide what to stick atop it */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * TODO 2-phase aggregation for grouping sets paths not
						 * supported yet, but this the place where such paths
						 * should be constructed.
						 */</comment>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * We have aggregation, possibly with plain GROUP BY. Make
						 * an AggPath.
						 */</comment>

						<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														<argument><expr><name>grouped_rel</name></expr></argument>,
														<argument><expr><name>path</name></expr></argument>,
														<argument><expr><name>partial_grouping_target</name></expr></argument>,
										<argument><expr><ternary><condition><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr> ?</condition><then> <expr><name>AGG_SORTED</name></expr> </then><else>: <expr><name>AGG_PLAIN</name></expr></else></ternary></expr></argument>,
														<argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr></argument>,
														<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
														<argument><expr><name>NIL</name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>agg_partial_costs</name></expr></argument>,
														<argument><expr><name>dNumPartialGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
						<if_stmt><if>if <condition>(<expr><name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* redistribute local grouping results among datanodes */</comment>
							<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_redistribute_grouping_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
							<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
						<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
						<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>&amp;&amp;</operator> <name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name> <operator>&amp;&amp;</operator> 
							<operator>(</operator><operator>!</operator><name>is_sorted</name> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name><operator>)</operator></expr>)</condition>
						<block>{<block_content>
                            <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                     <argument><expr><name>grouped_rel</name></expr></argument>,
                                                     <argument><expr><name>path</name></expr></argument>,
                                                     <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
                                                     <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <comment type="block">/*
						 * We generate two paths, differing in the second phase
						 * implementation (sort and hash).
                        */</comment>
						<block>{<block_content>
							<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>agg_path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
									 <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><name>grouped_rel</name></expr></argument>,
												 <argument><expr><name>path</name></expr></argument>,
													 <argument><expr><name>target</name></expr></argument>,
											 <argument><expr><ternary><condition><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr> ?</condition><then> <expr><name>AGG_SORTED</name></expr> </then><else>: <expr><name>AGG_PLAIN</name></expr></else></ternary></expr></argument>,
													 <argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>,
													 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
													 <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>agg_final_costs</name></expr></argument>,
													 <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                           
							<comment type="line">//agg_path-&gt;parallel_safe = true;</comment>

							<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>agg_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>

						<if_stmt><if>if <condition>(<expr><name>can_hash</name></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>agg_path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
									 <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                            <argument><expr><name>grouped_rel</name></expr></argument>,
                                                            <argument><expr><name>path</name></expr></argument>,
													 <argument><expr><name>target</name></expr></argument>,
													 <argument><expr><name>AGG_HASHED</name></expr></argument>,
													 <argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>,
                                                            <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
													 <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>agg_final_costs</name></expr></argument>,
													 <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

							<comment type="line">//agg_path-&gt;parallel_safe = true;</comment>
							
							<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>agg_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition>
                    <block>{<block_content>
                            <comment type="block">/*
                             * We have GROUP BY without aggregation or grouping sets.
                             * Make a GroupPath.
                             */</comment>
                            <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_group_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                              <argument><expr><name>grouped_rel</name></expr></argument>,
                                                              <argument><expr><name>path</name></expr></argument>,
														  <argument><expr><name>partial_grouping_target</name></expr></argument>,
                                                              <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
                                                              <argument><expr><name>NIL</name></expr></argument>,
														  <argument><expr><name>dNumPartialGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
						<if_stmt><if>if <condition>(<expr><name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* redistribute local grouping results among datanodes */</comment>
                            <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_redistribute_grouping_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                        <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
						<if_stmt><if>if <condition>(<expr><name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>is_sorted</name> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name><operator>)</operator></expr>)</condition>
                        <block>{<block_content>
                                <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                                 <argument><expr><name>grouped_rel</name></expr></argument>,
                                                                 <argument><expr><name>path</name></expr></argument>,
                                                                 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
                                                                 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
						<block>{<block_content>
							<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>group_path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
									 <call><name>create_group_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                 <argument><expr><name>grouped_rel</name></expr></argument>,
                                                 <argument><expr><name>path</name></expr></argument>,
                                                 <argument><expr><name>target</name></expr></argument>,
                                                 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
                                                 <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
                                                 <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        
							<comment type="line">//group_path-&gt;parallel_safe = true;</comment>
                        
							<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>group_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block>

					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* Other cases should have been handled above */</comment>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>can_hash</name></expr>)</condition>
        <block>{<block_content>
			<expr_stmt><expr><name>hashaggtablesize</name> <operator>=</operator> <call><name>estimate_hashagg_tablesize</name><argument_list>(<argument><expr><name>cheapest_path</name></expr></argument>,
														  <argument><expr><name>agg_costs</name></expr></argument>,
														  <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Provided that the estimated size of the hashtable does not exceed
			 * work_mem, we'll generate a HashAgg Path, although if we were unable
			 * to sort above, then we'd better generate a Path, so that we at
			 * least have one.
			 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>hashaggtablesize</name> <operator>&lt;</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>||</operator> <name>g_hybrid_hash_agg</name> <operator>||</operator>
				<name><name>grouped_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<if_stmt><if>if <condition>(<expr><name>hashaggtablesize</name> <operator>&lt;</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>||</operator>
				<name><name>grouped_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<block>{<block_content>
				<comment type="block">/* If the whole aggregate was pushed down, we're done. */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>can_push_down_grouping</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>cheapest_path</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>agg_path</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										   <argument><expr><name>grouped_rel</name></expr></argument>,
										   <argument><expr><name>cheapest_path</name></expr></argument>,
										   <argument><expr><name>partial_grouping_target</name></expr></argument>,
										   <argument><expr><name>AGG_HASHED</name></expr></argument>,
										   <argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr></argument>,
										   <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
										   <argument><expr><name>NIL</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>agg_partial_costs</name></expr></argument>,
										   <argument><expr><name>dNumPartialGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* keep partially aggregated path for the can_sort branch */</comment>
					<expr_stmt><expr><name>agg_path</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<if_stmt><if>if <condition>(<expr><name>hashaggtablesize</name> <operator>&gt;=</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>&amp;&amp;</operator> <name>g_hybrid_hash_agg</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>AggPath</name> <modifier>*</modifier></type><name>aggpath</name> <init>= <expr><operator>(</operator><name>AggPath</name> <operator>*</operator><operator>)</operator><name>agg_path</name></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name><name>aggpath</name><operator>-&gt;</operator><name>hybrid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<if_stmt><if>if <condition>(<expr><name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* redistribute local grouping results among datanodes */</comment>
						<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_redistribute_grouping_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
					<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<comment type="block">/* Generate paths with both hash and sort second phase. */</comment>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>agg_path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
                                     <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                     <argument><expr><name>grouped_rel</name></expr></argument>,
												 <argument><expr><name>path</name></expr></argument>,
                                                     <argument><expr><name>target</name></expr></argument>,
                                                     <argument><expr><name>AGG_HASHED</name></expr></argument>,
                                                     <argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>,
                                                     <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
                                                     <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
                                                     <argument><expr><operator>&amp;</operator><name>agg_final_costs</name></expr></argument>,
                                                     <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<comment type="line">//agg_path-&gt;parallel_safe = true;</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
						<if_stmt><if>if <condition>(<expr><name>hashaggtablesize</name> <operator>&gt;=</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>&amp;&amp;</operator> <name>g_hybrid_hash_agg</name></expr>)</condition>
							<block>{<block_content>
							<decl_stmt><decl><type><name>AggPath</name> <modifier>*</modifier></type><name>aggpath</name> <init>= <expr><operator>(</operator><name>AggPath</name> <operator>*</operator><operator>)</operator><name>agg_path</name></expr></init></decl>;</decl_stmt>
                            
							<expr_stmt><expr><name><name>aggpath</name><operator>-&gt;</operator><name>hybrid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
						<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>agg_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block>

					<if_stmt><if>if <condition>(<expr><name>can_sort</name></expr>)</condition>
                    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>olap_optimizer</name> <operator>||</operator> <name>has_cold_hot_table</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                             <argument><expr><name>grouped_rel</name></expr></argument>,
									 <argument><expr><name>agg_path</name></expr></argument>,
                                                             <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
                                                             <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
						<if_stmt><if>if <condition>(<expr><name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
                        <block>{<block_content>
							<comment type="block">/* redistribute local grouping results among datanodes */</comment>
							<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_redistribute_grouping_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>agg_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
							<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
						<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
						<if_stmt><if>if <condition>(<expr><name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * AGG_HASHED aggregate paths are always unsorted, so add
							 * a Sorted node for the final AGG_SORTED step.
							 */</comment>
							<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name>grouped_rel</name></expr></argument>,
											 <argument><expr><name>path</name></expr></argument>,
											 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
											 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					  	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

						<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
                             <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                             <argument><expr><name>grouped_rel</name></expr></argument>,
                                             <argument><expr><name>path</name></expr></argument>,
                                             <argument><expr><name>target</name></expr></argument>,
                                             <argument><expr><ternary><condition><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr> ?</condition><then> <expr><name>AGG_SORTED</name></expr> </then><else>: <expr><name>AGG_PLAIN</name></expr></else></ternary></expr></argument>,
												 <argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>,
                                             <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
                                             <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>agg_final_costs</name></expr></argument>,
                                             <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="line">//path-&gt;parallel_safe = true;</comment>

						<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>try_distributed_distinct_agg_optimize</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupExprs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>agg</name> <init>= <expr><call><name>get_optimize_distinct_agg</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>groupExprs</name> <operator>=</operator> <call><name>get_sortgrouplist_exprs</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr></argument>, <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>dNumPartialGroups</name> <operator>=</operator> <call><name>estimate_num_groups</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>groupExprs</name></expr></argument>, <argument><expr><name><name>cheapest_path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
		                                        <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>input_rel-&gt;pathlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* check if we need redistribute */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>grouping_distribution_match</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr></argument>, <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_redistribute_distinct_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>agg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator><call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
			                               <argument><expr><name>grouped_rel</name></expr></argument>,
			                               <argument><expr><name>path</name></expr></argument>,
			                               <argument><expr><name>partial_grouping_target</name></expr></argument>,
			                               <argument><expr><name>AGG_HASHED</name></expr></argument>,
			                               <argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr></argument>,
			                               <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
			                               <argument><expr><name>NULL</name></expr></argument>,
			                               <argument><expr><operator>&amp;</operator><name>agg_partial_costs</name></expr></argument>,
			                               <argument><expr><name>dNumPartialGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* partial is not parallel safe */</comment>
			<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator><call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
			                               <argument><expr><name>grouped_rel</name></expr></argument>,
			                               <argument><expr><name>path</name></expr></argument>,
			                               <argument><expr><name>target</name></expr></argument>,
			                               <argument><expr><name>AGG_HASHED</name></expr></argument>,
			                               <argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>,
			                               <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
			                               <argument><expr><name>NULL</name></expr></argument>,
			                               <argument><expr><operator>&amp;</operator><name>agg_final_costs</name></expr></argument>,
			                               <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>AggPath</name> <operator>*</operator><operator>)</operator><name>path</name><operator>)</operator><operator>-&gt;</operator><name>noDistinct</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Give a helpful error if we failed to find any implementation */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not implement GROUP BY"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Some of the datatypes only support hashing, while others only support sorting."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="block">/*
	 * If there is an FDW that's responsible for all baserels of the query,
	 * let it consider adding ForeignPaths.
                     */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>&amp;&amp;</operator>
		<name><name>grouped_rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignUpperPaths</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>grouped_rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignUpperPaths</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_GROUP_AGG</name></expr></argument>,
													  <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Let extensions possibly add some more paths */</comment>
	<if_stmt><if>if <condition>(<expr><name>create_upper_paths_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>create_upper_paths_hook</name>) <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_GROUP_AGG</name></expr></argument>,
									<argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * For a given input path, consider the possible ways of doing grouping sets on
 * it, by combinations of hashing and sorting.  This can be called multiple
 * times, so it's important that it not scribble on input.  No result is
 * returned, but any generated paths are added to grouped_rel.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>consider_groupingsets_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>,
							<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>is_sorted</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>can_hash</name></decl></parameter>,
							<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
							<parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
							<parameter><decl><type><name>double</name></type> <name>dNumGroups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
	 * If we're not being offered sorted input, then only consider plans that
	 * can be done entirely by hashing.
             *
	 * We can hash everything if it looks like it'll fit in work_mem. But if
	 * the input is actually sorted despite not being advertised as such, we
	 * prefer to make use of that in order to use less memory.
             *
	 * If none of the grouping sets are sortable, then ignore the work_mem
	 * limit and generate a path anyway, since otherwise we'll just fail.
             */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_sorted</name></expr>)</condition>
                <block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_rollups</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>unhashed_rollup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sets_data</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>empty_sets_data</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>empty_sets</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l_start</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>rollups</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AggStrategy</name></type> <name>strat</name> <init>= <expr><name>AGG_HASHED</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>hashsize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>exclude_groups</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>can_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
			<expr_stmt><expr><name>unhashed_rollup</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>exclude_groups</name> <operator>=</operator> <name><name>unhashed_rollup</name><operator>-&gt;</operator><name>numGroups</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>l_start</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>l_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                
		<expr_stmt><expr><name>hashsize</name> <operator>=</operator> <call><name>estimate_hashagg_tablesize</name><argument_list>(<argument><expr><name>path</name></expr></argument>,
											  <argument><expr><name>agg_costs</name></expr></argument>,
											  <argument><expr><name>dNumGroups</name> <operator>-</operator> <name>exclude_groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
		 * gd-&gt;rollups is empty if we have only unsortable columns to work
		 * with.  Override work_mem in that case; otherwise, we'll rely on the
		 * sorted-input case to generate usable mixed paths.
             */</comment>
		<if_stmt><if>if <condition>(<expr><name>hashsize</name> <operator>&gt;</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>&amp;&amp;</operator> <name><name>gd</name><operator>-&gt;</operator><name>rollups</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>				<comment type="block">/* nope, won't fit */</comment>

                    <comment type="block">/*
		 * We need to burst the existing rollups list into individual grouping
		 * sets and recompute a groupClause for each set.
                     */</comment>
		<expr_stmt><expr><name>sets_data</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_sets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>l_start</argument>)</argument_list></macro>
                    <block>{<block_content>
			<decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="block">/*
			 * If we find an unhashable rollup that's not been skipped by the
			 * "actually sorted" check above, we can't cope; we'd need sorted
			 * input (with a different sort order) but we can't get that here.
			 * So bail out; we'll get a valid path from the is_sorted case
			 * instead.
			 *
			 * The mere presence of empty grouping sets doesn't make a rollup
			 * unhashable (see preprocess_grouping_sets), we handle those
			 * specially below.
                     */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rollup</name><operator>-&gt;</operator><name>hashable</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>sets_data</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>sets_data</name></expr></argument>, <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>sets_data</argument>)</argument_list></macro>
                    <block>{<block_content>
			<decl_stmt><decl><type><name>GroupingSetData</name> <modifier>*</modifier></type><name>gs</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>gset</name> <init>= <expr><name><name>gs</name><operator>-&gt;</operator><name>set</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>gset</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
                        <block>{<block_content>
				<comment type="block">/* Empty grouping sets can't be hashed. */</comment>
				<expr_stmt><expr><name>empty_sets_data</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>empty_sets_data</name></expr></argument>, <argument><expr><name>gs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>empty_sets</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>empty_sets</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
				<expr_stmt><expr><name>rollup</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RollupData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <call><name>preprocess_groupclause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>gset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets_data</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>gs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets</name></name> <operator>=</operator> <call><name>remap_to_groupclause_idx</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
														 <argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets_data</name></name></expr></argument>,
														 <argument><expr><name><name>gd</name><operator>-&gt;</operator><name>tleref_to_colnum_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <name><name>gs</name><operator>-&gt;</operator><name>numGroups</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>is_hashed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_rollups</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_rollups</name></expr></argument>, <argument><expr><name>rollup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block>

                    <comment type="block">/*
		 * If we didn't find anything nonempty to hash, then bail.  We'll
		 * generate a path from the is_sorted case.
                     */</comment>
		<if_stmt><if>if <condition>(<expr><name>new_rollups</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If there were empty grouping sets they should have been in the
		 * first rollup.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>unhashed_rollup</name> <operator>||</operator> <operator>!</operator><name>empty_sets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>unhashed_rollup</name></expr>)</condition>
                    <block>{<block_content>
			<expr_stmt><expr><name>new_rollups</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_rollups</name></expr></argument>, <argument><expr><name>unhashed_rollup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>strat</name> <operator>=</operator> <name>AGG_MIXED</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>empty_sets</name></expr>)</condition>
                        <block>{<block_content>
			<decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RollupData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets_data</name></name> <operator>=</operator> <name>empty_sets_data</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets</name></name> <operator>=</operator> <name>empty_sets</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>empty_sets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>is_hashed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_rollups</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_rollups</name></expr></argument>, <argument><expr><name>rollup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>strat</name> <operator>=</operator> <name>AGG_MIXED</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the grouping can't be fully pushed down, redistribute the
		 * path on top of the (sorted) path. If if can be pushed down,
		 * disable construction of complex distributed paths.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>can_push_down_grouping</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				 <call><name>create_groupingsets_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                 <argument><expr><name>grouped_rel</name></expr></argument>,
										  <argument><expr><name>path</name></expr></argument>,
                                                 <argument><expr><name>target</name></expr></argument>,
                                                 <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
										  <argument><expr><name>strat</name></expr></argument>,
										  <argument><expr><name>new_rollups</name></expr></argument>,
										  <argument><expr><name>agg_costs</name></expr></argument>,
										  <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
                        </block_content>}</block></if></if_stmt>
                        
	<comment type="block">/*
	 * If we have sorted input but nothing we can do with it, bail.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>rollups</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Given sorted input, we try and make two paths: one sorted and one mixed
	 * sort/hash. (We need to try both because hashagg might be disabled, or
	 * some columns might not be sortable.)
	 *
	 * can_hash is passed in as false if some obstacle elsewhere (such as
	 * ordered aggs) means that we shouldn't consider hashing at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>can_hash</name> <operator>&amp;&amp;</operator> <name><name>gd</name><operator>-&gt;</operator><name>any_hashable</name></name></expr>)</condition>
                    <block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rollups</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hash_sets</name> <init>= <expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>unsortable_sets</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>availspace</name> <init>= <expr><operator>(</operator><name>work_mem</name> <operator>*</operator> <literal type="number">1024.0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Account first for space needed for groups we can't sort at all.
		 */</comment>
		<expr_stmt><expr><name>availspace</name> <operator>-=</operator> <operator>(</operator><name>double</name><operator>)</operator> <call><name>estimate_hashagg_tablesize</name><argument_list>(<argument><expr><name>path</name></expr></argument>,
														  <argument><expr><name>agg_costs</name></expr></argument>,
														  <argument><expr><name><name>gd</name><operator>-&gt;</operator><name>dNumHashGroups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>availspace</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>rollups</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
                        <block>{<block_content>
			<decl_stmt><decl><type><name>double</name></type>		<name>scale</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>num_rollups</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>rollups</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>k_capacity</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>k_weights</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>num_rollups</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>hash_items</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
                        
			<comment type="block">/*
			 * We treat this as a knapsack problem: the knapsack capacity
			 * represents work_mem, the item weights are the estimated memory
			 * usage of the hashtables needed to implement a single rollup,
			 * and we really ought to use the cost saving as the item value;
			 * however, currently the costs assigned to sort nodes don't
			 * reflect the comparison costs well, and so we treat all items as
			 * of equal value (each rollup we hash instead saves us one sort).
			 *
			 * To use the discrete knapsack, we need to scale the values to a
			 * reasonably small bounded range.  We choose to allow a 5% error
			 * margin; we have no more than 4096 rollups in the worst possible
			 * case, which with a 5% error margin will require a bit over 42MB
			 * of workspace. (Anyone wanting to plan queries that complex had
			 * better have the memory for it.  In more reasonable cases, with
			 * no more than a couple of dozen rollups, the memory usage will
			 * be negligible.)
			 *
			 * k_capacity is naturally bounded, but we clamp the values for
			 * scale and weight (below) to avoid overflows or underflows (or
			 * uselessly trying to use a scale factor less than 1 byte).
			 */</comment>
			<expr_stmt><expr><name>scale</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>availspace</name> <operator>/</operator> <operator>(</operator><literal type="number">20.0</literal> <operator>*</operator> <name>num_rollups</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>k_capacity</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>floor</name><argument_list>(<argument><expr><name>availspace</name> <operator>/</operator> <name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
			 * We leave the first rollup out of consideration since it's the
			 * one that matches the input sort order.  We assign indexes "i"
			 * to only those entries considered for hashing; the second loop,
			 * below, must use the same condition.
             */</comment>
			<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>lnext(list_head(gd-&gt;rollups))</argument>)</argument_list></macro>
            <block>{<block_content>
				<decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>rollup</name><operator>-&gt;</operator><name>hashable</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>double</name></type>		<name>sz</name> <init>= <expr><call><name>estimate_hashagg_tablesize</name><argument_list>(<argument><expr><name>path</name></expr></argument>,
                                                          <argument><expr><name>agg_costs</name></expr></argument>,
																<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="block">/*
					 * If sz is enormous, but work_mem (and hence scale) is
					 * small, avoid integer overflow here.
                    */</comment>
					<expr_stmt><expr><name><name>k_weights</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>Min</name><argument_list>(<argument><expr><call><name>floor</name><argument_list>(<argument><expr><name>sz</name> <operator>/</operator> <name>scale</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>k_capacity</name> <operator>+</operator> <literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

                <comment type="block">/*
			 * Apply knapsack algorithm; compute the set of items which
			 * maximizes the value stored (in this case the number of sorts
			 * saved) while keeping the total size (approximately) within
			 * capacity.
                 */</comment>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>hash_items</name> <operator>=</operator> <call><name>DiscreteKnapsack</name><argument_list>(<argument><expr><name>k_capacity</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>k_weights</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>hash_items</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
				<expr_stmt><expr><name>rollups</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>rollups</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>lnext(list_head(gd-&gt;rollups))</argument>)</argument_list></macro>
                <block>{<block_content>
					<decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>rollup</name><operator>-&gt;</operator><name>hashable</name></name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>hash_items</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>hash_sets</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>hash_sets</name></expr></argument>,
													<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets_data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>rollups</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>, <argument><expr><name>rollup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>rollups</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>, <argument><expr><name>rollup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rollups</name> <operator>&amp;&amp;</operator> <name>hash_sets</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rollups</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>gd</name><operator>-&gt;</operator><name>rollups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>hash_sets</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GroupingSetData</name> <modifier>*</modifier></type><name>gs</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RollupData</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>gs</name><operator>-&gt;</operator><name>set</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <call><name>preprocess_groupclause</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>gs</name><operator>-&gt;</operator><name>set</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets_data</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>gs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets</name></name> <operator>=</operator> <call><name>remap_to_groupclause_idx</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
													 <argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets_data</name></name></expr></argument>,
													 <argument><expr><name><name>gd</name><operator>-&gt;</operator><name>tleref_to_colnum_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <name><name>gs</name><operator>-&gt;</operator><name>numGroups</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>is_hashed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rollups</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>rollup</name></expr></argument>, <argument><expr><name>rollups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>rollups</name></expr>)</condition>
						<block>{<block_content>
			<comment type="block">/*
			 * If the grouping can't be fully pushed down, redistribute the
			 * path on top of the (sorted) path. If if can be pushed down,
			 * disable construction of complex distributed paths.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>can_push_down_grouping</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
					 <call><name>create_groupingsets_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											  <argument><expr><name>grouped_rel</name></expr></argument>,
											  <argument><expr><name>path</name></expr></argument>,
											  <argument><expr><name>target</name></expr></argument>,
											  <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
											  <argument><expr><name>AGG_MIXED</name></expr></argument>,
											  <argument><expr><name>rollups</name></expr></argument>,
											  <argument><expr><name>agg_costs</name></expr></argument>,
											  <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
	 * Now try the simple sorted case.
                 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>gd</name><operator>-&gt;</operator><name>unsortable_sets</name></name></expr>)</condition>
                <block>{<block_content>
		<comment type="block">/*
		 * If the grouping can't be fully pushed down, redistribute the
		 * path on top of the (sorted) path. If if can be pushed down,
		 * disable construction of complex distributed paths.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>can_push_down_grouping</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
											
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				 <call><name>create_groupingsets_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                 <argument><expr><name>grouped_rel</name></expr></argument>,
                                                 <argument><expr><name>path</name></expr></argument>,
                                                 <argument><expr><name>target</name></expr></argument>,
                                                 <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
										  <argument><expr><name>AGG_SORTED</name></expr></argument>,
										  <argument><expr><name><name>gd</name><operator>-&gt;</operator><name>rollups</name></name></expr></argument>,
										  <argument><expr><name>agg_costs</name></expr></argument>,
										  <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
                </block_content>}</block></function>

<comment type="block">/*
 * create_window_paths
 *
 * Build a new upperrel containing Paths for window-function evaluation.
 *
 * input_rel: contains the source-data Paths
 * input_target: result of make_window_input_target
 * output_target: what the topmost WindowAggPath should return
 * tlist: query's target list (needed to look up pathkeys)
 * wflists: result of find_window_functions
 * activeWindows: result of select_active_windows
 *
 * Note: all Paths in input_rel are expected to return input_target.
 */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>create_window_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
					<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>input_target</name></decl></parameter>,
					<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>output_target</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>output_target_parallel_safe</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
					<parameter><decl><type><name>WindowFuncLists</name> <modifier>*</modifier></type><name>wflists</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>activeWindows</name></decl></parameter>)</parameter_list>
                    <block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>window_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
                    
	<comment type="block">/* For now, do all work in the (WINDOW, NULL) upperrel */</comment>
	<expr_stmt><expr><name>window_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_WINDOW</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the input relation is not parallel-safe, then the window relation
	 * can't be parallel-safe, either.  Otherwise, we need to examine the
	 * target list and active windows for non-parallel-safe constructs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>input_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator> <name>output_target_parallel_safe</name> <operator>&amp;&amp;</operator>
		<call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>activeWindows</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>window_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the input rel belongs to a single FDW, so does the window rel.
	 */</comment>
	<expr_stmt><expr><name><name>window_rel</name><operator>-&gt;</operator><name>serverid</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>serverid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>window_rel</name><operator>-&gt;</operator><name>userid</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>userid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>window_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>window_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Consider computing window functions starting from the existing
	 * cheapest-total path (which will likely require a sort) as well as any
	 * existing paths that satisfy root-&gt;window_pathkeys (which won't).
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>input_rel-&gt;pathlist</argument>)</argument_list></macro>
					<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name> <operator>||</operator>
			<call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>window_pathkeys</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>create_one_window_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								   <argument><expr><name>window_rel</name></expr></argument>,
                                         <argument><expr><name>path</name></expr></argument>,
								   <argument><expr><name>input_target</name></expr></argument>,
								   <argument><expr><name>output_target</name></expr></argument>,
								   <argument><expr><name>tlist</name></expr></argument>,
								   <argument><expr><name>wflists</name></expr></argument>,
								   <argument><expr><name>activeWindows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block>

	<comment type="block">/*
	 * If there is an FDW that's responsible for all baserels of the query,
	 * let it consider adding ForeignPaths.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>window_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>&amp;&amp;</operator>
		<name><name>window_rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignUpperPaths</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>window_rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignUpperPaths</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_WINDOW</name></expr></argument>,
													 <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>window_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Let extensions possibly add some more paths */</comment>
	<if_stmt><if>if <condition>(<expr><name>create_upper_paths_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>create_upper_paths_hook</name>) <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_WINDOW</name></expr></argument>,
									<argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>window_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now choose the best path(s) */</comment>
	<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>window_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>window_rel</name></expr>;</return>
        </block_content>}</block></function>

        <comment type="block">/*
 * Stack window-function implementation steps atop the given Path, and
 * add the result to window_rel.
 *
 * window_rel: upperrel to contain result
 * path: input Path to use (must return input_target)
 * input_target: result of make_window_input_target
 * output_target: what the topmost WindowAggPath should return
 * tlist: query's target list (needed to look up pathkeys)
 * wflists: result of find_window_functions
 * activeWindows: result of select_active_windows
         */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_one_window_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>window_rel</name></decl></parameter>,
					   <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
					   <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>input_target</name></decl></parameter>,
					   <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>output_target</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
					   <parameter><decl><type><name>WindowFuncLists</name> <modifier>*</modifier></type><name>wflists</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>activeWindows</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>window_target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Since each window clause could require a different sort order, we stack
	 * up a WindowAgg node for each clause, with sort steps between them as
	 * needed.  (We assume that select_active_windows chose a good order for
	 * executing the clauses in.)
	 *
	 * input_target should contain all Vars and Aggs needed for the result.
	 * (In some cases we wouldn't need to propagate all of these all the way
	 * to the top, since they might only be needed as inputs to WindowFuncs.
	 * It's probably not worth trying to optimize that though.)  It must also
	 * contain all window partitioning and sorting expressions, to ensure
	 * they're computed only once at the bottom of the stack (that's critical
	 * for volatile functions).  As we climb up the stack, we'll add outputs
	 * for the WindowFuncs computed at each level.
	 */</comment>
	<expr_stmt><expr><name>window_target</name> <operator>=</operator> <name>input_target</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeWindows</argument>)</argument_list></macro>
            <block>{<block_content>
		<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><operator>(</operator><name>WindowClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>window_pathkeys</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>window_pathkeys</name> <operator>=</operator> <call><name>make_pathkeys_for_window</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												   <argument><expr><name>wc</name></expr></argument>,
												   <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Sort if necessary */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>window_pathkeys</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
			<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>window_rel</name></expr></argument>,
                                                   <argument><expr><name>path</name></expr></argument>,
											 <argument><expr><name>window_pathkeys</name></expr></argument>,
											 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
                <comment type="block">/*
			 * Add the current WindowFuncs to the output target for this
			 * intermediate WindowAggPath.  We must copy window_target to
			 * avoid changing the previous path's target.
                *
			 * Note: a WindowFunc adds nothing to the target's eval costs; but
			 * we do need to account for the increase in tlist width.
                */</comment>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>window_target</name> <operator>=</operator> <call><name>copy_pathtarget</name><argument_list>(<argument><expr><name>window_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>wflists-&gt;windowFuncs[wc-&gt;winref]</argument>)</argument_list></macro>
					<block>{<block_content>
				<decl_stmt><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>wfunc</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>WindowFunc</name></expr></argument>, <argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>window_target</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>wfunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>window_target</name><operator>-&gt;</operator><name>width</name></name> <operator>+=</operator> <call><name>get_typavgwidth</name><argument_list>(<argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>wintype</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
			<comment type="block">/* Install the goal target in the topmost WindowAgg */</comment>
			<expr_stmt><expr><name>window_target</name> <operator>=</operator> <name>output_target</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

		<comment type="block">/* We can't really push down window functions for now. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>can_push_down_window</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
			<call><name>create_windowagg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>window_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>window_target</name></expr></argument>,
								  <argument><expr><name><name>wflists</name><operator>-&gt;</operator><name>windowFuncs</name><index>[<expr><name><name>wc</name><operator>-&gt;</operator><name>winref</name></name></expr>]</index></name></expr></argument>,
								  <argument><expr><name>wc</name></expr></argument>,
								  <argument><expr><name>window_pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>window_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

    <comment type="block">/*
 * create_distinct_paths
     *
 * Build a new upperrel containing Paths for SELECT DISTINCT evaluation.
     *
 * input_rel: contains the source-data Paths
     *
 * Note: input paths should already compute the desired pathtarget, since
 * Sort/Unique won't project anything.
     */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>create_distinct_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_input_path</name> <init>= <expr><name><name>input_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>distinct_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>numDistinctRows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>allow_hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* For now, do all work in the (DISTINCT, NULL) upperrel */</comment>
	<expr_stmt><expr><name>distinct_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_DISTINCT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
	 * We don't compute anything at this level, so distinct_rel will be
	 * parallel-safe if the input rel is parallel-safe.  In particular, if
	 * there is a DISTINCT ON (...) clause, any path for the input_rel will
	 * output those expressions, and will not be parallel-safe unless those
	 * expressions are parallel-safe.
         */</comment>
	<expr_stmt><expr><name><name>distinct_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the input rel belongs to a single FDW, so does the distinct_rel.
	 */</comment>
	<expr_stmt><expr><name><name>distinct_rel</name><operator>-&gt;</operator><name>serverid</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>serverid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distinct_rel</name><operator>-&gt;</operator><name>userid</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>userid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distinct_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distinct_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name></expr>;</expr_stmt>

	<comment type="block">/* Estimate number of distinct rows there will be */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator>
		<name><name>root</name><operator>-&gt;</operator><name>hasHavingQual</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
		 * If there was grouping or aggregation, use the number of input rows
		 * as the estimated number of DISTINCT rows (ie, assume the input is
		 * already mostly unique).
             */</comment>
		<expr_stmt><expr><name>numDistinctRows</name> <operator>=</operator> <name><name>cheapest_input_path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
            <block>{<block_content>
		<comment type="block">/*
		 * Otherwise, the UNIQUE filter has effects comparable to GROUP BY.
		 */</comment>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>distinctExprs</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>distinctExprs</name> <operator>=</operator> <call><name>get_sortgrouplist_exprs</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>,
												<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>numDistinctRows</name> <operator>=</operator> <call><name>estimate_num_groups</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>distinctExprs</name></expr></argument>,
											  <argument><expr><name><name>cheapest_input_path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

                <comment type="block">/*
	 * Consider sort-based implementations of DISTINCT, if possible.
                 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>grouping_is_sortable</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
		 * First, if we have any adequately-presorted paths, just stick a
		 * Unique node on those.  Then consider doing an explicit sort of the
		 * cheapest input path and Unique'ing that.
                     *
		 * When we have DISTINCT ON, we must sort by the more rigorous of
		 * DISTINCT and ORDER BY, else it won't have the desired behavior.
		 * Also, if we do have to do an explicit sort, we might as well use
		 * the more rigorous ordering to avoid a second sort later.  (Note
		 * that the parser will have ensured that one clause is a prefix of
		 * the other.)
                     */</comment>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>needed_pathkeys</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>&amp;&amp;</operator>
			<call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
			<call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>needed_pathkeys</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>needed_pathkeys</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>input_rel-&gt;pathlist</argument>)</argument_list></macro>
                    <block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>needed_pathkeys</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
				 * Make sure the distribution matches the distinct clause,
				 * needed by the UNIQUE path.
				 *
				 * FIXME This could probably benefit from pushing a UNIQUE
				 * to the remote side, and only doing a merge locally.
                         */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>grouping_distribution_match</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>distinct_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
						 <call><name>create_upper_unique_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>distinct_rel</name></expr></argument>,
                                                        <argument><expr><name>path</name></expr></argument>,
												  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><name>numDistinctRows</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/* For explicit-sort case, always use the more rigorous clause */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
			<call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
			<expr_stmt><expr><name>needed_pathkeys</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr>;</expr_stmt>
			<comment type="block">/* Assert checks that parser didn't mess up... */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name></expr></argument>,
										 <argument><expr><name>needed_pathkeys</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>needed_pathkeys</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>path</name> <operator>=</operator> <name>cheapest_input_path</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>needed_pathkeys</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>distinct_rel</name></expr></argument>,
                                                             <argument><expr><name>path</name></expr></argument>,
											 <argument><expr><name>needed_pathkeys</name></expr></argument>,
                                                             <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* In case of grouping / distribution mismatch, inject remote scan. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>grouping_distribution_match</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>distinct_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				 <call><name>create_upper_unique_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>distinct_rel</name></expr></argument>,
										  <argument><expr><name>path</name></expr></argument>,
										  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>numDistinctRows</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>

                        <comment type="block">/*
	 * Consider hash-based implementations of DISTINCT, if possible.
	 *
	 * If we were not able to make any other types of path, we *must* hash or
	 * die trying.  If we do have other choices, there are several things that
	 * should prevent selection of hashing: if the query uses DISTINCT ON
	 * (because it won't really have the expected behavior if we hash), or if
	 * enable_hashagg is off, or if it looks like the hashtable will exceed
	 * work_mem.
	 *
	 * Note: grouping_is_hashable() is much more expensive to check than the
	 * other gating conditions, so we want to do it last.
                         */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>distinct_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>allow_hash</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>		<comment type="block">/* we have no alternatives */</comment>
	<if type="elseif">else if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>||</operator> <operator>!</operator><name>enable_hashagg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>allow_hash</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>		<comment type="block">/* policy-based decision not to hash */</comment>
	<else>else
                        <block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>hashentrysize</name></decl>;</decl_stmt>

		<comment type="block">/* Estimate per-hash-entry space at tuple width... */</comment>
		<expr_stmt><expr><name>hashentrysize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>cheapest_input_path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call> <operator>+</operator>
			<call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofMinimalTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* plus the per-hash-entry overhead */</comment>
		<expr_stmt><expr><name>hashentrysize</name> <operator>+=</operator> <call><name>hash_agg_entry_size</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            
		<comment type="block">/* Allow hashing only if hashtable is predicted to fit in work_mem */</comment>
		<expr_stmt><expr><name>allow_hash</name> <operator>=</operator> <operator>(</operator><name>hashentrysize</name> <operator>*</operator> <name>numDistinctRows</name> <operator>&lt;=</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal><operator>)</operator></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>allow_hash</name> <operator>&amp;&amp;</operator> <call><name>grouping_is_hashable</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
		<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>input_path</name> <init>= <expr><name>cheapest_input_path</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* If needed, inject RemoteSubplan redistributing the data. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>grouping_distribution_match</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>input_path</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>input_path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>input_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* XXX Maybe we can make this a 2-phase aggregate too? */</comment>

		<comment type="block">/* Generate hashed aggregate path --- no sort needed */</comment>
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>distinct_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
                                     <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								 <argument><expr><name>distinct_rel</name></expr></argument>,
								 <argument><expr><name>input_path</name></expr></argument>,
								 <argument><expr><name><name>input_path</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>,
                                                     <argument><expr><name>AGG_HASHED</name></expr></argument>,
								 <argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
								 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>,
								 <argument><expr><name>NIL</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>numDistinctRows</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Give a helpful error if we failed to find any implementation */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>distinct_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not implement DISTINCT"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Some of the datatypes only support hashing, while others only support sorting."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            
	<comment type="block">/*
	 * If there is an FDW that's responsible for all baserels of the query,
	 * let it consider adding ForeignPaths.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>distinct_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>&amp;&amp;</operator>
		<name><name>distinct_rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignUpperPaths</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>distinct_rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignUpperPaths</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_DISTINCT</name></expr></argument>,
													   <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>distinct_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Let extensions possibly add some more paths */</comment>
	<if_stmt><if>if <condition>(<expr><name>create_upper_paths_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>create_upper_paths_hook</name>) <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_DISTINCT</name></expr></argument>,
									<argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>distinct_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now choose the best path(s) */</comment>
	<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name>distinct_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>distinct_rel</name></expr>;</return>
                    </block_content>}</block></function>

<comment type="block">/*
 * create_ordered_paths
 *
 * Build a new upperrel containing Paths for ORDER BY evaluation.
 *
 * All paths in the result must satisfy the ORDER BY ordering.
 * The only new path we need consider is an explicit sort on the
 * cheapest-total existing path.
 *
 * input_rel: contains the source-data Paths
 * target: the output tlist the result Paths must emit
 * limit_tuples: estimated bound on the number of output tuples,
 *		or -1 if no LIMIT or couldn't estimate
 */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>create_ordered_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
					 <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>target_parallel_safe</name></decl></parameter>,
					 <parameter><decl><type><name>double</name></type> <name>limit_tuples</name></decl></parameter>)</parameter_list>
                    <block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_input_path</name> <init>= <expr><name><name>input_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>ordered_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* For now, do all work in the (ORDERED, NULL) upperrel */</comment>
	<expr_stmt><expr><name>ordered_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_ORDERED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/*
	 * If the input relation is not parallel-safe, then the ordered relation
	 * can't be parallel-safe, either.  Otherwise, it's parallel-safe if the
	 * target list is parallel-safe.
                         */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>input_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator> <name>target_parallel_safe</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ordered_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the input rel belongs to a single FDW, so does the ordered_rel.
	 */</comment>
	<expr_stmt><expr><name><name>ordered_rel</name><operator>-&gt;</operator><name>serverid</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>serverid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ordered_rel</name><operator>-&gt;</operator><name>userid</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>userid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ordered_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ordered_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>=</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>input_rel-&gt;pathlist</argument>)</argument_list></macro>
                        <block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>is_sorted</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>is_sorted</name> <operator>=</operator> <call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr></argument>,
										  <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>cheapest_input_path</name> <operator>||</operator> <name>is_sorted</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_sorted</name></expr>)</condition>
                        <block>{<block_content>
				<comment type="block">/* An explicit sort here can take advantage of LIMIT */</comment>
                            <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><name>ordered_rel</name></expr></argument>,
                                                             <argument><expr><name>path</name></expr></argument>,
												 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr></argument>,
												 <argument><expr><name>limit_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>

			<comment type="block">/* Add projection step if needed */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>!=</operator> <name>target</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>apply_projection_to_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ordered_rel</name></expr></argument>,
												<argument><expr><name>path</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            
			<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>ordered_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block>

            <comment type="block">/*
	 * generate_gather_paths() will have already generated a simple Gather
	 * path for the best parallel path, if any, and the loop above will have
	 * considered sorting it.  Similarly, generate_gather_paths() will also
	 * have generated order-preserving Gather Merge plans which can be used
	 * without sorting if they happen to match the sort_pathkeys, and the loop
	 * above will have handled those as well.  However, there's one more
	 * possibility: it may make sense to sort the cheapest partial path
	 * according to the required output order and then use Gather Merge.
             */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ordered_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
		<name><name>input_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
                    <block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_partial_path</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cheapest_partial_path</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>input_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <comment type="block">/*
		 * If cheapest partial path doesn't need a sort, this is redundant
		 * with what's already been tried.
                             */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr></argument>,
								   <argument><expr><name><name>cheapest_partial_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>total_groups</name></decl>;</decl_stmt>

                            <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name>ordered_rel</name></expr></argument>,
											 <argument><expr><name>cheapest_partial_path</name></expr></argument>,
											 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr></argument>,
                                                             <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>total_groups</name> <operator>=</operator> <name><name>cheapest_partial_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator>
				<name><name>cheapest_partial_path</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
				<call><name>create_gather_merge_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ordered_rel</name></expr></argument>,
                                                 <argument><expr><name>path</name></expr></argument>,
										 <argument><expr><name>target</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>total_groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Add projection step if needed */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>!=</operator> <name>target</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>apply_projection_to_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ordered_rel</name></expr></argument>,
												<argument><expr><name>path</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>ordered_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If there is an FDW that's responsible for all baserels of the query,
     * let it consider adding ForeignPaths.
     */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ordered_rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>&amp;&amp;</operator>
		<name><name>ordered_rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignUpperPaths</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>ordered_rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignUpperPaths</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_ORDERED</name></expr></argument>,
													  <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>ordered_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Let extensions possibly add some more paths */</comment>
    <if_stmt><if>if <condition>(<expr><name>create_upper_paths_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>create_upper_paths_hook</name>) <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_ORDERED</name></expr></argument>,
									<argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>ordered_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
	 * No need to bother with set_cheapest here; grouping_planner does not
	 * need us to do it.
     */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ordered_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ordered_rel</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * make_group_input_target
 *	  Generate appropriate PathTarget for initial input to grouping nodes.
 *
 * If there is grouping or aggregation, the scan/join subplan cannot emit
 * the query's final targetlist; for example, it certainly can't emit any
 * aggregate function calls.  This routine generates the correct target
 * for the scan/join subplan.
 *
 * The query target list passed from the parser already contains entries
 * for all ORDER BY and GROUP BY expressions, but it will not have entries
 * for variables used only in HAVING clauses; so we need to add those
 * variables to the subplan target list.  Also, we flatten all expressions
 * except GROUP BY items into their component variables; other expressions
 * will be computed by the upper plan nodes rather than by the subplan.
 * For example, given a query like
 *		SELECT a+b,SUM(c+d) FROM table GROUP BY a+b;
 * we want to pass this targetlist to the subplan:
 *		a+b,c,d
 * where the a+b target will be used by the Sort/Group steps, and the
 * other targets will be used for computing the final results.
 *
 * 'final_target' is the query's final target list (in PathTarget form)
 *
 * The result is the PathTarget to be computed by the Paths returned from
 * query_planner().
 */</comment>
<function><type><specifier>static</specifier> <name>PathTarget</name> <modifier>*</modifier></type>
<name>make_group_input_target</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>final_target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>input_target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>non_group_cols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>non_group_vars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/*
	 * We must build a target containing all grouping columns, plus any other
	 * Vars mentioned in the query's targetlist and HAVING qual.
	 */</comment>
	<expr_stmt><expr><name>input_target</name> <operator>=</operator> <call><name>create_empty_pathtarget</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>non_group_cols</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>final_target-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type>		<name>sgref</name> <init>= <expr><call><name>get_pathtarget_sortgroupref</name><argument_list>(<argument><expr><name>final_target</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>sgref</name> <operator>&amp;&amp;</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>&amp;&amp;</operator>
			<call><name>get_sortgroupref_clause_noerr</name><argument_list>(<argument><expr><name>sgref</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
			<comment type="block">/*
			 * It's a grouping column, so add it to the input target as-is.
			 */</comment>
			<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>input_target</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>sgref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Non-grouping column, so just remember the expression for later
			 * call to pull_var_clause.
			 */</comment>
			<expr_stmt><expr><name>non_group_cols</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>non_group_cols</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

        <comment type="block">/*
	 * If there's a HAVING clause, we'll need the Vars it uses, too.
         */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>non_group_cols</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>non_group_cols</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
	 * Pull out all the Vars mentioned in non-group cols (plus HAVING), and
	 * add them to the input target if not already present.  (A Var used
	 * directly as a GROUP BY item will be present already.)  Note this
	 * includes Vars used in resjunk items, so we are covering the needs of
	 * ORDER BY and window specifications.  Vars used within Aggrefs and
	 * WindowFuncs will be pulled out here, too.
         */</comment>
	<expr_stmt><expr><name>non_group_vars</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>non_group_cols</name></expr></argument>,
									 <argument><expr><name>PVC_RECURSE_AGGREGATES</name> <operator>|</operator>
									 <name>PVC_RECURSE_WINDOWFUNCS</name> <operator>|</operator>
									 <name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_new_columns_to_pathtarget</name><argument_list>(<argument><expr><name>input_target</name></expr></argument>, <argument><expr><name>non_group_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* clean up cruft */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>non_group_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>non_group_cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XXX this causes some redundant cost calculation ... */</comment>
	<return>return <expr><call><name>set_pathtarget_cost_width</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>input_target</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

            <comment type="block">/*
 * make_partial_grouping_target
 *	  Generate appropriate PathTarget for output of partial aggregate
 *	  (or partial grouping, if there are no aggregates) nodes.
             *
 * A partial aggregation node needs to emit all the same aggregates that
 * a regular aggregation node would, plus any aggregates used in HAVING;
 * except that the Aggref nodes should be marked as partial aggregates.
 *
 * In addition, we'd better emit any Vars and PlaceholderVars that are
 * used outside of Aggrefs in the aggregation tlist and HAVING.  (Presumably,
 * these would be Vars that are grouped by or used in grouping expressions.)
 *
 * grouping_target is the tlist to be emitted by the topmost aggregation step.
 * havingQual represents the HAVING clause.
             */</comment>
<function><type><specifier>static</specifier> <name>PathTarget</name> <modifier>*</modifier></type>
<name>make_partial_grouping_target</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							 <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>grouping_target</name></decl></parameter>,
							 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>havingQual</name></decl></parameter>)</parameter_list>
        <block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>partial_target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>non_group_cols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>non_group_exprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>partial_target</name> <operator>=</operator> <call><name>create_empty_pathtarget</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>non_group_cols</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>grouping_target-&gt;exprs</argument>)</argument_list></macro>
            <block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type>		<name>sgref</name> <init>= <expr><call><name>get_pathtarget_sortgroupref</name><argument_list>(<argument><expr><name>grouping_target</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>sgref</name> <operator>&amp;&amp;</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>&amp;&amp;</operator>
			<call><name>get_sortgroupref_clause_noerr</name><argument_list>(<argument><expr><name>sgref</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * It's a grouping column, so add it to the partial_target as-is.
			 * (This allows the upper agg step to repeat the grouping calcs.)
			 */</comment>
			<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>partial_target</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>sgref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
			<comment type="block">/*
			 * Non-grouping column, so just remember the expression for later
			 * call to pull_var_clause.
			 */</comment>
			<expr_stmt><expr><name>non_group_cols</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>non_group_cols</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block>

        <comment type="block">/*
	 * If there's a HAVING clause, we'll need the Vars/Aggrefs it uses, too.
         */</comment>
	<if_stmt><if>if <condition>(<expr><name>havingQual</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>non_group_cols</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>non_group_cols</name></expr></argument>, <argument><expr><name>havingQual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
	 * Pull out all the Vars, PlaceHolderVars, and Aggrefs mentioned in
	 * non-group cols (plus HAVING), and add them to the partial_target if not
	 * already present.  (An expression used directly as a GROUP BY item will
	 * be present already.)  Note this includes Vars used in resjunk items, so
	 * we are covering the needs of ORDER BY and window specifications.
         */</comment>
	<expr_stmt><expr><name>non_group_exprs</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>non_group_cols</name></expr></argument>,
									  <argument><expr><name>PVC_INCLUDE_AGGREGATES</name> <operator>|</operator>
									  <name>PVC_RECURSE_WINDOWFUNCS</name> <operator>|</operator>
									  <name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>add_new_columns_to_pathtarget</name><argument_list>(<argument><expr><name>partial_target</name></expr></argument>, <argument><expr><name>non_group_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Adjust Aggrefs to put them in partial mode.  At this point all Aggrefs
	 * are at the top level of the target list, so we can just scan the list
	 * rather than recursing through the expression trees.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>partial_target-&gt;exprs</argument>)</argument_list></macro>
        <block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>aggref</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>aggref</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>newaggref</name></decl>;</decl_stmt>

        <comment type="block">/*
			 * We shouldn't need to copy the substructure of the Aggref node,
			 * but flat-copy the node itself to avoid damaging other trees.
         */</comment>
			<expr_stmt><expr><name>newaggref</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newaggref</name></expr></argument>, <argument><expr><name>aggref</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* For now, assume serialization is required */</comment>
			<expr_stmt><expr><call><name>mark_partial_aggref</name><argument_list>(<argument><expr><name>newaggref</name></expr></argument>, <argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>newaggref</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
    </block_content>}</block>

	<comment type="block">/* clean up cruft */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>non_group_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>non_group_cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XXX this causes some redundant cost calculation ... */</comment>
	<return>return <expr><call><name>set_pathtarget_cost_width</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>partial_target</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

    <comment type="block">/*
 * mark_partial_aggref
 *	  Adjust an Aggref to make it represent a partial-aggregation step.
     *
 * The Aggref node is modified in-place; caller must do any copying required.
     */</comment>
<function><type><name>void</name></type>
<name>mark_partial_aggref</name><parameter_list>(<parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>, <parameter><decl><type><name>AggSplit</name></type> <name>aggsplit</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
	<comment type="block">/* aggtranstype should be computed by this point */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggtranstype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* ... but aggsplit should still be as the parser left it */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>==</operator> <name>AGGSPLIT_SIMPLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark the Aggref with the intended partial-aggregation mode */</comment>
	<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>aggsplit</name></expr>;</expr_stmt>

            <comment type="block">/*
	 * Adjust result type if needed.  Normally, a partial aggregate returns
	 * the aggregate's transition type; but if that's INTERNAL and we're
	 * serializing, it returns BYTEA instead.
             */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>DO_AGGSPLIT_SKIPFINAL</name><argument_list>(<argument><expr><name>aggsplit</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>==</operator> <name>INTERNALOID</name> <operator>&amp;&amp;</operator> <call><name>DO_AGGSPLIT_SERIALIZE</name><argument_list>(<argument><expr><name>aggsplit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <name>BYTEAOID</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <name><name>agg</name><operator>-&gt;</operator><name>aggtranstype</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

            <comment type="block">/*
 * postprocess_setop_tlist
 *	  Fix up targetlist returned by plan_set_operations().
 *
 * We need to transpose sort key info from the orig_tlist into new_tlist.
 * NOTE: this would not be good enough if we supported resjunk sort keys
 * for results of set operations --- then, we'd need to project a whole
 * new tlist to evaluate the resjunk columns.  For now, just ereport if we
 * find any resjunk columns in orig_tlist.
             */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>postprocess_setop_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>new_tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>orig_tlist</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>orig_tlist_item</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name>orig_tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>new_tlist</argument>)</argument_list></macro>
                <block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>new_tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>orig_tle</name></decl>;</decl_stmt>

		<comment type="block">/* ignore resjunk columns in setop result */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>new_tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>orig_tlist_item</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>orig_tle</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>orig_tlist_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>orig_tlist_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>orig_tlist_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>orig_tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* should not happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"resjunk output columns are not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>new_tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>==</operator> <name><name>orig_tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name><name>orig_tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>;</expr_stmt>
                </block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>orig_tlist_item</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"resjunk output columns are not implemented"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>new_tlist</name></expr>;</return>
            </block_content>}</block></function>

            <comment type="block">/*
 * select_active_windows
 *		Create a list of the "active" window clauses (ie, those referenced
 *		by non-deleted WindowFuncs) in the order they are to be executed.
             */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>select_active_windows</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>WindowFuncLists</name> <modifier>*</modifier></type><name>wflists</name></decl></parameter>)</parameter_list>
            <block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>actives</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* First, make a list of the active windows */</comment>
	<expr_stmt><expr><name>actives</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;parse-&gt;windowClause</argument>)</argument_list></macro>
                <block>{<block_content>
		<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><operator>(</operator><name>WindowClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* It's only active if wflists shows some related WindowFuncs */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>winref</name></name> <operator>&lt;=</operator> <name><name>wflists</name><operator>-&gt;</operator><name>maxWinRef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>wflists</name><operator>-&gt;</operator><name>windowFuncs</name><index>[<expr><name><name>wc</name><operator>-&gt;</operator><name>winref</name></name></expr>]</index></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>actives</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>actives</name></expr></argument>, <argument><expr><name>wc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>

	<comment type="block">/*
	 * Now, ensure that windows with identical partitioning/ordering clauses
	 * are adjacent in the list.  This is required by the SQL standard, which
	 * says that only one sort is to be used for such windows, even if they
	 * are otherwise distinct (eg, different names or framing clauses).
	 *
	 * There is room to be much smarter here, for example detecting whether
	 * one window's sort keys are a prefix of another's (so that sorting for
	 * the latter would do for the former), or putting windows first that
	 * match a sort order available for the underlying query.  For the moment
	 * we are content with meeting the spec.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>actives</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
        <block>{<block_content>
		<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><operator>(</operator><name>WindowClause</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>actives</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

		<comment type="block">/* Move wc from actives to result */</comment>
		<expr_stmt><expr><name>actives</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>actives</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>wc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now move any matching windows from actives to result */</comment>
		<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>lc</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>actives</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>lc</name></expr>;</condition> <incr><expr><name>lc</name> <operator>=</operator> <name>next</name></expr></incr>)</control>
        <block>{<block_content>
			<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc2</name> <init>= <expr><operator>(</operator><name>WindowClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* framing options are NOT to be compared here! */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>, <argument><expr><name><name>wc2</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>equal</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>, <argument><expr><name><name>wc2</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>actives</name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name>actives</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>wc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>lc</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>
    </block_content>}</block></while>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_window_input_target
 *	  Generate appropriate PathTarget for initial input to WindowAgg nodes.
 *
 * When the query has window functions, this function computes the desired
 * target to be computed by the node just below the first WindowAgg.
 * This tlist must contain all values needed to evaluate the window functions,
 * compute the final target list, and perform any required final sort step.
 * If multiple WindowAggs are needed, each intermediate one adds its window
 * function results onto this base tlist; only the topmost WindowAgg computes
 * the actual desired target list.
 *
 * This function is much like make_group_input_target, though not quite enough
 * like it to share code.  As in that function, we flatten most expressions
 * into their component variables.  But we do not want to flatten window
 * PARTITION BY/ORDER BY clauses, since that might result in multiple
 * evaluations of them, which would be bad (possibly even resulting in
 * inconsistent answers, if they contain volatile functions).
 * Also, we must not flatten GROUP BY clauses that were left unflattened by
 * make_group_input_target, because we may no longer have access to the
 * individual Vars in them.
 *
 * Another key difference from make_group_input_target is that we don't
 * flatten Aggref expressions, since those are to be computed below the
 * window functions and just referenced like Vars above that.
 *
 * 'final_target' is the query's final target list (in PathTarget form)
 * 'activeWindows' is the list of active windows previously identified by
 *			select_active_windows.
 *
 * The result is the PathTarget to be computed by the plan node immediately
 * below the first WindowAgg node.
 */</comment>
<function><type><specifier>static</specifier> <name>PathTarget</name> <modifier>*</modifier></type>
<name>make_window_input_target</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						 <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>final_target</name></decl></parameter>,
                    <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>activeWindows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>input_target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>sgrefs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>flattenable_cols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>flattenable_vars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
	 * Collect the sortgroupref numbers of window PARTITION/ORDER BY clauses
	 * into a bitmapset for convenient reference below.
     */</comment>
	<expr_stmt><expr><name>sgrefs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>activeWindows</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><operator>(</operator><name>WindowClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>wc-&gt;partitionClause</argument>)</argument_list></macro>
    <block>{<block_content>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>sgrefs</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>sgrefs</name></expr></argument>, <argument><expr><name><name>sortcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>wc-&gt;orderClause</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>sgrefs</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>sgrefs</name></expr></argument>, <argument><expr><name><name>sortcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<comment type="block">/* Add in sortgroupref numbers of GROUP BY clauses, too */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parse-&gt;groupClause</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grpcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>sgrefs</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>sgrefs</name></expr></argument>, <argument><expr><name><name>grpcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<comment type="block">/*
	 * Construct a target containing all the non-flattenable targetlist items,
	 * and save aside the others for a moment.
 */</comment>
	<expr_stmt><expr><name>input_target</name> <operator>=</operator> <call><name>create_empty_pathtarget</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>flattenable_cols</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>final_target-&gt;exprs</argument>)</argument_list></macro>
<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type>		<name>sgref</name> <init>= <expr><call><name>get_pathtarget_sortgroupref</name><argument_list>(<argument><expr><name>final_target</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
		 * Don't want to deconstruct window clauses or GROUP BY items.  (Note
		 * that such items can't contain window functions, so it's okay to
		 * compute them below the WindowAgg nodes.)
     */</comment>
		<if_stmt><if>if <condition>(<expr><name>sgref</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><name>sgref</name></expr></argument>, <argument><expr><name>sgrefs</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
			 * Don't want to deconstruct this value, so add it to the input
			 * target as-is.
             */</comment>
			<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>input_target</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>sgref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
			<comment type="block">/*
			 * Column is to be flattened, so just remember the expression for
			 * later call to pull_var_clause.
			 */</comment>
			<expr_stmt><expr><name>flattenable_cols</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>flattenable_cols</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

	<comment type="block">/*
	 * Pull out all the Vars and Aggrefs mentioned in flattenable columns, and
	 * add them to the input target if not already present.  (Some might be
	 * there already because they're used directly as window/group clauses.)
	 *
	 * Note: it's essential to use PVC_INCLUDE_AGGREGATES here, so that any
	 * Aggrefs are placed in the Agg node's tlist and not left to be computed
	 * at higher levels.  On the other hand, we should recurse into
	 * WindowFuncs to make sure their input expressions are available.
	 */</comment>
	<expr_stmt><expr><name>flattenable_vars</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>flattenable_cols</name></expr></argument>,
									   <argument><expr><name>PVC_INCLUDE_AGGREGATES</name> <operator>|</operator>
									   <name>PVC_RECURSE_WINDOWFUNCS</name> <operator>|</operator>
									   <name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_new_columns_to_pathtarget</name><argument_list>(<argument><expr><name>input_target</name></expr></argument>, <argument><expr><name>flattenable_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* clean up cruft */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>flattenable_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>flattenable_cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XXX this causes some redundant cost calculation ... */</comment>
	<return>return <expr><call><name>set_pathtarget_cost_width</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>input_target</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_pathkeys_for_window
 *		Create a pathkeys list describing the required input ordering
 *		for the given WindowClause.
 *
 * The required ordering is first the PARTITION keys, then the ORDER keys.
 * In the future we might try to implement windowing using hashing, in which
 * case the ordering could be relaxed, but for now we always sort.
 *
 * Caution: if you change this, see createplan.c's get_column_info_for_window!
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>make_pathkeys_for_window</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>window_pathkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>window_sortclauses</name></decl>;</decl_stmt>

	<comment type="block">/* Throw error if can't sort */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>grouping_is_sortable</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not implement window PARTITION BY"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Window partitioning columns must be of sortable datatypes."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>grouping_is_sortable</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not implement window ORDER BY"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Window ordering columns must be of sortable datatypes."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Okay, make the combined pathkeys */</comment>
	<expr_stmt><expr><name>window_sortclauses</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>window_pathkeys</name> <operator>=</operator> <call><name>make_pathkeys_for_sortclauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													<argument><expr><name>window_sortclauses</name></expr></argument>,
													<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>window_sortclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>window_pathkeys</name></expr>;</return>
</block_content>}</block></function>

    <comment type="block">/*
 * make_sort_input_target
 *	  Generate appropriate PathTarget for initial input to Sort step.
 *
 * If the query has ORDER BY, this function chooses the target to be computed
 * by the node just below the Sort (and DISTINCT, if any, since Unique can't
 * project) steps.  This might or might not be identical to the query's final
 * output target.
 *
 * The main argument for keeping the sort-input tlist the same as the final
 * is that we avoid a separate projection node (which will be needed if
 * they're different, because Sort can't project).  However, there are also
 * advantages to postponing tlist evaluation till after the Sort: it ensures
 * a consistent order of evaluation for any volatile functions in the tlist,
 * and if there's also a LIMIT, we can stop the query without ever computing
 * tlist functions for later rows, which is beneficial for both volatile and
 * expensive functions.
 *
 * Our current policy is to postpone volatile expressions till after the sort
 * unconditionally (assuming that that's possible, ie they are in plain tlist
 * columns and not ORDER BY/GROUP BY/DISTINCT columns).  We also prefer to
 * postpone set-returning expressions, because running them beforehand would
 * bloat the sort dataset, and because it might cause unexpected output order
 * if the sort isn't stable.  However there's a constraint on that: all SRFs
 * in the tlist should be evaluated at the same plan step, so that they can
 * run in sync in nodeProjectSet.  So if any SRFs are in sort columns, we
 * mustn't postpone any SRFs.  (Note that in principle that policy should
 * probably get applied to the group/window input targetlists too, but we
 * have not done that historically.)  Lastly, expensive expressions are
 * postponed if there is a LIMIT, or if root-&gt;tuple_fraction shows that
 * partial evaluation of the query is possible (if neither is true, we expect
 * to have to evaluate the expressions for every row anyway), or if there are
 * any volatile or set-returning expressions (since once we've put in a
 * projection at all, it won't cost any more to postpone more stuff).
 *
 * Another issue that could potentially be considered here is that
 * evaluating tlist expressions could result in data that's either wider
 * or narrower than the input Vars, thus changing the volume of data that
 * has to go through the Sort.  However, we usually have only a very bad
 * idea of the output width of any expression more complex than a Var,
 * so for now it seems too risky to try to optimize on that basis.
 *
 * Note that if we do produce a modified sort-input target, and then the
 * query ends up not using an explicit Sort, no particular harm is done:
 * we'll initially use the modified target for the preceding path nodes,
 * but then change them to the final target with apply_projection_to_path.
 * Moreover, in such a case the guarantees about evaluation order of
 * volatile functions still hold, since the rows are sorted already.
 *
 * This function has some things in common with make_group_input_target and
 * make_window_input_target, though the detailed rules for what to do are
 * different.  We never flatten/postpone any grouping or ordering columns;
 * those are needed before the sort.  If we do flatten a particular
 * expression, we leave Aggref and WindowFunc nodes alone, since those were
 * computed earlier.
 *
 * 'final_target' is the query's final target list (in PathTarget form)
 * 'have_postponed_srfs' is an output argument, see below
 *
 * The result is the PathTarget to be computed by the plan node immediately
 * below the Sort step (and the Distinct step, if any).  This will be
 * exactly final_target if we decide a projection step wouldn't be helpful.
 *
 * In addition, *have_postponed_srfs is set to TRUE if we choose to postpone
 * any set-returning functions to after the Sort.
     */</comment>
<function><type><specifier>static</specifier> <name>PathTarget</name> <modifier>*</modifier></type>
<name>make_sort_input_target</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					   <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>final_target</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>have_postponed_srfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>input_target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ncols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>col_is_srf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>postpone_col</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_srf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_volatile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_expensive</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_srf_sortcols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>postpone_srfs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>postponable_cols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>postponable_vars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* Shouldn't get here unless query has ORDER BY */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>have_postponed_srfs</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* default result */</comment>

	<comment type="block">/* Inspect tlist and collect per-column information */</comment>
	<expr_stmt><expr><name>ncols</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>final_target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>col_is_srf</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>ncols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>postpone_col</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>ncols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>have_srf</name> <operator>=</operator> <name>have_volatile</name> <operator>=</operator> <name>have_expensive</name> <operator>=</operator> <name>have_srf_sortcols</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>final_target-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
		 * If the column has a sortgroupref, assume it has to be evaluated
		 * before sorting.  Generally such columns would be ORDER BY, GROUP
		 * BY, etc targets.  One exception is columns that were removed from
		 * GROUP BY by remove_useless_groupby_columns() ... but those would
		 * only be Vars anyway.  There don't seem to be any cases where it
		 * would be worth the trouble to double-check.
     */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_pathtarget_sortgroupref</name><argument_list>(<argument><expr><name>final_target</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
			 * Check for SRF or volatile functions.  Check the SRF case first
			 * because we must know whether we have any postponed SRFs.
         */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>&amp;&amp;</operator>
				<call><name>expression_returns_set</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* We'll decide below whether these are postponable */</comment>
				<expr_stmt><expr><name><name>col_is_srf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>have_srf</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Unconditionally postpone */</comment>
				<expr_stmt><expr><name><name>postpone_col</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>have_volatile</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
				 * Else check the cost.  XXX it's annoying to have to do this
				 * when set_pathtarget_cost_width() just did it.  Refactor to
				 * allow sharing the work?
         */</comment>
				<decl_stmt><decl><type><name>QualCost</name></type>	<name>cost</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>cost_qual_eval_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cost</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
				 * We arbitrarily define "expensive" as "more than 10X
				 * cpu_operator_cost".  Note this will take in any PL function
				 * with default cost.
     */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>&gt;</operator> <literal type="number">10</literal> <operator>*</operator> <name>cpu_operator_cost</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>postpone_col</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>have_expensive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
    <block>{<block_content>
			<comment type="block">/* For sortgroupref cols, just check if any contain SRFs */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_srf_sortcols</name> <operator>&amp;&amp;</operator>
				<name><name>parse</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>&amp;&amp;</operator>
				<call><name>expression_returns_set</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>have_srf_sortcols</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

        <comment type="block">/*
	 * We can postpone SRFs if we have some but none are in sortgroupref cols.
         */</comment>
	<expr_stmt><expr><name>postpone_srfs</name> <operator>=</operator> <operator>(</operator><name>have_srf</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>have_srf_sortcols</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we don't need a post-sort projection, just return final_target.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>postpone_srfs</name> <operator>||</operator> <name>have_volatile</name> <operator>||</operator>
		  <operator>(</operator><name>have_expensive</name> <operator>&amp;&amp;</operator>
		   <operator>(</operator><name><name>parse</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>tuple_fraction</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>final_target</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Report whether the post-sort projection will contain set-returning
	 * functions.  This is important because it affects whether the Sort can
	 * rely on the query's LIMIT (if any) to bound the number of rows it needs
	 * to return.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>have_postponed_srfs</name> <operator>=</operator> <name>postpone_srfs</name></expr>;</expr_stmt>

                <comment type="block">/*
	 * Construct the sort-input target, taking all non-postponable columns and
	 * then adding Vars, PlaceHolderVars, Aggrefs, and WindowFuncs found in
	 * the postponable ones.
                 */</comment>
	<expr_stmt><expr><name>input_target</name> <operator>=</operator> <call><name>create_empty_pathtarget</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>postponable_cols</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>final_target-&gt;exprs</argument>)</argument_list></macro>
        <block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>postpone_col</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <operator>(</operator><name>postpone_srfs</name> <operator>&amp;&amp;</operator> <name><name>col_is_srf</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>postponable_cols</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>postponable_cols</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>input_target</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>,
									 <argument><expr><call><name>get_pathtarget_sortgroupref</name><argument_list>(<argument><expr><name>final_target</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Pull out all the Vars, Aggrefs, and WindowFuncs mentioned in
	 * postponable columns, and add them to the sort-input target if not
	 * already present.  (Some might be there already.)  We mustn't
	 * deconstruct Aggrefs or WindowFuncs here, since the projection node
	 * would be unable to recompute them.
	 */</comment>
	<expr_stmt><expr><name>postponable_vars</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>postponable_cols</name></expr></argument>,
									   <argument><expr><name>PVC_INCLUDE_AGGREGATES</name> <operator>|</operator>
									   <name>PVC_INCLUDE_WINDOWFUNCS</name> <operator>|</operator>
									   <name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_new_columns_to_pathtarget</name><argument_list>(<argument><expr><name>input_target</name></expr></argument>, <argument><expr><name>postponable_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* clean up cruft */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>postponable_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>postponable_cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XXX this represents even more redundant cost calculation ... */</comment>
	<return>return <expr><call><name>set_pathtarget_cost_width</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>input_target</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></function>

    <comment type="block">/*
 * get_cheapest_fractional_path
 *	  Find the cheapest path for retrieving a specified fraction of all
 *	  the tuples expected to be returned by the given relation.
     *
 * We interpret tuple_fraction the same way as grouping_planner.
     *
 * We assume set_cheapest() has been run on the given rel.
     */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>get_cheapest_fractional_path</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>tuple_fraction</name></decl></parameter>)</parameter_list>
    <block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>best_path</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* If all tuples will be retrieved, just return the cheapest-total path */</comment>
	<if_stmt><if>if <condition>(<expr><name>tuple_fraction</name> <operator>&lt;=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>best_path</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Convert absolute # of tuples to a fraction; no need to clamp to 0..1 */</comment>
	<if_stmt><if>if <condition>(<expr><name>tuple_fraction</name> <operator>&gt;=</operator> <literal type="number">1.0</literal> <operator>&amp;&amp;</operator> <name><name>best_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tuple_fraction</name> <operator>/=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>rel-&gt;pathlist</argument>)</argument_list></macro>
    <block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name> <operator>||</operator>
			<call><name>compare_fractional_path_costs</name><argument_list>(<argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>tuple_fraction</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>best_path</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
    </block_content>}</block>

	<return>return <expr><name>best_path</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * adjust_paths_for_srfs
 *		Fix up the Paths of the given upperrel to handle tSRFs properly.
 *
 * The executor can only handle set-returning functions that appear at the
 * top level of the targetlist of a ProjectSet plan node.  If we have any SRFs
 * that are not at top level, we need to split up the evaluation into multiple
 * plan levels in which each level satisfies this constraint.  This function
 * modifies each Path of an upperrel that (might) compute any SRFs in its
 * output tlist to insert appropriate projection steps.
 *
 * The given targets and targets_contain_srfs lists are from
 * split_pathtarget_at_srfs().  We assume the existing Paths emit the first
 * target in targets.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>adjust_paths_for_srfs</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targets</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targets_contain_srfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>targets</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>targets_contain_srfs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>linitial_int</name><argument_list>(<argument><expr><name>targets_contain_srfs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If no SRFs appear at this plan level, nothing to do */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>targets</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
	 * Stack SRF-evaluation nodes atop each path for the rel.
	 *
	 * In principle we should re-run set_cheapest() here to identify the
	 * cheapest path, but it seems unlikely that adding the same tlist eval
	 * costs to all the paths would change that, so we don't bother. Instead,
	 * just assume that the cheapest-startup and cheapest-total paths remain
	 * so.  (There should be no parameterized paths anymore, so we needn't
	 * worry about updating cheapest_parameterized_paths.)
     */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;pathlist</argument>)</argument_list></macro>
    <block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>newpath</name> <init>= <expr><name>subpath</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>forboth</name><argument_list>(<argument>lc1</argument>, <argument>targets</argument>, <argument>lc2</argument>, <argument>targets_contain_srfs</argument>)</argument_list></macro>
            <block>{<block_content>
			<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>thistarget</name> <init>= <expr><operator>(</operator><name>PathTarget</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>contains_srfs</name> <init>= <expr><operator>(</operator><name>bool</name><operator>)</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* If this level doesn't contain SRFs, do regular projection */</comment>
			<if_stmt><if>if <condition>(<expr><name>contains_srfs</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_set_projection_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															  <argument><expr><name>rel</name></expr></argument>,
															  <argument><expr><name>newpath</name></expr></argument>,
															  <argument><expr><name>thistarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>newpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>apply_projection_to_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															<argument><expr><name>rel</name></expr></argument>,
															<argument><expr><name>newpath</name></expr></argument>,
															<argument><expr><name>thistarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block>
		<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>newpath</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>subpath</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>cheapest_startup_path</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_startup_path</name></name> <operator>=</operator> <name>newpath</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>subpath</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name> <operator>=</operator> <name>newpath</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>

	<comment type="block">/* Likewise for partial paths, if any */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;partial_pathlist</argument>)</argument_list></macro>
    <block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>newpath</name> <init>= <expr><name>subpath</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>forboth</name><argument_list>(<argument>lc1</argument>, <argument>targets</argument>, <argument>lc2</argument>, <argument>targets_contain_srfs</argument>)</argument_list></macro>
        <block>{<block_content>
			<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>thistarget</name> <init>= <expr><operator>(</operator><name>PathTarget</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>contains_srfs</name> <init>= <expr><operator>(</operator><name>bool</name><operator>)</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* If this level doesn't contain SRFs, do regular projection */</comment>
			<if_stmt><if>if <condition>(<expr><name>contains_srfs</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_set_projection_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															  <argument><expr><name>rel</name></expr></argument>,
															  <argument><expr><name>newpath</name></expr></argument>,
															  <argument><expr><name>thistarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* avoid apply_projection_to_path, in case of multiple refs */</comment>
				<expr_stmt><expr><name>newpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_projection_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														  <argument><expr><name>rel</name></expr></argument>,
														  <argument><expr><name>newpath</name></expr></argument>,
														  <argument><expr><name>thistarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>newpath</name></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></function>

    <comment type="block">/*
 * expression_planner
 *		Perform planner's transformations on a standalone expression.
 *
 * Various utility commands need to evaluate expressions that are not part
 * of a plannable query.  They can do so using the executor's regular
 * expression-execution machinery, but first the expression has to be fed
 * through here to transform it from parser output to something executable.
 *
 * Currently, we disallow sublinks in standalone expressions, so there's no
 * real "planning" involved here.  (That might not always be true though.)
 * What we must do is run eval_const_expressions to ensure that any function
 * calls are converted to positional notation and function default arguments
 * get inserted.  The fact that constant subexpressions get simplified is a
 * side-effect that is useful when the expression will get evaluated more than
 * once.  Also, we must fix operator function IDs.
 *
 * Note: this must not make any damaging changes to the passed-in expression
 * tree.  (It would actually be okay to apply fix_opfuncids to it, but since
 * we first do an expression_tree_mutator-based walk, what is returned will
 * be a new node tree.)
     */</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type>
<name>expression_planner</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <comment type="block">/*
	 * Convert named-argument function calls, insert default arguments and
	 * simplify constant subexprs
     */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fill in opfuncid values if missing */</comment>
	<expr_stmt><expr><call><name>fix_opfuncids</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * plan_cluster_use_sort
 *		Use the planner to decide how CLUSTER should implement sorting
 *
 * tableOid is the OID of a table to be clustered on its index indexOid
 * (which is already known to be a btree index).  Decide whether it's
 * cheaper to do an indexscan or a seqscan-plus-sort to execute the CLUSTER.
 * Return TRUE to use sorting, FALSE to use an indexscan.
 *
 * Note: caller had better already hold some type of lock on the table.
 */</comment>
<function><type><name>bool</name></type>
<name>plan_cluster_use_sort</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tableOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QualCost</name></type>	<name>indexExprCost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>comparisonCost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>seqScanPath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name></type>		<name>seqScanAndSortPath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexPath</name>  <modifier>*</modifier></type><name>indexScanPath</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* We can short-circuit the cost comparison if indexscans are disabled */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_indexscan</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* use sort */</comment>

	<comment type="block">/* Set up mostly-dummy planner state */</comment>
	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>glob</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerGlobal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name> <operator>=</operator> <name>query</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name> <operator>=</operator> <name>glob</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>query_level</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>planner_cxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>wt_param_id</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>recursiveOk</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Build a minimal RTE for the rel */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_RELATION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>tableOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>RELKIND_RELATION</name></expr>;</expr_stmt>	<comment type="block">/* Don't be too picky. */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up RTE/RelOptInfo arrays */</comment>
	<expr_stmt><expr><call><name>setup_simple_rel_arrays</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build RelOptInfo */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>build_simple_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Locate IndexOptInfo for the target index */</comment>
	<expr_stmt><expr><name>indexInfo</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;indexlist</argument>)</argument_list></macro>
        <block>{<block_content>
		<expr_stmt><expr><name>indexInfo</name> <operator>=</operator> <operator>(</operator><name>IndexOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>indexoid</name></name> <operator>==</operator> <name>indexOid</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block>

            <comment type="block">/*
	 * It's possible that get_relation_info did not generate an IndexOptInfo
	 * for the desired index; this could happen if it's not yet reached its
	 * indcheckxmin usability horizon, or if it's a system index and we're
	 * ignoring system indexes.  In such cases we should tell CLUSTER to not
	 * trust the index contents but use seqscan-and-sort.
             */</comment>
	<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>				<comment type="block">/* not in the list? */</comment>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* use sort */</comment>

    <comment type="block">/*
	 * Rather than doing all the pushups that would be needed to use
	 * set_baserel_size_estimates, just do a quick hack for rows and width.
     */</comment>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <call><name>get_relation_data_width</name><argument_list>(<argument><expr><name>tableOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>total_table_pages</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>pages</name></name></expr>;</expr_stmt>

    <comment type="block">/*
	 * Determine eval cost of the index expressions, if any.  We need to
	 * charge twice that amount for each tuple comparison that happens during
	 * the sort, since tuplesort.c will have to re-evaluate the index
	 * expressions each time.  (XXX that's pretty inefficient...)
     */</comment>
	<expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indexExprCost</name></expr></argument>, <argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>indexprs</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>comparisonCost</name> <operator>=</operator> <literal type="number">2.0</literal> <operator>*</operator> <operator>(</operator><name><name>indexExprCost</name><operator>.</operator><name>startup</name></name> <operator>+</operator> <name><name>indexExprCost</name><operator>.</operator><name>per_tuple</name></name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Estimate the cost of seq scan + sort */</comment>
	<expr_stmt><expr><name>seqScanPath</name> <operator>=</operator> <call><name>create_seqscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cost_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqScanAndSortPath</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
			  <argument><expr><name><name>seqScanPath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
			  <argument><expr><name>comparisonCost</name></expr></argument>, <argument><expr><name>maintenance_work_mem</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Estimate the cost of index scan */</comment>
	<expr_stmt><expr><name>indexScanPath</name> <operator>=</operator> <call><name>create_index_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>,
									  <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
									  <argument><expr><name>ForwardScanDirection</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name><name>seqScanAndSortPath</name><operator>.</operator><name>total_cost</name></name> <operator>&lt;</operator> <name><name>indexScanPath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * grouping_distribution_match
 * 	Check if the path distribution matches grouping distribution.
 *
 * Grouping preserves distribution if the distribution key is on of the
 * grouping keys (arbitrary one). In that case it's guaranteed that groups
 * on different nodes do not overlap, and we can push the aggregation to
 * remote nodes as a whole.
 *
 * Otherwise we need to either fetch all the data to the coordinator and
 * perform the aggregation there, or use two-phase aggregation, with the
 * first phase (partial aggregation) pushed down, and the second phase
 * (combining and finalizing the results) executed on the coordinator.
 *
 * XXX This is used not only for plain aggregation, but also for various
 * other paths, relying on grouping infrastructure (DISTINCT ON, UNIQUE).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>grouping_distribution_match</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	<name>matches_key</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Distribution</name> <modifier>*</modifier></type><name>distribution</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>distribution</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>numGroupCols</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>groupColIdx</name> <init>= <expr><call><name>extract_grouping_cols</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>,
													<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>has_cold_hot_table</name></expr>)</condition>
        <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>path</name><operator>-&gt;</operator><name>distribution</name></name></expr>)</condition>
        <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
	 * With no explicit data distribution or replicated tables, we can simply
	 * push down the whole aggregation to the remote node, without any sort
	 * of redistribution. So consider this to be a match.
     */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>distribution</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator>
		<call><name>IsLocatorReplicated</name><argument_list>(<argument><expr><name><name>distribution</name><operator>-&gt;</operator><name>distributionType</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* But no distribution expression means 'no match'. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>distribution</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
	 * With distributed data and table distributed using an expression, we
	 * need to check if the distribution expression matches one of the
	 * grouping keys (arbitrary one).
     */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numGroupCols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator><call><name>list_nth</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>,
												  <argument><expr><name><name>groupColIdx</name><index>[<expr><name>i</name></expr>]</index></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name><name>distribution</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
			<expr_stmt><expr><name>matches_key</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

	<return>return <expr><name>matches_key</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * add_paths_to_grouping_rel
 *
 * Add non-partial paths to grouping relation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_paths_to_grouping_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
                          <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>, <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
                          <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>partial_grouping_target</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_final_costs</name></decl></parameter>,
                          <parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>can_sort</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>can_hash</name></decl></parameter>,
                          <parameter><decl><type><name>double</name></type> <name>dNumGroups</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>havingQual</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>try_distributed_aggregation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Query</name>      <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>cheapest_path</name> <init>= <expr><name><name>input_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>can_sort</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
		 * Use any available suitably-sorted path as input, and also consider
		 * sorting the cheapest-total path.
         */</comment>
	    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>input_rel-&gt;pathlist</argument>)</argument_list></macro>
        <block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>is_sorted</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>is_sorted</name> <operator>=</operator> <call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
											  <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * XL: Can it happen that the cheapest path can't be pushed down,
			 * while some other path could be? Perhaps we should move the check
			 * if a path can be pushed down up, and add another OR condition
			 * to consider all paths that can be pushed down?
			 *
			 * if (path == cheapest_path || is_sorted || can_push_down)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>cheapest_path</name> <operator>||</operator> <name>is_sorted</name></expr>)</condition>
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<decl_stmt><decl><type><name>bool</name></type> <name>try_redistribute_grouping</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type> <name>local_grouping_target</name> <init>= <expr><call><name>make_partial_grouping_target</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Estimate number of partial groups. */</comment>
				<decl_stmt><decl><type><name>double</name></type> <name>dNumLocalGroups</name> <init>= <expr><call><name>get_number_of_groups</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														 <argument><expr><name><name>cheapest_path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
														 <argument><expr><name>gd</name></expr></argument>,
														 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<if_stmt><if>if <condition>(<expr><name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
                <block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_sorted</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>agg_costs</name><operator>-&gt;</operator><name>hasOnlyDistinct</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														 <argument><expr><name>grouped_rel</name></expr></argument>,
														 <argument><expr><name>path</name></expr></argument>,
														 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
														 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if>
                <else>else
				<block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				    <comment type="block">/* Sort the cheapest-total path if it isn't already sorted */</comment>
				    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_sorted</name></expr>)</condition><block type="pseudo"><block_content>
					    <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													 <argument><expr><name>grouped_rel</name></expr></argument>,
													 <argument><expr><name>path</name></expr></argument>,
													 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
													 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
				 * If the grouping can't be fully pushed down, redistribute the
				 * path on top of the (sorted) path. If if can be pushed down,
				 * disable construction of complex distributed paths.
 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>can_push_down_grouping</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <block>{<block_content>
					<comment type="block">/* some special aggs cannot be parallel executed, such as count(distinct) */</comment>
					<if_stmt><if>if<condition>(<expr><name><name>agg_costs</name><operator>-&gt;</operator><name>hasNonPartial</name></name> <operator>||</operator> <name><name>agg_costs</name><operator>-&gt;</operator><name>hasNonSerial</name></name> <operator>||</operator>
						<name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator> <name><name>path</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>==</operator> <name>T_Agg</name> <operator>||</operator>
						<name><name>path</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>==</operator> <name>T_Group</name> <operator>||</operator> <operator>!</operator><name>olap_optimizer</name> <operator>||</operator> <name>has_cold_hot_table</name></expr>)</condition>
                    <block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>agg_costs</name><operator>-&gt;</operator><name>hasOnlyDistinct</name></name> <operator>&amp;&amp;</operator> <name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name>
							<operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_redistribute_grouping_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>agg_costs</name><operator>-&gt;</operator><name>hasOnlyDistinct</name></name> <operator>&amp;&amp;</operator> <name>olap_optimizer</name> <operator>&amp;&amp;</operator>
							<operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
                        <block>{<block_content>
							<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr>)</condition>
                            <block>{<block_content>
								<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><name>grouped_rel</name></expr></argument>,
												 <argument><expr><name>path</name></expr></argument>,
												 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
												 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if>
					<else>else
					<block>{<block_content>
                         <comment type="block">/*
						  * If the grouping can not be fully pushed down, we adopt another
						  * strategy instead.
						  * 1. do grouping on each datanode locally
						  * 2. re-distribute grouping results among datanodes, then do the
						  * 	final grouping
                          */</comment>

						<expr_stmt><expr><name>try_redistribute_grouping</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

						<comment type="block">/* step 1 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
						<block>{<block_content>
                            <comment type="block">/*
							 * TODO 2-phase aggregation for grouping sets paths not
							 * supported yet, but this the place where such paths
							 * should be constructed.
                             */</comment>
						</block_content>}</block></if>
						<if type="elseif">else if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/*
							 * We have aggregation, possibly with plain GROUP BY. Make
							 * an AggPath.
                             */</comment>

							<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															<argument><expr><name>grouped_rel</name></expr></argument>,
															<argument><expr><name>path</name></expr></argument>,
															<argument><expr><name>local_grouping_target</name></expr></argument>,
											<argument><expr><ternary><condition><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr> ?</condition><then> <expr><name>AGG_SORTED</name></expr> </then><else>: <expr><name>AGG_PLAIN</name></expr></else></ternary></expr></argument>,
															<argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr></argument>,
															<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
															<argument><expr><name>NIL</name></expr></argument>,
															<argument><expr><name>agg_costs</name></expr></argument>,
															<argument><expr><name>dNumLocalGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if>
						<if type="elseif">else if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/*
							 * We have GROUP BY without aggregation or grouping sets.
							 * Make a GroupPath.
                             */</comment>
							<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_group_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															  <argument><expr><name>grouped_rel</name></expr></argument>,
															  <argument><expr><name>path</name></expr></argument>,
															  <argument><expr><name>local_grouping_target</name></expr></argument>,
															  <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
															  <argument><expr><name>NIL</name></expr></argument>,
															  <argument><expr><name>dNumLocalGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<comment type="block">/* Other cases should have been handled above */</comment>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>

						<comment type="block">/* step 2*/</comment>
						<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_redistribute_grouping_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
					<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

				<if_stmt><else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>try_distributed_aggregation</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<if_stmt><if>if<condition>(<expr><name>try_redistribute_grouping</name></expr>)</condition>
				<block>{<block_content>
                    <comment type="block">/*
					 * do final grouping at each datanode
                     */</comment>

					<comment type="block">/* Now decide what to stick atop it */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * TODO 2-phase aggregation for grouping sets paths not
						 * supported yet, but this the place where such paths
						 * should be constructed.
						 */</comment>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * We generate two paths, differing in the second phase
						 * implementation (sort and hash).
						 */</comment>
						<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>remote_path</name> <init>= <expr><name>path</name></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_sorted</name> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
																 <argument><expr><name>grouped_rel</name></expr></argument>,
																 <argument><expr><name>path</name></expr></argument>,
																 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
																 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if></if_stmt>

						<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator><call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><name>grouped_rel</name></expr></argument>,
												 <argument><expr><name>path</name></expr></argument>,
												 <argument><expr><name>target</name></expr></argument>,
										 <argument><expr><ternary><condition><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr> ?</condition><then> <expr><name>AGG_SORTED</name></expr> </then><else>: <expr><name>AGG_PLAIN</name></expr></else></ternary></expr></argument>,
												 <argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>,
												 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
												 <argument><expr><name>havingQual</name></expr></argument>,
												 <argument><expr><name>agg_final_costs</name></expr></argument>,
												 <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="line">//path-&gt;parallel_safe = true;</comment>

						<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>can_hash</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
									 <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													 <argument><expr><name>grouped_rel</name></expr></argument>,
													 <argument><expr><name>remote_path</name></expr></argument>,
													 <argument><expr><name>target</name></expr></argument>,
													 <argument><expr><name>AGG_HASHED</name></expr></argument>,
													 <argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>,
													 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
													 <argument><expr><name>havingQual</name></expr></argument>,
													 <argument><expr><name>agg_final_costs</name></expr></argument>,
													 <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<comment type="line">//path-&gt;parallel_safe = true;</comment>
							<if_stmt><if>if <condition>(<expr><name>g_hybrid_hash_agg</name></expr>)</condition>
							<block>{<block_content>
								<decl_stmt><decl><type><name>AggPath</name> <modifier>*</modifier></type><name>agg</name> <init>= <expr><operator>(</operator><name>AggPath</name> <operator>*</operator><operator>)</operator><name>path</name></expr></init></decl>;</decl_stmt>
								<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>hybrid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>

							<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_sorted</name> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															 <argument><expr><name>grouped_rel</name></expr></argument>,
															 <argument><expr><name>path</name></expr></argument>,
															 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
															 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
								 <call><name>create_group_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												   <argument><expr><name>grouped_rel</name></expr></argument>,
												   <argument><expr><name>path</name></expr></argument>,
												   <argument><expr><name>target</name></expr></argument>,
												   <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
												   <argument><expr><name>havingQual</name></expr></argument>,
												   <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="line">//path-&gt;parallel_safe = true;</comment>

                        <comment type="block">/*
						 * We have GROUP BY without aggregation or grouping sets.
						 * Make a GroupPath.
                         */</comment>
						<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					</block_content>}</block></if>
					<else>else
                    <block>{<block_content>
						<comment type="block">/* Other cases should have been handled above */</comment>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

				<comment type="block">/* Now decide what to stick atop it */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>consider_groupingsets_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>,
												<argument><expr><name>path</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>can_hash</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
												<argument><expr><name>gd</name></expr></argument>, <argument><expr><name>agg_costs</name></expr></argument>, <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition>
				<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<decl_stmt><decl><type><name>bool</name></type> <name>parallel_aware</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type> <name>parallel_safe</name>  <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>agg_path</name>      <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name> <operator>&amp;&amp;</operator> <name>olap_optimizer</name> <operator>&amp;&amp;</operator>
						<operator>!</operator><name>has_cold_hot_table</name> <operator>&amp;&amp;</operator> <name><name>agg_costs</name><operator>-&gt;</operator><name>hasOnlyDistinct</name></name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
											  <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name>grouped_rel</name></expr></argument>,
											 <argument><expr><name>path</name></expr></argument>,
											 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
											 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					  	</block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>==</operator> <name>T_Sort</name> <operator>&amp;&amp;</operator> <name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>SortPath</name>   <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><operator>(</operator><name>SortPath</name> <operator>*</operator><operator>)</operator><name>path</name></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>==</operator> <name>T_Gather</name> <operator>||</operator> <name><name>agg_costs</name><operator>-&gt;</operator><name>hasOnlyDistinct</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>parallel_aware</name>       <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>parallel_safe</name>        <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>agg_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
							 <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name>grouped_rel</name></expr></argument>,
											 <argument><expr><name>path</name></expr></argument>,
											 <argument><expr><name>target</name></expr></argument>,
											 <argument><expr><ternary><condition><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr> ?</condition><then> <expr><name>AGG_SORTED</name></expr> </then><else>: <expr><name>AGG_PLAIN</name></expr></else></ternary></expr></argument>,
											 <argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
											 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
											 <argument><expr><name>havingQual</name></expr></argument>,
											 <argument><expr><name>agg_costs</name></expr></argument>,
											 <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>agg_path</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>parallel_aware</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>agg_path</name><operator>-&gt;</operator><name>parallel_safe</name></name>  <operator>=</operator> <name>parallel_safe</name></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>agg_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <comment type="block">/*
					 * We have aggregation, possibly with plain GROUP BY. Make
					 * an AggPath.
                     */</comment>
					<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
							 <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name>grouped_rel</name></expr></argument>,
											 <argument><expr><name>path</name></expr></argument>,
											 <argument><expr><name>target</name></expr></argument>,
											 <argument><expr><ternary><condition><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr> ?</condition><then> <expr><name>AGG_SORTED</name></expr> </then><else>: <expr><name>AGG_PLAIN</name></expr></else></ternary></expr></argument>,
											 <argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
											 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
											 <argument><expr><name>havingQual</name></expr></argument>,
											 <argument><expr><name>agg_costs</name></expr></argument>,
											 <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition>
				<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<decl_stmt><decl><type><name>bool</name></type> <name>parallel_aware</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type> <name>parallel_safe</name>	<init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>group_path</name>      <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name> <operator>&amp;&amp;</operator> <name>olap_optimizer</name> <operator>&amp;&amp;</operator>
						<operator>!</operator><name>has_cold_hot_table</name> <operator>&amp;&amp;</operator> <name><name>agg_costs</name><operator>-&gt;</operator><name>hasOnlyDistinct</name></name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
											  <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name>grouped_rel</name></expr></argument>,
											 <argument><expr><name>path</name></expr></argument>,
											 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
											 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					  	</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>==</operator> <name>T_Sort</name> <operator>&amp;&amp;</operator> <name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>SortPath</name>   <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><operator>(</operator><name>SortPath</name> <operator>*</operator><operator>)</operator><name>path</name></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>==</operator> <name>T_Gather</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>parallel_aware</name>       <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>parallel_safe</name>        <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>group_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
							 <call><name>create_group_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											   <argument><expr><name>grouped_rel</name></expr></argument>,
											   <argument><expr><name>path</name></expr></argument>,
											   <argument><expr><name>target</name></expr></argument>,
											   <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
											   <argument><expr><name>havingQual</name></expr></argument>,
											   <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>group_path</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>parallel_aware</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>group_path</name><operator>-&gt;</operator><name>parallel_safe</name></name>  <operator>=</operator> <name>parallel_safe</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>group_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

					<comment type="block">/*
					 * We have GROUP BY without aggregation or grouping sets.
					 * Make a GroupPath.
					 */</comment>
					<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
							 <call><name>create_group_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											   <argument><expr><name>grouped_rel</name></expr></argument>,
											   <argument><expr><name>path</name></expr></argument>,
											   <argument><expr><name>target</name></expr></argument>,
											   <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
											   <argument><expr><name>havingQual</name></expr></argument>,
											   <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				</block_content>}</block></if>
				<else>else
                <block>{<block_content>
					<comment type="block">/* Other cases should have been handled above */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

        <comment type="block">/*
		 * Now generate a complete GroupAgg Path atop of the cheapest partial
		 * path.  We can do this using either Gather or Gather Merge.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<decl_stmt><decl><type><name>bool</name>       <name>redistribute_group</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<decl_stmt><decl><type><name>double</name></type>		<name>total_groups</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>total_groups</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>total_groups</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<decl_stmt><decl><type><name>double</name></type>		<name>total_groups</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_gather_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											   <argument><expr><name>grouped_rel</name></expr></argument>,
											   <argument><expr><name>path</name></expr></argument>,
											   <argument><expr><name>partial_grouping_target</name></expr></argument>,
											   <argument><expr><name>NULL</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>total_groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/*
			 * Since Gather's output is always unsorted, we'll need to sort,
			 * unless there's no GROUP BY clause or a degenerate (constant)
			 * one, in which case there will only be a single group.
         */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>olap_optimizer</name> <operator>||</operator> <name>has_cold_hot_table</name></expr>)</condition>
            <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			    <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr>)</condition><block type="pseudo"><block_content>
				    <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><name>grouped_rel</name></expr></argument>,
												 <argument><expr><name>path</name></expr></argument>,
												 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
												 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	    	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/*
			 * If the grouping can't be fully pushed down, we'll push down the
			 * first phase of the aggregate, and redistribute only the partial
			 * results.
			 *
			 * If if can be pushed down, disable construction of complex
			 * distributed paths.
			 *
			 * XXX Keep this after the Sort node, to make the path sorted.
             */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>can_push_down_grouping</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
                <block>{<block_content>
					<comment type="block">/* redistribute local grouping results among datanodes */</comment>
					<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_redistribute_grouping_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>redistribute_group</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<if_stmt><else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>try_distributed_aggregation</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <comment type="block">/*
			 * Since Gather's output is always unsorted, we'll need to sort,
			 * unless there's no GROUP BY clause or a degenerate (constant)
			 * one, in which case there will only be a single group.
                 */</comment>
			<if_stmt><if>if <condition>(<expr><name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
            <block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													 <argument><expr><name>grouped_rel</name></expr></argument>,
													 <argument><expr><name>path</name></expr></argument>,
													 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
													 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>agg_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>agg_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
						 <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										 <argument><expr><name>grouped_rel</name></expr></argument>,
										 <argument><expr><name>path</name></expr></argument>,
										 <argument><expr><name>target</name></expr></argument>,
										 <argument><expr><ternary><condition><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr> ?</condition><then> <expr><name>AGG_SORTED</name></expr> </then><else>: <expr><name>AGG_PLAIN</name></expr></else></ternary></expr></argument>,
										 <argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>,
										 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
										 <argument><expr><name>havingQual</name></expr></argument>,
										 <argument><expr><name>agg_final_costs</name></expr></argument>,
										 <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>agg_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>agg_path</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>agg_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
				<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>group_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>group_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
						 <call><name>create_group_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										   <argument><expr><name>grouped_rel</name></expr></argument>,
										   <argument><expr><name>path</name></expr></argument>,
										   <argument><expr><name>target</name></expr></argument>,
										   <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
										   <argument><expr><name>havingQual</name></expr></argument>,
										   <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>group_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>group_path</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>group_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/*
			 * The point of using Gather Merge rather than Gather is that it
			 * can preserve the ordering of the input path, so there's no
			 * reason to try it unless (1) it's possible to produce more than
			 * one output row and (2) we want the output path to be ordered.
             */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>grouped_rel-&gt;partial_pathlist</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>gmpath</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>double</name></type>		<name>total_groups</name></decl>;</decl_stmt>

                    <comment type="block">/*
					 * It's useful to consider paths that are already properly
					 * ordered for Gather Merge, because those don't need a
					 * sort.  It's also useful to consider the cheapest path,
					 * because sorting it in parallel and then doing Gather
					 * Merge may be better than doing an unordered Gather
					 * followed by a sort.  But there's no point in
					 * considering non-cheapest paths that aren't already
					 * sorted correctly.
                     */</comment>
					<if_stmt><if>if <condition>(<expr><name>path</name> <operator>!=</operator> <name>subpath</name> <operator>&amp;&amp;</operator>
						<operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
											   <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<if_stmt><if>if <condition>(<expr><name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>total_groups</name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<expr_stmt><expr><name>total_groups</name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<if_stmt><if>if <condition>(<expr><name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
                    <block>{<block_content>
					    <expr_stmt><expr><name>gmpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_gather_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													     <argument><expr><name>grouped_rel</name></expr></argument>,
													     <argument><expr><name>subpath</name></expr></argument>,
													     <argument><expr><name>partial_grouping_target</name></expr></argument>,
													     <argument><expr><name>NULL</name></expr></argument>,
													     <argument><expr><operator>&amp;</operator><name>total_groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<expr_stmt><expr><name>gmpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
						<call><name>create_gather_merge_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><name>grouped_rel</name></expr></argument>,
												 <argument><expr><name>subpath</name></expr></argument>,
												 <argument><expr><name>partial_grouping_target</name></expr></argument>,
												 <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>total_groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                    <comment type="block">/*
					 * If the grouping can't be fully pushed down, we'll push down the
					 * first phase of the aggregate, and redistribute only the partial
					 * results.
                     */</comment>
					<expr_stmt><expr><name>redistribute_group</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>can_push_down_grouping</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>gmpath</name></expr></argument>)</argument_list></call></expr>)</condition>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* redistribute local grouping results among datanodes */</comment>
							<expr_stmt><expr><name>gmpath</name> <operator>=</operator> <call><name>create_redistribute_grouping_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>gmpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>redistribute_group</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
                        <block>{<block_content>
							<expr_stmt><expr><name>gmpath</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>gmpath</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
					<expr_stmt><expr><name>gmpath</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>gmpath</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <comment type="block">/*
					 * Since Gather's output is always unsorted, we'll need to sort,
					 * unless there's no GROUP BY clause or a degenerate (constant)
					 * one, in which case there will only be a single group.
                     */</comment>
					<if_stmt><if>if <condition>(<expr><name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
                    <block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>gmpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															  <argument><expr><name>grouped_rel</name></expr></argument>,
															  <argument><expr><name>gmpath</name></expr></argument>,
															  <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
															  <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

								<expr_stmt><expr><name><name>gmpath</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>agg_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name>agg_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
								 <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><name>grouped_rel</name></expr></argument>,
												 <argument><expr><name>gmpath</name></expr></argument>,
												 <argument><expr><name>target</name></expr></argument>,
												 <argument><expr><ternary><condition><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr> ?</condition><then> <expr><name>AGG_SORTED</name></expr> </then><else>: <expr><name>AGG_PLAIN</name></expr></else></ternary></expr></argument>,
												 <argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>,
												 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
												 <argument><expr><name>havingQual</name></expr></argument>,
												 <argument><expr><name>agg_final_costs</name></expr></argument>,
												 <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>agg_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>agg_path</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>agg_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
                    <block>{<block_content>
						<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>group_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name>group_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
								 <call><name>create_group_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												   <argument><expr><name>grouped_rel</name></expr></argument>,
												   <argument><expr><name>gmpath</name></expr></argument>,
												   <argument><expr><name>target</name></expr></argument>,
												   <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
												   <argument><expr><name>havingQual</name></expr></argument>,
												   <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
                        <block>{<block_content>
							<expr_stmt><expr><name><name>group_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>group_path</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>group_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block>
			</block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>can_hash</name></expr>)</condition>
    <block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>        <name>hashaggtablesize</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
        <block>{<block_content>
			<comment type="block">/*
			 * Try for a hash-only groupingsets path over unsorted input.
			 */</comment>
			<expr_stmt><expr><call><name>consider_groupingsets_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>,
										<argument><expr><name>cheapest_path</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
										<argument><expr><name>gd</name></expr></argument>, <argument><expr><name>agg_costs</name></expr></argument>, <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
        <else>else
        <block>{<block_content>
			<expr_stmt><expr><name>hashaggtablesize</name> <operator>=</operator> <call><name>estimate_hashagg_tablesize</name><argument_list>(<argument><expr><name>cheapest_path</name></expr></argument>,
														  <argument><expr><name>agg_costs</name></expr></argument>,
														  <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
			 * Provided that the estimated size of the hashtable does not
			 * exceed work_mem, we'll generate a HashAgg Path, although if we
			 * were unable to sort above, then we'd better generate a Path, so
			 * that we at least have one.
             */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>hashaggtablesize</name> <operator>&lt;</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>||</operator> <name>g_hybrid_hash_agg</name> <operator>||</operator>
				<name><name>grouped_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<if_stmt><if>if <condition>(<expr><name>hashaggtablesize</name> <operator>&lt;</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>||</operator>
				<name><name>grouped_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <block>{<block_content>
				<comment type="block">/* Don't mess with the cheapest path directly. */</comment>
				<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><name>cheapest_path</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<decl_stmt><decl><type><name>bool</name></type> <name>try_redistribute_grouping</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <comment type="block">/*
				 * If the grouping can't be fully pushed down, we'll push down the
				 * first phase of the aggregate, and redistribute only the partial
				 * results.
				 *
				 * If if can be pushed down, disable construction of complex
				 * distributed paths.
                 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>can_push_down_grouping</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
				<block>{<block_content>
					<comment type="block">/* some special aggs cannot be parallel executed, such as count(distinct) */</comment>
					<if_stmt><if>if<condition>(<expr><name><name>agg_costs</name><operator>-&gt;</operator><name>hasNonPartial</name></name> <operator>||</operator> <name><name>agg_costs</name><operator>-&gt;</operator><name>hasNonSerial</name></name> <operator>||</operator>
						<name><name>path</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>==</operator> <name>T_Agg</name> <operator>||</operator> <name><name>path</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>==</operator> <name>T_Group</name> <operator>||</operator>
						<operator>!</operator><name>olap_optimizer</name> <operator>||</operator> <name>has_cold_hot_table</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>agg_costs</name><operator>-&gt;</operator><name>hasOnlyDistinct</name></name> <operator>&amp;&amp;</operator> <name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_redistribute_grouping_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						  * If the grouping can not be fully pushed down, we adopt another
						  * strategy instead.
						  * 1. do grouping on each datanode locally
						  * 2. re-distribute grouping results among datanodes, then do the
						  * 	final grouping
										*/</comment>
						<decl_stmt><decl><type><name>AggClauseCosts</name></type> <name>hashagg_partial_costs</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type> <name>local_grouping_target</name> <init>= <expr><call><name>make_partial_grouping_target</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<comment type="block">/* Estimate number of partial groups. */</comment>
						<decl_stmt><decl><type><name>double</name></type> <name>dNumLocalGroups</name> <init>= <expr><call><name>get_number_of_groups</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
																 <argument><expr><name><name>cheapest_path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
																 <argument><expr><name>gd</name></expr></argument>,
																 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><name>try_redistribute_grouping</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hashagg_partial_costs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggClauseCosts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>get_agg_clause_costs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>local_grouping_target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
								 <argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>hashagg_partial_costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* step 1 */</comment>
						<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														<argument><expr><name>grouped_rel</name></expr></argument>,
														<argument><expr><name>cheapest_path</name></expr></argument>,
														<argument><expr><name>local_grouping_target</name></expr></argument>,
														<argument><expr><name>AGG_HASHED</name></expr></argument>,
														<argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr></argument>,
														<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
														<argument><expr><name>NIL</name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>hashagg_partial_costs</name></expr></argument>,
														<argument><expr><name>dNumLocalGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
						<if_stmt><if>if <condition>(<expr><name>hashaggtablesize</name> <operator>&gt;=</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>&amp;&amp;</operator> <name>g_hybrid_hash_agg</name></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>AggPath</name> <modifier>*</modifier></type><name>aggpath</name> <init>= <expr><operator>(</operator><name>AggPath</name> <operator>*</operator><operator>)</operator><name>path</name></expr></init></decl>;</decl_stmt>

							<expr_stmt><expr><name><name>aggpath</name><operator>-&gt;</operator><name>hybrid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

						<comment type="block">/* step 2 */</comment>
						<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_redistribute_grouping_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<if_stmt><else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>try_distributed_aggregation</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<comment type="block">/*
				 * We just need an Agg over the cheapest-total input path,
				 * since input order won't matter.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<if_stmt><if>if<condition>(<expr><name>try_redistribute_grouping</name></expr>)</condition>
                <block>{<block_content>
					<decl_stmt><decl><type><name>AggClauseCosts</name></type> <name>hashagg_final_costs</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>agg_path</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hashagg_final_costs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AggClauseCosts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>get_agg_clause_costs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
								 <argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>hashagg_final_costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>get_agg_clause_costs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
								 <argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>hashagg_final_costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>agg_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
								 <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												 <argument><expr><name>grouped_rel</name></expr></argument>,
												 <argument><expr><name>path</name></expr></argument>,
												 <argument><expr><name>target</name></expr></argument>,
												 <argument><expr><name>AGG_HASHED</name></expr></argument>,
												 <argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>,
												 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
												 <argument><expr><name>havingQual</name></expr></argument>,
												 <argument><expr><operator>&amp;</operator><name>hashagg_final_costs</name></expr></argument>,
												 <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<if_stmt><if>if <condition>(<expr><name>hashaggtablesize</name> <operator>&gt;=</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>&amp;&amp;</operator> <name>g_hybrid_hash_agg</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>AggPath</name> <modifier>*</modifier></type><name>aggpath</name> <init>= <expr><operator>(</operator><name>AggPath</name> <operator>*</operator><operator>)</operator><name>agg_path</name></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name><name>aggpath</name><operator>-&gt;</operator><name>hybrid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<comment type="line">//agg_path-&gt;parallel_safe = true;</comment>

					<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>agg_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type> <name>parallel_aware</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type> <name>parallel_safe</name>  <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>agg_path</name>      <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>path</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>==</operator> <name>T_Gather</name> <operator>||</operator> <name><name>agg_costs</name><operator>-&gt;</operator><name>hasOnlyDistinct</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <name>olap_optimizer</name>
						<operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>parallel_safe</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>parallel_aware</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>agg_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
						 <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>,
										 <argument><expr><name>path</name></expr></argument>,
										 <argument><expr><name>target</name></expr></argument>,
										 <argument><expr><name>AGG_HASHED</name></expr></argument>,
										 <argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
										 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
										 <argument><expr><name>havingQual</name></expr></argument>,
										 <argument><expr><name>agg_costs</name></expr></argument>,
										 <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>agg_path</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>parallel_aware</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>agg_path</name><operator>-&gt;</operator><name>parallel_safe</name></name>  <operator>=</operator> <name>parallel_safe</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<if_stmt><if>if <condition>(<expr><name>hashaggtablesize</name> <operator>&gt;=</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>&amp;&amp;</operator> <name>g_hybrid_hash_agg</name></expr>)</condition>
                    <block>{<block_content>
						<decl_stmt><decl><type><name>AggPath</name> <modifier>*</modifier></type><name>aggpath</name> <init>= <expr><operator>(</operator><name>AggPath</name> <operator>*</operator><operator>)</operator><name>agg_path</name></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name><name>aggpath</name><operator>-&gt;</operator><name>hybrid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>agg_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
						 <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>grouped_rel</name></expr></argument>,
										 <argument><expr><name>path</name></expr></argument>,
										 <argument><expr><name>target</name></expr></argument>,
										 <argument><expr><name>AGG_HASHED</name></expr></argument>,
										 <argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
										 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
										 <argument><expr><name>havingQual</name></expr></argument>,
										 <argument><expr><name>agg_costs</name></expr></argument>,
										 <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
		 * Generate a HashAgg Path atop of the cheapest partial path. Once
		 * again, we'll only do this if it looks as though the hash table
		 * won't exceed work_mem.
         */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>       <name>redistribute_group</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>grouped_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>hashaggtablesize</name> <operator>=</operator> <call><name>estimate_hashagg_tablesize</name><argument_list>(<argument><expr><name>path</name></expr></argument>,
														  <argument><expr><name>agg_final_costs</name></expr></argument>,
														  <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>hashaggtablesize</name> <operator>&lt;</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>||</operator> <name>g_hybrid_hash_agg</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<if_stmt><if>if <condition>(<expr><name>hashaggtablesize</name> <operator>&lt;</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<decl_stmt><decl><type><name>double</name></type>		<name>total_groups</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>total_groups</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>total_groups</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<decl_stmt><decl><type><name>double</name></type>		<name>total_groups</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_gather_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												   <argument><expr><name>grouped_rel</name></expr></argument>,
												   <argument><expr><name>path</name></expr></argument>,
												   <argument><expr><name>partial_grouping_target</name></expr></argument>,
												   <argument><expr><name>NULL</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>total_groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
               <comment type="block">/*
				* If the grouping can't be fully pushed down, we'll push down the
				* first phase of the aggregate, and redistribute only the partial
				* results.
				*
				* If if can be pushed down, disable construction of complex
				* distributed paths.
                */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>can_push_down_grouping</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* redistribute local grouping results among datanodes */</comment>
						<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_redistribute_grouping_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>redistribute_group</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
					<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<if_stmt><else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>try_distributed_aggregation</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>redistribute_group</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>agg_path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
						 <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										 <argument><expr><name>grouped_rel</name></expr></argument>,
										 <argument><expr><name>path</name></expr></argument>,
										 <argument><expr><name>target</name></expr></argument>,
										 <argument><expr><name>AGG_HASHED</name></expr></argument>,
										 <argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>,
										 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
										 <argument><expr><name>havingQual</name></expr></argument>,
										 <argument><expr><name>agg_final_costs</name></expr></argument>,
										 <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>agg_path</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>agg_path</name><operator>-&gt;</operator><name>parallel_safe</name></name>  <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<if_stmt><if>if <condition>(<expr><name>hashaggtablesize</name> <operator>&gt;=</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>&amp;&amp;</operator> <name>g_hybrid_hash_agg</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>AggPath</name> <modifier>*</modifier></type><name>aggpath</name> <init>= <expr><operator>(</operator><name>AggPath</name> <operator>*</operator><operator>)</operator><name>agg_path</name></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name><name>aggpath</name><operator>-&gt;</operator><name>hybrid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>agg_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
                <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>agg_path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
						 <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										 <argument><expr><name>grouped_rel</name></expr></argument>,
										 <argument><expr><name>path</name></expr></argument>,
										 <argument><expr><name>target</name></expr></argument>,
										 <argument><expr><name>AGG_HASHED</name></expr></argument>,
										 <argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>,
										 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
										 <argument><expr><name>havingQual</name></expr></argument>,
										 <argument><expr><name>agg_final_costs</name></expr></argument>,
										 <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>has_cold_hot_table</name></expr>)</condition>
                <block>{<block_content>
					<expr_stmt><expr><name><name>agg_path</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>agg_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<if_stmt><if>if <condition>(<expr><name>hashaggtablesize</name> <operator>&gt;=</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>&amp;&amp;</operator> <name>g_hybrid_hash_agg</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>AggPath</name> <modifier>*</modifier></type><name>aggpath</name> <init>= <expr><operator>(</operator><name>AggPath</name> <operator>*</operator><operator>)</operator><name>agg_path</name></expr></init></decl>;</decl_stmt>
        
					<expr_stmt><expr><name><name>aggpath</name><operator>-&gt;</operator><name>hybrid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><name>agg_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

    <comment type="block">/*
 * add_partial_paths_to_grouping_rel
 *
 * Add partial paths to grouping relation.  These paths are not fully
 * aggregated; a FinalizeAggregate step is still required.
     */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_partial_paths_to_grouping_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                                  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
                                  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>,
                                  <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
                                  <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>partial_grouping_target</name></decl></parameter>,
                                  <parameter><decl><type><name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_partial_costs</name></decl></parameter>,
                                  <parameter><decl><type><name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_final_costs</name></decl></parameter>,
                                  <parameter><decl><type><name>grouping_sets_data</name> <modifier>*</modifier></type><name>gd</name></decl></parameter>,
                                  <parameter><decl><type><name>bool</name></type> <name>can_sort</name></decl></parameter>,
                                  <parameter><decl><type><name>bool</name></type> <name>can_hash</name></decl></parameter>,
                                  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>havingQual</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Query</name>      <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>cheapest_partial_path</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>input_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>hashaggtablesize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>      <name>dNumPartialGroups</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* Estimate number of partial groups. */</comment>
    <expr_stmt><expr><name>dNumPartialGroups</name> <operator>=</operator> <call><name>get_number_of_groups</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                             <argument><expr><name><name>cheapest_partial_path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
											 <argument><expr><name>gd</name></expr></argument>,
											 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>can_sort</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* This should have been checked previously */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
         * Use any available suitably-sorted path as input, and also consider
         * sorting the cheapest partial path.
     */</comment>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>input_rel-&gt;partial_pathlist</argument>)</argument_list></macro>
    <block>{<block_content>
            <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>is_sorted</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>is_sorted</name> <operator>=</operator> <call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
                                              <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>cheapest_partial_path</name> <operator>||</operator> <name>is_sorted</name></expr>)</condition>
        <block>{<block_content>
                <comment type="block">/* Sort the cheapest partial path, if it isn't already */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_sorted</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                     <argument><expr><name>grouped_rel</name></expr></argument>,
                                                     <argument><expr><name>path</name></expr></argument>,
                                                     <argument><expr><name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr></argument>,
                                                     <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>add_partial_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
                                     <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                     <argument><expr><name>grouped_rel</name></expr></argument>,
                                                     <argument><expr><name>path</name></expr></argument>,
                                                     <argument><expr><name>partial_grouping_target</name></expr></argument>,
                                                     <argument><expr><ternary><condition><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr> ?</condition><then> <expr><name>AGG_SORTED</name></expr> </then><else>: <expr><name>AGG_PLAIN</name></expr></else></ternary></expr></argument>,
                                                     <argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr></argument>,
                                                     <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
                                                     <argument><expr><name>NIL</name></expr></argument>,
                                                     <argument><expr><name>agg_partial_costs</name></expr></argument>,
                                                     <argument><expr><name>dNumPartialGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>add_partial_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
                                     <call><name>create_group_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                       <argument><expr><name>grouped_rel</name></expr></argument>,
                                                       <argument><expr><name>path</name></expr></argument>,
                                                       <argument><expr><name>partial_grouping_target</name></expr></argument>,
                                                       <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
                                                       <argument><expr><name>NIL</name></expr></argument>,
                                                       <argument><expr><name>dNumPartialGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
</block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>can_hash</name></expr>)</condition>
<block>{<block_content>
        <comment type="block">/* Checked above */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>hashaggtablesize</name> <operator>=</operator>
            <call><name>estimate_hashagg_tablesize</name><argument_list>(<argument><expr><name>cheapest_partial_path</name></expr></argument>,
                                       <argument><expr><name>agg_partial_costs</name></expr></argument>,
                                       <argument><expr><name>dNumPartialGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Tentatively produce a partial HashAgg Path, depending on if it
		 * looks as if the hash table will fit in work_mem.
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>hashaggtablesize</name> <operator>&lt;</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>||</operator> <name>g_hybrid_hash_agg</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<if_stmt><if>if <condition>(<expr><name>hashaggtablesize</name> <operator>&lt;</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
			<decl_stmt><decl><type><name>AggPath</name> <modifier>*</modifier></type><name>aggpath</name> <init>= <expr><operator>(</operator><name>AggPath</name> <operator>*</operator><operator>)</operator>
							 <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name>grouped_rel</name></expr></argument>,
											 <argument><expr><name>cheapest_partial_path</name></expr></argument>,
											 <argument><expr><name>partial_grouping_target</name></expr></argument>,
											 <argument><expr><name>AGG_HASHED</name></expr></argument>,
											 <argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr></argument>,
											 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
											 <argument><expr><name>NIL</name></expr></argument>,
											 <argument><expr><name>agg_partial_costs</name></expr></argument>,
											 <argument><expr><name>dNumPartialGroups</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>hashaggtablesize</name> <operator>&gt;=</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition>
        <block>{<block_content>
				<expr_stmt><expr><name><name>aggpath</name><operator>-&gt;</operator><name>hybrid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>add_partial_path</name><argument_list>(<argument><expr><name>grouped_rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator><name>aggpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * can_parallel_agg
 *
 * Determines whether or not parallel grouping and/or aggregation is possible.
 * Returns true when possible, false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>can_parallel_agg</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
                 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Query</name>      <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>grouped_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>)</condition>
   <block>{<block_content>
        <comment type="block">/* Not even parallel-safe. */</comment>
        <return>return <expr><name>false</name></expr>;</return>
   </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>input_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Nothing to use as input for partial aggregate. */</comment>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>&amp;&amp;</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We don't know how to do parallel aggregation unless we have either
         * some aggregates or a grouping clause.
         */</comment>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We don't know how to do grouping sets in parallel. */</comment>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>agg_costs</name><operator>-&gt;</operator><name>hasNonPartial</name></name> <operator>||</operator> <name><name>agg_costs</name><operator>-&gt;</operator><name>hasNonSerial</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Insufficient support for partial mode. */</comment>
        <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>

    <comment type="block">/* Everything looks good. */</comment>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>groupingsets_distribution_match</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Distribution</name> <modifier>*</modifier></type><name>distribution</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>distribution</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * With no explicit data distribution or replicated tables, we can simply
     * push down the whole grouping sets to the remote node, without any sort
     * of redistribution. So consider this to be a match.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>distribution</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator>
        <call><name>IsLocatorReplicated</name><argument_list>(<argument><expr><name><name>distribution</name><operator>-&gt;</operator><name>distributionType</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * adjust_path_distribution
 *        Adjust distribution of the path to match what's expected by ModifyTable.
 *
 * We use root-&gt;distribution to communicate distribution expected by a ModifyTable.
 * Currently it's set either in preprocess_targetlist() for simple target relations,
 * or in inheritance_planner() for targets that are inheritance trees.
 *
 * If root-&gt;distribution is NULL, we don't need to do anything and we can leave the
 * path distribution as it is. This happens when there is no ModifyTable node, for
 * example.
 *
 * If the root-&gt;distribution is set, we need to inspect it and redistribute the data
 * if needed (when it root-&gt;distribution does not match path-&gt;distribution).
 *
 * We also detect DML (e.g. correlated UPDATE/DELETE or updates of distribution key)
 * that we can't handle at this point.
 *
 * XXX We must not update root-&gt;distribution here, because we need to do this on all
 * paths considered by grouping_planner(), and there's no obvious guarantee all the
 * paths will share the same distribution. Postgres-XL 9.5 was allowed to do that,
 * because prior to the pathification (in PostgreSQL 9.6) grouping_planner() picked
 * before the distributions were adjusted.
 */</comment>
<function><type><specifier>static</specifier> <name>Path</name> <modifier>*</modifier></type>
<name>adjust_path_distribution</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* if there is no root distribution, no redistribution is needed */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>distribution</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>path</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* and also skip dummy paths */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IS_DUMMY_PATH</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>path</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Both the path and root have distribution. Let's see if they differ,
     * and do a redistribution if not.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>equal_distributions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IsLocatorReplicated</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>distributionType</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STATEMENT_TOO_COMPLEX</name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"can not update replicated table with result of volatile function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Source tuple will be consumed on the same node where it is
         * produced, so if it is known that some node does not yield tuples
         * we do not want to send subquery for execution on these nodes
         * at all. So copy the restriction to the external distribution.
         *
         * XXX Is that ever possible if external restriction is already
         * defined? If yes we probably should use intersection of the sets,
         * and if resulting set is empty create dummy plan and set it as
         * the result_plan. Need to think this over
         */</comment>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator>
                <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * If the planned statement is either UPDATE or DELETE, different
         * distributions here mean the ModifyTable node will be placed on
         * top of RemoteSubquery.
         *
         * UPDATE and DELETE versions of ModifyTable use TID of incoming
         * tuple to apply the changes, but the RemoteSubquery plan supplies
         * RemoteTuples, without such field. Therefore we can't execute
         * such plan and error-out.
         *
         * Most common example is when the UPDATE statement modifies the
         * distribution column, or when a complex UPDATE or DELETE statement
         * involves a join. It's difficult to determine the exact reason,
         * but we assume the first one (correlated UPDATE) is more likely.
         *
         * There are two ways of fixing the UPDATE ambiguity:
         *
         * 1. Modify the planner to never consider redistribution of the
         * target table. In this case the planner would find there's no way
         * to plan the query, and it would throw error somewhere else, and
         * we'd only be dealing with updates of distribution columns.
         *
         * 2. Modify executor to allow distribution column updates. However
         * there are a lot of issues behind the scene when implementing that
         * approach, and so it's unlikely to happen soon.
         *
         * DELETE statements may only fail because of complex joins.
         */</comment>

        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STATEMENT_TOO_COMPLEX</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not plan this distributed update"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"correlated UPDATE or updating distribution column currently not supported in Postgres-XL."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STATEMENT_TOO_COMPLEX</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not plan this distributed update"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"correlated UPDATE or updating distribution column currently not supported in TBase."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STATEMENT_TOO_COMPLEX</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not plan this distributed delete"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"correlated or complex DELETE is currently not supported in Postgres-XL."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STATEMENT_TOO_COMPLEX</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not plan this distributed delete"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"correlated or complex DELETE is currently not supported in TBase."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/*
          * If the planned statement is DML, and the target relation has
          * unshippable triggers, we will add distribution before ModifyTable
          * instead.
                 */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasUnshippableTriggers</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name> <operator>||</operator>
                  <name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator>
                  <name><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unshippable triggers with non-DML statement."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>path</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * We already know the distributions are not equal, but let's see if
         * the redistribution is actually necessary. We can skip it if we
         * already have Result path, and if the distribution is one of
         *
         * a) 'hash' restricted to a single node
		 * b) 'shard' restricted to a single node
		 * c) 'replicate' without volatile functions in the target list
         *
         * In those cases we don't need the RemoteSubplan.
         *
         * XXX Not sure what the (result_plan-&gt;lefttree == NULL) does.
         * See planner.c:2730 in 9.5.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>ResultPath</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <comment type="block">/* FIXME missing (result_plan-&gt;lefttree == NULL) condition */</comment>
		      <operator>(</operator><operator>(</operator><operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>==</operator> <literal type="char">'H'</literal> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>==</operator> <literal type="char">'S'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
		        <call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator>
             <operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>==</operator> <literal type="char">'R'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

            <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>path</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
 * can_distinct_agg_optimize
 *		Check if distinct app is workable.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>can_distinct_agg_optimize</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
                          <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>grouped_rel</name></decl></parameter>, <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>pathtarget</name></decl></parameter>,
                          <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>  <modifier>*</modifier></type><name>parse</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>meet_distint_agg_clause</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>parse</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr>;</expr_stmt>

    <comment type="block">/* It's no use for 2phase agg on datanode */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>grouped_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>||</operator> <name><name>input_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>==</operator> <name>NIL</name> <operator>||</operator>
	    <operator>!</operator><name><name>agg_costs</name><operator>-&gt;</operator><name>hasOnlyDistinct</name></name> <operator>||</operator> <name><name>agg_costs</name><operator>-&gt;</operator><name>hasNonSerial</name></name> <operator>||</operator> <name><name>agg_costs</name><operator>-&gt;</operator><name>hasOrder</name></name> <operator>||</operator>
	    <name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>||</operator>
	    <name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>||</operator> <name>has_cold_hot_table</name> <operator>||</operator> <operator>!</operator><name>olap_optimizer</name> <operator>||</operator> <operator>!</operator><name>enable_distinct_optimizer</name> <operator>||</operator>
	    <name>IS_PGXC_DATANODE</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>pathtarget-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>aggref</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggdistinct</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* only one distinct agg is allowed */</comment>
			<if_stmt><if>if<condition>(<expr><name>meet_distint_agg_clause</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>false</name></expr>;</return>	
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* currently we only support hash agg */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>grouping_is_hashable</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>meet_distint_agg_clause</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>meet_distint_agg_clause</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>can_push_down_grouping</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* only called when constructing grouping paths */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>has_cold_hot_table</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>path</name><operator>-&gt;</operator><name>distribution</name></name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>groupingsets_distribution_match</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>grouping_distribution_match</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>can_push_down_window</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>has_cold_hot_table</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>path</name><operator>-&gt;</operator><name>distribution</name></name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*  */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator> <name><name>path</name><operator>-&gt;</operator><name>distribution</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>Path</name> <modifier>*</modifier></type>
<name>adjust_modifytable_subpath</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>create_remotesubplan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>path</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
