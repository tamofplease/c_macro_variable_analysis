<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/optimizer/plan/subselect.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<comment type="block">/*-------------------------------------------------------------------------
 *
 * subselect.c
 *      Planning routines for subselects and parameters.
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *      src/backend/optimizer/plan/subselect.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/subselect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><name>bool</name></type>  <name>enable_pullup_subquery</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><struct>struct <name>convert_testexpr_context</name>
<block>{
    <decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subst_nodes</name></decl>;</decl_stmt>    <comment type="block">/* Nodes to substitute for Params */</comment>
}</block></struct></type> <name>convert_testexpr_context</name>;</typedef>

<typedef>typedef <type><struct>struct <name>process_sublinks_context</name>
<block>{
    <decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isTopQual</name></decl>;</decl_stmt>
}</block></struct></type> <name>process_sublinks_context</name>;</typedef>

<typedef>typedef <type><struct>struct <name>finalize_primnode_context</name>
<block>{
    <decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>paramids</name></decl>;</decl_stmt>        <comment type="block">/* Non-local PARAM_EXEC paramids found */</comment>
}</block></struct></type> <name>finalize_primnode_context</name>;</typedef>

<typedef>typedef <type><struct>struct <name>inline_cte_walker_context</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ctename</name></decl>;</decl_stmt>		<comment type="block">/* name and relative level of target CTE */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>levelsup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>refcount</name></decl>;</decl_stmt>		<comment type="block">/* number of remaining references */</comment>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>ctequery</name></decl>;</decl_stmt>		<comment type="block">/* query to substitute */</comment>
}</block></struct></type> <name>inline_cte_walker_context</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>build_subplan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name></decl></parameter>,
              <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>plan_params</name></decl></parameter>,
              <parameter><decl><type><name>SubLinkType</name></type> <name>subLinkType</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subLinkId</name></decl></parameter>,
              <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>testexpr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>adjust_testexpr</name></decl></parameter>,
              <parameter><decl><type><name>bool</name></type> <name>unknownEqFalse</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>generate_subquery_params</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
                         <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>paramIds</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>generate_subquery_vars</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
                       <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>convert_testexpr</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>testexpr</name></decl></parameter>,
                 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subst_nodes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>convert_testexpr_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                         <parameter><decl><type><name>convert_testexpr_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>subplan_is_hashable</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>testexpr_is_hashable</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>testexpr</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>convert_joinqual_to_antiqual</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>Query</name><modifier>*</modifier></type> <name>parse</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>convert_opexpr_to_boolexpr_for_antijoin</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>Query</name><modifier>*</modifier></type> <name>parse</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>var_is_nullable</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>hash_ok_operator</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_dml</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_dml_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_outer_selfref</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_outer_selfref_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>depth</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>inline_cte</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>inline_cte_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>inline_cte_walker_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>simplify_EXISTS_query</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>convert_EXISTS_to_ANY</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subselect</name></decl></parameter>,
                      <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>testexpr</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>paramIds</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>replace_correlation_vars_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>process_sublinks_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                         <parameter><decl><type><name>process_sublinks_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>finalize_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
              <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>gather_param</name></decl></parameter>,
              <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>valid_params</name></decl></parameter>,
              <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>scan_params</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>finalize_primnode</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>finalize_primnode_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>finalize_agg_primnode</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>finalize_primnode_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type> <name>convert_OR_EXIST_sublink_to_join</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
			  <parameter><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>jtlink</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type> <name>get_or_exist_subquery_targetlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
			  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>joinClause</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>next_attno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_simple_subquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>, <parameter><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>lowest_outer_join</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>deletion_ok</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
 * Select a PARAM_EXEC number to identify the given Var as a parameter for
 * the current subquery, or for a nestloop's inner scan.
 * If the Var already has a param in the current context, return that one.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>assign_param_for_var</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ppl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PlannerParamItem</name> <modifier>*</modifier></type><name>pitem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name></type>        <name>levelsup</name></decl>;</decl_stmt>

    <comment type="block">/* Find the query level the Var belongs to */</comment>
    <for>for <control>(<init><expr><name>levelsup</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr>;</init> <condition><expr><name>levelsup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>levelsup</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>root</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>parent_root</name></name></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* If there's already a matching PlannerParamItem there, just use it */</comment>
    <macro><name>foreach</name><argument_list>(<argument>ppl</argument>, <argument>root-&gt;plan_params</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>pitem</name> <operator>=</operator> <operator>(</operator><name>PlannerParamItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ppl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>pitem</name><operator>-&gt;</operator><name>item</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Var</name>           <modifier>*</modifier></type><name>pvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>pitem</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * This comparison must match _equalVar(), except for ignoring
             * varlevelsup.  Note that _equalVar() ignores the location.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>pvar</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator>
                <name><name>pvar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&amp;&amp;</operator>
                <name><name>pvar</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>vartype</name></name> <operator>&amp;&amp;</operator>
                <name><name>pvar</name><operator>-&gt;</operator><name>vartypmod</name></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>vartypmod</name></name> <operator>&amp;&amp;</operator>
                <name><name>pvar</name><operator>-&gt;</operator><name>varcollid</name></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>varcollid</name></name> <operator>&amp;&amp;</operator>
                <name><name>pvar</name><operator>-&gt;</operator><name>varnoold</name></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>varnoold</name></name> <operator>&amp;&amp;</operator>
                <name><name>pvar</name><operator>-&gt;</operator><name>varoattno</name></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>varoattno</name></name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/* Nope, so make a new one */</comment>
    <expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>pitem</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerParamItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pitem</name><operator>-&gt;</operator><name>item</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>nParamExec</name></name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name></expr></argument>, <argument><expr><name>pitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a Param node to replace the given Var,
 * which is expected to have varlevelsup &gt; 0 (ie, it is not local).
 */</comment>
<function><type><specifier>static</specifier> <name>Param</name> <modifier>*</modifier></type>
<name>replace_outer_var</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Param</name>       <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>query_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Find the Var in the appropriate plan_params, or add it if not present */</comment>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>assign_param_for_var</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_EXEC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtypmod</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>vartypmod</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramcollid</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varcollid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

    <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a Param node to replace the given Var, which will be supplied
 * from an upper NestLoop join node.
 *
 * This is effectively the same as replace_outer_var, except that we expect
 * the Var to be local to the current query level.
 */</comment>
<function><type><name>Param</name> <modifier>*</modifier></type>
<name>assign_nestloop_param_var</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Param</name>       <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>assign_param_for_var</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_EXEC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtypmod</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>vartypmod</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramcollid</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varcollid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

    <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Select a PARAM_EXEC number to identify the given PlaceHolderVar as a
 * parameter for the current subquery, or for a nestloop's inner scan.
 * If the PHV already has a param in the current context, return that one.
 *
 * This is just like assign_param_for_var, except for PlaceHolderVars.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>assign_param_for_placeholdervar</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ppl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PlannerParamItem</name> <modifier>*</modifier></type><name>pitem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name></type>        <name>levelsup</name></decl>;</decl_stmt>

    <comment type="block">/* Find the query level the PHV belongs to */</comment>
    <for>for <control>(<init><expr><name>levelsup</name> <operator>=</operator> <name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name></expr>;</init> <condition><expr><name>levelsup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>levelsup</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>root</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>parent_root</name></name></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* If there's already a matching PlannerParamItem there, just use it */</comment>
    <macro><name>foreach</name><argument_list>(<argument>ppl</argument>, <argument>root-&gt;plan_params</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>pitem</name> <operator>=</operator> <operator>(</operator><name>PlannerParamItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ppl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>pitem</name><operator>-&gt;</operator><name>item</name></name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>pphv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name><name>pitem</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* We assume comparing the PHIDs is sufficient */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>pphv</name><operator>-&gt;</operator><name>phid</name></name> <operator>==</operator> <name><name>phv</name><operator>-&gt;</operator><name>phid</name></name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/* Nope, so make a new one */</comment>
    <expr_stmt><expr><name>phv</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>phv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>phv</name></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>pitem</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerParamItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pitem</name><operator>-&gt;</operator><name>item</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>phv</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>nParamExec</name></name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name></expr></argument>, <argument><expr><name>pitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a Param node to replace the given PlaceHolderVar,
 * which is expected to have phlevelsup &gt; 0 (ie, it is not local).
 *
 * This is just like replace_outer_var, except for PlaceHolderVars.
 */</comment>
<function><type><specifier>static</specifier> <name>Param</name> <modifier>*</modifier></type>
<name>replace_outer_placeholdervar</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Param</name>       <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>query_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Find the PHV in the appropriate plan_params, or add it if not present */</comment>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>assign_param_for_placeholdervar</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>phv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_EXEC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtypmod</name></name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramcollid</name></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a Param node to replace the given PlaceHolderVar, which will be
 * supplied from an upper NestLoop join node.
 *
 * This is just like assign_nestloop_param_var, except for PlaceHolderVars.
 */</comment>
<function><type><name>Param</name> <modifier>*</modifier></type>
<name>assign_nestloop_param_placeholdervar</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Param</name>       <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>assign_param_for_placeholdervar</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>phv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_EXEC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtypmod</name></name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramcollid</name></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a Param node to replace the given Aggref
 * which is expected to have agglevelsup &gt; 0 (ie, it is not local).
 */</comment>
<function><type><specifier>static</specifier> <name>Param</name> <modifier>*</modifier></type>
<name>replace_outer_agg</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Param</name>       <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PlannerParamItem</name> <modifier>*</modifier></type><name>pitem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name></type>        <name>levelsup</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>agg</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>query_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Find the query level the Aggref belongs to */</comment>
    <for>for <control>(<init><expr><name>levelsup</name> <operator>=</operator> <name><name>agg</name><operator>-&gt;</operator><name>agglevelsup</name></name></expr>;</init> <condition><expr><name>levelsup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>levelsup</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>root</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>parent_root</name></name></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/*
     * It does not seem worthwhile to try to match duplicate outer aggs. Just
     * make a new slot every time.
     */</comment>
    <expr_stmt><expr><name>agg</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>agg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>agg</name></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>agglevelsup</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pitem</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerParamItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pitem</name><operator>-&gt;</operator><name>item</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>agg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>nParamExec</name></name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name></expr></argument>, <argument><expr><name>pitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_EXEC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <name><name>agg</name><operator>-&gt;</operator><name>aggtype</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramcollid</name></name> <operator>=</operator> <name><name>agg</name><operator>-&gt;</operator><name>aggcollid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>agg</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

    <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a Param node to replace the given GroupingFunc expression which is
 * expected to have agglevelsup &gt; 0 (ie, it is not local).
 */</comment>
<function><type><specifier>static</specifier> <name>Param</name> <modifier>*</modifier></type>
<name>replace_outer_grouping</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>GroupingFunc</name> <modifier>*</modifier></type><name>grp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Param</name>       <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PlannerParamItem</name> <modifier>*</modifier></type><name>pitem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name></type>        <name>levelsup</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>grp</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>grp</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>query_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Find the query level the GroupingFunc belongs to */</comment>
    <for>for <control>(<init><expr><name>levelsup</name> <operator>=</operator> <name><name>grp</name><operator>-&gt;</operator><name>agglevelsup</name></name></expr>;</init> <condition><expr><name>levelsup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>levelsup</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>root</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>parent_root</name></name></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/*
     * It does not seem worthwhile to try to match duplicate outer aggs. Just
     * make a new slot every time.
     */</comment>
    <expr_stmt><expr><name>grp</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>grp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>grp</name></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator> <name><name>grp</name><operator>-&gt;</operator><name>agglevelsup</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>grp</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pitem</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerParamItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pitem</name><operator>-&gt;</operator><name>item</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>grp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>nParamExec</name></name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name></expr></argument>, <argument><expr><name>pitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_EXEC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>grp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramcollid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>grp</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

    <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a new Param node that will not conflict with any other.
 *
 * This is used to create Params representing subplan outputs.
 * We don't need to build a PlannerParamItem for such a Param, but we do
 * need to record the PARAM_EXEC slot number as being allocated.
 */</comment>
<function><type><specifier>static</specifier> <name>Param</name> <modifier>*</modifier></type>
<name>generate_new_param</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>paramtype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>paramtypmod</name></decl></parameter>,
                   <parameter><decl><type><name>Oid</name></type> <name>paramcollation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Param</name>       <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_EXEC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>nParamExec</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <name>paramtype</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramtypmod</name></name> <operator>=</operator> <name>paramtypmod</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>paramcollid</name></name> <operator>=</operator> <name>paramcollation</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retval</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Assign a (nonnegative) PARAM_EXEC ID for a special parameter (one that
 * is not actually used to carry a value at runtime).  Such parameters are
 * used for special runtime signaling purposes, such as connecting a
 * recursive union node to its worktable scan node or forcing plan
 * re-evaluation within the EvalPlanQual mechanism.  No actual Param node
 * exists with this ID, however.
 */</comment>
<function><type><name>int</name></type>
<name>SS_assign_special_param</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>nParamExec</name></name><operator>++</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the datatype/typmod/collation of the first column of the plan's output.
 *
 * This information is stored for ARRAY_SUBLINK execution and for
 * exprType()/exprTypmod()/exprCollation(), which have no way to get at the
 * plan associated with a SubPlan node.  We really only need the info for
 * EXPR_SUBLINK and ARRAY_SUBLINK subplans, but for consistency we save it
 * always.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_first_col_type</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>coltype</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>coltypmod</name></decl></parameter>,
                   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>colcollation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* In cases such as EXISTS, tlist might be empty; arbitrarily use VOID */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tent</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tent</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>coltype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>coltypmod</name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>colcollation</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>coltype</name> <operator>=</operator> <name>VOIDOID</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>coltypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>colcollation</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
 * Check if there is a range table entry of type func expr whose arguments
 * are correlated
 */</comment>
<function><type><name>bool</name></type>
<name>has_correlation_in_funcexpr_rte</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * check if correlation occurs in a func expr in the from clause of the
	 * subselect
	 */</comment>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc_rte</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc_rte</argument>, <argument>rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc_rte</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name> <operator>&amp;&amp;</operator> <call><name>contain_vars_upper_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * is_simple_subquery
 *	  Check a subquery in the range table to see if it's simple enough
 *	  to pull up into the parent query.
 *
 * rte is the RTE_SUBQUERY RangeTblEntry that contained the subquery.
 * (Note subquery is not necessarily equal to rte-&gt;subquery; it could be a
 * processed copy of that.)
 * lowest_outer_join is the lowest outer join above the subquery, or NULL.
 * deletion_ok is TRUE if it'd be okay to delete the subquery entirely.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_simple_subquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>,
				   <parameter><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>lowest_outer_join</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>deletion_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Let's just make sure it's a valid subselect ...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subquery is bogus"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Can't currently pull up a query with setops (unless it's simple UNION
	 * ALL, which is handled by a different code path). Maybe after querytree
	 * redesign...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Can't pull up a subquery involving grouping, aggregation, SRFs,
	 * sorting, limiting, or WITH.  (XXX WITH could possibly be allowed later)
	 *
	 * We also don't pull up a subquery that has explicit FOR UPDATE/SHARE
	 * clauses, because pullup would cause the locking to occur semantically
	 * higher than it should.  Implicit FOR UPDATE/SHARE is okay because in
	 * that case the locking was originally declared in the upper query
	 * anyway.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>hasForUpdate</name></name> <operator>||</operator>
		<name><name>subquery</name><operator>-&gt;</operator><name>cteList</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't pull up a subquery with an empty jointree, unless it has no quals
	 * and deletion_ok is TRUE and we're not underneath an outer join.
	 *
	 * query_planner() will correctly generate a Result plan for a jointree
	 * that's totally empty, but we can't cope with an empty FromExpr
	 * appearing lower down in a jointree: we identify join rels via baserelid
	 * sets, so we couldn't distinguish a join containing such a FromExpr from
	 * one without it.  We can only handle such cases if the place where the
	 * subquery is linked is a FromExpr or inner JOIN that would still be
	 * nonempty after removal of the subquery, so that it's still identifiable
	 * via its contained baserelids.  Safe contexts are signaled by
	 * deletion_ok.
	 *
	 * But even in a safe context, we must keep the subquery if it has any
	 * quals, because it's unclear where to put them in the upper query.
	 *
	 * Also, we must forbid pullup if such a subquery is underneath an outer
	 * join, because then we might need to wrap its output columns with
	 * PlaceHolderVars, and the PHVs would then have empty relid sets meaning
	 * we couldn't tell where to evaluate them.  (This test is separate from
	 * the deletion_ok flag for possible future expansion: deletion_ok tells
	 * whether the immediate parent site in the jointree could cope, not
	 * whether we'd have PHV issues.  It's possible this restriction could be
	 * fixed by letting the PHVs use the relids of the parent jointree item,
	 * but that complication is for another day.)
	 *
	 * Note that deletion of a subquery is also dependent on the check below
	 * that its targetlist contains no set-returning functions.  Deletion from
	 * a FROM list or inner JOIN is okay only if the subquery must return
	 * exactly one row.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>subquery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
		 <operator>!</operator><name>deletion_ok</name> <operator>||</operator>
		 <name>lowest_outer_join</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't pull up a subquery that has any volatile functions in its
	 * targetlist.  Otherwise we might introduce multiple evaluations of these
	 * functions, if they get copied to multiple places in the upper query,
	 * leading to surprising results.  (Note: the PlaceHolderVar mechanism
	 * doesn't quite guarantee single evaluation; else we could pull up anyway
	 * and just wrap such items in PlaceHolderVars ...)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Convert a SubLink (as created by the parser) into a SubPlan.
 *
 * We are given the SubLink's contained query, type, ID, and testexpr.  We are
 * also told if this expression appears at top level of a WHERE/HAVING qual.
 *
 * Note: we assume that the testexpr has been AND/OR flattened (actually,
 * it's been through eval_const_expressions), but not converted to
 * implicit-AND form; and any SubLinks in it should already have been
 * converted to SubPlans.  The subquery is as yet untouched, however.
 *
 * The result is whatever we need to substitute in place of the SubLink node
 * in the executable expression.  If we're going to do the subplan as a
 * regular subplan, this will be the constructed SubPlan node.  If we're going
 * to do the subplan as an InitPlan, the SubPlan node instead goes into
 * root-&gt;init_plans, and what we return here is an expression tree
 * representing the InitPlan's result: usually just a Param node representing
 * a single scalar result, but possibly a row comparison tree containing
 * multiple Param nodes, or for a MULTIEXPR subquery a simple NULL constant
 * (since the real output Params are elsewhere in the tree, and the MULTIEXPR
 * subquery itself is in a resjunk tlist entry whose value is uninteresting).
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>make_subplan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>orig_subquery</name></decl></parameter>,
             <parameter><decl><type><name>SubLinkType</name></type> <name>subLinkType</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subLinkId</name></decl></parameter>,
             <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>testexpr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopQual</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>subquery</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>simple_exists</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>tuple_fraction</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>final_rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>best_path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>plan_params</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Copy the source Query node.  This is a quick and dirty kluge to resolve
     * the fact that the parser can generate trees with multiple links to the
     * same sub-Query node, but the planner wants to scribble on the Query.
     * Try to clean this up when we do querytree redesign...
     */</comment>
    <expr_stmt><expr><name>subquery</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>orig_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If it's an EXISTS subplan, we might be able to simplify it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>EXISTS_SUBLINK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>simple_exists</name> <operator>=</operator> <call><name>simplify_EXISTS_query</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * For an EXISTS subplan, tell lower-level planner to expect that only the
     * first tuple will be retrieved.  For ALL and ANY subplans, we will be
     * able to stop evaluating if the test condition fails or matches, so very
     * often not all the tuples will be retrieved; for lack of a better idea,
     * specify 50% retrieval.  For EXPR, MULTIEXPR, and ROWCOMPARE subplans,
     * use default behavior (we're only expecting one row out, anyway).
     *
     * NOTE: if you change these numbers, also change cost_subplan() in
     * path/costsize.c.
     *
     * XXX If an ANY subplan is uncorrelated, build_subplan may decide to hash
     * its output.  In that case it would've been better to specify full
     * retrieval.  At present, however, we can only check hashability after
     * we've made the subplan :-(.  (Determining whether it'll fit in work_mem
     * is the really hard part.)  Therefore, we don't want to be too
     * optimistic about the percentage of tuples retrieved, for fear of
     * selecting a plan that's bad for the materialization case.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>EXISTS_SUBLINK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* just like a LIMIT 1 */</comment>
    <if type="elseif">else if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>ALL_SUBLINK</name> <operator>||</operator>
             <name>subLinkType</name> <operator>==</operator> <name>ANY_SUBLINK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <literal type="number">0.5</literal></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* 50% */</comment>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>tuple_fraction</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>    <comment type="block">/* default behavior */</comment>

    <comment type="block">/* plan_params should not be in use in current query level */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Generate Paths for the subquery */</comment>
    <expr_stmt><expr><name>subroot</name> <operator>=</operator> <call><name>subquery_planner</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>,
                               <argument><expr><name>root</name></expr></argument>,
                               <argument><expr><name>false</name></expr></argument>, <argument><expr><name>tuple_fraction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Isolate the params needed by this specific subplan */</comment>
    <expr_stmt><expr><name>plan_params</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Select best Path and turn it into a Plan.  At least for now, there
     * seems no reason to postpone doing that.
     */</comment>
    <expr_stmt><expr><name>final_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>best_path</name> <operator>=</operator> <call><name>get_cheapest_fractional_path</name><argument_list>(<argument><expr><name>final_rel</name></expr></argument>, <argument><expr><name>tuple_fraction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>subroot</name><operator>-&gt;</operator><name>distribution</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>distribution</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>distribution</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_plan</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <comment type="block">/* Add a custom remote subplan if a re-distribution is needed. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>subroot</name><operator>-&gt;</operator><name>distribution</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>remote_subplan_depth</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_remotesubplan</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>,
                                           <argument><expr><name>plan</name></expr></argument>,
                                           <argument><expr><name>NULL</name></expr></argument>,
                                           <argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>,
                                           <argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>query_pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>remote_subplan_depth</name><operator>--</operator></expr>;</expr_stmt>
        <comment type="block">/*
         * SS_finalize_plan has already been run on the subplan,
         * so we have to copy parameter info to wrapper plan node.
         */</comment>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>extParam</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name><operator>-&gt;</operator><name>extParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>allParam</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name><operator>-&gt;</operator><name>allParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* And convert to SubPlan or InitPlan format. */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>build_subplan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>plan_params</name></expr></argument>,
                           <argument><expr><name>subLinkType</name></expr></argument>, <argument><expr><name>subLinkId</name></expr></argument>,
                           <argument><expr><name>testexpr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>isTopQual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
    <comment type="block">/* This is not necessary for a PGXC Coordinator, we just need one plan */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If it's a correlated EXISTS with an unimportant targetlist, we might be
     * able to transform it to the equivalent of an IN and then implement it
     * by hashing.  We don't have enough information yet to tell which way is
     * likely to be better (it depends on the expected number of executions of
     * the EXISTS qual, and we are much too early in planning the outer query
     * to be able to guess that).  So we generate both plans, if possible, and
     * leave it to the executor to decide which to use.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>simple_exists</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>newtestexpr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>paramIds</name></decl>;</decl_stmt>

        <comment type="block">/* Make a second copy of the original subquery */</comment>
        <expr_stmt><expr><name>subquery</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>orig_subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* and re-simplify */</comment>
        <expr_stmt><expr><name>simple_exists</name> <operator>=</operator> <call><name>simplify_EXISTS_query</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>simple_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* See if it can be converted to an ANY query */</comment>
        <expr_stmt><expr><name>subquery</name> <operator>=</operator> <call><name>convert_EXISTS_to_ANY</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>newtestexpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>paramIds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>subquery</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Generate Paths for the ANY subquery; we'll need all rows */</comment>
            <expr_stmt><expr><name>subroot</name> <operator>=</operator> <call><name>subquery_planner</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>,
                                       <argument><expr><name>root</name></expr></argument>,
                                       <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Isolate the params needed by this specific subplan */</comment>
            <expr_stmt><expr><name>plan_params</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

            <comment type="block">/* Select best Path and turn it into a Plan */</comment>
            <expr_stmt><expr><name>final_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>best_path</name> <operator>=</operator> <name><name>final_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_plan</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Now we can check if it'll fit in work_mem */</comment>
            <comment type="block">/* XXX can we check this at the Path stage? */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>subplan_is_hashable</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>hashplan</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>AlternativeSubPlan</name> <modifier>*</modifier></type><name>asplan</name></decl>;</decl_stmt>

                <comment type="block">/* OK, convert to SubPlan format. */</comment>
                <expr_stmt><expr><name>hashplan</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>SubPlan</name></expr></argument>,
                                    <argument><expr><call><name>build_subplan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>,
                                                  <argument><expr><name>plan_params</name></expr></argument>,
                                                  <argument><expr><name>ANY_SUBLINK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                                  <argument><expr><name>newtestexpr</name></expr></argument>,
                                                  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Check we got what we expected */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hashplan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hashplan</name><operator>-&gt;</operator><name>useHashTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* build_subplan won't have filled in paramIds */</comment>
                <expr_stmt><expr><name><name>hashplan</name><operator>-&gt;</operator><name>paramIds</name></name> <operator>=</operator> <name>paramIds</name></expr>;</expr_stmt>

                <comment type="block">/* Leave it to the executor to decide which plan to use */</comment>
                <expr_stmt><expr><name>asplan</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlternativeSubPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>asplan</name><operator>-&gt;</operator><name>subplans</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>hashplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>asplan</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build a SubPlan node given the raw inputs --- subroutine for make_subplan
 *
 * Returns either the SubPlan, or a replacement expression if we decide to
 * make it an InitPlan, as explained in the comments for make_subplan.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>build_subplan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name></decl></parameter>,
              <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>plan_params</name></decl></parameter>,
              <parameter><decl><type><name>SubLinkType</name></type> <name>subLinkType</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subLinkId</name></decl></parameter>,
              <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>testexpr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>adjust_testexpr</name></decl></parameter>,
              <parameter><decl><type><name>bool</name></type> <name>unknownEqFalse</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>splan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isInitPlan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Initialize the SubPlan node.  Note plan_id, plan_name, and cost fields
     * are set further down.
     */</comment>
    <expr_stmt><expr><name>splan</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>=</operator> <name>subLinkType</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>testexpr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>paramIds</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>get_first_col_type</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>splan</name><operator>-&gt;</operator><name>firstColType</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>splan</name><operator>-&gt;</operator><name>firstColTypmod</name></name></expr></argument>,
                       <argument><expr><operator>&amp;</operator><name><name>splan</name><operator>-&gt;</operator><name>firstColCollation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>useHashTable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>unknownEqFalse</name></name> <operator>=</operator> <name>unknownEqFalse</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>setParam</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Make parParam and args lists of param IDs and expressions that current
     * query level will pass to this child plan.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plan_params</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PlannerParamItem</name> <modifier>*</modifier></type><name>pitem</name> <init>= <expr><operator>(</operator><name>PlannerParamItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>arg</name> <init>= <expr><name><name>pitem</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * The Var, PlaceHolderVar, or Aggref has already been adjusted to
         * have the correct varlevelsup, phlevelsup, or agglevelsup.
         *
         * If it's a PlaceHolderVar or Aggref, its arguments might contain
         * SubLinks, which have not yet been processed (see the comments for
         * SS_replace_correlation_vars).  Do that now.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>SS_process_sublinks</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name></expr></argument>, <argument><expr><name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Un-correlated or undirect correlated plans of EXISTS, EXPR, ARRAY,
     * ROWCOMPARE, or MULTIEXPR types can be used as initPlans.  For EXISTS,
     * EXPR, or ARRAY, we return a Param referring to the result of evaluating
     * the initPlan.  For ROWCOMPARE, we must modify the testexpr tree to
     * contain PARAM_EXEC Params instead of the PARAM_SUBLINK Params emitted
     * by the parser, and then return that tree.  For MULTIEXPR, we return a
     * null constant: the resjunk targetlist item containing the SubLink does
     * not need to return anything useful, since the referencing Params are
     * elsewhere.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>subLinkType</name> <operator>==</operator> <name>EXISTS_SUBLINK</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Param</name>       <modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>testexpr</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>prm</name> <operator>=</operator> <call><name>generate_new_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>setParam</name></name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>isInitPlan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>prm</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>subLinkType</name> <operator>==</operator> <name>EXPR_SUBLINK</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Param</name>       <modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>te</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>testexpr</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>prm</name> <operator>=</operator> <call><name>generate_new_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                 <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>setParam</name></name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>isInitPlan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>prm</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>subLinkType</name> <operator>==</operator> <name>ARRAY_SUBLINK</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>arraytype</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Param</name>       <modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>te</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>testexpr</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>arraytype</name> <operator>=</operator> <call><name>get_promoted_array_type</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>arraytype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find array type for datatype %s"</literal></expr></argument>,
                 <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>prm</name> <operator>=</operator> <call><name>generate_new_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                 <argument><expr><name>arraytype</name></expr></argument>,
                                 <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>setParam</name></name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>isInitPlan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>prm</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>subLinkType</name> <operator>==</operator> <name>ROWCOMPARE_SUBLINK</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Adjust the Params */</comment>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>params</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>testexpr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>generate_subquery_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                          <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name><name>splan</name><operator>-&gt;</operator><name>paramIds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>convert_testexpr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                  <argument><expr><name>testexpr</name></expr></argument>,
                                  <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>setParam</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>paramIds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>isInitPlan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <comment type="block">/*
         * The executable expression is returned to become part of the outer
         * plan's expression tree; it is not kept in the initplan node.
         */</comment>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>MULTIEXPR_SUBLINK</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Whether it's an initplan or not, it needs to set a PARAM_EXEC Param
         * for each output column.
         */</comment>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>params</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>testexpr</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>generate_subquery_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                          <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name><name>splan</name><operator>-&gt;</operator><name>setParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Save the list of replacement Params in the n'th cell of
         * root-&gt;multiexpr_params; setrefs.c will use it to replace
         * PARAM_MULTIEXPR Params.
         */</comment>
        <while>while <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>multiexpr_params</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>subLinkId</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>multiexpr_params</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>multiexpr_params</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_nth_cell</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>multiexpr_params</name></name></expr></argument>, <argument><expr><name>subLinkId</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>params</name></expr>;</expr_stmt>

        <comment type="block">/* It can be an initplan if there are no parParams. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>isInitPlan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name>RECORDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>isInitPlan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>splan</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * Adjust the Params in the testexpr, unless caller said it's not
         * needed.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>testexpr</name> <operator>&amp;&amp;</operator> <name>adjust_testexpr</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>params</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>generate_subquery_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                              <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
                                              <argument><expr><operator>&amp;</operator><name><name>splan</name><operator>-&gt;</operator><name>paramIds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>testexpr</name></name> <operator>=</operator> <call><name>convert_testexpr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                               <argument><expr><name>testexpr</name></expr></argument>,
                                               <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>testexpr</name></name> <operator>=</operator> <name>testexpr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*
         * We can't convert subplans of ALL_SUBLINK or ANY_SUBLINK types to
         * initPlans, even when they are uncorrelated or undirect correlated,
         * because we need to scan the output of the subplan for each outer
         * tuple.  But if it's a not-direct-correlated IN (= ANY) test, we
         * might be able to use a hashtable to avoid comparing all the tuples.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>subLinkType</name> <operator>==</operator> <name>ANY_SUBLINK</name> <operator>&amp;&amp;</operator>
            <name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
            <call><name>subplan_is_hashable</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>testexpr_is_hashable</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>useHashTable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>

        <comment type="block">/*
         * Otherwise, we have the option to tack a Material node onto the top
         * of the subplan, to reduce the cost of reading it repeatedly.  This
         * is pointless for a direct-correlated subplan, since we'd have to
         * recompute its results each time anyway.  For uncorrelated/undirect
         * correlated subplans, we add Material unless the subplan's top plan
         * node would materialize its output anyway.  Also, if enable_material
         * is false, then the user does not want us to materialize anything
         * unnecessarily, so we don't.
         */</comment>
        <if type="elseif">else if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>enable_material</name> <operator>&amp;&amp;</operator>
                 <operator>!</operator><call><name>ExecMaterializesOutput</name><argument_list>(<argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>materialize_finished_plan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>splan</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>isInitPlan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Add the subplan and its PlannerInfo to the global lists.
     */</comment>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subroots</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subroots</name></name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>plan_id</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>isInitPlan</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>init_plans</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>init_plans</name></name></expr></argument>, <argument><expr><name>splan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * A parameterless subplan (not initplan) should be prepared to handle
     * REWIND efficiently.  If it has direct parameters then there's no point
     * since it'll be reset on each scan anyway; and if it's an initplan then
     * there's no point since it won't get re-run without parameter changes
     * anyway.  The input of a hashed subplan doesn't need REWIND either.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isInitPlan</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>splan</name><operator>-&gt;</operator><name>useHashTable</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>rewindPlanIDs</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>rewindPlanIDs</name></name></expr></argument>,
                                                   <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Label the subplan for EXPLAIN purposes */</comment>
    <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>plan_name</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">32</literal> <operator>+</operator> <literal type="number">12</literal> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>setParam</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan_name</name></name></expr></argument>, <argument><expr><literal type="string">"%s %d"</literal></expr></argument>,
            <argument><expr><ternary><condition><expr><name>isInitPlan</name></expr> ?</condition><then> <expr><literal type="string">"InitPlan"</literal></expr> </then><else>: <expr><literal type="string">"SubPlan"</literal></expr></else></ternary></expr></argument>,
            <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>setParam</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name><name>splan</name><operator>-&gt;</operator><name>plan_name</name></name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">" (returns "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>splan-&gt;setParam</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"$%d%s"</literal></expr></argument>,
                           <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><ternary><condition><expr><call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">","</literal></expr> </then><else>: <expr><literal type="string">")"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Lastly, fill in the cost estimates for use later */</comment>
    <expr_stmt><expr><call><name>cost_subplan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>splan</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generate_subquery_params: build a list of Params representing the output
 * columns of a sublink's sub-select, given the sub-select's targetlist.
 *
 * We also return an integer list of the paramids of the Params.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>generate_subquery_params</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>paramIds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>ids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>ids</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tent</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Param</name>       <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>tent</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>generate_new_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                   <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ids</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>ids</name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><operator>*</operator><name>paramIds</name> <operator>=</operator> <name>ids</name></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generate_subquery_vars: build a list of Vars representing the output
 * columns of a sublink's sub-select, given the sub-select's targetlist.
 * The Vars have the specified varno (RTE index).
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>generate_subquery_vars</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tent</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Var</name>           <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>tent</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVarFromTargetEntry</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name>tent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * convert_testexpr: convert the testexpr given by the parser into
 * actually executable form.  This entails replacing PARAM_SUBLINK Params
 * with Params or Vars representing the results of the sub-select.  The
 * nodes to be substituted are passed in as the List result from
 * generate_subquery_params or generate_subquery_vars.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>convert_testexpr</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>testexpr</name></decl></parameter>,
                 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subst_nodes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>convert_testexpr_context</name></type> <name>context</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>subst_nodes</name></name> <operator>=</operator> <name>subst_nodes</name></expr>;</expr_stmt>
    <return>return <expr><call><name>convert_testexpr_mutator</name><argument_list>(<argument><expr><name>testexpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>convert_testexpr_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                         <parameter><decl><type><name>convert_testexpr_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Param</name>       <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_SUBLINK</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
                <name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>subst_nodes</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected PARAM_SUBLINK ID: %d"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * We copy the list item to avoid having doubly-linked
             * substructure in the modified parse tree.  This is probably
             * unnecessary when it's a Param, but be safe.
             */</comment>
            <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>subst_nodes</name></name></expr></argument>,
                                                <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If we come across a nested SubLink, it is neither necessary nor
         * correct to recurse into it: any PARAM_SUBLINKs we might find inside
         * belong to the inner SubLink not the outer. So just return it as-is.
         *
         * This reasoning depends on the assumption that nothing will pull
         * subexpressions into or out of the testexpr field of a SubLink, at
         * least not without replacing PARAM_SUBLINKs first.  If we did want
         * to do that we'd need to rethink the parser-output representation
         * altogether, since currently PARAM_SUBLINKs are only unique per
         * SubLink not globally across the query.  The whole point of
         * replacing them with Vars or PARAM_EXEC nodes is to make them
         * globally unique before they escape from the SubLink's testexpr.
         *
         * Note: this can't happen when called during SS_process_sublinks,
         * because that recursively processes inner SubLinks first.  It can
         * happen when called from convert_ANY_sublink_to_join, though.
         */</comment>
        <return>return <expr><name>node</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
                                   <argument><expr><name>convert_testexpr_mutator</name></expr></argument>,
                                   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * subplan_is_hashable: can we implement an ANY subplan by hashing?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>subplan_is_hashable</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type>        <name>subquery_size</name></decl>;</decl_stmt>

    <comment type="block">/*
     * The estimated size of the subquery result must fit in work_mem. (Note:
     * we use heap tuple overhead here even though the tuples will actually be
     * stored as MinimalTuples; this provides some fudge factor for hashtable
     * overhead.)
     */</comment>
    <expr_stmt><expr><name>subquery_size</name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>*</operator>
        <operator>(</operator><call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_width</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofHeapTupleHeader</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>subquery_size</name> <operator>&gt;</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * testexpr_is_hashable: is an ANY SubLink's test expression hashable?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>testexpr_is_hashable</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>testexpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * The testexpr must be a single OpExpr, or an AND-clause containing only
     * OpExprs.
     *
     * The combining operators must be hashable and strict. The need for
     * hashability is obvious, since we want to use hashing. Without
     * strictness, behavior in the presence of nulls is too unpredictable.  We
     * actually must assume even more than plain strictness: they can't yield
     * NULL for non-null inputs, either (see nodeSubplan.c).  However, hash
     * indexes and hash joins assume that too.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>testexpr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>testexpr</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>hash_ok_operator</name><argument_list>(<argument><expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>testexpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>and_clause</name><argument_list>(<argument><expr><name>testexpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((BoolExpr *) testexpr)-&gt;args</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>andarg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>andarg</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hash_ok_operator</name><argument_list>(<argument><expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>andarg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
 * Rewrite qual to complete nullability check for NOT IN/ANY sublink pullup
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name><modifier>*</modifier></type>
<name>convert_joinqual_to_antiqual</name><parameter_list>(<parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>Query</name><modifier>*</modifier></type> <name>parse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>antiqual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
			<expr_stmt><expr><name>antiqual</name> <operator>=</operator> <call><name>convert_opexpr_to_boolexpr_for_antijoin</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/* Not IN, should be and clause.*/</comment>
            <if_stmt><if>if <condition>(<expr><call><name>and_clause</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
            	<decl_stmt><decl><type><name>BoolExpr</name><modifier>*</modifier></type> <name>boolexpr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name><operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
            	<decl_stmt><decl><type><name>List</name><modifier>*</modifier></type> <name>andarglist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
            	<decl_stmt><decl><type><name>ListCell</name><modifier>*</modifier></type> <name>l</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            	<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>boolexpr-&gt;args</argument>)</argument_list></macro>
            	<block>{<block_content>
            		<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>andarg</name> <init>= <expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            		<decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>expr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            		<comment type="block">/* The listcell type of args should be OpExpr. */</comment>
            		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>convert_opexpr_to_boolexpr_for_antijoin</name><argument_list>(<argument><expr><name>andarg</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            		<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

            		<expr_stmt><expr><name>andarglist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>andarglist</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            	</block_content>}</block>

            	<expr_stmt><expr><name>antiqual</name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>andarglist</name></expr></argument>, <argument><expr><name><name>boolexpr</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
            	<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
        </block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
		<case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
		<default>default:</default>
			<expr_stmt><expr><name>antiqual</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>antiqual</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>convert_opexpr_to_boolexpr_for_antijoin</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	<modifier>*</modifier></type><name>boolexpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	<modifier>*</modifier></type><name>antiqual</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OpExpr</name>	<modifier>*</modifier></type><name>opexpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	<modifier>*</modifier></type><name>larg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	<modifier>*</modifier></type><name>rarg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>opexpr</name> <operator>=</operator> <operator>(</operator><name>OpExpr</name><operator>*</operator><operator>)</operator><name>node</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>antiqual</name> <operator>=</operator> <operator>(</operator><name>List</name><operator>*</operator><operator>)</operator><call><name>list_make1</name><argument_list>(<argument><expr><name>opexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>larg</name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>larg</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>larg</name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>RelabelType</name><operator>*</operator><operator>)</operator><name>larg</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>var_is_nullable</name><argument_list>(<argument><expr><name>larg</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>antiqual</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>antiqual</name></expr></argument>, <argument><expr><call><name>makeNullTest</name><argument_list>(<argument><expr><name>IS_NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name><operator>*</operator><operator>)</operator><call><name>copyObject</name><argument_list>(<argument><expr><name>larg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>rarg</name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><call><name>lsecond</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rarg</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rarg</name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>RelabelType</name><operator>*</operator><operator>)</operator><name>rarg</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>var_is_nullable</name><argument_list>(<argument><expr><name>rarg</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>antiqual</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>antiqual</name></expr></argument>, <argument><expr><call><name>makeNullTest</name><argument_list>(<argument><expr><name>IS_NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name><operator>*</operator><operator>)</operator><call><name>copyObject</name><argument_list>(<argument><expr><name>rarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>antiqual</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>boolexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><call><name>makeBoolExprTreeNode</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><name>antiqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>boolexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>opexpr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>boolexpr</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Check expression is hashable + strict
 *
 * We could use op_hashjoinable() and op_strict(), but do it like this to
 * avoid a redundant cache lookup.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>hash_ok_operator</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>opid</name> <init>= <expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* quick out if not a binary operator */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>opid</name> <operator>==</operator> <name>ARRAY_EQ_OP</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* array_eq is strict, but must check input type to ensure hashable */</comment>
        <comment type="block">/* XXX record_eq will need same treatment when it becomes hashable */</comment>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>leftarg</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <return>return <expr><call><name>op_hashjoinable</name><argument_list>(<argument><expr><name>opid</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>leftarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* else must look up the operator properties */</comment>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>, <argument><expr><name>opid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>optup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>optup</name><operator>-&gt;</operator><name>oprcanhash</name></name> <operator>||</operator> <operator>!</operator><call><name>func_strict</name><argument_list>(<argument><expr><name><name>optup</name><operator>-&gt;</operator><name>oprcode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
 * Check if total cost of inlining to multiple subquery is cheaper.
 *
 * There are three alternatives to optimize CTE with multiple references.
 * XXX Keep the CTE as an optimization fence, using materialized CTE scan could
 * 	   be cost saving. But in TBase distributed system, this will lead to more
 * 	   executor nodes perfored in CN, which could be much slower.
 * XXX Inline the CTE to multiple subqueries. This could leverage more join
 *     reordering and predicate pushdown opetimization automatically.
 * XXX Inline the CTE to some of the reference place(s). This need an overall
 *     cost based optimizer including CTE inline and sublink pullup phase,
 *     postgres optimizer does not support this yet.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_cte_worth_inline</name><parameter_list>(<parameter><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type> 	<name>inline_total_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type> 	<name>cte_total_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type> 	<name>material_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> 	<name>material_bytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>	<name>work_mem_bytes</name> <init>= <expr><name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Force pullup multi-reference CTE when enable_pullup_subquery enabled */</comment>
	<if_stmt><if>if <condition>(<expr><name>enable_pullup_subquery</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Num bytes to be materialized by CTE */</comment>
	<expr_stmt><expr><name>material_bytes</name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>*</operator> <name><name>plan</name><operator>-&gt;</operator><name>plan_width</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Whether spilling or not, charge 2x cpu_operator_cost per tuple to
	 * reflect bookkeeping overhead.  (This rate must be more than what
	 * cost_rescan charges for materialize, ie, cpu_operator_cost per tuple;
	 * if it is exactly the same then there will be a cost tie between
	 * nestloop with A outer, materialized B inner and nestloop with B outer,
	 * materialized A inner.  The extra cost ensures we'll prefer
	 * materializing the smaller rel.)	Note that this is normally a good deal
	 * less than cpu_tuple_cost; which is OK because a Material plan node
	 * doesn't do qual-checking or projection, so it's got less overhead than
	 * most plan nodes.
	 */</comment>
	<expr_stmt><expr><name>material_cost</name> <operator>+=</operator> <literal type="number">2</literal> <operator>*</operator> <name>cpu_operator_cost</name> <operator>*</operator> <name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we will spill to disk, charge at the rate of seq_page_cost per page.
	 * This cost is assumed to be evenly spread through the plan run phase,
	 * which isn't exactly accurate but our cost model doesn't allow for
	 * nonuniform costs within the run phase.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>material_bytes</name> <operator>&gt;</operator> <name>work_mem_bytes</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type> <name>npages</name> <init>= <expr><call><name>ceil</name><argument_list>(<argument><expr><name>material_bytes</name> <operator>/</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>material_bytes</name> <operator>+=</operator> <name>seq_page_cost</name> <operator>*</operator> <name>npages</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Calculate total costs for different options */</comment>
	<expr_stmt><expr><name>cte_total_cost</name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+</operator> <name>material_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>inline_total_cost</name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>*</operator> <name><name>cte</name><operator>-&gt;</operator><name>cterefcount</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * In a distributed system like TBase, the inline one could leverage more
	 * optimizations like subquery pullup, predicate pushdown, etc. We add a
	 * optimization factor 0.5 here to show case these cost saves.
	 */</comment>
	<expr_stmt><expr><name>inline_total_cost</name> <operator>=</operator> <name>inline_total_cost</name> <operator>*</operator> <literal type="number">0.5</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>inline_total_cost</name> <operator>&lt;=</operator> <name>cte_total_cost</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * SS_process_ctes: process a query's WITH list
 *
 * Consider each CTE in the WITH list and either ignore it (if it's an
 * unreferenced SELECT), "inline" it to create a regular sub-SELECT-in-FROM,
 * or convert it to an initplan.
 *
 * A side effect is to fill in root-&gt;cte_plan_ids with a list that
 * parallels root-&gt;parse-&gt;cteList and provides the subplan ID for
 * each CTE's initplan, or a dummy ID (-1) if we didn't make an initplan.
 */</comment>
<function><type><name>void</name></type>
<name>SS_process_ctes</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cte_plan_ids</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;parse-&gt;cteList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CmdType</name></type>		<name>cmdType</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name><operator>)</operator><operator>-&gt;</operator><name>commandType</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subquery</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>final_rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>best_path</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>splan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Ignore SELECT CTEs that are not actually referenced anywhere.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cte</name><operator>-&gt;</operator><name>cterefcount</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cmdType</name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Make a dummy entry in cte_plan_ids */</comment>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>cte_plan_ids</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cte_plan_ids</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

 		<comment type="block">/*
		 * Consider inlining the CTE (creating RTE_SUBQUERY RTE(s)) instead of
		 * implementing it as a separately-planned CTE.
		 *
		 * We cannot inline if any of these conditions hold:
		 *
		 * 1. The user said not to (the CTEMaterializeAlways option).
		 *
		 * 2. The CTE is recursive.
		 *
		 * 3. The CTE has side-effects; this includes either not being a plain
		 * SELECT, or containing volatile functions.  Inlining might change
		 * the side-effects, which would be bad.
		 *
		 * 4. The CTE is multiply-referenced and contains a self-reference to
		 * a recursive CTE outside itself.  Inlining would result in multiple
		 * recursive self-references, which we don't support.
		 *
		 * Otherwise, we have an option whether to inline or not.  That should
		 * always be a win if there's just a single reference, but if the CTE
		 * is multiply-referenced then it's unclear: inlining adds duplicate
		 * computations, but the ability to absorb restrictions from the outer
		 * query level could outweigh that.  We do not have nearly enough
		 * information at this point to tell whether that's true, so we let
		 * the user express a preference.  Our default behavior is to inline
		 * only singly-referenced CTEs, but a CTE marked CTEMaterializeNever
		 * will be inlined even if multiply referenced.
		 *
		 * Note: we check for volatile functions last, because that's more
		 * expensive than the other tests needed.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cte</name><operator>-&gt;</operator><name>ctematerialized</name></name> <operator>==</operator> <name>CTEMaterializeNever</name> <operator>||</operator>
			 <operator>(</operator><name><name>cte</name><operator>-&gt;</operator><name>ctematerialized</name></name> <operator>==</operator> <name>CTEMaterializeDefault</name> <operator>&amp;&amp;</operator>
			  <name><name>cte</name><operator>-&gt;</operator><name>cterefcount</name></name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>cte</name><operator>-&gt;</operator><name>cterecursive</name></name> <operator>&amp;&amp;</operator>
			<name>cmdType</name> <operator>==</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>contain_dml</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>cte</name><operator>-&gt;</operator><name>cterefcount</name></name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>||</operator>
			 <operator>!</operator><call><name>contain_outer_selfref</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>inline_cte</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>cte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Make a dummy entry in cte_plan_ids */</comment>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>cte_plan_ids</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cte_plan_ids</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Copy the source Query node.  Probably not necessary, but let's keep
		 * this similar to make_subplan.
		 */</comment>
		<expr_stmt><expr><name>subquery</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* plan_params should not be in use in current query level */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Generate Paths for the CTE query.  Always plan for full retrieval
		 * --- we don't have enough info to predict otherwise.
		 */</comment>
		<expr_stmt><expr><name>subroot</name> <operator>=</operator> <call><name>subquery_planner</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>,
								   <argument><expr><name>root</name></expr></argument>,
								   <argument><expr><name><name>cte</name><operator>-&gt;</operator><name>cterecursive</name></name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Since the current query level doesn't yet contain any RTEs, it
		 * should not be possible for the CTE to have requested parameters of
		 * this level.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected outer reference in CTE query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Select best Path and turn it into a Plan.  At least for now, there
		 * seems no reason to postpone doing that.
		 */</comment>
		<expr_stmt><expr><name>final_rel</name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>UPPERREL_FINAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>best_path</name> <operator>=</operator> <name><name>final_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>subroot</name><operator>-&gt;</operator><name>distribution</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>subroot</name><operator>-&gt;</operator><name>distribution</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>distribution</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_plan</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<comment type="block">/*
		 * Handle the CTE with multiple references in the main query. Since we
		 * need to compare the cost between CTE Scan and inline subquery Scan,
		 * perform the inline check after we got the best path of CTE subquery.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cte</name><operator>-&gt;</operator><name>ctematerialized</name></name> <operator>==</operator> <name>CTEMaterializeNever</name> <operator>||</operator>
			 <operator>(</operator><name><name>cte</name><operator>-&gt;</operator><name>ctematerialized</name></name> <operator>==</operator> <name>CTEMaterializeDefault</name> <operator>&amp;&amp;</operator>
			  <name><name>cte</name><operator>-&gt;</operator><name>cterefcount</name></name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>cte</name><operator>-&gt;</operator><name>cterecursive</name></name> <operator>&amp;&amp;</operator>
			<name>cmdType</name> <operator>==</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>contain_dml</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>cte</name><operator>-&gt;</operator><name>cterefcount</name></name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>||</operator>
			 <operator>!</operator><call><name>contain_outer_selfref</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Check if total cost of inlining to multiple subquery is cheaper.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>is_cte_worth_inline</name><argument_list>(<argument><expr><name>cte</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>inline_cte</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>cte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Make a dummy entry in cte_plan_ids */</comment>
				<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>cte_plan_ids</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cte_plan_ids</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        <comment type="block">/* Add a remote subplan, if redistribution is needed. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>subroot</name><operator>-&gt;</operator><name>distribution</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>remote_subplan_depth</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_remotesubplan</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>,
                                               <argument><expr><name>plan</name></expr></argument>,
                                               <argument><expr><name>NULL</name></expr></argument>,
                                               <argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>,
                                               <argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>query_pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>remote_subplan_depth</name><operator>--</operator></expr>;</expr_stmt>
            <comment type="block">/*
             * SS_finalize_plan has already been run on the subplan,
             * so we have to copy parameter info to wrapper plan node.
             */</comment>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>extParam</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name><operator>-&gt;</operator><name>extParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>allParam</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name><operator>-&gt;</operator><name>allParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * Make a SubPlan node for it.  This is just enough unlike
         * build_subplan that we can't share code.
         *
         * Note plan_id, plan_name, and cost fields are set further down.
         */</comment>
        <expr_stmt><expr><name>splan</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>=</operator> <name>CTE_SUBLINK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>testexpr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>paramIds</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>get_first_col_type</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>splan</name><operator>-&gt;</operator><name>firstColType</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>splan</name><operator>-&gt;</operator><name>firstColTypmod</name></name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name><name>splan</name><operator>-&gt;</operator><name>firstColCollation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>useHashTable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>unknownEqFalse</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <comment type="block">/*
         * CTE scans are not considered for parallelism (cf
         * set_rel_consider_parallel), and even if they were, initPlans aren't
         * parallel-safe.
         */</comment>
        <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>setParam</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>parParam</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

        <comment type="block">/*
         * The node can't have any inputs (since it's an initplan), so the
         * parParam and args lists remain empty.  (It could contain references
         * to earlier CTEs' output param IDs, but CTE outputs are not
         * propagated via the args list.)
         */</comment>

        <comment type="block">/*
         * Assign a param ID to represent the CTE's output.  No ordinary
         * "evaluation" of this param slot ever happens, but we use the param
         * ID for setParam/chgParam signaling just as if the CTE plan were
         * returning a simple scalar output.  (Also, the executor abuses the
         * ParamExecData slot for this param ID for communication among
         * multiple CteScan nodes that might be scanning this CTE.)
         */</comment>
        <expr_stmt><expr><name>paramid</name> <operator>=</operator> <call><name>SS_assign_special_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>setParam</name></name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name>paramid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Add the subplan and its PlannerInfo to the global lists.
         */</comment>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subroots</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subroots</name></name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>plan_id</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>init_plans</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>init_plans</name></name></expr></argument>, <argument><expr><name>splan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>cte_plan_ids</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cte_plan_ids</name></name></expr></argument>, <argument><expr><name><name>splan</name><operator>-&gt;</operator><name>plan_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Label the subplan for EXPLAIN purposes */</comment>
        <expr_stmt><expr><name><name>splan</name><operator>-&gt;</operator><name>plan_name</name></name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"CTE %s"</literal></expr></argument>, <argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Lastly, fill in the cost estimates for use later */</comment>
        <expr_stmt><expr><call><name>cost_subplan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>splan</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>simplify_EXPR_query</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>whereclause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_pullup_subquery</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>cteList</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>query-&gt;rtable</argument>)</argument_list></macro>
    <block>{<block_content>
    	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
    	<block>{<block_content>
    		<return>return <expr><name>false</name></expr>;</return>
    	</block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name>whereclause</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>contain_vars_upper_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>whereclause</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>contain_vars_upper_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>whereclause</name></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>whereclause</name></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>simplify_ALL_query</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* 
 * If where clause contains 'not' BoolExpr or not-equal OpExpr, return true.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_notexpr_or_neopexpr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>whereclause</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>check_or</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>joinquals</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>whereclause</name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator><name>whereclause</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>or_clause</name><argument_list>(<argument><expr><name>whereclause</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>last</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if<condition>(<expr><operator>!</operator><name>check_or</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/* Look for common EXPR */</comment>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>expr-&gt;args</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				
				<if_stmt><if>if<condition>(<expr><call><name>contain_notexpr_or_neopexpr</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>check_or</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cur</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>last</name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>last</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><name>true</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>

			<expr_stmt><expr><operator>*</operator><name>joinquals</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><operator>*</operator><name>joinquals</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

		<comment type="block">/* AND EXPR */</comment>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>expr-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>result</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>contain_notexpr_or_neopexpr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>check_or</name></expr></argument>, <argument><expr><name>joinquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block>

        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>whereclause</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator><name>whereclause</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>lexpr</name>  <init>=  <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><operator>*</operator><name>joinquals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>joinquals</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Make sure the operator is hashjoinable */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_hashjoinable</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>lexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Check the operands of the OpExpr */</comment>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>expr-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>result</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>contain_notexpr_or_neopexpr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>check_or</name></expr></argument>, <argument><expr><name>joinquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block>

        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>whereclause</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>whereclause</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>result</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>label</name> <init>= <expr><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator><name>whereclause</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>contain_notexpr_or_neopexpr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>label</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>,
											 <argument><expr><name>check_or</name></expr></argument>,
											 <argument><expr><name>joinquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<comment type="block">/* In case the where clause is "tbl.col_a IN ('0','1')" */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>whereclause</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> 		  <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>scalarArray</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name><operator>*</operator><operator>)</operator><name>whereclause</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> 			  <modifier>*</modifier></type><name>lexpr</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>scalarArray</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_hashjoinable</name><argument_list>(<argument><expr><name><name>scalarArray</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>lexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>scalarArray-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>contain_notexpr_or_neopexpr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>check_or</name></expr></argument>,
											<argument><expr><name>joinquals</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<comment type="block">/*
	 * The right operand of ScalarArrayOpExpr, we only support array of
	 * constant values
	 */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>whereclause</name></expr></argument>, <argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ArrayExpr</name> <modifier>*</modifier></type><name>arrayExpr</name> <init>= <expr><operator>(</operator><name>ArrayExpr</name> <operator>*</operator><operator>)</operator><name>whereclause</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>arrayExpr-&gt;elements</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
    <comment type="block">/* In case the where clause is "tbl.col_a is(is not) NULL" */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>whereclause</name></expr></argument>, <argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NullTest</name> <modifier>*</modifier></type><name>nullTestExpr</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator><name>whereclause</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>contain_notexpr_or_neopexpr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>nullTestExpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>,
										<argument><expr><name>check_or</name></expr></argument>,
										<argument><expr><name>joinquals</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>append_var_to_subquery_targetlist</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>temp_var</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>ent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>varno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>temp_var</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ent</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>temp_var</name></expr></argument>, <argument><expr><name><name>temp_var</name><operator>-&gt;</operator><name>varoattno</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>varno</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>varno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varoattno</name></name> <operator>=</operator> <name>varno</name></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name>target</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <name>ent</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>targetList</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_vars_to_subquery_targetlist</name><parameter_list>(<parameter><decl><type><name>Node</name>     <modifier>*</modifier></type><name>whereClause</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subselect</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rtindex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>vars</name> <init>= <expr><call><name>pull_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>whereClause</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>vars</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>rtindex</name> <operator>||</operator> <name>rtindex</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type> <name>match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>temp_var</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>ent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>varno</name>         <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>varlevelsup</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>varlevelsup</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><name>temp_var</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>temp_var</name><operator>-&gt;</operator><name>varno</name></name> <operator>-=</operator> <name>offset</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>temp_var</name><operator>-&gt;</operator><name>varnoold</name></name> <operator>-=</operator> <name>offset</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>match</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>subselect-&gt;targetList</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tent</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>temp_var</name></expr></argument>, <argument><expr><name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                        <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varoattno</name></name> <operator>=</operator> <name><name>tent</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
                        
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>match</name></expr>)</condition>
            <block>{<block_content>
				<expr_stmt><expr><name>ent</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>temp_var</name></expr></argument>, <argument><expr><name><name>temp_var</name><operator>-&gt;</operator><name>varoattno</name></name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
                <expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>varno</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>varno</name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varoattno</name></name> <operator>=</operator> <name>varno</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>varlevelsup</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>=</operator> <name>varlevelsup</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * contain_dml: is any subquery not a plain SELECT?
 *
 * We reject SELECT FOR UPDATE/SHARE as well as INSERT etc.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_dml</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>contain_dml_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_dml_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>||</operator>
			<name><name>query</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<return>return <expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>contain_dml_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_dml_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * contain_outer_selfref: is there an external recursive self-reference?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_outer_selfref</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We should be starting with a Query, so that depth will be 1 while
	 * examining its immediate contents.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>contain_outer_selfref_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>depth</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_outer_selfref_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Index</name> <modifier>*</modifier></type><name>depth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check for a self-reference to a CTE that's above the Query that our
		 * search started at.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name> <operator>&amp;&amp;</operator>
			<name><name>rte</name><operator>-&gt;</operator><name>self_reference</name></name> <operator>&amp;&amp;</operator>
			<name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name> <operator>&gt;=</operator> <operator>*</operator><name>depth</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>			<comment type="block">/* allow range_table_walker to continue */</comment>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Recurse into subquery, tracking nesting depth properly */</comment>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>depth</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>contain_outer_selfref_walker</name></expr></argument>,
								   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>depth</name></expr></argument>, <argument><expr><name>QTW_EXAMINE_RTES_BEFORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>depth</name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_outer_selfref_walker</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>depth</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * inline_cte: convert RTE_CTE references to given CTE into RTE_SUBQUERYs
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>inline_cte</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>inline_cte_walker_context</name></name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>ctename</name></name> <operator>=</operator> <name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr>;</expr_stmt>
	<comment type="block">/* Start at levelsup = -1 because we'll immediately increment it */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>levelsup</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>refcount</name></name> <operator>=</operator> <name><name>cte</name><operator>-&gt;</operator><name>cterefcount</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>ctequery</name></name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>inline_cte_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assert we replaced all references */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>refcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>inline_cte_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>inline_cte_walker_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>levelsup</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Visit the query's RTE nodes after their contents; otherwise
		 * query_tree_walker would descend into the newly inlined CTE query,
		 * which we don't want.
		 */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>inline_cte_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>,
								 <argument><expr><name>QTW_EXAMINE_RTES_AFTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>levelsup</name></name><operator>--</operator></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>levelsup</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Found a reference to replace.  Generate a copy of the CTE query
			 * with appropriate level adjustment for outer references (e.g.,
			 * to other CTEs).
			 */</comment>
			<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>newquery</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>levelsup</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newquery</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>levelsup</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Convert the RTE_CTE RTE into a RTE_SUBQUERY.
			 *
			 * Historically, a FOR UPDATE clause has been treated as extending
			 * into views and subqueries, but not into CTEs.  We preserve this
			 * distinction by not trying to push rowmarks into the new
			 * subquery.
			 */</comment>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_SUBQUERY</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>newquery</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>security_barrier</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/* Zero out CTE-specific fields */</comment>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>self_reference</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypmods</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>colcollations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

			<comment type="block">/* Count the number of replacements we've done */</comment>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>refcount</name></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>inline_cte_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * convert_ANY_sublink_to_join: try to convert an ANY SubLink to a join
 *
 * The caller has found an ANY SubLink at the top level of one of the query's
 * qual clauses, but has not checked the properties of the SubLink further.
 * Decide whether it is appropriate to process this SubLink in join style.
 * If so, form a JoinExpr and return it.  Return NULL if the SubLink cannot
 * be converted to a join.
 *
 * The only non-obvious input parameter is available_rels: this is the set
 * of query rels that can safely be referenced in the sublink expression.
 * (We must restrict this to avoid changing the semantics when a sublink
 * is present in an outer join's ON qual.)  The conversion must fail if
 * the converted qual would reference any but these parent-query relids.
 *
 * On success, the returned JoinExpr has larg = NULL and rarg = the jointree
 * item representing the pulled-up subquery.  The caller must set larg to
 * represent the relation(s) on the lefthand side of the new join, and insert
 * the JoinExpr into the upper query's jointree at an appropriate place
 * (typically, where the lefthand relation(s) had been).  Note that the
 * passed-in SubLink must also be removed from its original position in the
 * query quals, since the quals of the returned JoinExpr replace it.
 * (Notionally, we replace the SubLink with a constant TRUE, then elide the
 * redundant constant from the qual.)
 *
 * On success, the caller is also responsible for recursively applying
 * pull_up_sublinks processing to the rarg and quals of the returned JoinExpr.
 * (On failure, there is no need to do anything, since pull_up_sublinks will
 * be applied when we recursively plan the sub-select.)
 *
 * Side effects of a successful conversion include adding the SubLink's
 * subselect to the query's rangetable, so that it can be referenced in
 * the JoinExpr's rarg.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><name>JoinExpr</name> <modifier>*</modifier></type>
<name>convert_ANY_sublink_to_join</name><argument_list>(<argument><expr><name>PlannerInfo</name> <operator>*</operator><name>root</name></expr></argument>, <argument><expr><name>SubLink</name> <operator>*</operator><name>sublink</name></expr></argument>,
                            <argument><expr><name>Relids</name> <name>available_rels</name></expr></argument>, <argument><expr><name>bool</name> <name>under_not</name></expr></argument>)</argument_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<name>JoinExpr</name> <modifier>*</modifier>
<name>convert_ANY_sublink_to_join</name><argument_list>(<argument><expr><name>PlannerInfo</name> <operator>*</operator><name>root</name></expr></argument>, <argument><expr><name>SubLink</name> <operator>*</operator><name>sublink</name></expr></argument>,
                            <argument><expr><name>Relids</name> <name>available_rels</name></expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>subselect</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relids</name></type>        <name>upper_varnos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rtindex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subquery_vars</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>quals</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<decl_stmt><decl><type><name>bool</name></type>		<name>correlated</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>ANY_SUBLINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>enable_pullup_subquery</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If there are CTEs, then the transformation does not work. Don't attempt
		 * to pullup.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>cteList</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If uncorrelated, and no Var nodes on lhs, the subquery will be executed
		 * only once.  It should become an InitPlan, but make_subplan() doesn't
		 * handle that case, so just flatten it for now.
		 * TODO: Let it become an InitPlan, so its QEs can be recycled.
		 *
		 * We only handle level 1 correlated cases. The sub-select must not refer
		 * to any Vars of the parent query. (Vars of higher levels should be okay,
		 * though.)
		 */</comment>
		<expr_stmt><expr><name>correlated</name> <operator>=</operator> <call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subselect</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>correlated</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If deeply(&gt;1) correlated, then don't pull it up
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>contain_vars_upper_level</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Under certain conditions, we cannot pull up the subquery as a join.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_simple_subquery</name><argument_list>(<argument><expr><name>subselect</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Do not pull subqueries with correlation in a func expr in the from
			 * clause of the subselect
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>has_correlation_in_funcexpr_rte</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>contain_subplans</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/*
	 * The sub-select must not refer to any Vars of the parent query. (Vars of
	 * higher levels should be okay, though.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subselect</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * The test expression must contain some Vars of the parent query, else
     * it's not gonna be a join.  (Note that it won't have Vars referring to
     * the subquery, rather Params.)
     */</comment>
    <expr_stmt><expr><name>upper_varnos</name> <operator>=</operator> <call><name>pull_varnos</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>upper_varnos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * However, it can't refer to anything outside available_rels.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>upper_varnos</name></expr></argument>, <argument><expr><name>available_rels</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * The combining operators and left-hand expressions mustn't be volatile.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Create a dummy ParseState for addRangeTableEntryForSubquery */</comment>
    <expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Okay, pull up the sub-select into upper range table.
	 *
	 * We rely here on the assumption that the outer query has no references
	 * to the inner (necessarily true, other than the Vars that we build
	 * below). Therefore this is a lot easier than what pull_up_subqueries has
	 * to go through.
	 *
	 * If the subquery is correlated, i.e. it refers to any Vars of the
	 * parent query, mark it as lateral.
	 */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><name>subselect</name></expr></argument>,
										<argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"ANY_subquery"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
										<argument><expr><name>correlated</name></expr></argument>,	<comment type="block">/* lateral */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
										<argument><expr><name>false</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
										<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Form a RangeTblRef for the pulled-up sub-select.
     */</comment>
    <expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Build a list of Vars representing the subselect outputs.
     */</comment>
    <expr_stmt><expr><name>subquery_vars</name> <operator>=</operator> <call><name>generate_subquery_vars</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                           <argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                           <argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build the new join's qual expression, replacing Params with these Vars.
	 */</comment>
	<expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>convert_testexpr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>subquery_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * And finally, build the JoinExpr node.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<comment type="block">/* Different logic for NOT IN/ANY sublink */</comment>
	<if_stmt><if>if <condition>(<expr><name>under_not</name></expr>)</condition>
	<block>{<block_content>
        <decl_stmt><decl><type><name>Node</name><modifier>*</modifier></type> <name>antiquals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>antiquals</name> <operator>=</operator> <call><name>convert_joinqual_to_antiqual</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>antiquals</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>JOIN_ANTI</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>antiquals</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Basic logic for IN/ANY sublink */</comment>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>JOIN_SEMI</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>quals</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>isNatural</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>        <comment type="block">/* caller must fill this in */</comment>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rtr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>usingClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>        <comment type="block">/* we don't need an RTE for it */</comment>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<comment type="block">/*
 * convert_EXISTS_sublink_to_join: try to convert an EXISTS SubLink to a join
 *
 * The API of this function is identical to convert_ANY_sublink_to_join's,
 * except that we also support the case where the caller has found NOT EXISTS,
 * so we need an additional input parameter "under_not".
 */</comment>
<function><type><name>JoinExpr</name> <modifier>*</modifier></type>
<name>convert_EXISTS_sublink_to_join</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name></decl></parameter>,
                               <parameter><decl><type><name>bool</name></type> <name>under_not</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>available_rels</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>subselect</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>whereClause</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rtoffset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>varno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relids</name></type>        <name>clause_varnos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relids</name></type>        <name>upper_varnos</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>EXISTS_SUBLINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Can't flatten if it contains WITH.  (We could arrange to pull up the
     * WITH into the parent query's cteList, but that risks changing the
     * semantics, since a WITH ought to be executed once per associated query
     * call.)  Note that convert_ANY_sublink_to_join doesn't have to reject
     * this case, since it just produces a subquery RTE that doesn't have to
     * get flattened into the parent query.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>subselect</name><operator>-&gt;</operator><name>cteList</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Copy the subquery so we can modify it safely (see comments in
     * make_subplan).
     */</comment>
    <expr_stmt><expr><name>subselect</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>subselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * See if the subquery can be simplified based on the knowledge that it's
     * being used in EXISTS().  If we aren't able to get rid of its
     * targetlist, we have to fail, because the pullup operation leaves us
     * with noplace to evaluate the targetlist.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>simplify_EXISTS_query</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subselect</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * The subquery must have a nonempty jointree, else we won't have a join.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Separate out the WHERE clause.  (We could theoretically also remove
     * top-level plain JOIN/ON clauses, but it's probably not worth the
     * trouble.)
     */</comment>
    <expr_stmt><expr><name>whereClause</name> <operator>=</operator> <name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * The rest of the sub-select must not refer to any Vars of the parent
     * query.  (Vars of higher levels should be okay, though.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subselect</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * On the other hand, the WHERE clause must contain some Vars of the
     * parent query, else it's not gonna be a join.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We don't risk optimizing if the WHERE clause is volatile, either.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Prepare to pull up the sub-select into top range table.
     *
     * We rely here on the assumption that the outer query has no references
     * to the inner (necessarily true). Therefore this is a lot easier than
     * what pull_up_subqueries has to go through.
     *
     * In fact, it's even easier than what convert_ANY_sublink_to_join has to
     * do.  The machinations of simplify_EXISTS_query ensured that there is
     * nothing interesting in the subquery except an rtable and jointree, and
     * even the jointree FromExpr no longer has quals.  So we can just append
     * the rtable to our own and use the FromExpr in our jointree. But first,
     * adjust all level-zero varnos in the subquery to account for the rtable
     * merger.
     */</comment>
    <expr_stmt><expr><name>rtoffset</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OffsetVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subselect</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OffsetVarNodes</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>, <argument><expr><name>rtoffset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Upper-level vars in subquery will now be one level closer to their
     * parent than before; in particular, anything that had been level 1
     * becomes level zero.
     */</comment>
    <expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subselect</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now that the WHERE clause is adjusted to match the parent query
     * environment, we can easily identify all the level-zero rels it uses.
     * The ones &lt;= rtoffset belong to the upper query; the ones &gt; rtoffset do
     * not.
     */</comment>
    <expr_stmt><expr><name>clause_varnos</name> <operator>=</operator> <call><name>pull_varnos</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>upper_varnos</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>varno</name> <operator>=</operator> <call><name>bms_first_member</name><argument_list>(<argument><expr><name>clause_varnos</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>varno</name> <operator>&lt;=</operator> <name>rtoffset</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>upper_varnos</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>upper_varnos</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>clause_varnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>upper_varnos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now that we've got the set of upper-level varnos, we can make the last
     * check: only available_rels can be referenced.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>upper_varnos</name></expr></argument>, <argument><expr><name>available_rels</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Now we can attach the modified subquery rtable to the parent */</comment>
    <expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * And finally, build the JoinExpr node.
     */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <ternary><condition><expr><name>under_not</name></expr> ?</condition><then> <expr><name>JOIN_ANTI</name></expr> </then><else>: <expr><name>JOIN_SEMI</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>isNatural</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>        <comment type="block">/* caller must fill this in */</comment>
    <comment type="block">/* flatten out the FromExpr node if it's useless */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subselect</name><operator>-&gt;</operator><name>jointree</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>usingClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>whereClause</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>        <comment type="block">/* we don't need an RTE for it */</comment>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
  * try to convert an expr SubLink to a join
  */</comment>
<function><type><name>JoinExpr</name> <modifier>*</modifier></type>
<name>convert_EXPR_sublink_to_join</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
		                    <parameter><decl><type><name>Relids</name></type> <name>available_rels</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>filter</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>subselect</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>whereClause</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relids</name></type> <name>clause_varnos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>varno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rtindex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinquals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>pullupquals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sublinks</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ressortgroupref</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>ent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>count_agg</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>hasAgg</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>vars</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition>
    <block>{<block_content>
    	<return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>find_sublink_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sublinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* only one sublink can be handled */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>sublinks</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>sublink</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>sublinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* only process agg case */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator><name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name><operator>)</operator><operator>-&gt;</operator><name>hasAggs</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>subselect</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator><call><name>copyObject</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* we can just handle simple case now! */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>simplify_EXPR_query</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subselect</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>whereClause</name> <operator>=</operator> <name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * The rest of the sub-select must not refer to any Vars of the parent
     * query.  (Vars of higher levels should be okay, though.)
     */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>subselect</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* subquery must contain one output */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* output must not be count */</comment>
	<expr_stmt><expr><name>tent</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>PVC_INCLUDE_AGGREGATES</name> <operator>|</operator>
														 <name>PVC_RECURSE_PLACEHOLDERS</name> <operator>|</operator>
														 <name>PVC_RECURSE_WINDOWFUNCS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>vars</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>ref</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator><name>n</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>hasAgg</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/* count agg */</comment>
			<if_stmt><if>if<condition>(<expr><name><name>ref</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>==</operator> <literal type="number">2147</literal> <operator>||</operator> <name><name>ref</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>==</operator> <literal type="number">2803</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>count_agg</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>get_func_name</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if<condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/* strict agg is allowed */</comment>
			<if_stmt><if>if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><literal type="string">"max"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><literal type="string">"min"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><literal type="string">"stddev"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><literal type="string">"sum"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><literal type="string">"avg"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>,<argument><expr><literal type="string">"variance"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> )</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hasAgg</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * On the other hand, the WHERE clause must contain some Vars of the
     * parent query, else it's not gonna be a join.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* process 'op' and 'bool' expr only */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_notexpr_or_neopexpr</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>joinquals</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* should not have others quals contain vars of parent query */</comment>
	<if_stmt><if>if <condition>(<expr><name>pullupquals</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We don't risk optimizing if the WHERE clause is volatile, either.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* get vars of parent query */</comment>
    <expr_stmt><expr><name>clause_varnos</name> <operator>=</operator> <call><name>pull_varnos_of_level</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>clause_varnos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* whereclause contains vars from different parent query */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>clause_varnos</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>clause_varnos</name></expr></argument>, <argument><expr><name>available_rels</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* 
     * whereclause can only be 'and' expr and 'op =' expr , this
     * has been checked before.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>joinquals</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>pull_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>joinquals</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* construct groupby clause */</comment>
	<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>vars</argument>)</argument_list></macro>
    <block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>sortop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>eqop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>hashable</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>restype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grpcl</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator><call><name>list_nth</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tbl</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator> <name><name>tbl</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_CTE</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>restype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>grpcl</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>ressortgroupref</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tbl</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
		<block>{<block_content>
            <expr_stmt><expr><name>ent</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varoattno</name></name></expr></argument>, <argument><expr><call><name>get_relid_attribute_name</name><argument_list>(<argument><expr><name><name>tbl</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varoattno</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>plan_id</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>ndx</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>cte_plan</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>cte_ent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Note: cte_plan_ids can be shorter than cteList, if we are still working
			 * on planning the CTEs (ie, this is a side-reference from another CTE).
			 * So we mustn't use forboth here.
			 */</comment>
			<expr_stmt><expr><name>ndx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>root-&gt;parse-&gt;cteList</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>, <argument><expr><name><name>tbl</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>ndx</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* shouldn't happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>tbl</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>ndx</name> <operator>&gt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cte_plan_ids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find plan for CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>tbl</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>plan_id</name> <operator>=</operator> <call><name>list_nth_int</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cte_plan_ids</name></name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cte_plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><call><name>list_nth_cell</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name>plan_id</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cte_ent</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><call><name>list_nth_cell</name><argument_list>(<argument><expr><name><name>cte_plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ent</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varoattno</name></name></expr></argument>, <argument><expr><name><name>cte_ent</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name>ressortgroupref</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>varno</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>varno</name></expr>;</expr_stmt>

		<comment type="block">/* determine the eqop and optional sortop */</comment>
		<expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><name>restype</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>sortop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eqop</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>=</operator> <name>ressortgroupref</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>eqop</name></name> <operator>=</operator> <name>eqop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>sortop</name></name> <operator>=</operator> <name>sortop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* OK with or without sortop */</comment>
		<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>hashable</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>, <argument><expr><name>grpcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>add_vars_to_subquery_targetlist</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>whereClause</name></expr></argument>, <argument><expr><name>subselect</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><name>subselect</name></expr></argument>,
										<argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"EXPR_subquery"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>false</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Form a RangeTblRef for the pulled-up sub-select.
	 */</comment>
	<expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>

	<comment type="block">/* adjust all sublevelup 0 varno to rtindex */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>n</name></expr> ;</condition><incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>whereClause</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block>

	<comment type="block">/* pullup whereclause , all sublevel-1 vars change to 0 */</comment>
	<expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>whereClause</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* form join quals */</comment>
	<expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>makeVarFromTargetEntry</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		
		<if_stmt><if>if<condition>(<expr><name>count_agg</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>coalesce</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>coalesce</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>target</name></expr></argument>,<argument><expr><call><name>makeConst</name><argument_list>(<argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>InvalidOid</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>false</name></expr></argument>,<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>coalesce</name><operator>-&gt;</operator><name>coalescetype</name></name> <operator>=</operator> <name>INT8OID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>target</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>coalesce</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
        
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator><call><name>substitute_sublink_with_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>, <argument><expr><name>sublink</name></expr></argument>,<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<comment type="block">/*
	 * And finally, build the JoinExpr node.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>JOIN_LEFT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>isNatural</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* caller must fill this in */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>rtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>usingClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>whereClause</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* we don't need an RTE for it */</comment>


	<expr_stmt><expr><operator>*</operator><name>filter</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>expr</name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>convert_OR_EXIST_sublink_to_join_recurse</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>jtlink</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>new_clauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>EXISTS_SUBLINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>convert_OR_EXIST_sublink_to_join</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sublink</name></expr></argument>, <argument><expr><name>jtlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_clauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_clauses</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>or_clause</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>((BoolExpr *)node)-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>convert_OR_EXIST_sublink_to_join_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
															  <argument><expr><name>jtlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>new_clauses</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>new_clauses</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>new_clauses</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>get_or_exist_subquery_targetlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>joinClause</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>next_attno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>and_clause</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>new_args</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>((BoolExpr *)node)-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_or_exist_subquery_targetlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>targetList</name></expr></argument>, <argument><expr><name>joinClause</name></expr></argument>, <argument><expr><name>next_attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>new_args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_args</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>new_args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name>new_args</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>new_args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>make_andclause</name><argument_list>(<argument><expr><name>new_args</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>pull_vars_of_level</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
		<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>vars</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>pull_vars_of_level</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* only support upper_var = local_var */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>vars</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
		<expr_stmt><expr><operator>*</operator><name>targetList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetList</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name><name>vars</name><operator>-&gt;</operator><name>head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>pull_vars_of_level</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>var</name>  <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name><name>vars</name><operator>-&gt;</operator><name>head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <operator>*</operator><name>next_attno</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>next_attno</name> <operator>=</operator> <operator>*</operator><name>next_attno</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>joinClause</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>joinClause</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
 * simplify_TargetList_query:remove any useless stuff in an TargetList's
 * subquery
 *
 * For subquery in targetlist, normally we use JOIN_LEFT_SCALAR type to
 * make sure there will be only one row found. If subquery contains
 * aggregation clause, then we are OK with JOIN_LEFT_SEMI. Further more, if
 * subquery got 'limit 1' or  equivalent clauses such as Oracle 'rownum = 1'.
 * Then we can remove the limit clause and use JOIN_SEMI to simplify the
 * subquery.
 *
 * Returns TRUE if was able to discard the 'LIMIT 1' cluase or the subquery
 * already simple enough, else FALSE.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>simplify_TargetList_query</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>useLeftSemiJoin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We don't try to simplify at all if the query uses set operations,
	 * aggregates, grouping sets, SRFs, modifying CTEs, HAVING, OFFSET, or FOR
	 * UPDATE/SHARE; none of these seem likely in normal usage and their
	 * possible effects are complex.  (Note: we could ignore an "OFFSET 0"
	 * clause, but that traditionally is used as an optimization fence, so we
	 * don't.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>rowMarks</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* By default, use JOIN_LEFT_SCALAR. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>useLeftSemiJoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>useLeftSemiJoin</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Handle 'limit 1' case as described above. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The LIMIT clause has not yet been through eval_const_expressions,
		 * so we have to apply that here.  It might seem like this is a waste
		 * of cycles, since the only case plausibly worth worrying about is
		 * "LIMIT 1" ... but what we'll actually see is "LIMIT int8(1::int4)",
		 * so we have to fold constants or we're not going to recognize it.
		 */</comment>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>limit</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type>		<name>limitValue</name></decl>;</decl_stmt>

		<comment type="block">/* Might as well update the query if we simplified the clause. */</comment>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>limit</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>limit</name><operator>-&gt;</operator><name>consttype</name></name> <operator>==</operator> <name>INT8OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>limitValue</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>limit</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Invalid value, we have to get at least one row. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>limit</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>&amp;&amp;</operator> <name>limitValue</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the SubQuery got limit 1(actually must be limit 1), then the
		 * join Semantic equals JOIN_SEMI. We don't need to continue when got
		 * one LHS match.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>limitValue</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Remove the limit clause for more possible subquery pullup
			 * optimizations.
			 */</comment>
			<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<comment type="block">/* Inform caller to use JOIN_LEFT_SEMI */</comment>
			<expr_stmt><expr><operator>*</operator><name>useLeftSemiJoin</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try to convert an SubLink in targetlist to a join
 *
 * The sublink in targetlist has the semantic of SCALAR. Normal joins will join
 * simply generate repeated tuples. So we add a new join type JOIN_LEFT_SCALAR
 * which acts like left join and reports error when scalar semantics is broken.
 *
 * On success, it converts sublink to subquery to parent jointree and returns
 * the converted new targetlist entry. Otherwise, it returnes NULL.
 */</comment>
<function><type><name>TargetEntry</name> <modifier>*</modifier></type>
<name>convert_TargetList_sublink_to_join</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>		<modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>		<modifier>*</modifier></type><name>whereClause</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>		<modifier>*</modifier></type><name>subselect</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JoinExpr</name>	<modifier>*</modifier></type><name>joinExpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name>	<modifier>*</modifier></type><name>pstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SubLink</name>		<modifier>*</modifier></type><name>sublink</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblRef</name>	<modifier>*</modifier></type><name>rtr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>		<modifier>*</modifier></type><name>target</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>		<modifier>*</modifier></type><name>sublinks</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>		 <name>count_agg</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>		 <name>useLeftSemiJoin</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* By default, JOIN_LEFT_SCALAR is the worst choice */</comment>
    <decl_stmt><decl><type><name>JoinType</name></type> 	 <name>finalJoinType</name> <init>= <expr><name>JOIN_LEFT_SCALAR</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Find sublinks in the targetlist entry */</comment>
	<expr_stmt><expr><call><name>find_sublink_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sublinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Only one sublink can be handled */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>sublinks</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>sublink</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>sublinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>!=</operator> <name>EXPR_SUBLINK</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Copy object so that we can modify it.
	 */</comment>
	<expr_stmt><expr><name>subselect</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>whereClause</name> <operator>=</operator> <name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Only one targetEntry can be handled.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The SubQuery must have a non-empty JoinTree, else we won't have a join.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * See if the subquery can be simplified. For now, we just try to remove
	 * 'limit 1' clause. If it's been removed, we can use JOIN_LEFT_SEMI to
	 * save more costs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>simplify_TargetList_query</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subselect</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>useLeftSemiJoin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* 'limit 1' optimized */</comment>
	<if_stmt><if>if <condition>(<expr><name>useLeftSemiJoin</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>finalJoinType</name> <operator>=</operator> <name>JOIN_LEFT_SEMI</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * What we can not optimize.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subselect</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>||</operator> <name><name>subselect</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>||</operator>
		<name><name>subselect</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>||</operator> <name><name>subselect</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator>
		<name><name>subselect</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator> <name><name>subselect</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>||</operator>
		<name><name>subselect</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>||</operator> <name><name>subselect</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>||</operator>
		<name><name>subselect</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>||</operator> <name><name>subselect</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>||</operator>
		<name><name>subselect</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>||</operator> <name><name>subselect</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>||</operator>
		<name><name>subselect</name><operator>-&gt;</operator><name>cteList</name></name> <operator>||</operator> <name><name>subselect</name><operator>-&gt;</operator><name>sortClause</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * On one hand, the WHERE clause must contain some Vars of the
	 * parent query, else it's not gonna be a join.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We don't risk optimizing if the WHERE clause is volatile, either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The rest of the sub-select must not refer to any Vars of the parent
	 * query. (Vars of higher levels should be okay, though.)
	 */</comment>
	<expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subselect</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>whereClause</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subselect</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition>
	<block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>ressortgroupref</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>varno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinquals</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>vars</name>       <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>ent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>  <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>agg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>  <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* process 'op' and 'bool' expr only */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>contain_notexpr_or_neopexpr</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>joinquals</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator><name>expr</name><operator>)</operator><operator>-&gt;</operator><name>expr</name></expr>;</expr_stmt>
		<comment type="block">/*
		 * First node must be Agg.
		 * we optimize subquery only like "SELECT agg()",
		 * others will not be optimized for now.
		 */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>agg</name> <operator>=</operator> <operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator><name>expr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>get_func_name</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggfnoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><name>name</name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* count agg */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>count_agg</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* strict aggs are allowed */</comment>
        <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"max"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal>    <operator>&amp;&amp;</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"min"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                 <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"stddev"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"sum"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                 <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"avg"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal>    <operator>&amp;&amp;</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"variance"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>pull_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>joinquals</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* construct groupby clause */</comment>
        <macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>vars</argument>)</argument_list></macro>
        <block>{<block_content>
        	<decl_stmt><decl><type><name>Oid</name></type> <name>sortop</name></decl>;</decl_stmt>
        	<decl_stmt><decl><type><name>Oid</name></type> <name>eqop</name></decl>;</decl_stmt>
        	<decl_stmt><decl><type><name>bool</name></type> <name>hashable</name></decl>;</decl_stmt>
        	<decl_stmt><decl><type><name>Oid</name></type> <name>restype</name></decl>;</decl_stmt>
        	<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grpcl</name></decl>;</decl_stmt>
        	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        	<if_stmt><if>if <condition>(<expr><name><name>tbl</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator> <name><name>tbl</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_CTE</name></expr>)</condition><block type="pseudo"><block_content>
        		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

        	<expr_stmt><expr><name>restype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        	<expr_stmt><expr><name>grpcl</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        	<expr_stmt><expr><name>ressortgroupref</name><operator>++</operator></expr>;</expr_stmt>

        	<if_stmt><if>if <condition>(<expr><name><name>tbl</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
        	<block>{<block_content>
        		<expr_stmt><expr><name>ent</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varoattno</name></name></expr></argument>,
        							  <argument><expr><call><name>get_relid_attribute_name</name><argument_list>(<argument><expr><name><name>tbl</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varoattno</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        	</block_content>}</block></if>
        	<else>else
        	<block>{<block_content>
        		<decl_stmt><decl><type><name>int</name></type> <name>plan_id</name></decl>;</decl_stmt>
        		<decl_stmt><decl><type><name>int</name></type> <name>ndx</name></decl>;</decl_stmt>
        		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        		<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>cte_plan</name></decl>;</decl_stmt>
        		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>cte_ent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        		<comment type="block">/*
        		 * Note: cte_plan_ids can be shorter than cteList, if we are still working
        		 * on planning the CTEs (ie, this is a side-reference from another CTE).
        		 * So we mustn't use forboth here.
        		 */</comment>
        		<expr_stmt><expr><name>ndx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>root-&gt;parse-&gt;cteList</argument>)</argument_list></macro>
        		<block>{<block_content>
        			<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>, <argument><expr><name><name>tbl</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        				<break>break;</break></block_content></block></if></if_stmt>
        			<expr_stmt><expr><name>ndx</name><operator>++</operator></expr>;</expr_stmt>
        		</block_content>}</block>
        		<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* shouldn't happen */</comment>
        			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>tbl</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        		<if_stmt><if>if <condition>(<expr><name>ndx</name> <operator>&gt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cte_plan_ids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find plan for CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>tbl</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        		<expr_stmt><expr><name>plan_id</name> <operator>=</operator> <call><name>list_nth_int</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>cte_plan_ids</name></name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        		<expr_stmt><expr><name>cte_plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><call><name>list_nth_cell</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name>plan_id</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        		<expr_stmt><expr><name>cte_ent</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><call><name>list_nth_cell</name><argument_list>(<argument><expr><name><name>cte_plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        		<expr_stmt><expr><name>ent</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varoattno</name></name></expr></argument>, <argument><expr><name><name>cte_ent</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        	</block_content>}</block></else></if_stmt>

        	<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name>ressortgroupref</name></expr>;</expr_stmt>

        	<expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        	<expr_stmt><expr><name>varno</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        	<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>varno</name></expr>;</expr_stmt>

        	<comment type="block">/* determine the eqop and optional sortop */</comment>
        	<expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><name>restype</name></expr></argument>,
        							 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
        							 <argument><expr><operator>&amp;</operator><name>sortop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eqop</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
        							 <argument><expr><operator>&amp;</operator><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        	<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>=</operator> <name>ressortgroupref</name></expr>;</expr_stmt>
        	<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>eqop</name></name> <operator>=</operator> <name>eqop</name></expr>;</expr_stmt>
        	<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>sortop</name></name> <operator>=</operator> <name>sortop</name></expr>;</expr_stmt>
        	<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* OK with or without sortop */</comment>
        	<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>hashable</name></expr>;</expr_stmt>

        	<expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>, <argument><expr><name>grpcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <comment type="block">/*
         * If we got Aggregation clause, since there is only one TargetList,
         * then we can use JOIN_LEFT_SEMI over JOIN_LEFT/JOIN_LEFT_SCALAR to
         * save more costs.
         */</comment>
        <expr_stmt><expr><name>finalJoinType</name> <operator>=</operator> <name>JOIN_LEFT_SEMI</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Move sub-select to the parent query.
	 */</comment>
	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><name>subselect</name></expr></argument>,
										<argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"TARGETLIST_subquery"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>true</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Form join node.
	 */</comment>
	<expr_stmt><expr><name>joinExpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>finalJoinType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>isNatural</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>jointree</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>usingClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>alias</name></name>   <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* we don't need an RTE for it */</comment>
	<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>quals</name></name>   <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Wrap join node in FromExpr as required. */</comment>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>joinExpr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build a Var pointing to the subquery */</comment>
	<expr_stmt><expr><name>target</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>makeVarFromTargetEntry</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>,
											<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add Coalesce(count,0) */</comment>
    <if_stmt><if>if <condition>(<expr><name>count_agg</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>coalesce</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>constExpr</name> <init>= <expr><call><name>makeConst</name><argument_list>(<argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr></argument>,
        							 <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>coalesce</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>constExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>coalesce</name><operator>-&gt;</operator><name>coalescetype</name></name> <operator>=</operator> <name>INT8OID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>target</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>coalesce</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

	<comment type="block">/* Replace sublink node with Result. */</comment>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>substitute_sublink_with_node</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
													   <argument><expr><name>sublink</name></expr></argument>,
													   <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>convert_OR_EXIST_sublink_to_join</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>jtlink</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>joinExpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctColums</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>joinClause</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>subselect</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator><name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>whereClause</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NullTest</name> <modifier>*</modifier></type><name>ntest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fake_colnames</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rtindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>subrtindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ressortgroupref</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>next_attno</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>EXISTS_SUBLINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>subselect</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>subselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>simplify_EXISTS_query</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>whereClause</name> <operator>=</operator> <name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><name>subselect</name></expr></argument>,
										<argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"EXIST_subquery"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>false</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>next_attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator>
		<call><name>get_or_exist_subquery_targetlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>whereClause</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>distinctColums</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>joinClause</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ressortgroupref</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>distinctColums</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>sortop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>eqop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>hashable</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>restype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grpcl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>append_var_to_subquery_targetlist</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>,
                                                                  <argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>restype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><name>restype</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>sortop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eqop</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ressortgroupref</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name>ressortgroupref</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>grpcl</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>=</operator> <name>ressortgroupref</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>eqop</name></name> <operator>=</operator> <name>eqop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>sortop</name></name> <operator>=</operator> <name>sortop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* OK with or without sortop */</comment>
		<expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>hashable</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>, <argument><expr><name>grpcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

	<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><operator>(</operator><call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>expr</name></expr></argument>,
																			<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
																			<argument><expr><name>NULL</name></expr></argument>,
																			<argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>subselect-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>fake_colnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fake_colnames</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"fake"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"EXIST_subquery"</literal></expr></argument>, <argument><expr><name>fake_colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>joinExpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>JOIN_LEFT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>isNatural</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>*</operator><name>jtlink</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>rtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>usingClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* we don't need an RTE for it */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>joinClause</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name>joinClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>make_andclause</name><argument_list>(<argument><expr><name>joinClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>jtlink</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>joinExpr</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>subrtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>subrtindex</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><name><name>joinExpr</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ntest</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>makeVar</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>,
								 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>BOOLOID</name></expr></argument>,
								 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
								 <argument><expr><name>InvalidOid</name></expr></argument>,
								 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name>IS_NOT_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ntest</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>ntest</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>check_or_exist_qual_pullupable</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>and_clause</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name> <argument_list>(<argument>l</argument>, <argument>((BoolExpr *)node)-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_or_exist_qual_pullupable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>or_clause</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>pull_vars_of_level</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NIL</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pull_vars_of_level</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* If upper_var, only support upper_var = local_var */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pull_vars_of_level</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type> <name>opertup</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>operform</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>oprname</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal> <operator>||</operator>
				<operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>opertup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				
			<expr_stmt><expr><name>operform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator><call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>oprname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* only support simple equal */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>check_or_exist_sublink_pullupable</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>    <modifier>*</modifier></type><name>whereClause</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>   <modifier>*</modifier></type><name>subselect</name></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	
	<expr_stmt><expr><name>subselect</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator><call><name>copyObject</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>node</name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>subselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subselect</name><operator>-&gt;</operator><name>cteList</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		
	<if_stmt><if>if <condition>(<expr><name><name>subselect</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>simplify_EXISTS_query</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subselect</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		
	<if_stmt><if>if <condition>(<expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>whereClause</name> <operator>=</operator> <name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>subselect</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
  * try to convert all sublink to join or new query
  */</comment>
<function><type><name>JoinExpr</name> <modifier>*</modifier></type>
<name>convert_ALL_sublink_to_join</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name></decl></parameter>,
                               <parameter><decl><type><name>Relids</name></type> <name>available_rels</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>subselect</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>whereClause</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>quals</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Var</name>         <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Param</name>       <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>varno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>rtindex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relids</name></type>        <name>upper_varnos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subquery_vars</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>       <name>use_max</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>ent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>nEnt</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>joinquals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>subselect</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator><call><name>copyObject</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* subquery must be simple query */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>simplify_ALL_query</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subselect</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* we can only handle '&gt;' and '&lt;' in testexpr now.. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>opertup</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>operform</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>oprname</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OpExpr</name>     <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>opertup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
        
        <expr_stmt><expr><name>operform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>oprname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>use_max</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>, <argument><expr><literal type="string">"&lt;"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>use_max</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>var</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>param</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>expr-&gt;args</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name>arg</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>param</name> <operator>=</operator> <operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator><name>arg</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>var</name> <operator>||</operator> <operator>!</operator><name>param</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>

    <comment type="block">/* subquery must return one column */</comment>
    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>subselect-&gt;targetList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>nEnt</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>ent</name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
    </block_content>}</block>

    <if_stmt><if>if <condition>(<expr><name>nEnt</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    
    <comment type="block">/*
     * The test expression must contain some Vars of the parent query, else
     * it's not gonna be a join.  (Note that it won't have Vars referring to
     * the subquery, rather Params.)
     */</comment>
    <expr_stmt><expr><name>upper_varnos</name> <operator>=</operator> <call><name>pull_varnos</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>upper_varnos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * However, it can't refer to anything outside available_rels.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>upper_varnos</name></expr></argument>, <argument><expr><name>available_rels</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * The combining operators and left-hand expressions mustn't be volatile.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* correlated subquery must contain some vars of parent query */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subselect</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>whereClause</name> <operator>=</operator> <name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/* vars of parent query must be in whereclause */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subselect</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>upper_varnos</name> <operator>=</operator> <call><name>pull_varnos_of_level</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>upper_varnos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* whereclause contains vars from different parent query */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>upper_varnos</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    
        <comment type="block">/*
         * However, it can't refer to anything outside available_rels.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>upper_varnos</name></expr></argument>, <argument><expr><name>available_rels</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* process 'op' and 'bool' expr only */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>contain_notexpr_or_neopexpr</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>joinquals</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* we can not handle correlated subquery with groupby now. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>subselect</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>joinquals</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>subselect</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* 
              * whereclause can only be 'and' expr and 'op =' expr , this
              * has been checked before.
              */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>  <name>ressortgroupref</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>vars</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>OpExpr</name>     <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator><call><name>copyObject</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            
            <expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>pull_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>joinquals</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* construct groupby clause */</comment>
            <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>vars</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>sortop</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>eqop</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>        <name>hashable</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>         <name>restype</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grpcl</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>TargetEntry</name>     <modifier>*</modifier></type><name>tent</name></decl>;</decl_stmt>
            
                <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator><call><name>list_nth</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>tbl</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
                
                <expr_stmt><expr><name>restype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>grpcl</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>ressortgroupref</name><operator>++</operator></expr>;</expr_stmt>

                <expr_stmt><expr><name>tent</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varoattno</name></name></expr></argument>, <argument><expr><call><name>get_relid_attribute_name</name><argument_list>(<argument><expr><name><name>tbl</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varoattno</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>tent</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name>ressortgroupref</name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>tent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>varno</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>tent</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>varno</name></expr>;</expr_stmt>

                <comment type="line">//var-&gt;varattno = var-&gt;varoattno = varno;</comment>

                <comment type="block">/* determine the eqop and optional sortop */</comment>
                <expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><name>restype</name></expr></argument>,
                                         <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>sortop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eqop</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>=</operator> <name>ressortgroupref</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>eqop</name></name> <operator>=</operator> <name>eqop</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>sortop</name></name> <operator>=</operator> <name>sortop</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* OK with or without sortop */</comment>
                <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>hashable</name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>, <argument><expr><name>grpcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>

            <expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>OffsetVarNodes</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                        <argument><expr><name>subselect</name></expr></argument>,
                                        <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"ALL_subquery"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><name>false</name></expr></argument>,
                                        <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Form a RangeTblRef for the pulled-up sub-select.
             */</comment>
            <expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>add_vars_to_subquery_targetlist</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>, <argument><expr><name>subselect</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>list_delete</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><call><name>makeVarFromTargetEntry</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>quals</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * And finally, build the JoinExpr node.
             */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>JOIN_INNER</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>isNatural</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>        <comment type="block">/* caller must fill this in */</comment>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rtr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>usingClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>quals</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>        <comment type="block">/* we don't need an RTE for it */</comment>

            <return>return <expr><name>result</name></expr>;</return>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* 
              * whereclause can only be 'and' expr and 'op =' expr , this
              * has been checked before.
              */</comment>
            <decl_stmt><decl><type><name>Aggref</name>       <modifier>*</modifier></type><name>aggref</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>aggfuncname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>FuncDetailCode</name></type> <name>fdresult</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>        <name><name>actual_arg_types</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>rettype</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>funcid</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>declared_arg_types</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>argdefaults</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>retset</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>nvargs</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>vatype</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>  <name>ressortgroupref</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>vars</name> <init>= <expr><call><name>pull_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>joinquals</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>OpExpr</name>     <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator><call><name>copyObject</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TargetEntry</name>     <modifier>*</modifier></type><name>tent</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <comment type="block">/* construct groupby clause */</comment>
            <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>vars</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>sortop</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>eqop</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>        <name>hashable</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>         <name>restype</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grpcl</name></decl>;</decl_stmt>
                
                
                <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator><call><name>list_nth</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>tbl</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
                
                <expr_stmt><expr><name>restype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>grpcl</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>ressortgroupref</name><operator>++</operator></expr>;</expr_stmt>

                <expr_stmt><expr><name>tent</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varoattno</name></name></expr></argument>, <argument><expr><call><name>get_relid_attribute_name</name><argument_list>(<argument><expr><name><name>tbl</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varoattno</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>tent</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name>ressortgroupref</name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>tent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>varno</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>tent</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>varno</name></expr>;</expr_stmt>

                <comment type="line">//var-&gt;varattno = var-&gt;varoattno = varno;</comment>

                <comment type="block">/* determine the eqop and optional sortop */</comment>
                <expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><name>restype</name></expr></argument>,
                                         <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>sortop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eqop</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>=</operator> <name>ressortgroupref</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>eqop</name></name> <operator>=</operator> <name>eqop</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>sortop</name></name> <operator>=</operator> <name>sortop</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* OK with or without sortop */</comment>
                <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>hashable</name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>, <argument><expr><name>grpcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>

            <comment type="block">/* have only one entry for rtable */</comment>
            <expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><name><name>actual_arg_types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>ent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* construct agg function */</comment>
            <if_stmt><if>if <condition>(<expr><name>use_max</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>aggfuncname</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>aggfuncname</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"max"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>aggfuncname</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>aggfuncname</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"min"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name>fdresult</name> <operator>=</operator> <call><name>func_get_detail</name><argument_list>(<argument><expr><name>aggfuncname</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
                           <argument><expr><name>actual_arg_types</name></expr></argument>,
                           <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name>funcid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rettype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>retset</name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name>nvargs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vatype</name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name>declared_arg_types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argdefaults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>fdresult</name> <operator>!=</operator> <name>FUNCDETAIL_AGGREGATE</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

            <comment type="block">/* make targetlist of subquery */</comment>
            <expr_stmt><expr><name>aggref</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>=</operator> <name>funcid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <name>rettype</name></expr>;</expr_stmt>
            <comment type="block">/* aggcollid and inputcollid will be set by parse_collate.c */</comment>
            <expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>    <comment type="block">/* will be set by planner */</comment>
            <expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>=</operator> <name>AGGKIND_NORMAL</name></expr>;</expr_stmt>
            <comment type="block">/* agglevelsup will be set by transformAggregateCall */</comment>
            <expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>AGGSPLIT_SIMPLE</name></expr>;</expr_stmt> <comment type="block">/* planner might change this */</comment>

            <expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggargtypes</name></name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>ent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name><name>ent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>use_max</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>tent</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>aggref</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"max"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>tent</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>aggref</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"min"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            
            <expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>tent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>varno</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>tent</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>varno</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>offset</name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>OffsetVarNodes</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                        <argument><expr><name>subselect</name></expr></argument>,
                                        <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"ALL_subquery"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><name>false</name></expr></argument>,
                                        <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Form a RangeTblRef for the pulled-up sub-select.
             */</comment>
            <expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>add_vars_to_subquery_targetlist</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>, <argument><expr><name>subselect</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>list_delete</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><call><name>makeVarFromTargetEntry</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>tent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>quals</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * And finally, build the JoinExpr node.
             */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>JOIN_INNER</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>isNatural</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>        <comment type="block">/* caller must fill this in */</comment>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rtr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>usingClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>quals</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>        <comment type="block">/* we don't need an RTE for it */</comment>

            <return>return <expr><name>result</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <comment type="block">/* uncorrelated subquery */</comment>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
          * if subquery has aggs without groupby, subquery will get one rows output,
          * and we can transform to join directly
          */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>subselect</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>subselect</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Create a dummy ParseState for addRangeTableEntryForSubquery */</comment>
            <expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                <argument><expr><name>subselect</name></expr></argument>,
                                <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"ALL_subquery"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>false</name></expr></argument>,
                                <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Form a RangeTblRef for the pulled-up sub-select.
             */</comment>
            <expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>

            <comment type="block">/*
             * Build a list of Vars representing the subselect outputs.
             */</comment>
            <expr_stmt><expr><name>subquery_vars</name> <operator>=</operator> <call><name>generate_subquery_vars</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                   <argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                                   <argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Build the new join's qual expression, replacing Params with these Vars.
             */</comment>
            <expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>convert_testexpr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>subquery_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * And finally, build the JoinExpr node.
             */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>JOIN_INNER</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>isNatural</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>        <comment type="block">/* caller must fill this in */</comment>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rtr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>usingClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>quals</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>        <comment type="block">/* we don't need an RTE for it */</comment>
            
            <return>return <expr><name>result</name></expr>;</return>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
              * subquery has groupby, we have to make decision according to
              * subquery's testexpr.
              * if it is '&gt;', we use 'max' instead of ALL;
              * and if it is '&lt;', we choose 'min'.
              */</comment>

            <comment type="block">/* constrcut new query instead of ALL sublink */</comment>
            <decl_stmt><decl><type><name>Aggref</name>       <modifier>*</modifier></type><name>aggref</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>aggfuncname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>FuncDetailCode</name></type> <name>fdresult</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>        <name><name>actual_arg_types</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Var</name>        <modifier>*</modifier></type><name>aggArg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>rettype</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>funcid</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>declared_arg_types</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>argdefaults</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>retset</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>nvargs</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>vatype</name></decl>;</decl_stmt>
            
            <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name><name>subselect</name><operator>-&gt;</operator><name>commandType</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>canSetTag</name></name>   <operator>=</operator> <name><name>subselect</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>querySource</name></name> <operator>=</operator> <name><name>subselect</name><operator>-&gt;</operator><name>querySource</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>hasAggs</name></name>     <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <comment type="block">/* Create a dummy ParseState for addRangeTableEntryForSubquery */</comment>
            <expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                <argument><expr><name>subselect</name></expr></argument>,
                                <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"ALL_subquery"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>false</name></expr></argument>,
                                <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Form a RangeTblRef for the pulled-up sub-select.
             */</comment>
            <expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>rtr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>aggArg</name> <operator>=</operator> <call><name>makeVarFromTargetEntry</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>actual_arg_types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>aggArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* construct agg function */</comment>
            <if_stmt><if>if <condition>(<expr><name>use_max</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>aggfuncname</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>aggfuncname</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"max"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>aggfuncname</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>aggfuncname</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"min"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name>fdresult</name> <operator>=</operator> <call><name>func_get_detail</name><argument_list>(<argument><expr><name>aggfuncname</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>aggArg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
                           <argument><expr><name>actual_arg_types</name></expr></argument>,
                           <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name>funcid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rettype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>retset</name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name>nvargs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vatype</name></expr></argument>,
                           <argument><expr><operator>&amp;</operator><name>declared_arg_types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argdefaults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>fdresult</name> <operator>!=</operator> <name>FUNCDETAIL_AGGREGATE</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

            <comment type="block">/* make targetlist of newquery */</comment>
            <expr_stmt><expr><name>aggref</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>=</operator> <name>funcid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggtype</name></name> <operator>=</operator> <name>rettype</name></expr>;</expr_stmt>
            <comment type="block">/* aggcollid and inputcollid will be set by parse_collate.c */</comment>
            <expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>    <comment type="block">/* will be set by planner */</comment>
            <expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggkind</name></name> <operator>=</operator> <name>AGGKIND_NORMAL</name></expr>;</expr_stmt>
            <comment type="block">/* agglevelsup will be set by transformAggregateCall */</comment>
            <expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>AGGSPLIT_SIMPLE</name></expr>;</expr_stmt> <comment type="block">/* planner might change this */</comment>

            <expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggargtypes</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggargtypes</name></name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>aggArg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>aggArg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>use_max</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>aggref</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"max"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>aggref</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"min"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                <argument><expr><name>query</name></expr></argument>,
                                <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"temp"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>false</name></expr></argument>,
                                <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Form a RangeTblRef for the pulled-up sub-select.
             */</comment>
            <expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>

            <comment type="block">/*
             * Build a list of Vars representing the subselect outputs.
             */</comment>
            <expr_stmt><expr><name>subquery_vars</name> <operator>=</operator> <call><name>generate_subquery_vars</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                   <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                                   <argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Build the new join's qual expression, replacing Params with these Vars.
             */</comment>
            <expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>list_delete</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator><name>quals</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator><name>quals</name><operator>)</operator><operator>-&gt;</operator><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator><name>quals</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>subquery_vars</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>            
            quals = convert_testexpr(root, sublink-&gt;testexpr, subquery_vars);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/*
             * And finally, build the JoinExpr node.
             */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>JOIN_INNER</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>isNatural</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>        <comment type="block">/* caller must fill this in */</comment>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rtr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>usingClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>quals</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>        <comment type="block">/* we don't need an RTE for it */</comment>
            
            <return>return <expr><name>result</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
 * simplify_EXISTS_query: remove any useless stuff in an EXISTS's subquery
 *
 * The only thing that matters about an EXISTS query is whether it returns
 * zero or more than zero rows.  Therefore, we can remove certain SQL features
 * that won't affect that.  The only part that is really likely to matter in
 * typical usage is simplifying the targetlist: it's a common habit to write
 * "SELECT * FROM" even though there is no need to evaluate any columns.
 *
 * Note: by suppressing the targetlist we could cause an observable behavioral
 * change, namely that any errors that might occur in evaluating the tlist
 * won't occur, nor will other side-effects of volatile functions.  This seems
 * unlikely to bother anyone in practice.
 *
 * Returns TRUE if was able to discard the targetlist, else FALSE.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>simplify_EXISTS_query</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/*
     * We don't try to simplify at all if the query uses set operations,
     * aggregates, grouping sets, SRFs, modifying CTEs, HAVING, OFFSET, or FOR
     * UPDATE/SHARE; none of these seem likely in normal usage and their
     * possible effects are complex.  (Note: we could ignore an "OFFSET 0"
     * clause, but that traditionally is used as an optimization fence, so we
     * don't.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>hasModifyingCTE</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>rowMarks</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * LIMIT with a constant positive (or NULL) value doesn't affect the
     * semantics of EXISTS, so let's ignore such clauses.  This is worth doing
     * because people accustomed to certain other DBMSes may be in the habit
     * of writing EXISTS(SELECT ... LIMIT 1) as an optimization.  If there's a
     * LIMIT with anything else as argument, though, we can't simplify.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * The LIMIT clause has not yet been through eval_const_expressions,
         * so we have to apply that here.  It might seem like this is a waste
         * of cycles, since the only case plausibly worth worrying about is
         * "LIMIT 1" ... but what we'll actually see is "LIMIT int8(1::int4)",
         * so we have to fold constants or we're not going to recognize it.
         */</comment>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Const</name>       <modifier>*</modifier></type><name>limit</name></decl>;</decl_stmt>

        <comment type="block">/* Might as well update the query if we simplified the clause. */</comment>
        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>limit</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>limit</name><operator>-&gt;</operator><name>consttype</name></name> <operator>==</operator> <name>INT8OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>limit</name><operator>-&gt;</operator><name>constisnull</name></name> <operator>&amp;&amp;</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>limit</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* Whether or not the targetlist is safe, we can drop the LIMIT. */</comment>
        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Otherwise, we can throw away the targetlist, as well as any GROUP,
     * WINDOW, DISTINCT, and ORDER BY clauses; none of those clauses will
     * change a nonzero-rows result to zero rows or vice versa.  (Furthermore,
     * since our parsetree representation of these clauses depends on the
     * targetlist, we'd better throw them away if we drop the targetlist.)
     */</comment>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>windowClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * convert_EXISTS_to_ANY: try to convert EXISTS to a hashable ANY sublink
 *
 * The subselect is expected to be a fresh copy that we can munge up,
 * and to have been successfully passed through simplify_EXISTS_query.
 *
 * On success, the modified subselect is returned, and we store a suitable
 * upper-level test expression at *testexpr, plus a list of the subselect's
 * output Params at *paramIds.  (The test expression is already Param-ified
 * and hence need not go through convert_testexpr, which is why we have to
 * deal with the Param IDs specially.)
 *
 * On failure, returns NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>convert_EXISTS_to_ANY</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subselect</name></decl></parameter>,
                      <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>testexpr</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>paramIds</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>whereClause</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>leftargs</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>rightargs</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>opids</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>opcollations</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>newWhere</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>tlist</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>testlist</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>paramids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>rc</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>oc</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>cc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>resno</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Query must not require a targetlist, since we have to insert a new one.
     * Caller should have dealt with the case already.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Separate out the WHERE clause.  (We could theoretically also remove
     * top-level plain JOIN/ON clauses, but it's probably not worth the
     * trouble.)
     */</comment>
    <expr_stmt><expr><name>whereClause</name> <operator>=</operator> <name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * The rest of the sub-select must not refer to any Vars of the parent
     * query.  (Vars of higher levels should be okay, though.)
     *
     * Note: we need not check for Aggrefs separately because we know the
     * sub-select is as yet unoptimized; any uplevel Aggref must therefore
     * contain an uplevel Var reference.  This is not the case below ...
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subselect</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We don't risk optimizing if the WHERE clause is volatile, either.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Clean up the WHERE clause by doing const-simplification etc on it.
     * Aside from simplifying the processing we're about to do, this is
     * important for being able to pull chunks of the WHERE clause up into the
     * parent query.  Since we are invoked partway through the parent's
     * preprocess_expression() work, earlier steps of preprocess_expression()
     * wouldn't get applied to the pulled-up stuff unless we do them here. For
     * the parts of the WHERE clause that get put back into the child query,
     * this work is partially duplicative, but it shouldn't hurt.
     *
     * Note: we do not run flatten_join_alias_vars.  This is OK because any
     * parent aliases were flattened already, and we're not going to pull any
     * child Vars (of any description) into the parent.
     *
     * Note: passing the parent's root to eval_const_expressions is
     * technically wrong, but we can get away with it since only the
     * boundParams (if any) are used, and those would be the same in a
     * subroot.
     */</comment>
    <expr_stmt><expr><name>whereClause</name> <operator>=</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>whereClause</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>canonicalize_qual</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>whereClause</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We now have a flattened implicit-AND list of clauses, which we try to
     * break apart into "outervar = innervar" hash clauses. Anything that
     * can't be broken apart just goes back into the newWhere list.  Note that
     * we aren't trying hard yet to ensure that we have only outer or only
     * inner on each side; we'll check that if we get to the end.
     */</comment>
    <expr_stmt><expr><name>leftargs</name> <operator>=</operator> <name>rightargs</name> <operator>=</operator> <name>opids</name> <operator>=</operator> <name>opcollations</name> <operator>=</operator> <name>newWhere</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>(List *) whereClause</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>OpExpr</name>       <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>hash_ok_operator</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>leftarg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>rightarg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><name>leftarg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>leftargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>leftargs</name></expr></argument>, <argument><expr><name>leftarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rightargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rightargs</name></expr></argument>, <argument><expr><name>rightarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>opids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>opids</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>opcollations</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>opcollations</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><name>rightarg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * We must commute the clause to put the outer var on the
                 * left, because the hashing code in nodeSubplan.c expects
                 * that.  This probably shouldn't ever fail, since hashable
                 * operators ought to have commutators, but be paranoid.
                 */</comment>
                <expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <call><name>get_commutator</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>hash_ok_operator</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>leftargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>leftargs</name></expr></argument>, <argument><expr><name>rightarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>rightargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rightargs</name></expr></argument>, <argument><expr><name>leftarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>opids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>opids</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>opcollations</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>opcollations</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* If no commutator, no chance to optimize the WHERE clause */</comment>
                <return>return <expr><name>NULL</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Couldn't handle it as a hash clause */</comment>
        <expr_stmt><expr><name>newWhere</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newWhere</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * If we didn't find anything we could convert, fail.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>leftargs</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * There mustn't be any parent Vars or Aggs in the stuff that we intend to
     * put back into the child query.  Note: you might think we don't need to
     * check for Aggs separately, because an uplevel Agg must contain an
     * uplevel Var in its argument.  But it is possible that the uplevel Var
     * got optimized away by eval_const_expressions.  Consider
     *
     * SUM(CASE WHEN false THEN uplevelvar ELSE 0 END)
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newWhere</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rightargs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>&amp;&amp;</operator>
        <operator>(</operator><call><name>contain_aggs_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newWhere</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator>
         <call><name>contain_aggs_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rightargs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * And there can't be any child Vars in the stuff we intend to pull up.
     * (Note: we'd need to check for child Aggs too, except we know the child
     * has no aggs at all because of simplify_EXISTS_query's check. The same
     * goes for window functions.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>leftargs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Also reject sublinks in the stuff we intend to pull up.  (It might be
     * possible to support this, but doesn't seem worth the complication.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>contain_subplans</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>leftargs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Okay, adjust the sublevelsup in the stuff we're pulling up.
     */</comment>
    <expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>leftargs</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Put back any child-level-only WHERE clauses.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>newWhere</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_ands_explicit</name><argument_list>(<argument><expr><name>newWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Build a new targetlist for the child that emits the expressions we
     * need.  Concurrently, build a testexpr for the parent using Params to
     * reference the child outputs.  (Since we generate Params directly here,
     * there will be no need to convert the testexpr in build_subplan.)
     */</comment>
    <expr_stmt><expr><name>tlist</name> <operator>=</operator> <name>testlist</name> <operator>=</operator> <name>paramids</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>resno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <comment type="block">/* there's no "forfour" so we have to chase one of the lists manually */</comment>
    <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>opcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>forthree</name><argument_list>(<argument>lc</argument>, <argument>leftargs</argument>, <argument>rc</argument>, <argument>rightargs</argument>, <argument>oc</argument>, <argument>opids</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>leftarg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>rightarg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>opid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>oc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>opcollation</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Param</name>       <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>generate_new_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                   <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>rightarg</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>rightarg</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>rightarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
                        <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>rightarg</name></expr></argument>,
                                        <argument><expr><name>resno</name><operator>++</operator></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>,
                                        <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>testlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>testlist</name></expr></argument>,
                           <argument><expr><call><name>make_opclause</name><argument_list>(<argument><expr><name>opid</name></expr></argument>, <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>leftarg</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>param</name></expr></argument>,
                                         <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>opcollation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>paramids</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>paramids</name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Put everything where it should go, and we're done */</comment>
    <expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>testexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_ands_explicit</name><argument_list>(<argument><expr><name>testlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>paramIds</name> <operator>=</operator> <name>paramids</name></expr>;</expr_stmt>

    <return>return <expr><name>subselect</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Replace correlation vars (uplevel vars) with Params.
 *
 * Uplevel PlaceHolderVars and aggregates are replaced, too.
 *
 * Note: it is critical that this runs immediately after SS_process_sublinks.
 * Since we do not recurse into the arguments of uplevel PHVs and aggregates,
 * they will get copied to the appropriate subplan args list in the parent
 * query with uplevel vars not replaced by Params, but only adjusted in level
 * (see replace_outer_placeholdervar and replace_outer_agg).  That's exactly
 * what we want for the vars of the parent level --- but if a PHV's or
 * aggregate's argument contains any further-up variables, they have to be
 * replaced with Params in their turn. That will happen when the parent level
 * runs SS_replace_correlation_vars.  Therefore it must do so after expanding
 * its sublinks to subplans.  And we don't want any steps in between, else
 * those steps would never get applied to the argument expressions, either in
 * the parent or the child level.
 *
 * Another fairly tricky thing going on here is the handling of SubLinks in
 * the arguments of uplevel PHVs/aggregates.  Those are not touched inside the
 * intermediate query level, either.  Instead, SS_process_sublinks recurses on
 * them after copying the PHV or Aggref expression into the parent plan level
 * (this is actually taken care of in build_subplan).
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>SS_replace_correlation_vars</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* No setup needed for tree walk, so away we go */</comment>
    <return>return <expr><call><name>replace_correlation_vars_mutator</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>replace_correlation_vars_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>varlevelsup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>replace_outer_var</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>phlevelsup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>replace_outer_placeholdervar</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                         <argument><expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>agglevelsup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>replace_outer_agg</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>agglevelsup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>replace_outer_grouping</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
                                   <argument><expr><name>replace_correlation_vars_mutator</name></expr></argument>,
                                   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>root</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Expand SubLinks to SubPlans in the given expression.
 *
 * The isQual argument tells whether or not this expression is a WHERE/HAVING
 * qualifier expression.  If it is, any sublinks appearing at top level need
 * not distinguish FALSE from UNKNOWN return values.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>SS_process_sublinks</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isQual</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>process_sublinks_context</name></type> <name>context</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>isTopQual</name></name> <operator>=</operator> <name>isQual</name></expr>;</expr_stmt>
    <return>return <expr><call><name>process_sublinks_mutator</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>process_sublinks_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>process_sublinks_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>process_sublinks_context</name></type> <name>locContext</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>locContext</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>sublink</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>testexpr</name></decl>;</decl_stmt>

        <comment type="block">/*
         * First, recursively process the lefthand-side expressions, if any.
         * They're not top-level anymore.
         */</comment>
        <expr_stmt><expr><name><name>locContext</name><operator>.</operator><name>isTopQual</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>testexpr</name> <operator>=</operator> <call><name>process_sublinks_mutator</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>locContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Now build the SubPlan node and make the expr to return.
         */</comment>
        <return>return <expr><call><name>make_subplan</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
                            <argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>,
                            <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name></expr></argument>,
                            <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkId</name></name></expr></argument>,
                            <argument><expr><name>testexpr</name></expr></argument>,
                            <argument><expr><name><name>context</name><operator>-&gt;</operator><name>isTopQual</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Don't recurse into the arguments of an outer PHV or aggregate here. Any
     * SubLinks in the arguments have to be dealt with at the outer query
     * level; they'll be handled when build_subplan collects the PHV or Aggref
     * into the arguments to be passed down to the current subplan.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>phlevelsup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>agglevelsup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We should never see a SubPlan expression in the input (since this is
     * the very routine that creates 'em to begin with).  We shouldn't find
     * ourselves invoked directly on a Query, either.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>AlternativeSubPlan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Because make_subplan() could return an AND or OR clause, we have to
     * take steps to preserve AND/OR flatness of a qual.  We assume the input
     * has been AND/OR flattened and so we need no recursion here.
     *
     * (Due to the coding here, we will not get called on the List subnodes of
     * an AND; and the input is *not* yet in implicit-AND format.  So no check
     * is needed for a bare List.)
     *
     * Anywhere within the top-level AND/OR clause structure, we can tell
     * make_subplan() that NULL and FALSE are interchangeable.  So isTopQual
     * propagates down in both cases.  (Note that this is unlike the meaning
     * of "top level qual" used in most other places in Postgres.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>and_clause</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>newargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

        <comment type="block">/* Still at qual top-level */</comment>
        <expr_stmt><expr><name><name>locContext</name><operator>.</operator><name>isTopQual</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>isTopQual</name></name></expr>;</expr_stmt>

        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((BoolExpr *) node)-&gt;args</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>newarg</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>newarg</name> <operator>=</operator> <call><name>process_sublinks_mutator</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>locContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>and_clause</name><argument_list>(<argument><expr><name>newarg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>newarg</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>newarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block>
        <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_andclause</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>or_clause</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>newargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

        <comment type="block">/* Still at qual top-level */</comment>
        <expr_stmt><expr><name><name>locContext</name><operator>.</operator><name>isTopQual</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>isTopQual</name></name></expr>;</expr_stmt>

        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((BoolExpr *) node)-&gt;args</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>newarg</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>newarg</name> <operator>=</operator> <call><name>process_sublinks_mutator</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>locContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>or_clause</name><argument_list>(<argument><expr><name>newarg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>newarg</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>newarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block>
        <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_orclause</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If we recurse down through anything other than an AND or OR node, we
     * are definitely not at top qual level anymore.
     */</comment>
    <expr_stmt><expr><name><name>locContext</name><operator>.</operator><name>isTopQual</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
                                   <argument><expr><name>process_sublinks_mutator</name></expr></argument>,
                                   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>locContext</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SS_identify_outer_params - identify the Params available from outer levels
 *
 * This must be run after SS_replace_correlation_vars and SS_process_sublinks
 * processing is complete in a given query level as well as all of its
 * descendant levels (which means it's most practical to do it at the end of
 * processing the query level).  We compute the set of paramIds that outer
 * levels will make available to this level+descendants, and record it in
 * root-&gt;outer_params for use while computing extParam/allParam sets in final
 * plan cleanup.  (We can't just compute it then, because the upper levels'
 * plan_params lists are transient and will be gone by then.)
 */</comment>
<function><type><name>void</name></type>
<name>SS_identify_outer_params</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>outer_params</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>proot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If no parameters have been assigned anywhere in the tree, we certainly
     * don't need to do anything here.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>nParamExec</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Scan all query levels above this one to see which parameters are due to
     * be available from them, either because lower query levels have
     * requested them (via plan_params) or because they will be available from
     * initPlans of those levels.
     */</comment>
    <expr_stmt><expr><name>outer_params</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>proot</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>parent_root</name></name></expr>;</init> <condition><expr><name>proot</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>proot</name> <operator>=</operator> <name><name>proot</name><operator>-&gt;</operator><name>parent_root</name></name></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* Include ordinary Var/PHV/Aggref params */</comment>
        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>proot-&gt;plan_params</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PlannerParamItem</name> <modifier>*</modifier></type><name>pitem</name> <init>= <expr><operator>(</operator><name>PlannerParamItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>outer_params</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>outer_params</name></expr></argument>, <argument><expr><name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <comment type="block">/* Include any outputs of outer-level initPlans */</comment>
        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>proot-&gt;init_plans</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>initsubplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>

            <macro><name>foreach</name><argument_list>(<argument>l2</argument>, <argument>initsubplan-&gt;setParam</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>outer_params</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>outer_params</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block>
        <comment type="block">/* Include worktable ID, if a recursive query is being planned */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>proot</name><operator>-&gt;</operator><name>wt_param_id</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>outer_params</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>outer_params</name></expr></argument>, <argument><expr><name><name>proot</name><operator>-&gt;</operator><name>wt_param_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>outer_params</name></name> <operator>=</operator> <name>outer_params</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SS_charge_for_initplans - account for initplans in Path costs &amp; parallelism
 *
 * If any initPlans have been created in the current query level, they will
 * get attached to the Plan tree created from whichever Path we select from
 * the given rel.  Increment all that rel's Paths' costs to account for them,
 * and make sure the paths get marked as parallel-unsafe, since we can't
 * currently transmit initPlans to parallel workers.
 *
 * This is separate from SS_attach_initplans because we might conditionally
 * create more initPlans during create_plan(), depending on which Path we
 * select.  However, Paths that would generate such initPlans are expected
 * to have included their cost already.
 */</comment>
<function><type><name>void</name></type>
<name>SS_charge_for_initplans</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>final_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Cost</name></type>        <name>initplan_cost</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* Nothing to do if no initPlans */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>init_plans</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Compute the cost increment just once, since it will be the same for all
     * Paths.  We assume each initPlan gets run once during top plan startup.
     * This is a conservative overestimate, since in fact an initPlan might be
     * executed later than plan startup, or even not at all.
     */</comment>
    <expr_stmt><expr><name>initplan_cost</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;init_plans</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>initsubplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>initplan_cost</name> <operator>+=</operator> <name><name>initsubplan</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+</operator> <name><name>initsubplan</name><operator>-&gt;</operator><name>per_call_cost</name></name></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Now adjust the costs and parallel_safe flags.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>final_rel-&gt;pathlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+=</operator> <name>initplan_cost</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+=</operator> <name>initplan_cost</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block>

	<comment type="block">/*
	 * Forget about any partial paths and clear consider_parallel, too;
	 * they're not usable if we attached an initPlan.
	 */</comment>
	<expr_stmt><expr><name><name>final_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>final_rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* We needn't do set_cheapest() here, caller will do it */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * SS_attach_initplans - attach initplans to topmost plan node
 *
 * Attach any initplans created in the current query level to the specified
 * plan node, which should normally be the topmost node for the query level.
 * (In principle the initPlans could go in any node at or above where they're
 * referenced; but there seems no reason to put them any lower than the
 * topmost node, so we don't bother to track exactly where they came from.)
 * We do not touch the plan node's cost; the initplans should have been
 * accounted for in path costing.
 */</comment>
<function><type><name>void</name></type>
<name>SS_attach_initplans</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>initPlan</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>init_plans</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SS_finalize_plan - do final parameter processing for a completed Plan.
 *
 * This recursively computes the extParam and allParam sets for every Plan
 * node in the given plan tree.  (Oh, and RangeTblFunction.funcparams too.)
 *
 * We assume that SS_finalize_plan has already been run on any initplans or
 * subplans the plan tree could reference.
 */</comment>
<function><type><name>void</name></type>
<name>SS_finalize_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* No setup needed, just recurse through plan tree. */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>finalize_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>outer_params</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Recursive processing of all nodes in the plan tree
 *
 * gather_param is the rescan_param of an ancestral Gather/GatherMerge,
 * or -1 if there is none.
 *
 * valid_params is the set of param IDs supplied by outer plan levels
 * that are valid to reference in this plan node or its children.
 *
 * scan_params is a set of param IDs to force scan plan nodes to reference.
 * This is for EvalPlanQual support, and is always NULL at the top of the
 * recursion.
 *
 * The return value is the computed allParam set for the given Plan node.
 * This is just an internal notational convenience: we can add a child
 * plan's allParams to the set of param IDs of interest to this level
 * in the same statement that recurses to that child.
 *
 * Do not scribble on caller's values of valid_params or scan_params!
 *
 * Note: although we attempt to deal with initPlans anywhere in the tree, the
 * logic is not really right.  The problem is that a plan node might return an
 * output Param of its initPlan as a targetlist item, in which case it's valid
 * for the parent plan level to reference that same Param; the parent's usage
 * will be converted into a Var referencing the child plan node by setrefs.c.
 * But this function would see the parent's reference as out of scope and
 * complain about it.  For now, this does not matter because the planner only
 * attaches initPlans to the topmost plan node in a query level, so the case
 * doesn't arise.  If we ever merge this processing into setrefs.c, maybe it
 * can be handled more cleanly.
 */</comment>
<function><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type>
<name>finalize_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>gather_param</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>valid_params</name></decl></parameter>,
              <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>scan_params</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>finalize_primnode_context</name></type> <name>context</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>locally_added_param</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>nestloop_params</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>initExtParam</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>initSetParam</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>child_params</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>initPlan</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>    <comment type="block">/* initialize set to empty */</comment>
    <expr_stmt><expr><name>locally_added_param</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* there isn't one */</comment>
    <expr_stmt><expr><name>nestloop_params</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>        <comment type="block">/* there aren't any */</comment>

    <comment type="block">/*
     * Examine any initPlans to determine the set of external params they
     * reference and the set of output params they supply.  (We assume
     * SS_finalize_plan was run on them already.)
     */</comment>
    <expr_stmt><expr><name>initExtParam</name> <operator>=</operator> <name>initSetParam</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Usually initPlans are attached to the top level plan, but in Postgres-XL
     * we might add a RemoteSubplan plan on top the top level plan. If we don't
     * look at the initPlans, we might fail to conclude that param references
     * are valid (issue #81).
     */</comment>
    <expr_stmt><expr><name>initPlan</name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>initPlan</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>initPlan</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>RemoteSubplan</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>initPlan</name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>lefttree</name><operator>-&gt;</operator><name>initPlan</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>initPlan</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>initsubplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>initplan</name> <init>= <expr><call><name>planner_subplan_get_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>initsubplan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>initExtParam</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>initExtParam</name></expr></argument>, <argument><expr><name><name>initplan</name><operator>-&gt;</operator><name>extParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>l2</argument>, <argument>initsubplan-&gt;setParam</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>initSetParam</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>initSetParam</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block>

    <comment type="block">/* Any setParams are validly referenceable in this node and children */</comment>
    <if_stmt><if>if <condition>(<expr><name>initSetParam</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>valid_params</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>valid_params</name></expr></argument>, <argument><expr><name>initSetParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * When we call finalize_primnode, context.paramids sets are automatically
     * merged together.  But when recursing to self, we have to do it the hard
     * way.  We want the paramids set to include params in subplans as well as
     * at this level.
     */</comment>

    <comment type="block">/* Find params in targetlist and qual */</comment>
    <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check additional node-type-specific fields */</comment>
    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_Result</name></expr>:</case>
            <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Result</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>resconstantqual</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SeqScan</name></expr>:</case>
            <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SampleScan</name></expr>:</case>
            <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>SampleScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>tablesample</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_IndexScan</name></expr>:</case>
            <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>IndexScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>indexqual</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>IndexScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>indexorderby</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * we need not look at indexqualorig, since it will have the same
             * param references as indexqual.  Likewise, we can ignore
             * indexorderbyorig.
             */</comment>
            <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
            <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>indexqual</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>indexorderby</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * we need not look at indextlist, since it cannot contain Params.
             */</comment>
            <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
            <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>BitmapIndexScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>indexqual</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * we need not look at indexqualorig, since it will have the same
             * param references as indexqual.
             */</comment>
            <break>break;</break>

        <case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
            <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>BitmapHeapScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>bitmapqualorig</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_TidScan</name></expr>:</case>
            <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>TidScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>tidquals</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

		<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>sscan</name> <init>= <expr><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>subquery_params</name></decl>;</decl_stmt>

				<comment type="block">/* We must run finalize_plan on the subquery */</comment>
                <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>sscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>subquery_params</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>subroot</name><operator>-&gt;</operator><name>outer_params</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>gather_param</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>subquery_params</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>subquery_params</name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><name>gather_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>finalize_plan</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>subroot</name></name></expr></argument>, <argument><expr><name><name>sscan</name><operator>-&gt;</operator><name>subplan</name></name></expr></argument>, <argument><expr><name>gather_param</name></expr></argument>,
							  <argument><expr><name>subquery_params</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Now we can add its extParams to the parent's params */</comment>
                <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
                                                   <argument><expr><name><name>sscan</name><operator>-&gt;</operator><name>subplan</name><operator>-&gt;</operator><name>extParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* We need scan_params too, though */</comment>
                <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
                                                   <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_FunctionScan</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>FunctionScan</name> <modifier>*</modifier></type><name>fscan</name> <init>= <expr><operator>(</operator><name>FunctionScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * Call finalize_primnode independently on each function
                 * expression, so that we can record which params are
                 * referenced in each, in order to decide which need
                 * re-evaluating during rescan.
                 */</comment>
                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fscan-&gt;functions</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>finalize_primnode_context</name></type> <name>funccontext</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>funccontext</name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>funccontext</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>funccontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* remember results for execution */</comment>
                    <expr_stmt><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcparams</name></name> <operator>=</operator> <name><name>funccontext</name><operator>.</operator><name>paramids</name></name></expr>;</expr_stmt>

                    <comment type="block">/* add the function's params to the overall set */</comment>
                    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
                                                       <argument><expr><name><name>funccontext</name><operator>.</operator><name>paramids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>

                <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
                                                   <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_TableFuncScan</name></expr>:</case>
            <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>TableFuncScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>tablefunc</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ValuesScan</name></expr>:</case>
            <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>ValuesScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>values_lists</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CteScan</name></expr>:</case>
            <block>{<block_content>
                <comment type="block">/*
                 * You might think we should add the node's cteParam to
                 * paramids, but we shouldn't because that param is just a
                 * linkage mechanism for multiple CteScan nodes for the same
                 * CTE; it is never used for changed-param signaling.  What we
                 * have to do instead is to find the referenced CTE plan and
                 * incorporate its external paramids, so that the correct
                 * things will happen if the CTE references outer-level
                 * variables.  See test cases for bug #4902.  (We assume
                 * SS_finalize_plan was run on the CTE plan already.)
                 */</comment>
                <decl_stmt><decl><type><name>int</name></type>            <name>plan_id</name> <init>= <expr><operator>(</operator><operator>(</operator><name>CteScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>ctePlanId</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>cteplan</name></decl>;</decl_stmt>

                <comment type="block">/* so, do this ... */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>plan_id</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>plan_id</name></expr></argument> &gt;</argument_list></name> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find plan for CteScan referencing plan ID %d"</literal></expr></argument>,
                         <argument><expr><name>plan_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>cteplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name>plan_id</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator>
                    <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name><name>cteplan</name><operator>-&gt;</operator><name>extParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
                <comment type="block">/* ... but not this */</comment>
                <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator>
                    <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
                                   <argument><expr><operator>(</operator><operator>(</operator><name>CteScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>cteParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
                                                   <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_WorkTableScan</name></expr>:</case>
            <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator>
                <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
                               <argument><expr><operator>(</operator><operator>(</operator><name>WorkTableScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>wtParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
            <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ForeignScan</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>fscan</name> <init>= <expr><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fscan</name><operator>-&gt;</operator><name>fdw_exprs</name></name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fscan</name><operator>-&gt;</operator><name>fdw_recheck_quals</name></name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* We assume fdw_scan_tlist cannot contain Params */</comment>
                <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
                                                   <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_CustomScan</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cscan</name><operator>-&gt;</operator><name>custom_exprs</name></name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* We assume custom_scan_tlist cannot contain Params */</comment>
                <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator>
                    <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* child nodes if any */</comment>
                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>cscan-&gt;custom_plans</argument>)</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator>
                        <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
                                        <argument><expr><call><name>finalize_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                      <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><name>gather_param</name></expr></argument>,
                                                      <argument><expr><name>valid_params</name></expr></argument>,
                                                      <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_ModifyTable</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>mtplan</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

                <comment type="block">/* Force descendant scan nodes to reference epqParam */</comment>
                <expr_stmt><expr><name>locally_added_param</name> <operator>=</operator> <name><name>mtplan</name><operator>-&gt;</operator><name>epqParam</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>valid_params</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>valid_params</name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><name>locally_added_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>scan_params</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><name>locally_added_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>mtplan</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>mtplan</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>mtplan</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* exclRelTlist contains only Vars, doesn't need examination */</comment>
                <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>mtplan-&gt;plans</argument>)</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator>
                        <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
                                        <argument><expr><call><name>finalize_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                      <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><name>gather_param</name></expr></argument>,
                                                      <argument><expr><name>valid_params</name></expr></argument>,
                                                      <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
            </block_content>}</block>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <case>case <expr><name>T_RemoteQuery</name></expr>:</case>
            <comment type="line">//PGXCTODO</comment>
            <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        <case>case <expr><name>T_RemoteSubplan</name></expr>:</case>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <case>case <expr><name>T_Append</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

                <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((Append *) plan)-&gt;appendplans</argument>)</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator>
                        <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
                                        <argument><expr><call><name>finalize_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                      <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><name>gather_param</name></expr></argument>,
                                                      <argument><expr><name>valid_params</name></expr></argument>,
                                                      <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_MergeAppend</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

                <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((MergeAppend *) plan)-&gt;mergeplans</argument>)</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator>
                        <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
                                        <argument><expr><call><name>finalize_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                      <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><name>gather_param</name></expr></argument>,
                                                      <argument><expr><name>valid_params</name></expr></argument>,
                                                      <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_BitmapAnd</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

                <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((BitmapAnd *) plan)-&gt;bitmapplans</argument>)</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator>
                        <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
                                        <argument><expr><call><name>finalize_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                      <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><name>gather_param</name></expr></argument>,
                                                      <argument><expr><name>valid_params</name></expr></argument>,
                                                      <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_BitmapOr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

                <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((BitmapOr *) plan)-&gt;bitmapplans</argument>)</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator>
                        <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
                                        <argument><expr><call><name>finalize_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                      <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><name>gather_param</name></expr></argument>,
                                                      <argument><expr><name>valid_params</name></expr></argument>,
                                                      <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_NestLoop</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>joinqual</name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* collect set of params that will be passed to right child */</comment>
                <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((NestLoop *) plan)-&gt;nestParams</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>NestLoopParam</name> <modifier>*</modifier></type><name>nlp</name> <init>= <expr><operator>(</operator><name>NestLoopParam</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name>nestloop_params</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>nestloop_params</name></expr></argument>,
                                                     <argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_MergeJoin</name></expr>:</case>
            <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>joinqual</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>MergeJoin</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>mergeclauses</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_HashJoin</name></expr>:</case>
            <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>joinqual</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>HashJoin</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>hashclauses</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_Limit</name></expr>:</case>
            <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Limit</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>limitOffset</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Limit</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>limitCount</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_RecursiveUnion</name></expr>:</case>
            <comment type="block">/* child nodes are allowed to reference wtParam */</comment>
            <expr_stmt><expr><name>locally_added_param</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RecursiveUnion</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>wtParam</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>valid_params</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>valid_params</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>locally_added_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* wtParam does *not* get added to scan_params */</comment>
            <break>break;</break>

        <case>case <expr><name>T_LockRows</name></expr>:</case>
            <comment type="block">/* Force descendant scan nodes to reference epqParam */</comment>
            <expr_stmt><expr><name>locally_added_param</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>LockRows</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>epqParam</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>valid_params</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>valid_params</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>locally_added_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>scan_params</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><name>locally_added_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_Agg</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Agg</name>           <modifier>*</modifier></type><name>agg</name> <init>= <expr><operator>(</operator><name>Agg</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/*
                 * AGG_HASHED plans need to know which Params are referenced
                 * in aggregate calls.  Do a separate scan to identify them.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>finalize_primnode_context</name></type> <name>aggcontext</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name><name>aggcontext</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>aggcontext</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>finalize_agg_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name>aggcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>finalize_agg_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name>aggcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>aggParams</name></name> <operator>=</operator> <name><name>aggcontext</name><operator>.</operator><name>paramids</name></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_WindowAgg</name></expr>:</case>
            <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>WindowAgg</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>startOffset</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>WindowAgg</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>endOffset</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ProjectSet</name></expr>:</case>
        <case>case <expr><name>T_Hash</name></expr>:</case>
        <case>case <expr><name>T_Material</name></expr>:</case>
        <case>case <expr><name>T_Sort</name></expr>:</case>
        <case>case <expr><name>T_Unique</name></expr>:</case>
        <case>case <expr><name>T_Gather</name></expr>:</case>
        <case>case <expr><name>T_GatherMerge</name></expr>:</case>
        <case>case <expr><name>T_SetOp</name></expr>:</case>
        <case>case <expr><name>T_Group</name></expr>:</case>
            <comment type="block">/* no node-type-specific fields need fixing */</comment>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <comment type="block">/* Process left and right child plans, if any */</comment>
    <expr_stmt><expr><name>child_params</name> <operator>=</operator> <call><name>finalize_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                 <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>,
								 <argument><expr><name>gather_param</name></expr></argument>,
                                 <argument><expr><name>valid_params</name></expr></argument>,
                                 <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>child_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>nestloop_params</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* right child can reference nestloop_params as well as valid_params */</comment>
        <expr_stmt><expr><name>child_params</name> <operator>=</operator> <call><name>finalize_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                     <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>,
									 <argument><expr><name>gather_param</name></expr></argument>,
                                     <argument><expr><call><name>bms_union</name><argument_list>(<argument><expr><name>nestloop_params</name></expr></argument>, <argument><expr><name>valid_params</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* ... and they don't count as parameters used at my level */</comment>
        <expr_stmt><expr><name>child_params</name> <operator>=</operator> <call><name>bms_difference</name><argument_list>(<argument><expr><name>child_params</name></expr></argument>, <argument><expr><name>nestloop_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>nestloop_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* easy case */</comment>
        <expr_stmt><expr><name>child_params</name> <operator>=</operator> <call><name>finalize_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                     <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>,
									 <argument><expr><name>gather_param</name></expr></argument>,
                                     <argument><expr><name>valid_params</name></expr></argument>,
                                     <argument><expr><name>scan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>child_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Any locally generated parameter doesn't count towards its generating
     * plan node's external dependencies.  (Note: if we changed valid_params
     * and/or scan_params, we leak those bitmapsets; not worth the notational
     * trouble to clean them up.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>locally_added_param</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>,
                                          <argument><expr><name>locally_added_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Now we have all the paramids referenced in this node and children */</comment>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>valid_params</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"plan should not reference subplan's variable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * The plan node's allParam and extParam fields should include all its
     * referenced paramids, plus contributions from any child initPlans.
     * However, any setParams of the initPlans should not be present in the
     * parent node's extParams, only in its allParams.  (It's possible that
     * some initPlans have extParams that are setParams of other initPlans.)
     */</comment>

    <comment type="block">/* allParam must include initplans' extParams and setParams */</comment>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>allParam</name></name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>initExtParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>allParam</name></name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>allParam</name></name></expr></argument>, <argument><expr><name>initSetParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* extParam must include any initplan extParams */</comment>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>extParam</name></name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>initExtParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* but not any initplan setParams */</comment>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>extParam</name></name> <operator>=</operator> <call><name>bms_del_members</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>extParam</name></name></expr></argument>, <argument><expr><name>initSetParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * For speed at execution time, make sure extParam/allParam are actually
     * NULL if they are empty sets.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>extParam</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>extParam</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>allParam</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>allParam</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name><name>plan</name><operator>-&gt;</operator><name>allParam</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * finalize_primnode: add IDs of all PARAM_EXEC params appearing in the given
 * expression tree to the result set.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>finalize_primnode</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>finalize_primnode_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>paramkind</name> <operator>==</operator> <name>PARAM_EXEC</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>paramid</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>paramid</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>paramid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>false</name></expr>;</return>            <comment type="block">/* no more to do here */</comment>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><call><name>planner_subplan_get_plan</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>subparamids</name></decl>;</decl_stmt>

        <comment type="block">/* Recurse into the testexpr, but not into the Plan */</comment>
        <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Remove any param IDs of output parameters of the subplan that were
         * referenced in the testexpr.  These are not interesting for
         * parameter change signaling since we always re-evaluate the subplan.
         * Note that this wouldn't work too well if there might be uses of the
         * same param IDs elsewhere in the plan, but that can't happen because
         * generate_new_param never tries to merge params.
         */</comment>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>subplan-&gt;paramIds</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>paramids</name></name></expr></argument>,
                                               <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <comment type="block">/* Also examine args list */</comment>
        <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subplan</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Add params needed by the subplan to paramids, but excluding those
         * we will pass down to it.  (We assume SS_finalize_plan was run on
         * the subplan already.)
         */</comment>
        <expr_stmt><expr><name>subparamids</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>extParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>subplan-&gt;parParam</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>subparamids</name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name>subparamids</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_join</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>paramids</name></name></expr></argument>, <argument><expr><name>subparamids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>false</name></expr>;</return>            <comment type="block">/* no more to do here */</comment>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>finalize_primnode</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * finalize_agg_primnode: find all Aggref nodes in the given expression tree,
 * and add IDs of all PARAM_EXEC params appearing within their aggregated
 * arguments to the result set.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>finalize_agg_primnode</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>finalize_primnode_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Aggref</name>       <modifier>*</modifier></type><name>agg</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* we should not consider the direct arguments, if any */</comment>
        <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>finalize_primnode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>            <comment type="block">/* there can't be any Aggrefs below here */</comment>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>finalize_agg_primnode</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SS_make_initplan_output_param - make a Param for an initPlan's output
 *
 * The plan is expected to return a scalar value of the given type/collation.
 *
 * Note that in some cases the initplan may not ever appear in the finished
 * plan tree.  If that happens, we'll have wasted a PARAM_EXEC slot, which
 * is no big deal.
 */</comment>
<function><type><name>Param</name> <modifier>*</modifier></type>
<name>SS_make_initplan_output_param</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                              <parameter><decl><type><name>Oid</name></type> <name>resulttype</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>resulttypmod</name></decl></parameter>,
                              <parameter><decl><type><name>Oid</name></type> <name>resultcollation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>generate_new_param</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>resulttype</name></expr></argument>, <argument><expr><name>resulttypmod</name></expr></argument>, <argument><expr><name>resultcollation</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SS_make_initplan_from_plan - given a plan tree, make it an InitPlan
 *
 * We build an EXPR_SUBLINK SubPlan node and put it into the initplan
 * list for the outer query level.  A Param that represents the initplan's
 * output has already been assigned using SS_make_initplan_output_param.
 */</comment>
<function><type><name>void</name></type>
<name>SS_make_initplan_from_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                           <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
                           <parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>prm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Add the subplan and its PlannerInfo to the global lists.
     */</comment>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subroots</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subroots</name></name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create a SubPlan node and add it to the outer list of InitPlans. Note
     * it has to appear after any other InitPlans it might depend on (see
     * comments in ExecReScan).
     */</comment>
    <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>=</operator> <name>EXPR_SUBLINK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>plan_id</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>plan_name</name></name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"InitPlan %d (returns $%d)"</literal></expr></argument>,
                               <argument><expr><name><name>node</name><operator>-&gt;</operator><name>plan_id</name></name></expr></argument>, <argument><expr><name><name>prm</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>get_first_col_type</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>firstColType</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>firstColTypmod</name></name></expr></argument>,
                       <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>firstColCollation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>setParam</name></name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>init_plans</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>init_plans</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The node can't have any inputs (since it's an initplan), so the
     * parParam and args lists remain empty.
     */</comment>

    <comment type="block">/* Set costs of SubPlan using info from the plan tree */</comment>
    <expr_stmt><expr><call><name>cost_subplan</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * SS_remote_attach_initplans
 *
 * recursively look into a plantree, find any RemoteSubplan and
 * attach params id that generated from init-plan of this query.
 */</comment>
<function><type><name>void</name></type>
<name>SS_remote_attach_initplans</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>RemoteSubplan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>plan_lc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>param_lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RemoteSubplan</name> <modifier>*</modifier></type><name>rsplan</name> <init>= <expr><operator>(</operator><name>RemoteSubplan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rsplan</name><operator>-&gt;</operator><name>initPlanParams</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>plan_lc</argument>, <argument>root-&gt;init_plans</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SubPlan</name> <modifier>*</modifier></type><name>initplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>plan_lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<macro><name>foreach</name><argument_list>(<argument>param_lc</argument>, <argument>initplan-&gt;setParam</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name><name>rsplan</name><operator>-&gt;</operator><name>initPlanParams</name></name> <operator>=</operator> 
					<call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>rsplan</name><operator>-&gt;</operator><name>initPlanParams</name></name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>param_lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
	
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>sscan</name> <init>= <expr><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
			
			<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>sscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SS_remote_attach_initplans</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>subroot</name></name></expr></argument>, <argument><expr><name><name>sscan</name><operator>-&gt;</operator><name>subplan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_CustomScan</name></expr>:</case>
		<block>{<block_content>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>((CustomScan *) plan)-&gt;custom_plans</argument>)</argument_list></macro>
				<expr_stmt><expr><call><name>SS_remote_attach_initplans</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_ModifyTable</name></expr>:</case>
		<block>{<block_content>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>((ModifyTable *) plan)-&gt;plans</argument>)</argument_list></macro>
				<expr_stmt><expr><call><name>SS_remote_attach_initplans</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Append</name></expr>:</case>
		<block>{<block_content>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>((Append *) plan)-&gt;appendplans</argument>)</argument_list></macro>
				<expr_stmt><expr><call><name>SS_remote_attach_initplans</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_MergeAppend</name></expr>:</case>
		<block>{<block_content>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>((MergeAppend *) plan)-&gt;mergeplans</argument>)</argument_list></macro>
				<expr_stmt><expr><call><name>SS_remote_attach_initplans</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_BitmapAnd</name></expr>:</case>
		<block>{<block_content>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>((BitmapAnd *) plan)-&gt;bitmapplans</argument>)</argument_list></macro>
				<expr_stmt><expr><call><name>SS_remote_attach_initplans</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_BitmapOr</name></expr>:</case>
		<block>{<block_content>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>((BitmapOr *) plan)-&gt;bitmapplans</argument>)</argument_list></macro>
				<expr_stmt><expr><call><name>SS_remote_attach_initplans</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
	
	<comment type="block">/* Process left and right child plans, if any */</comment>
	<expr_stmt><expr><call><name>SS_remote_attach_initplans</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SS_remote_attach_initplans</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>var_is_nullable</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name><modifier>*</modifier></type> <name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name><operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_SPECIAL_VARNO</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>rte</name> <operator>=</operator> <operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator><call><name>list_nth</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tp</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>!</operator><operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator><call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>attnotnull</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator><call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>var_is_nullable</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
