<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/optimizer/plan/createplan.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * createplan.c
 *      Routines to create the desired plan for processing a query.
 *      Planning is complete, we just need to convert the selected
 *      Path into a Plan.
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/optimizer/plan/createplan.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/stratnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/extensible.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/placeholder.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/plancat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/predtest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/restrictinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/subselect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxcnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/prepare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* PGXC */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/nodemgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/squeue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"audit/audit_fga.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAgg.h"</cpp:file></cpp:include>
<comment type="block">/*
 * Flag bits that can appear in the flags argument of create_plan_recurse().
 * These can be OR-ed together.
 *
 * CP_EXACT_TLIST specifies that the generated plan node must return exactly
 * the tlist specified by the path's pathtarget (this overrides both
 * CP_SMALL_TLIST and CP_LABEL_TLIST, if those are set).  Otherwise, the
 * plan node is allowed to return just the Vars and PlaceHolderVars needed
 * to evaluate the pathtarget.
 *
 * CP_SMALL_TLIST specifies that a narrower tlist is preferred.  This is
 * passed down by parent nodes such as Sort and Hash, which will have to
 * store the returned tuples.
 *
 * CP_LABEL_TLIST specifies that the plan node must return columns matching
 * any sortgrouprefs specified in its pathtarget, with appropriate
 * ressortgroupref labels.  This is passed down by parent nodes such as Sort
 * and Group, which need these values to be available in their inputs.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CP_EXACT_TLIST</name></cpp:macro>        <cpp:value>0x0001</cpp:value></cpp:define>    <comment type="block">/* Plan must return specified tlist */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CP_SMALL_TLIST</name></cpp:macro>        <cpp:value>0x0002</cpp:value></cpp:define>    <comment type="block">/* Prefer narrower tlists */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CP_LABEL_TLIST</name></cpp:macro>        <cpp:value>0x0004</cpp:value></cpp:define>    <comment type="block">/* tlist must contain sortgrouprefs */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>remote_subplan_depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupOids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>mergejoin</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>child_of_gather</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>enable_group_across_query</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>enable_distributed_unique_plan</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>min_workers_of_hashjon_gather</name> <init>= <expr><name>PG_INT32_MAX</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
<decl_stmt><decl><type><name>bool</name></type> <name>has_cold_hot_table</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>create_plan_recurse</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                    <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>create_scan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>build_path_tlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>use_physical_tlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_gating_quals</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>create_gating_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
                   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>gating_quals</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>create_join_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>JoinPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>create_append_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>AppendPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>create_merge_append_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>MergeAppendPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Result</name> <modifier>*</modifier></type><name>create_result_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>ResultPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>adjust_subplan_distribution</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Distribution</name> <modifier>*</modifier></type><name>pathd</name></decl></parameter>,
                          <parameter><decl><type><name>Distribution</name> <modifier>*</modifier></type><name>subd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RemoteSubplan</name> <modifier>*</modifier></type><name>create_remotescan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                       <parameter><decl><type><name>RemoteSubPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="line">//static char *get_internal_cursor(void);</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>ProjectSet</name> <modifier>*</modifier></type><name>create_project_set_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>ProjectSetPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Material</name> <modifier>*</modifier></type><name>create_material_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>MaterialPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                     <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>create_unique_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>UniquePath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                   <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Gather</name> <modifier>*</modifier></type><name>create_gather_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>GatherPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>create_projection_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>ProjectionPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>inject_projection_plan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>parallel_safe</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Sort</name> <modifier>*</modifier></type><name>create_sort_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SortPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Group</name> <modifier>*</modifier></type><name>create_group_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>GroupPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Unique</name> <modifier>*</modifier></type><name>create_upper_unique_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>UpperUniquePath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                         <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Agg</name> <modifier>*</modifier></type><name>create_agg_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>AggPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>create_groupingsets_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>GroupingSetsPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Result</name> <modifier>*</modifier></type><name>create_minmaxagg_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>MinMaxAggPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>WindowAgg</name> <modifier>*</modifier></type><name>create_windowagg_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>WindowAggPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SetOp</name> <modifier>*</modifier></type><name>create_setop_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SetOpPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RecursiveUnion</name> <modifier>*</modifier></type><name>create_recursiveunion_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RecursiveUnionPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_column_info_for_window</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name></decl></parameter>,
                           <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
                           <parameter><decl><type><name>int</name></type> <name>numSortCols</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl></parameter>,
                           <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>partNumCols</name></decl></parameter>,
                           <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier><modifier>*</modifier></type><name>partColIdx</name></decl></parameter>,
                           <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>partOperators</name></decl></parameter>,
                           <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ordNumCols</name></decl></parameter>,
                           <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier><modifier>*</modifier></type><name>ordColIdx</name></decl></parameter>,
                           <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>ordOperators</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>LockRows</name> <modifier>*</modifier></type><name>create_lockrows_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>LockRowsPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                     <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ModifyTable</name> <modifier>*</modifier></type><name>create_modifytable_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>ModifyTablePath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Limit</name> <modifier>*</modifier></type><name>create_limit_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>LimitPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                  <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>offset_est</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>count_est</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SeqScan</name> <modifier>*</modifier></type><name>create_seqscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                    <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SampleScan</name> <modifier>*</modifier></type><name>create_samplescan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                       <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Scan</name> <modifier>*</modifier></type><name>create_indexscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>indexonly</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BitmapHeapScan</name> <modifier>*</modifier></type><name>create_bitmap_scan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                        <parameter><decl><type><name>BitmapHeapPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                        <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>create_bitmap_subplan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>bitmapqual</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>indexqual</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>indexECs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bitmap_subplan_mark_shared</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TidScan</name> <modifier>*</modifier></type><name>create_tidscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>TidPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                    <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SubqueryScan</name> <modifier>*</modifier></type><name>create_subqueryscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                         <parameter><decl><type><name>SubqueryScanPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                         <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>FunctionScan</name> <modifier>*</modifier></type><name>create_functionscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                         <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ValuesScan</name> <modifier>*</modifier></type><name>create_valuesscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                       <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TableFuncScan</name> <modifier>*</modifier></type><name>create_tablefuncscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                          <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CteScan</name> <modifier>*</modifier></type><name>create_ctescan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                    <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>NamedTuplestoreScan</name> <modifier>*</modifier></type><name>create_namedtuplestorescan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                                <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>WorkTableScan</name> <modifier>*</modifier></type><name>create_worktablescan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                          <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ForeignScan</name> <modifier>*</modifier></type><name>create_foreignscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>ForeignPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                        <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CustomScan</name> <modifier>*</modifier></type><name>create_customscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                       <parameter><decl><type><name>CustomPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                       <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>NestLoop</name> <modifier>*</modifier></type><name>create_nestloop_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>NestPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MergeJoin</name> <modifier>*</modifier></type><name>create_mergejoin_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>MergePath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HashJoin</name> <modifier>*</modifier></type><name>create_hashjoin_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>HashPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>replace_nestloop_params</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>replace_nestloop_params_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>process_subquery_nestloop_params</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                                 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subplan_params</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>fix_indexqual_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>index_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>fix_indexorderby_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>index_path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>fix_indexqual_operand</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indexcol</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_switched_clauses</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>outerrelids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>order_qual_clauses</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>copy_generic_path_info</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>copy_plan_costsize</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>label_sort_with_costsize</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Sort</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
                         <parameter><decl><type><name>double</name></type> <name>limit_tuples</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SeqScan</name> <modifier>*</modifier></type><name>make_seqscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SampleScan</name> <modifier>*</modifier></type><name>make_samplescan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
                <parameter><decl><type><name>TableSampleClause</name> <modifier>*</modifier></type><name>tsc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>IndexScan</name> <modifier>*</modifier></type><name>make_indexscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
               <parameter><decl><type><name>Oid</name></type> <name>indexid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexqual</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexqualorig</name></decl></parameter>,
               <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexorderby</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexorderbyorig</name></decl></parameter>,
               <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexorderbyops</name></decl></parameter>,
               <parameter><decl><type><name>ScanDirection</name></type> <name>indexscandir</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>IndexOnlyScan</name> <modifier>*</modifier></type><name>make_indexonlyscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
                   <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexid</name></decl></parameter>,
                   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexqual</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexorderby</name></decl></parameter>,
                   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indextlist</name></decl></parameter>,
                   <parameter><decl><type><name>ScanDirection</name></type> <name>indexscandir</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BitmapIndexScan</name> <modifier>*</modifier></type><name>make_bitmap_indexscan</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexid</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexqual</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexqualorig</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BitmapHeapScan</name> <modifier>*</modifier></type><name>make_bitmap_heapscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
                     <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
                     <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
                     <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>bitmapqualorig</name></decl></parameter>,
                     <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TidScan</name> <modifier>*</modifier></type><name>make_tidscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
             <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tidquals</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SubqueryScan</name> <modifier>*</modifier></type><name>make_subqueryscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
                  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
                  <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
                  <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>FunctionScan</name> <modifier>*</modifier></type><name>make_functionscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
                  <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>functions</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>funcordinality</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ValuesScan</name> <modifier>*</modifier></type><name>make_valuesscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
                <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>values_lists</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TableFuncScan</name> <modifier>*</modifier></type><name>make_tablefuncscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
                   <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>, <parameter><decl><type><name>TableFunc</name> <modifier>*</modifier></type><name>tablefunc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CteScan</name> <modifier>*</modifier></type><name>make_ctescan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
             <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ctePlanId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cteParam</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>NamedTuplestoreScan</name> <modifier>*</modifier></type><name>make_namedtuplestorescan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
                         <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>enrname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>WorkTableScan</name> <modifier>*</modifier></type><name>make_worktablescan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
                   <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>wtParam</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Append</name> <modifier>*</modifier></type><name>make_append</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>appendplans</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitioned_rels</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RecursiveUnion</name> <modifier>*</modifier></type><name>make_recursive_union</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                     <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
                     <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
                     <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>righttree</name></decl></parameter>,
                     <parameter><decl><type><name>int</name></type> <name>wtParam</name></decl></parameter>,
                     <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctList</name></decl></parameter>,
                     <parameter><decl><type><name>long</name></type> <name>numGroups</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BitmapAnd</name> <modifier>*</modifier></type><name>make_bitmap_and</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>bitmapplans</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>BitmapOr</name> <modifier>*</modifier></type><name>make_bitmap_or</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>bitmapplans</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>NestLoop</name> <modifier>*</modifier></type><name>make_nestloop</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
              <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinclauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>otherclauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nestParams</name></decl></parameter>,
              <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>righttree</name></decl></parameter>,
              <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inner_unique</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HashJoin</name> <modifier>*</modifier></type><name>make_hashjoin</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
              <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinclauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>otherclauses</name></decl></parameter>,
              <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashclauses</name></decl></parameter>,
              <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>righttree</name></decl></parameter>,
              <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inner_unique</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Hash</name> <modifier>*</modifier></type><name>make_hash</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
          <parameter><decl><type><name>Oid</name></type> <name>skewTable</name></decl></parameter>,
          <parameter><decl><type><name>AttrNumber</name></type> <name>skewColumn</name></decl></parameter>,
          <parameter><decl><type><name>bool</name></type> <name>skewInherit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MergeJoin</name> <modifier>*</modifier></type><name>make_mergejoin</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
               <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinclauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>otherclauses</name></decl></parameter>,
               <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeclauses</name></decl></parameter>,
               <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>mergefamilies</name></decl></parameter>,
               <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>mergecollations</name></decl></parameter>,
               <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>mergestrategies</name></decl></parameter>,
               <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>mergenullsfirst</name></decl></parameter>,
               <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>righttree</name></decl></parameter>,
               <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inner_unique</name></decl></parameter>,
               <parameter><decl><type><name>bool</name></type> <name>skip_mark_restore</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Sort</name> <modifier>*</modifier></type><name>make_sort</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>,
          <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sortOperators</name></decl></parameter>,
          <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collations</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nullsFirst</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>prepare_sort_from_pathkeys</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
                           <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>AttrNumber</name> <modifier>*</modifier></type><name>reqColIdx</name></decl></parameter>,
                           <parameter><decl><type><name>bool</name></type> <name>adjust_tlist_in_place</name></decl></parameter>,
                           <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>p_numsortkeys</name></decl></parameter>,
                           <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_sortColIdx</name></decl></parameter>,
                           <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_sortOperators</name></decl></parameter>,
                           <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_collations</name></decl></parameter>,
                           <parameter><decl><type><name>bool</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_nullsFirst</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>EquivalenceMember</name> <modifier>*</modifier></type><name>find_ec_member_for_tle</name><parameter_list>(<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,
                       <parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl></parameter>,
                       <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Sort</name> <modifier>*</modifier></type><name>make_sort_from_pathkeys</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
						<parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Sort</name> <modifier>*</modifier></type><name>make_sort_from_groupcols</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupcls</name></decl></parameter>,
                         <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>grpColIdx</name></decl></parameter>,
                         <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Material</name> <modifier>*</modifier></type><name>make_material</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>WindowAgg</name> <modifier>*</modifier></type><name>make_windowagg</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>winref</name></decl></parameter>,
               <parameter><decl><type><name>int</name></type> <name>partNumCols</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>partColIdx</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partOperators</name></decl></parameter>,
               <parameter><decl><type><name>int</name></type> <name>ordNumCols</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>ordColIdx</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>ordOperators</name></decl></parameter>,
               <parameter><decl><type><name>int</name></type> <name>frameOptions</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>startOffset</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>endOffset</name></decl></parameter>,
               <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Group</name> <modifier>*</modifier></type><name>make_group</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numGroupCols</name></decl></parameter>,
           <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>grpColIdx</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>grpOperators</name></decl></parameter>,
           <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Unique</name> <modifier>*</modifier></type><name>make_unique_from_sortclauses</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Unique</name> <modifier>*</modifier></type><name>make_unique_from_pathkeys</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
                          <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Gather</name> <modifier>*</modifier></type><name>make_gather</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
            <parameter><decl><type><name>int</name></type> <name>nworkers</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>single_copy</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SetOp</name> <modifier>*</modifier></type><name>make_setop</name><parameter_list>(<parameter><decl><type><name>SetOpCmd</name></type> <name>cmd</name></decl></parameter>, <parameter><decl><type><name>SetOpStrategy</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
           <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctList</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>flagColIdx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>firstFlag</name></decl></parameter>,
           <parameter><decl><type><name>long</name></type> <name>numGroups</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>LockRows</name> <modifier>*</modifier></type><name>make_lockrows</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rowMarks</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>epqParam</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Result</name> <modifier>*</modifier></type><name>make_result</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>resconstantqual</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ProjectSet</name> <modifier>*</modifier></type><name>make_project_set</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ModifyTable</name> <modifier>*</modifier></type><name>make_modifytable</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                 <parameter><decl><type><name>CmdType</name></type> <name>operation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>,
                 <parameter><decl><type><name>Index</name></type> <name>nominalRelation</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitioned_rels</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>partColsUpdated</name></decl></parameter>,
                 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>resultRelations</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subplans</name></decl></parameter>,
                 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>withCheckOptionLists</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningLists</name></decl></parameter>,
                 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rowMarks</name></decl></parameter>, <parameter><decl><type><name>OnConflictExpr</name> <modifier>*</modifier></type><name>onconflict</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>epqParam</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>GatherMerge</name> <modifier>*</modifier></type><name>create_gather_merge_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                         <parameter><decl><type><name>GatherMergePath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>add_sort_column</name><parameter_list>(<parameter><decl><type><name>AttrNumber</name></type> <name>colIdx</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sortOp</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>coll</name></decl></parameter>,
                <parameter><decl><type><name>bool</name></type> <name>nulls_first</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl></parameter>,
                <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sortOperators</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collations</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nullsFirst</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>GetPlanRows</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>set_plan_parallel</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_plan_nonparallel</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>materialize_top_remote_subplan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contain_node_walker</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>NodeTag</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>search_nonparallel</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>RemoteSubplan</name> <modifier>*</modifier></type><name>find_push_down_plan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * create_plan
 *      Creates the access plan for a query by recursively processing the
 *      desired tree of pathnodes, starting at the node 'best_path'.  For
 *      every pathnode found, we create a corresponding plan node containing
 *      appropriate id, target list, and qualification information.
 *
 *      The tlists and quals in the plan tree are still in planner format,
 *      ie, Vars still correspond to the parser's numbering.  This will be
 *      fixed later by setrefs.c.
 *
 *      best_path is the best access path
 *
 *      Returns a Plan tree.
 */</comment>
<function><type><name>Plan</name> <modifier>*</modifier></type>
<name>create_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>

    <comment type="block">/* plan_params should not be in use in current query level */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Initialize this module's private workspace in PlannerInfo */</comment>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRestrict</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>adjust_subplan_distribution</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>,
                              <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Recursively process the path tree, demanding the correct tlist result */</comment>
    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Make sure the topmost plan node's targetlist exposes the original
     * column names and other decorative info.  Targetlists generated within
     * the planner don't bother with that stuff, but we must have it on the
     * top-level tlist seen at execution time.  However, ModifyTable plan
     * nodes don't have a tlist matching the querytree targetlist.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>ModifyTable</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>apply_tlist_labeling</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Attach any initPlans created in this query level to the topmost plan
     * node.  (In principle the initplans could go in any plan node at or
     * above where they're referenced, but there seems no reason to put them
     * any lower than the topmost node for the query level.  Also, see
     * comments for SS_finalize_plan before you try to change this.)
     */</comment>
    <expr_stmt><expr><call><name>SS_attach_initplans</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check we successfully assigned all NestLoopParams to plan nodes */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to assign all NestLoopParams to plan nodes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Reset plan_params to ensure param IDs used for nestloop params are not
     * re-used later
     */</comment>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>plan_params</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_plan_recurse
 *      Recursive guts of create_plan().
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>create_plan_recurse</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>pathtype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_SeqScan</name></expr>:</case>
        <case>case <expr><name>T_SampleScan</name></expr>:</case>
        <case>case <expr><name>T_IndexScan</name></expr>:</case>
        <case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
        <case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
        <case>case <expr><name>T_TidScan</name></expr>:</case>
        <case>case <expr><name>T_SubqueryScan</name></expr>:</case>
        <case>case <expr><name>T_FunctionScan</name></expr>:</case>
        <case>case <expr><name>T_TableFuncScan</name></expr>:</case>
        <case>case <expr><name>T_ValuesScan</name></expr>:</case>
        <case>case <expr><name>T_CteScan</name></expr>:</case>
        <case>case <expr><name>T_WorkTableScan</name></expr>:</case>
        <case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
        <case>case <expr><name>T_ForeignScan</name></expr>:</case>
        <case>case <expr><name>T_CustomScan</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_scan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        <case>case <expr><name>T_RemoteSubplan</name></expr>:</case>
            <expr_stmt><expr><name>remote_subplan_depth</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_remotescan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                   <argument><expr><operator>(</operator><name>RemoteSubPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>remote_subplan_depth</name><operator>--</operator></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>T_HashJoin</name></expr>:</case>
        <case>case <expr><name>T_MergeJoin</name></expr>:</case>
        <case>case <expr><name>T_NestLoop</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_join_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                    <argument><expr><operator>(</operator><name>JoinPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_Append</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_append_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                      <argument><expr><operator>(</operator><name>AppendPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_MergeAppend</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_merge_append_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                            <argument><expr><operator>(</operator><name>MergeAppendPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_Result</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>ProjectionPath</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_projection_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                              <argument><expr><operator>(</operator><name>ProjectionPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>MinMaxAggPath</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_minmaxagg_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                      <argument><expr><operator>(</operator><name>MinMaxAggPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>ResultPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_result_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                   <argument><expr><operator>(</operator><name>ResultPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>
        <case>case <expr><name>T_ProjectSet</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_project_set_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                    <argument><expr><operator>(</operator><name>ProjectSetPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_Material</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_material_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                 <argument><expr><operator>(</operator><name>MaterialPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
                                                 <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_Unique</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>UpperUniquePath</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_upper_unique_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                         <argument><expr><operator>(</operator><name>UpperUniquePath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
                                                         <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>UniquePath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_unique_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                          <argument><expr><operator>(</operator><name>UniquePath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
                                          <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>
        <case>case <expr><name>T_Gather</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_gather_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                               <argument><expr><operator>(</operator><name>GatherPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_Sort</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                             <argument><expr><operator>(</operator><name>SortPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
                                             <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_Group</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_group_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                              <argument><expr><operator>(</operator><name>GroupPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_Agg</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>GroupingSetsPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_groupingsets_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                <argument><expr><operator>(</operator><name>GroupingSetsPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>AggPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                <argument><expr><operator>(</operator><name>AggPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>
        <case>case <expr><name>T_WindowAgg</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_windowagg_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                  <argument><expr><operator>(</operator><name>WindowAggPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_SetOp</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_setop_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                              <argument><expr><operator>(</operator><name>SetOpPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
                                              <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_RecursiveUnion</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_recursiveunion_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                       <argument><expr><operator>(</operator><name>RecursiveUnionPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_LockRows</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_lockrows_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                 <argument><expr><operator>(</operator><name>LockRowsPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
                                                 <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_ModifyTable</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_modifytable_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                    <argument><expr><operator>(</operator><name>ModifyTablePath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_Limit</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_limit_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                              <argument><expr><operator>(</operator><name>LimitPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
                                              <argument><expr><name>flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_GatherMerge</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_gather_merge_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                     <argument><expr><operator>(</operator><name>GatherMergePath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>best_path</name><operator>-&gt;</operator><name>pathtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>        <comment type="block">/* keep compiler quiet */</comment>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_scan_plan
 *     Create a scan plan for the parent relation of 'best_path'.
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>create_scan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>scan_clauses</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>gating_clauses</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type>    <name>isindexscan</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>                <comment type="block">/* result is sorted? */</comment>
    <decl_stmt><decl><type><name>bool</name></type>    <name>need_merge_append</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>            <comment type="block">/* need MergeAppend */</comment>
<comment type="line">//    bool    need_pullup_filter = false;         /* need pull up filter */</comment>
    <decl_stmt><decl><type><name>bool</name></type>    <name>isbackward</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>                 <comment type="block">/* indexscan is backward ?*/</comment>
    <decl_stmt><decl><type><name>AttrNumber</name></type> <name>partkey</name></decl>;</decl_stmt>
<comment type="line">//    List        *outtlist = NULL;</comment>
<comment type="line">//    List        *qual = NULL;</comment>

    <decl_stmt><decl><type><name>Relation</name></type> <name>relation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

<comment type="line">//    bool    does_use_physical_tlist = false;</comment>
<comment type="line">//    bool    need_projection = false;</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Extract the relevant restriction clauses from the parent relation. The
     * executor must apply all these restrictions during the scan, except for
     * pseudoconstants which we'll take care of below.
     *
     * If this is a plain indexscan or index-only scan, we need not consider
     * restriction clauses that are implied by the index's predicate, so use
     * indrestrictinfo not baserestrictinfo.  Note that we can't do that for
     * bitmap indexscans, since there's not necessarily a single index
     * involved; but it doesn't matter since create_bitmap_scan_plan() will be
     * able to get rid of such clauses anyway via predicate proof.
     */</comment>
    <switch>switch <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>pathtype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_IndexScan</name></expr>:</case>
        <case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
            <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>IndexPath</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>indexinfo</name><operator>-&gt;</operator><name>indrestrictinfo</name></name></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/*
     * If this is a parameterized scan, we also need to enforce all the join
     * clauses available from the outer relation(s).
     *
     * For paranoia's sake, don't modify the stored baserestrictinfo list.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>param_info</name><operator>-&gt;</operator><name>ppi_clauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Detect whether we have any pseudoconstant quals to deal with.  Then, if
     * we'll need a gating Result node, it will be able to project, so there
     * are no requirements on the child's tlist.
     */</comment>
    <expr_stmt><expr><name>gating_clauses</name> <operator>=</operator> <call><name>get_gating_quals</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>gating_clauses</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * For table scans, rather than using the relation targetlist (which is
     * only those Vars actually needed by the query), we prefer to generate a
     * tlist containing all Vars in order.  This will allow the executor to
     * optimize away projection of the table tuples, if possible.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>use_physical_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>==</operator> <name>T_IndexOnlyScan</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* For index-only scan, the preferred tlist is the index's */</comment>
            <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>IndexPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name><operator>)</operator><operator>-&gt;</operator><name><name>indexinfo</name><operator>-&gt;</operator><name>indextlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Transfer any sortgroupref data to the replacement tlist, unless
             * we don't care because the gating Result will handle it.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>gating_clauses</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>apply_pathtarget_labeling_to_tlist</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_physical_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="line">//            does_use_physical_tlist = true;</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if_stmt><if>if <condition>(<expr><name>tlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Failed because of dropped cols, so use regular method */</comment>
                <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* As above, transfer sortgroupref data to replacement tlist */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>gating_clauses</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>apply_pathtarget_labeling_to_tlist</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
        
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <comment type="block">/* find is there any tables located in more than one group */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name> <operator>||</operator> <name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_OTHER_MEMBER_REL</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
    <block>{<block_content>
        
        <expr_stmt><expr><name>rte</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_locator_info</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>loc</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>rd_locator_info</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>loc</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>loc</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                    <expr_stmt><expr><name>has_cold_hot_table</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name> <operator>||</operator> <name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_OTHER_MEMBER_REL</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>intervalparent</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>isdefault</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>rte</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* get partition key info, to decide to use append or mergeappend*/</comment>
        <expr_stmt><expr><name>partkey</name> <operator>=</operator> <call><name>RelationGetPartitionColumnIndex</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>indexpath</name> <init>= <expr><operator>(</operator><name>IndexPath</name> <operator>*</operator><operator>)</operator><name>best_path</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>isindexscan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name><name>indexpath</name><operator>-&gt;</operator><name>indexscandir</name></name> <operator>==</operator> <name>BackwardScanDirection</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>isbackward</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
    
            <if_stmt><if>if<condition>(<expr><call><name>partkey_match_index</name><argument_list>(<argument><expr><name><name>indexpath</name><operator>-&gt;</operator><name>indexinfo</name><operator>-&gt;</operator><name>indexoid</name></name></expr></argument>, <argument><expr><name>partkey</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>need_merge_append</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>need_merge_append</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
<comment type="line">//            need_pullup_filter = false;</comment>
<comment type="block">/*
            if(need_pullup_filter)
            {
                if(does_use_physical_tlist)
                {
                    outtlist = tlist;
                }
                else
                {
                    List *physical_tlist = build_physical_tlist(root, rel);

                    outtlist = copyObject((void *)tlist);
                    tlist = build_physical_tlist_with_sysattr(tlist, physical_tlist);

                    if (!tlist_same_exprs(outtlist, tlist))
                        need_projection = true;
                }
            }
*/</comment>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>childs</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>best_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>/</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>childs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>best_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>/</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>childs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <switch>switch <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>pathtype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_SeqScan</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_seqscan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                <argument><expr><name>best_path</name></expr></argument>,
                                                <argument><expr><name>tlist</name></expr></argument>,
                                                <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SampleScan</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_samplescan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                   <argument><expr><name>best_path</name></expr></argument>,
                                                   <argument><expr><name>tlist</name></expr></argument>,
                                                   <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_IndexScan</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_indexscan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                  <argument><expr><operator>(</operator><name>IndexPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
                                                  <argument><expr><name>tlist</name></expr></argument>,
                                                  <argument><expr><name>scan_clauses</name></expr></argument>,
                                                  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_indexscan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                  <argument><expr><operator>(</operator><name>IndexPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
                                                  <argument><expr><name>tlist</name></expr></argument>,
                                                  <argument><expr><name>scan_clauses</name></expr></argument>,
                                                  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_bitmap_scan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                    <argument><expr><operator>(</operator><name>BitmapHeapPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
                                                    <argument><expr><name>tlist</name></expr></argument>,
                                                    <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_TidScan</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_tidscan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                <argument><expr><operator>(</operator><name>TidPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
                                                <argument><expr><name>tlist</name></expr></argument>,
                                                <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SubqueryScan</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_subqueryscan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                     <argument><expr><operator>(</operator><name>SubqueryScanPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
                                                     <argument><expr><name>tlist</name></expr></argument>,
                                                     <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_FunctionScan</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_functionscan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                     <argument><expr><name>best_path</name></expr></argument>,
                                                     <argument><expr><name>tlist</name></expr></argument>,
                                                     <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_TableFuncScan</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_tablefuncscan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                      <argument><expr><name>best_path</name></expr></argument>,
                                                      <argument><expr><name>tlist</name></expr></argument>,
                                                      <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ValuesScan</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_valuesscan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                   <argument><expr><name>best_path</name></expr></argument>,
                                                   <argument><expr><name>tlist</name></expr></argument>,
                                                   <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CteScan</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_ctescan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                <argument><expr><name>best_path</name></expr></argument>,
                                                <argument><expr><name>tlist</name></expr></argument>,
                                                <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_namedtuplestorescan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                            <argument><expr><name>best_path</name></expr></argument>,
                                                            <argument><expr><name>tlist</name></expr></argument>,
                                                            <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_WorkTableScan</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_worktablescan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                      <argument><expr><name>best_path</name></expr></argument>,
                                                      <argument><expr><name>tlist</name></expr></argument>,
                                                      <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ForeignScan</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_foreignscan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                    <argument><expr><operator>(</operator><name>ForeignPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
                                                    <argument><expr><name>tlist</name></expr></argument>,
                                                    <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CustomScan</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_customscan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                   <argument><expr><operator>(</operator><name>CustomPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>,
                                                   <argument><expr><name>tlist</name></expr></argument>,
                                                   <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>best_path</name><operator>-&gt;</operator><name>pathtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>        <comment type="block">/* keep compiler quiet */</comment>
            <break>break;</break>
    </block_content>}</block></switch>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_BASEREL</name> <operator>||</operator> <name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_OTHER_MEMBER_REL</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>intervalparent</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>isdefault</name></name></expr>)</condition>
    <block>{<block_content>        
        <comment type="block">/* create append plan with a list of scan.
          * If partition parent relation is target realtion of UPDATE or DELETE statement,
          * then compute pruning result and not need to expand.
          * in case of this, target relation will be expend in ModifyTable operator.
          */</comment>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>childs</name></name></expr></argument>)</argument_list></call> 
            <operator>&amp;&amp;</operator> <operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>!=</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>            
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>scanlist</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Scan</name> <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Scan</name> <modifier>*</modifier><modifier>*</modifier></type><name>child_array</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>arrlen</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>arridx</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>parts</name></decl>;</decl_stmt>
<comment type="block">/*
            if(need_pullup_filter)
            {
                qual = plan-&gt;qual;
                plan-&gt;qual = NULL;
            }
*/</comment>
            <expr_stmt><expr><name>arrlen</name> <operator>=</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>childs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>parts</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>childs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>child_array</name> <operator>=</operator> <operator>(</operator><name>Scan</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name>arrlen</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Scan</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>scanlist</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>child</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>    
            <expr_stmt><expr><name>arridx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <while>while<condition>(<expr><operator>(</operator><name>idx</name> <operator>=</operator> <call><name>bms_first_member</name><argument_list>(<argument><expr><name>parts</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>child</name> <operator>=</operator> <operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator><call><name>copyObject</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>child</name><operator>-&gt;</operator><name>ispartchild</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>child</name><operator>-&gt;</operator><name>childidx</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
                <switch>switch<condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>T_SeqScan</name></expr>:</case>
					<case>case <expr><name>T_SampleScan</name></expr>:</case>
                        <break>break;</break>
                    <case>case <expr><name>T_IndexScan</name></expr>:</case>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>IndexScan</name> <modifier>*</modifier></type><name>idxscan_child</name></decl>;</decl_stmt>
                            <expr_stmt><expr><name>idxscan_child</name> <operator>=</operator> <operator>(</operator><name>IndexScan</name> <operator>*</operator><operator>)</operator><name>child</name></expr>;</expr_stmt>                 
                            <expr_stmt><expr><name><name>idxscan_child</name><operator>-&gt;</operator><name>indexid</name></name> <operator>=</operator> <call><name>RelationGetPartitionIndex</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,<argument><expr><name><name>idxscan_child</name><operator>-&gt;</operator><name>indexid</name></name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>
                        <break>break;</break>
                    <case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>IndexOnlyScan</name> <modifier>*</modifier></type><name>idxonlyscan_child</name></decl>;</decl_stmt>
                            <expr_stmt><expr><name>idxonlyscan_child</name> <operator>=</operator> <operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator><name>child</name></expr>;</expr_stmt>                 
                            <expr_stmt><expr><name><name>idxonlyscan_child</name><operator>-&gt;</operator><name>indexid</name></name> <operator>=</operator> <call><name>RelationGetPartitionIndex</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,<argument><expr><name><name>idxonlyscan_child</name><operator>-&gt;</operator><name>indexid</name></name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>
                        <break>break;</break>
                    <case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
                        <block>{<block_content>
                            <comment type="line">//BitmapHeapScan *bscan;</comment>
                            <comment type="line">//bscan = (BitmapHeapScan *)child;</comment>
                            <expr_stmt><expr><call><name>replace_partidx_bitmapheapscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name><name>child</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name></expr></argument>,<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>
                        <break>break;</break>
                    <case>case <expr><name>T_TidScan</name></expr>:</case>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"cannot use tidscan on partitioned table."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <default>default:</default>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"create scan plan: unsupported scan method[%d] on partitioned table."</literal></expr></argument>, <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>            

                <expr_stmt><expr><name><name>child_array</name><index>[<expr><name>arridx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>

                <comment type="line">//scanlist = lappend(scanlist,child);</comment>
            </block_content>}</block></while>

            <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>parts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><name>arrlen</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name><operator>*</operator><operator>)</operator><name><name>child_array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<comment type="block">/*
                if(need_pullup_filter)
                {
                    plan-&gt;qual = qual;
                }
*/</comment>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <if_stmt><if>if<condition>(<expr><name>isindexscan</name> <operator>&amp;&amp;</operator> <name>isbackward</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>arridx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <for>for<control>(<init><expr><name>arridx</name> <operator>=</operator> <name>arrlen</name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>arridx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>arridx</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>scanlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>scanlist</name></expr></argument>, <argument><expr><name><name>child_array</name><index>[<expr><name>arridx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>arridx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <for>for<control>(<init><expr><name>arridx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>arridx</name> <operator>&lt;</operator> <name>arrlen</name></expr>;</condition> <incr><expr><name>arridx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>scanlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>scanlist</name></expr></argument>, <argument><expr><name><name>child_array</name><index>[<expr><name>arridx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
                </block_content>}</block></else></if_stmt>

                <if_stmt><if>if<condition>(<expr><name>need_merge_append</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>MergeAppend</name> <modifier>*</modifier></type><name>mappend</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>MergeAppend</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    

                    <expr_stmt><expr><call><name>prepare_sort_from_pathkeys</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>,
                                                <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, 
                                                <argument><expr><name>NULL</name></expr></argument>, 
                                                <argument><expr><name>true</name></expr></argument>,
                                                <argument><expr><operator>&amp;</operator><name><name>mappend</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>,
                                                <argument><expr><operator>&amp;</operator><name><name>mappend</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
                                                <argument><expr><operator>&amp;</operator><name><name>mappend</name><operator>-&gt;</operator><name>sortOperators</name></name></expr></argument>,
                                                <argument><expr><operator>&amp;</operator><name><name>mappend</name><operator>-&gt;</operator><name>collations</name></name></expr></argument>,
                                                <argument><expr><operator>&amp;</operator><name><name>mappend</name><operator>-&gt;</operator><name>nullsFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    
                    <expr_stmt><expr><name><name>mappend</name><operator>-&gt;</operator><name>mergeplans</name></name> <operator>=</operator> <name>scanlist</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>mappend</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>mappend</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>mappend</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>plan_rows</name></name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>*</operator> <name>arrlen</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>mappend</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>plan_width</name></name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>plan_width</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>mappend</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>mappend</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>*</operator> <name>arrlen</name></expr>;</expr_stmt>    <comment type="block">/* ms */</comment>
<comment type="block">/*
                    if(need_pullup_filter)
                    {
                        mappend-&gt;plan.targetlist = outtlist;
                        mappend-&gt;plan.qual = qual;
                    }
                    else
*/</comment>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>mappend</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator><call><name>copyObject</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>mappend</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    </block_content>}</block>
                    <expr_stmt><expr><name><name>mappend</name><operator>-&gt;</operator><name>interval</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>mappend</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><name>mappend</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Append</name> <modifier>*</modifier></type><name>append</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>append</name> <operator>=</operator> <call><name>make_append</name><argument_list>(<argument><expr><name>scanlist</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>append</name><operator>-&gt;</operator><name>interval</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>append</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><name>append</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>child_array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>childs</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>isempty</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<comment type="block">/*
        if (need_projection)
        {
            plan = (Plan *)make_result(outtlist, NULL, plan);
            plan-&gt;parallel_aware = best_path-&gt;parallel_aware;
        }
*/</comment>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If there are any pseudoconstant clauses attached to this node, insert a
     * gating Result node that evaluates the pseudoconstants as one-time
     * quals.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>gating_clauses</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_gating_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>gating_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build a target list (ie, a list of TargetEntry) for the Path's output.
 *
 * This is almost just make_tlist_from_pathtarget(), but we also have to
 * deal with replacing nestloop params.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>build_path_tlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name>       <modifier>*</modifier></type><name>sortgrouprefs</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>resno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>v</argument>, <argument>path-&gt;pathtarget-&gt;exprs</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

        <comment type="block">/*
         * If it's a parameterized path, there might be lateral references in
         * the tlist, which need to be replaced with Params.  There's no need
         * to remake the TargetEntry nodes, so apply this to each list item
         * separately.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                              <argument><expr><name>resno</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>sortgrouprefs</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name><name>sortgrouprefs</name><index>[<expr><name>resno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>resno</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>
    <return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * use_physical_tlist
 *        Decide whether to use a tlist matching relation structure,
 *        rather than only those Vars actually referenced.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>use_physical_tlist</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Forget it if either exact tlist or small tlist is demanded.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>CP_EXACT_TLIST</name> <operator>|</operator> <name>CP_SMALL_TLIST</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We can do this for real relation scans, subquery scans, function scans,
     * tablefunc scans, values scans, and CTE scans (but not for, eg, joins).
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator>
        <name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_SUBQUERY</name> <operator>&amp;&amp;</operator>
        <name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_FUNCTION</name> <operator>&amp;&amp;</operator>
        <name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_TABLEFUNC</name> <operator>&amp;&amp;</operator>
        <name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_VALUES</name> <operator>&amp;&amp;</operator>
        <name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_CTE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Can't do it with inheritance cases either (mainly because Append
     * doesn't project; this test may be unnecessary now that
     * create_append_plan instructs its children to return an exact tlist).
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>!=</operator> <name>RELOPT_BASEREL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Also, don't do it to a CustomPath; the premise that we're extracting
     * columns from a simple physical tuple is unlikely to hold for those.
     * (When it does make sense, the custom path creator can set up the path's
     * pathtarget that way.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>CustomPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Can't do it if any system columns or whole-row Vars are requested.
     * (This could possibly be fixed but would take some fragile assumptions
     * in setrefs.c, I think.)
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>attr_needed</name><index>[<expr><name>i</name> <operator>-</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Can't do it if the rel is required to emit any placeholder expressions,
     * either.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;placeholder_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>phinfo</name> <init>= <expr><operator>(</operator><name>PlaceHolderInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>bms_nonempty_difference</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_needed</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>phinfo</name><operator>-&gt;</operator><name>ph_eval_at</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Also, can't do it if CP_LABEL_TLIST is specified and path is requested
     * to emit any sort/group columns that are not simple Vars.  (If they are
     * simple Vars, they should appear in the physical tlist, and
     * apply_pathtarget_labeling_to_tlist will take care of getting them
     * labeled again.)    We also have to check that no two sort/group columns
     * are the same Var, else that element of the physical tlist would need
     * conflicting ressortgroupref labels.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CP_LABEL_TLIST</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>sortgroupatts</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>path-&gt;pathtarget-&gt;exprs</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type>            <name>attno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name>attno</name> <operator>-=</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>attno</name></expr></argument>, <argument><expr><name>sortgroupatts</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>sortgroupatts</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>sortgroupatts</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_gating_quals
 *      See if there are pseudoconstant quals in a node's quals list
 *
 * If the node's quals list includes any pseudoconstant quals,
 * return just those quals.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_gating_quals</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* No need to look if we know there are no pseudoconstants */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>hasPseudoConstantQuals</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Sort into desirable execution order while still in RestrictInfo form */</comment>
    <expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Pull out any pseudoconstant quals from the RestrictInfo list */</comment>
    <return>return <expr><call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_gating_plan
 *      Deal with pseudoconstant qual clauses
 *
 * Add a gating Result node atop the already-built plan.
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>create_gating_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
                   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>gating_quals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>gplan</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>gating_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Since we need a Result node anyway, always return the path's requested
     * tlist; that's never a wrong choice, even if the parent node didn't ask
     * for CP_EXACT_TLIST.
     */</comment>
    <expr_stmt><expr><name>gplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_result</name><argument_list>(<argument><expr><call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>gating_quals</name></expr></argument>,
                                 <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Notice that we don't change cost or size estimates when doing gating.
     * The costs of qual eval were already included in the subplan's cost.
     * Leaving the size alone amounts to assuming that the gating qual will
     * succeed, which is the conservative estimate for planning upper queries.
     * We certainly don't want to assume the output size is zero (unless the
     * gating qual is actually constant FALSE, and that case is dealt with in
     * clausesel.c).  Interpolating between the two cases is silly, because it
     * doesn't reflect what will really happen at runtime, and besides which
     * in most cases we have only a very bad idea of the probability of the
     * gating qual being true.
     */</comment>
    <expr_stmt><expr><call><name>copy_plan_costsize</name><argument_list>(<argument><expr><name>gplan</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Gating quals could be unsafe, so better use the Path's safety flag */</comment>
    <expr_stmt><expr><name><name>gplan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>

    <return>return <expr><name>gplan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_join_plan
 *      Create a join plan for 'best_path' and (recursively) plans for its
 *      inner and outer paths.
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>create_join_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>JoinPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>gating_clauses</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_MergeJoin</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_mergejoin_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                  <argument><expr><operator>(</operator><name>MergePath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_HashJoin</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_hashjoin_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                 <argument><expr><operator>(</operator><name>HashPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_NestLoop</name></expr>:</case>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>create_nestloop_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                 <argument><expr><operator>(</operator><name>NestPath</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>        <comment type="block">/* keep compiler quiet */</comment>
            <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/*
     * If there are any pseudoconstant clauses attached to this node, insert a
     * gating Result node that evaluates the pseudoconstants as one-time
     * quals.
     */</comment>
    <expr_stmt><expr><name>gating_clauses</name> <operator>=</operator> <call><name>get_gating_quals</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>joinrestrictinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>gating_clauses</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_gating_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>,
                                  <argument><expr><name>gating_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>

    <comment type="block">/*
     * * Expensive function pullups may have pulled local predicates * into
     * this path node.  Put them in the qpqual of the plan node. * JMH,
     * 6/15/92
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>get_loc_restrictinfo</name><argument_list>(<argument><expr><name>best_path</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>set_qpqual</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name><operator>)</operator> <name>plan</name></expr></argument>,
                   <argument><expr><call><name>list_concat</name><argument_list>(<argument><expr><call><name>get_qpqual</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name><operator>)</operator> <name>plan</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>get_actual_clauses</name><argument_list>(<argument><expr><call><name>get_loc_restrictinfo</name><argument_list>(<argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_append_plan
 *      Create an Append plan for 'best_path' and (recursively) plans
 *      for its subpaths.
 *
 *      Returns a Plan node.
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>create_append_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>AppendPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Append</name>       <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name> <init>= <expr><call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subplans</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>subpaths</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type>       <name>parallel_aware</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * The subpaths list could be empty, if every child was proven empty by
     * constraint exclusion.  In that case generate a dummy plan that returns
     * no rows.
     *
     * Note that an AppendPath with no members is also generated in certain
     * cases where there was no appending construct at all, but we know the
     * relation is empty (see set_dummy_rel_pathlist).
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>subpaths</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Generate a Result plan with constant-FALSE gating qual */</comment>
        <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_result</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
                                    <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>false</name></expr></argument>,
                                                                      <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>plan</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Build the plan for each child */</comment>
    <macro><name>foreach</name><argument_list>(<argument>subpaths</argument>, <argument>best_path-&gt;subpaths</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>

        <comment type="block">/* Must insist that all children return the same tlist */</comment>
        <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>subplans</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><name>parallel_aware</name> <operator>=</operator> <name>parallel_aware</name> <operator>&amp;</operator> <name><name>subplan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block>

    <comment type="block">/*
     * XXX ideally, if there's just one child, we'd not bother to generate an
     * Append node but just return the single child.  At the moment this does
     * not work because the varno of the child scan plan won't match the
     * parent-rel Vars it'll be asked to emit.
     */</comment>

    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_append</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>partitioned_rels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>olap_optimizer</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>parallel_aware</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_merge_append_plan
 *      Create a MergeAppend plan for 'best_path' and (recursively) plans
 *      for its subpaths.
 *
 *      Returns a Plan node.
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>create_merge_append_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>MergeAppendPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MergeAppend</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>MergeAppend</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name> <init>= <expr><call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>pathkeys</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subplans</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>subpaths</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We don't have the actual creation of the MergeAppend node split out
     * into a separate make_xxx function.  This is because we want to run
     * prepare_sort_from_pathkeys on it before we do so on the individual
     * child plans, to make cross-checking the sort info easier.
     */</comment>
    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* Compute sort column info, and adjust MergeAppend's tlist as needed */</comment>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>prepare_sort_from_pathkeys</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>,
                                      <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
                                      <argument><expr><name>NULL</name></expr></argument>,
                                      <argument><expr><name>true</name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>sortOperators</name></name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>collations</name></name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>nullsFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Now prepare the child plans.  We must apply prepare_sort_from_pathkeys
     * even to subplans that don't need an explicit sort, to make sure they
     * are returning the same sort key columns the MergeAppend expects.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>subpaths</argument>, <argument>best_path-&gt;subpaths</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>numsortkeys</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>sortOperators</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>collations</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nullsFirst</name></decl>;</decl_stmt>

        <comment type="block">/* Build the child plan */</comment>
        <comment type="block">/* Must insist that all children return the same tlist */</comment>
        <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Compute sort column info, and adjust subplan's tlist as needed */</comment>
        <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>prepare_sort_from_pathkeys</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>,
                                             <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
                                             <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
                                             <argument><expr><name>false</name></expr></argument>,
                                             <argument><expr><operator>&amp;</operator><name>numsortkeys</name></expr></argument>,
                                             <argument><expr><operator>&amp;</operator><name>sortColIdx</name></expr></argument>,
                                             <argument><expr><operator>&amp;</operator><name>sortOperators</name></expr></argument>,
                                             <argument><expr><operator>&amp;</operator><name>collations</name></expr></argument>,
                                             <argument><expr><operator>&amp;</operator><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Check that we got the same sort key information.  We just Assert
         * that the sortops match, since those depend only on the pathkeys;
         * but it seems like a good idea to check the sort column numbers
         * explicitly, to ensure the tlists really do match up.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
                   <argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"MergeAppend child's targetlist doesn't match MergeAppend"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name>sortOperators</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sortOperators</name></name></expr></argument>,
                      <argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name>collations</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>collations</name></name></expr></argument>,
                      <argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name>nullsFirst</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nullsFirst</name></name></expr></argument>,
                      <argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Now, insert a Sort node if subplan isn't sufficiently ordered */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Sort</name>       <modifier>*</modifier></type><name>sort</name> <init>= <expr><call><name>make_sort</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>numsortkeys</name></expr></argument>,
                                         <argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name>sortOperators</name></expr></argument>,
                                         <argument><expr><name>collations</name></expr></argument>, <argument><expr><name>nullsFirst</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>label_sort_with_costsize</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>limit_tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>subplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>sort</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>subplans</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>partitioned_rels</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>partitioned_rels</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mergeplans</name></name> <operator>=</operator> <name>subplans</name></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_result_plan
 *      Create a Result plan for 'best_path'.
 *      This is only used for degenerate cases, such as a query with an empty
 *      jointree.
 *
 *      Returns a Plan node.
 */</comment>
<function><type><specifier>static</specifier> <name>Result</name> <modifier>*</modifier></type>
<name>create_result_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>ResultPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Result</name>       <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>quals</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* best_path-&gt;quals is just bare clauses */</comment>
    <expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>quals</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_project_set_plan
 *      Create a ProjectSet plan for 'best_path'.
 *
 *      Returns a Plan node.
 */</comment>
<function><type><specifier>static</specifier> <name>ProjectSet</name> <modifier>*</modifier></type>
<name>create_project_set_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>ProjectSetPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ProjectSet</name> <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>

    <comment type="block">/* Since we intend to project, we don't need to constrain child tlist */</comment>
    <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_project_set</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_material_plan
 *      Create a Material plan for 'best_path' and (recursively) plans
 *      for its subpaths.
 *
 *      Returns a Plan node.
 */</comment>
<function><type><specifier>static</specifier> <name>Material</name> <modifier>*</modifier></type>
<name>create_material_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>MaterialPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Material</name>   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We don't want any excess columns in the materialized tuples, so request
     * a smaller tlist.  Otherwise, since Material doesn't project, tlist
     * requirements pass through.
     */</comment>
    <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>,
                                  <argument><expr><name>flags</name> <operator>|</operator> <name>CP_SMALL_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_material</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_unique_plan
 *      Create a Unique plan for 'best_path' and (recursively) plans
 *      for its subpaths.
 *
 *      Returns a Plan node.
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>create_unique_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>UniquePath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>in_operators</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>uniq_exprs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>newtlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nextresno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>newitems</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numGroupCols</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>groupColIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>groupColPos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>distributed_expr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	    <modifier>*</modifier></type><name>subpath</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	    <modifier>*</modifier></type><name>sub_disExpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>match_distributed_column</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>enable_distributed_unique_plan</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>subpath</name> <operator>&amp;&amp;</operator> <name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name> <operator>&amp;&amp;</operator> <name><name>subpath</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sub_disExpr</name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Unique doesn't project, so tlist requirements pass through */</comment>
    <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Done if we don't need to do any actual unique-ifying */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>umethod</name></name> <operator>==</operator> <name>UNIQUE_PATH_NOOP</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>subplan</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * As constructed, the subplan has a "flat" tlist containing just the Vars
     * needed here and at upper levels.  The values we are supposed to
     * unique-ify may be expressions in these variables.  We have to add any
     * such expressions to the subplan's tlist.
     *
     * The subplan may have a "physical" tlist if it is a simple scan plan. If
     * we're going to sort, this should be reduced to the regular tlist, so
     * that we don't sort more data than we need to.  For hashing, the tlist
     * should be left as-is if we don't need to add any expressions; but if we
     * do have to add expressions, then a projection step will be needed at
     * runtime anyway, so we may as well remove unneeded items. Therefore
     * newtlist starts from build_path_tlist() not just a copy of the
     * subplan's tlist; and we don't install it into the subplan unless we are
     * sorting or stuff has to be added.
     */</comment>
    <expr_stmt><expr><name>in_operators</name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>in_operators</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>uniq_exprs</name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>uniq_exprs</name></name></expr>;</expr_stmt>

    <comment type="block">/* initialize modified subplan tlist as just the "required" vars */</comment>
    <expr_stmt><expr><name>newtlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nextresno</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>newtlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>newitems</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>uniq_exprs</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>uniqexpr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>tlist_member</name><argument_list>(<argument><expr><name>uniqexpr</name></expr></argument>, <argument><expr><name>newtlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>uniqexpr</name></expr></argument>,
                                  <argument><expr><name>nextresno</name></expr></argument>,
                                  <argument><expr><name>NULL</name></expr></argument>,
                                  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>newtlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newtlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nextresno</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>newitems</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <if_stmt><if>if <condition>(<expr><name>newitems</name> <operator>||</operator> <name><name>best_path</name><operator>-&gt;</operator><name>umethod</name></name> <operator>==</operator> <name>UNIQUE_PATH_SORT</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If the top plan node can't do projections and its existing target
         * list isn't already what we need, we need to add a Result node to
         * help it along.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_projection_capable_plan</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name>tlist_same_exprs</name><argument_list>(<argument><expr><name>newtlist</name></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>inject_projection_plan</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>newtlist</name></expr></argument>,
                                             <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>newtlist</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        <comment type="block">/*
         * RemoteSubplan is conditionally projection capable - it is pushing
         * projection to the data nodes
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>RemoteSubplan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>subplan</name><operator>-&gt;</operator><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>newtlist</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Build control information showing which subplan output columns are to
     * be examined by the grouping step.  Unfortunately we can't merge this
     * with the previous loop, since we didn't then know which version of the
     * subplan tlist we'd end up using.
     */</comment>
    <expr_stmt><expr><name>newtlist</name> <operator>=</operator> <name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>numGroupCols</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>uniq_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>groupColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numGroupCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>groupColPos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>uniq_exprs</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>uniqexpr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>tlist_member</name><argument_list>(<argument><expr><name>uniqexpr</name></expr></argument>, <argument><expr><name>newtlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>                <comment type="block">/* shouldn't happen */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to find unique expression in subplan tlist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>groupColIdx</name><index>[<expr><name>groupColPos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>enable_distributed_unique_plan</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>sub_disExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>match_distributed_column</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block>

    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>umethod</name></name> <operator>==</operator> <name>UNIQUE_PATH_HASH</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>groupOperators</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Get the hashable equality operators for the Agg node to use.
         * Normally these are the same as the IN clause operators, but if
         * those are cross-type operators then the equality operators are the
         * ones for the IN clause operators' RHS datatype.
         */</comment>
        <expr_stmt><expr><name>groupOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numGroupCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>groupColPos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>in_operators</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>in_oper</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>eq_oper</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_compatible_hash_operators</name><argument_list>(<argument><expr><name>in_oper</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eq_oper</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find compatible hash operator for operator %u"</literal></expr></argument>,
                     <argument><expr><name>in_oper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>groupOperators</name><index>[<expr><name>groupColPos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>eq_oper</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>enable_distributed_unique_plan</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>distributed_expr</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type> <name>groupColIndex</name> <init>= <expr><name>groupColPos</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name>distributed_expr</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
										   <argument><expr><name><name>groupColIdx</name><index>[<expr><name>groupColIndex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>enable_distributed_unique_plan</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match_distributed_column</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type> <name>is_distributable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>  <name>hashType</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>distributed_expr</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>hashType</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>distributed_expr</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>is_distributable</name> <operator>=</operator> <call><name>IsTypeHashDistributable</name><argument_list>(<argument><expr><name>hashType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_distributable</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"create_unique_plan using hash: redistribution is impossible because of"</literal>
						<literal type="string">" undistributable hash type %u"</literal></expr></argument>, <argument><expr><name>hashType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>subpath</name> <operator>&amp;&amp;</operator> <name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name> <operator>&amp;&amp;</operator> 
					<name><name>subpath</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>&amp;&amp;</operator> <name>is_distributable</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>remote_subplan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Distribution</name> <modifier>*</modifier></type><name>distribution</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<comment type="block">/* remove duplicated tuples on each node */</comment>
					<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>first_agg</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_agg</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
														 <argument><expr><name>NIL</name></expr></argument>,
														 <argument><expr><name>AGG_HASHED</name></expr></argument>,
														 <argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
														 <argument><expr><name>numGroupCols</name></expr></argument>,
														 <argument><expr><name>groupColIdx</name></expr></argument>,
														 <argument><expr><name>groupOperators</name></expr></argument>,
														 <argument><expr><name>NIL</name></expr></argument>,
														 <argument><expr><name>NIL</name></expr></argument>,
														 <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr></argument>,
														 <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<comment type="block">/* redistributed group by results between nodes */</comment>
					<expr_stmt><expr><name>distribution</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>distribution</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>distributed_expr</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>remote_subplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><call><name>make_remotesubplan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>first_agg</name></expr></argument>, <argument><expr><name>distribution</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* remove duplicated tuples on each node again */</comment>
					<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_agg</name><argument_list>(<argument><expr><call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></argument>,
														 <argument><expr><name>NIL</name></expr></argument>,
														 <argument><expr><name>AGG_HASHED</name></expr></argument>,
														 <argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
														 <argument><expr><name>numGroupCols</name></expr></argument>,
														 <argument><expr><name>groupColIdx</name></expr></argument>,
														 <argument><expr><name>groupOperators</name></expr></argument>,
														 <argument><expr><name>NIL</name></expr></argument>,
														 <argument><expr><name>NIL</name></expr></argument>,
														 <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr></argument>,
														 <argument><expr><name>remote_subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Copy cost data from Path to Plan */</comment>
					<expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<return>return <expr><name>plan</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/*
         * Since the Agg node is going to project anyway, we can give it the
         * minimum output tlist, without any stuff we might have added to the
         * subplan tlist.
         */</comment>
        <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_agg</name><argument_list>(<argument><expr><call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>NIL</name></expr></argument>,
                                 <argument><expr><name>AGG_HASHED</name></expr></argument>,
                                 <argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
                                 <argument><expr><name>numGroupCols</name></expr></argument>,
                                 <argument><expr><name>groupColIdx</name></expr></argument>,
                                 <argument><expr><name>groupOperators</name></expr></argument>,
                                 <argument><expr><name>NIL</name></expr></argument>,
                                 <argument><expr><name>NIL</name></expr></argument>,
                                 <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr></argument>,
                                 <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>sortList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Sort</name>       <modifier>*</modifier></type><name>sort</name></decl>;</decl_stmt>

        <comment type="block">/* Create an ORDER BY list to sort the input compatibly */</comment>
        <expr_stmt><expr><name>groupColPos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>in_operators</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>in_oper</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>sortop</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>eqop</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>sortop</name> <operator>=</operator> <call><name>get_ordering_op_for_equality_op</name><argument_list>(<argument><expr><name>in_oper</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* shouldn't happen */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find ordering operator for equality operator %u"</literal></expr></argument>,
                     <argument><expr><name>in_oper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * The Unique node will need equality operators.  Normally these
             * are the same as the IN clause operators, but if those are
             * cross-type operators then the equality operators are the ones
             * for the IN clause operators' RHS datatype.
             */</comment>
            <expr_stmt><expr><name>eqop</name> <operator>=</operator> <call><name>get_equality_op_for_ordering_op</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eqop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* shouldn't happen */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find equality operator for ordering operator %u"</literal></expr></argument>,
                     <argument><expr><name>sortop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
                                   <argument><expr><name><name>groupColIdx</name><index>[<expr><name>groupColPos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tle</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <comment type="block">/* get distributed column for remote_subplan */</comment>
            <if_stmt><if>if <condition>(<expr><name>enable_distributed_unique_plan</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>distributed_expr</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>distributed_expr</name> <operator>=</operator> <name>tle</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>sortcl</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><name>tle</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>=</operator> <call><name>assignSortGroupRef</name><argument_list>(<argument><expr><name>tle</name></expr></argument>,
                                                         <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>eqop</name></name> <operator>=</operator> <name>eqop</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>sortop</name></name> <operator>=</operator> <name>sortop</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>    <comment type="block">/* no need to make this accurate */</comment>
            <expr_stmt><expr><name>sortList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>sortList</name></expr></argument>, <argument><expr><name>sortcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>groupColPos</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>enable_distributed_unique_plan</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match_distributed_column</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>bool</name></type> <name>is_distributable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>  <name>hashType</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>distributed_expr</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>hashType</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>distributed_expr</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>is_distributable</name> <operator>=</operator> <call><name>IsTypeHashDistributable</name><argument_list>(<argument><expr><name>hashType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_distributable</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"create_unique_plan using sort: redistribution is impossible because of"</literal>
						<literal type="string">" undistributable hash type %u"</literal></expr></argument>, <argument><expr><name>hashType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>subpath</name> <operator>&amp;&amp;</operator> <name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name> <operator>&amp;&amp;</operator> 
					<name><name>subpath</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>&amp;&amp;</operator> <name>is_distributable</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Distribution</name> <modifier>*</modifier></type><name>distribution</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>distribution</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>distributed_expr</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>subplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><call><name>make_remotesubplan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>distribution</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>sort</name> <operator>=</operator> <call><name>make_sort_from_sortclauses</name><argument_list>(<argument><expr><name>sortList</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>label_sort_with_costsize</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_unique_from_sortclauses</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>sort</name></expr></argument>, <argument><expr><name>sortList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Copy cost data from Path to Plan */</comment>
    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_gather_plan
 *
 *      Create a Gather plan for 'best_path' and (recursively) plans
 *      for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>Gather</name> <modifier>*</modifier></type>
<name>create_gather_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>GatherPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Gather</name>       <modifier>*</modifier></type><name>gather_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>reset</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>contain_nonparallel_hashjoin</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* if child_of_gather is false, set child_of_gather true, and reset the value before return */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>child_of_gather</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>child_of_gather</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>reset</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Although the Gather node can project, we prefer to push down such work
     * to its child node, so demand an exact tlist from the child.
     */</comment>
    <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if contain nonparallel hashjoin, set num_workers to 1 */</comment>
    <expr_stmt><expr><name>contain_nonparallel_hashjoin</name> <operator>=</operator> <call><name>contain_node_walker</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>T_HashJoin</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>gather_plan</name> <operator>=</operator> <call><name>make_gather</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
                              <argument><expr><name>NIL</name></expr></argument>,
                              <argument><expr><ternary><condition><expr><operator>(</operator><name>contain_nonparallel_hashjoin</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name><name>best_path</name><operator>-&gt;</operator><name>num_workers</name></name></expr></else></ternary></expr></argument>,
                              <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>single_copy</name></name></expr></argument>,
                              <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gather_plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* use parallel mode for parallel plans. */</comment>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>reset</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>child_of_gather</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>gather_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_gather_merge_plan
 *
 *      Create a Gather Merge plan for 'best_path' and (recursively)
 *      plans for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>GatherMerge</name> <modifier>*</modifier></type>
<name>create_gather_merge_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>GatherMergePath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GatherMerge</name> <modifier>*</modifier></type><name>gm_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>pathkeys</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name> <init>= <expr><call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* As with Gather, it's best to project away columns in the workers. */</comment>
    <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Create a shell for a GatherMerge plan. */</comment>
    <expr_stmt><expr><name>gm_plan</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>GatherMerge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gm_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>gm_plan</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>num_workers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gm_plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Gather Merge is pointless with no pathkeys; use Gather instead. */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pathkeys</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Compute sort column info, and adjust subplan's tlist as needed */</comment>
    <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>prepare_sort_from_pathkeys</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>,
                                         <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
                                         <argument><expr><name><name>gm_plan</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
                                         <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name><name>gm_plan</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name><name>gm_plan</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name><name>gm_plan</name><operator>-&gt;</operator><name>sortOperators</name></name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name><name>gm_plan</name><operator>-&gt;</operator><name>collations</name></name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name><name>gm_plan</name><operator>-&gt;</operator><name>nullsFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <comment type="block">/* Now, insert a Sort node if subplan isn't sufficiently ordered */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>subplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_sort</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name><name>gm_plan</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>,
                                     <argument><expr><name><name>gm_plan</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
                                     <argument><expr><name><name>gm_plan</name><operator>-&gt;</operator><name>sortOperators</name></name></expr></argument>,
                                     <argument><expr><name><name>gm_plan</name><operator>-&gt;</operator><name>collations</name></name></expr></argument>,
                                     <argument><expr><name><name>gm_plan</name><operator>-&gt;</operator><name>nullsFirst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Now insert the subplan under GatherMerge. */</comment>
    <expr_stmt><expr><name><name>gm_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name> <operator>=</operator> <name>subplan</name></expr>;</expr_stmt>

    <comment type="block">/* use parallel mode for parallel plans. */</comment>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <return>return <expr><name>gm_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_projection_plan
 *
 *      Create a plan tree to do a projection step and (recursively) plans
 *      for its subpaths.  We may need a Result node for the projection,
 *      but sometimes we can just let the subplan do the work.
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>create_projection_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>ProjectionPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>

    <comment type="block">/* Since we intend to project, we don't need to constrain child tlist */</comment>
    <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We might not really need a Result node here, either because the subplan
     * can project or because it's returning the right list of expressions
     * anyway.  Usually create_projection_path will have detected that and set
     * dummypp if we don't need a Result; but its decision can't be final,
     * because some createplan.c routines change the tlists of their nodes.
     * (An example is that create_merge_append_plan might add resjunk sort
     * columns to a MergeAppend.)  So we have to recheck here.  If we do
     * arrive at a different answer than create_projection_path did, we'll
     * have made slightly wrong cost estimates; but label the plan with the
     * cost estimates we actually used, not "corrected" ones.  (XXX this could
     * be cleaned up if we moved more of the sortcolumn setup logic into Path
     * creation, but that would add expense to creating Paths we might end up
     * not using.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>is_projection_capable_path</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>tlist_same_exprs</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Don't need a separate Result, just assign tlist to subplan */</comment>
        <expr_stmt><expr><name>plan</name> <operator>=</operator> <name>subplan</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>

        <comment type="block">/* Label plan with the estimated costs we actually used */</comment>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_width</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
        <comment type="block">/* ... but don't change subplan's parallel_aware flag */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/* set interval child tlist */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Append</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Append</name> <modifier>*</modifier></type><name>append</name> <init>= <expr><operator>(</operator><name>Append</name> <operator>*</operator><operator>)</operator><name>plan</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>append</name><operator>-&gt;</operator><name>interval</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>append-&gt;appendplans</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>child_plan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name><name>child_plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
                </block_content>}</block>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>MergeAppend</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>MergeAppend</name> <modifier>*</modifier></type><name>mergeappend</name> <init>= <expr><operator>(</operator><name>MergeAppend</name> <operator>*</operator><operator>)</operator><name>plan</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>mergeappend</name><operator>-&gt;</operator><name>interval</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>mergeappend-&gt;mergeplans</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>child_plan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name><name>child_plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
                </block_content>}</block>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* We need a Result node */</comment>
        <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_result</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * inject_projection_plan
 *      Insert a Result node to do a projection step.
 *
 * This is used in a few places where we decide on-the-fly that we need a
 * projection step as part of the tree generated for some Path node.
 * We should try to get rid of this in favor of doing it more honestly.
 *
 * One reason it's ugly is we have to be told the right parallel_safe marking
 * to apply (since the tlist might be unsafe even if the child plan is safe).
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>inject_projection_plan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>parallel_safe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_result</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * In principle, we should charge tlist eval cost plus cpu_per_tuple per
     * row for the Result node.  But the former has probably been factored in
     * already and the latter was not accounted for during Path construction,
     * so being formally correct might just make the EXPLAIN output look less
     * consistent not more so.  Hence, just copy the subplan's cost.
     */</comment>
    <expr_stmt><expr><call><name>copy_plan_costsize</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name>parallel_safe</name></expr>;</expr_stmt>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_sort_plan
 *
 *      Create a Sort plan for 'best_path' and (recursively) plans
 *      for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>Sort</name> <modifier>*</modifier></type>
<name>create_sort_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SortPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Sort</name>       <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We don't want any excess columns in the sorted tuples, so request a
     * smaller tlist.  Otherwise, since Sort doesn't project, tlist
     * requirements pass through.
     */</comment>
    <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>,
                                  <argument><expr><name>flags</name> <operator>|</operator> <name>CP_SMALL_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_sort_from_pathkeys</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_aware</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>left</name> <init>= <expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>left</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>T_RemoteSubplan</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>left</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_group_plan
 *
 *      Create a Group plan for 'best_path' and (recursively) plans
 *      for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>Group</name> <modifier>*</modifier></type>
<name>create_group_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>GroupPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Group</name>       <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>quals</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Group can project, so no need to be terribly picky about child tlist,
     * but we do need grouping columns to be available
     */</comment>
    <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>CP_LABEL_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_group</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
                      <argument><expr><name>quals</name></expr></argument>,
                      <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>extract_grouping_cols</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
                                            <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>extract_grouping_ops</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_upper_unique_plan
 *
 *      Create a Unique plan for 'best_path' and (recursively) plans
 *      for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>Unique</name> <modifier>*</modifier></type>
<name>create_upper_unique_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>UpperUniquePath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Unique</name>       <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Unique doesn't project, so tlist requirements pass through; moreover we
     * need grouping columns to be labeled.
     */</comment>
    <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>,
                                  <argument><expr><name>flags</name> <operator>|</operator> <name>CP_LABEL_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_unique_from_pathkeys</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>,
                                     <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></argument>,
                                     <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>numkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_agg_plan
 *
 *      Create an Agg plan for 'best_path' and (recursively) plans
 *      for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>Agg</name> <modifier>*</modifier></type>
<name>create_agg_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>AggPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Agg</name>           <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>quals</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Agg can project, so no need to be terribly picky about child tlist, but
     * we do need grouping columns to be available
     */</comment>
    <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>CP_LABEL_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_agg</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>quals</name></expr></argument>,
                    <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>aggstrategy</name></name></expr></argument>,
                    <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>aggsplit</name></name></expr></argument>,
                    <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>extract_grouping_cols</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
                                          <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>extract_grouping_ops</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>NIL</name></expr></argument>,
                    <argument><expr><name>NIL</name></expr></argument>,
                    <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>numGroups</name></name></expr></argument>,
                    <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<comment type="block">/* set entry size of hashtable using by hashagg */</comment>
	<if_stmt><if>if <condition>(<expr><name>g_hybrid_hash_agg</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>entrySize</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>entrySize</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>hybrid</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>hybrid</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>entrySize</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid hashtable entry size %u"</literal></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>entrySize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>noDistinct</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>noDistinct</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a groupclause for a collection of grouping sets, produce the
 * corresponding groupColIdx.
 *
 * root-&gt;grouping_map maps the tleSortGroupRef to the actual column position in
 * the input tuple. So we get the ref from the entries in the groupclause and
 * look them up there.
 */</comment>
<function><type><specifier>static</specifier> <name>AttrNumber</name> <modifier>*</modifier></type>
<name>remap_groupColIdx</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>grouping_map</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>grouping_map</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>new_grpColIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>grouping_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>new_grpColIdx</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>groupClause</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>new_grpColIdx</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>grouping_map</name><index>[<expr><name><name>clause</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>new_grpColIdx</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_groupingsets_plan
 *      Create a plan for 'best_path' and (recursively) plans
 *      for its subpaths.
 *
 *      What we emit is an Agg plan with some vestigial Agg and Sort nodes
 *      hanging off the side.  The top Agg implements the last grouping set
 *      specified in the GroupingSetsPath, and any additional grouping sets
 *      each give rise to a subsidiary Agg and Sort node in the top Agg's
 *      "chain" list.  These nodes don't participate in the plan directly,
 *      but they are a convenient way to represent the required data for
 *      the extra steps.
 *
 *      Returns a Plan node.
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>create_groupingsets_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>GroupingSetsPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Agg</name>           <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>rollups</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>rollups</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>grouping_map</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>maxref</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>chain</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* Shouldn't get here without grouping sets */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rollups</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Agg can project, so no need to be terribly picky about child tlist, but
     * we do need grouping columns to be available
     */</comment>
    <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>CP_LABEL_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Compute the mapping from tleSortGroupRef to column index in the child's
     * tlist.  First, identify max SortGroupRef in groupClause, for array
     * sizing.
     */</comment>
    <expr_stmt><expr><name>maxref</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;parse-&gt;groupClause</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>gc</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>gc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>&gt;</operator> <name>maxref</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>maxref</name> <operator>=</operator> <name><name>gc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name>grouping_map</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name>maxref</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now look up the column numbers in the child's tlist */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;parse-&gt;groupClause</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>gc</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>gc</name></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>grouping_map</name><index>[<expr><name><name>gc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * During setrefs.c, we'll need the grouping_map to fix up the cols lists
     * in GroupingFunc nodes.  Save it for setrefs.c to use.
     *
     * This doesn't work if we're in an inheritance subtree (see notes in
     * create_modifytable_plan).  Fortunately we can't be because there would
     * never be grouping in an UPDATE/DELETE; but let's Assert that.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>hasInheritedTarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>grouping_map</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>grouping_map</name></name> <operator>=</operator> <name>grouping_map</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Generate the side nodes that describe the other sort and group
     * operations besides the top one.  Note that we don't worry about putting
     * accurate cost estimates in the side nodes; only the topmost Agg node's
     * costs will be shown by EXPLAIN.
     */</comment>
    <expr_stmt><expr><name>chain</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name> <init>= <expr><call><name>lnext</name><argument_list>(<argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>is_first_sort</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RollupData</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>is_hashed</name></expr></init></decl>;</decl_stmt>

        <macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>lc2</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>new_grpColIdx</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>sort_plan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>agg_plan</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>AggStrategy</name></type> <name>strat</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>new_grpColIdx</name> <operator>=</operator> <call><name>remap_groupColIdx</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rollup</name><operator>-&gt;</operator><name>is_hashed</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_first_sort</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>sort_plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator>
                    <call><name>make_sort_from_groupcols</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
                                             <argument><expr><name>new_grpColIdx</name></expr></argument>,
                                             <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rollup</name><operator>-&gt;</operator><name>is_hashed</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>is_first_sort</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>rollup</name><operator>-&gt;</operator><name>is_hashed</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>strat</name> <operator>=</operator> <name>AGG_HASHED</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>strat</name> <operator>=</operator> <name>AGG_PLAIN</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>strat</name> <operator>=</operator> <name>AGG_SORTED</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><name>agg_plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_agg</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>,
                                         <argument><expr><name>NIL</name></expr></argument>,
                                         <argument><expr><name>strat</name></expr></argument>,
                                         <argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
                                         <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><name>new_grpColIdx</name></expr></argument>,
                                         <argument><expr><call><name>extract_grouping_ops</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets</name></name></expr></argument>,
                                         <argument><expr><name>NIL</name></expr></argument>,
                                         <argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name></expr></argument>,
                                         <argument><expr><name>sort_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Remove stuff we don't need to avoid bloating debug output.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>sort_plan</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>sort_plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>sort_plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>chain</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>chain</name></expr></argument>, <argument><expr><name>agg_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Now make the real Agg node
     */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>top_grpColIdx</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>numGroupCols</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>top_grpColIdx</name> <operator>=</operator> <call><name>remap_groupColIdx</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>numGroupCols</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_agg</name><argument_list>(<argument><expr><call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>,
                        <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>aggstrategy</name></name></expr></argument>,
                        <argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
                        <argument><expr><name>numGroupCols</name></expr></argument>,
                        <argument><expr><name>top_grpColIdx</name></expr></argument>,
                        <argument><expr><call><name>extract_grouping_ops</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets</name></name></expr></argument>,
                        <argument><expr><name>chain</name></expr></argument>,
                        <argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name></expr></argument>,
                        <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Copy cost data from Path to Plan */</comment>
        <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_minmaxagg_plan
 *
 *      Create a Result plan for 'best_path' and (recursively) plans
 *      for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>Result</name> <modifier>*</modifier></type>
<name>create_minmaxagg_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>MinMaxAggPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Result</name>       <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* Prepare an InitPlan for each aggregate's subquery. */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>best_path-&gt;mmaggregates</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MinMaxAggInfo</name> <modifier>*</modifier></type><name>mminfo</name> <init>= <expr><operator>(</operator><name>MinMaxAggInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name> <init>= <expr><name><name>mminfo</name><operator>-&gt;</operator><name>subroot</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Query</name>       <modifier>*</modifier></type><name>subparse</name> <init>= <expr><name><name>subroot</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Generate the plan for the subquery. We already have a Path, but we
         * have to convert it to a Plan and attach a LIMIT node above it.
         * Since we are entering a different planner context (subroot),
         * recurse to create_plan not create_plan_recurse.
         */</comment>
        <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>create_plan</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name><name>mminfo</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_limit</name><argument_list>(<argument><expr><name>plan</name></expr></argument>,
                                   <argument><expr><name><name>subparse</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>,
                                   <argument><expr><name><name>subparse</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
								   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Must apply correct cost/width data to Limit node */</comment>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>mminfo</name><operator>-&gt;</operator><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>mminfo</name><operator>-&gt;</operator><name>pathcost</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_width</name></name> <operator>=</operator> <name><name>mminfo</name><operator>-&gt;</operator><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>mminfo</name><operator>-&gt;</operator><name>path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * XL: Add a remote subplan, splitting the LIMIT into a remote and
         * local part LIMIT parts.
         *
         * XXX This should probably happen when constructing the path in
         * create_minmaxagg_path(), not this late.
         *
         * XXX The costing in here is mostly bogus. Not that it'd matter
         * this late, though.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>mminfo</name><operator>-&gt;</operator><name>path</name><operator>-&gt;</operator><name>distribution</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>remote_subplan_depth</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_remotesubplan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>,
                                               <argument><expr><name>NULL</name></expr></argument>,
                                               <argument><expr><name><name>mminfo</name><operator>-&gt;</operator><name>path</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>,
                                               <argument><expr><name><name>mminfo</name><operator>-&gt;</operator><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>remote_subplan_depth</name><operator>--</operator></expr>;</expr_stmt>

            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_limit</name><argument_list>(<argument><expr><name>plan</name></expr></argument>,
                                       <argument><expr><name><name>subparse</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>,
                                       <argument><expr><name><name>subparse</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>,
									   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
									   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>mminfo</name><operator>-&gt;</operator><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>mminfo</name><operator>-&gt;</operator><name>pathcost</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_width</name></name> <operator>=</operator> <name><name>mminfo</name><operator>-&gt;</operator><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Convert the plan into an InitPlan in the outer query. */</comment>
        <expr_stmt><expr><call><name>SS_make_initplan_from_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name><name>mminfo</name><operator>-&gt;</operator><name>param</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Generate the output plan --- basically just a Result */</comment>
    <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_result</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>best_path</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * During setrefs.c, we'll need to replace references to the Agg nodes
     * with InitPlan output params.  (We can't just do that locally in the
     * MinMaxAgg node, because path nodes above here may have Agg references
     * as well.)  Save the mmaggregates list to tell setrefs.c to do that.
     *
     * This doesn't work if we're in an inheritance subtree (see notes in
     * create_modifytable_plan).  Fortunately we can't be because there would
     * never be aggregates in an UPDATE/DELETE; but let's Assert that.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>hasInheritedTarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>minmax_aggs</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>minmax_aggs</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>mmaggregates</name></name></expr>;</expr_stmt>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_windowagg_plan
 *
 *      Create a WindowAgg plan for 'best_path' and (recursively) plans
 *      for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>WindowAgg</name> <modifier>*</modifier></type>
<name>create_windowagg_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>WindowAggPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>WindowAgg</name>  <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>winclause</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numsortkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>sortOperators</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>collations</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nullsFirst</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>partNumCols</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>partColIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>partOperators</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ordNumCols</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>ordColIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>ordOperators</name></decl>;</decl_stmt>

    <comment type="block">/*
     * WindowAgg can project, so no need to be terribly picky about child
     * tlist, but we do need grouping columns to be available
     */</comment>
    <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>CP_LABEL_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We shouldn't need to actually sort, but it's convenient to use
     * prepare_sort_from_pathkeys to identify the input's sort columns.
     */</comment>
    <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>prepare_sort_from_pathkeys</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>,
                                         <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>winpathkeys</name></name></expr></argument>,
                                         <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>numsortkeys</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>sortColIdx</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>sortOperators</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>collations</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now deconstruct that into partition and ordering portions */</comment>
    <expr_stmt><expr><call><name>get_column_info_for_window</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                               <argument><expr><name>wc</name></expr></argument>,
                               <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
                               <argument><expr><name>numsortkeys</name></expr></argument>,
                               <argument><expr><name>sortColIdx</name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name>partNumCols</name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name>partColIdx</name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name>partOperators</name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name>ordNumCols</name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name>ordColIdx</name></expr></argument>,
                               <argument><expr><operator>&amp;</operator><name>ordOperators</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* And finally we can make the WindowAgg node */</comment>
    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_windowagg</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
                          <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>winref</name></name></expr></argument>,
                          <argument><expr><name>partNumCols</name></expr></argument>,
                          <argument><expr><name>partColIdx</name></expr></argument>,
                          <argument><expr><name>partOperators</name></expr></argument>,
                          <argument><expr><name>ordNumCols</name></expr></argument>,
                          <argument><expr><name>ordColIdx</name></expr></argument>,
                          <argument><expr><name>ordOperators</name></expr></argument>,
                          <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>frameOptions</name></name></expr></argument>,
                          <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>,
                          <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>,
                          <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_column_info_for_window
 *        Get the partitioning/ordering column numbers and equality operators
 *        for a WindowAgg node.
 *
 * This depends on the behavior of planner.c's make_pathkeys_for_window!
 *
 * We are given the target WindowClause and an array of the input column
 * numbers associated with the resulting pathkeys.  In the easy case, there
 * are the same number of pathkey columns as partitioning + ordering columns
 * and we just have to copy some data around.  However, it's possible that
 * some of the original partitioning + ordering columns were eliminated as
 * redundant during the transformation to pathkeys.  (This can happen even
 * though the parser gets rid of obvious duplicates.  A typical scenario is a
 * window specification "PARTITION BY x ORDER BY y" coupled with a clause
 * "WHERE x = y" that causes the two sort columns to be recognized as
 * redundant.)    In that unusual case, we have to work a lot harder to
 * determine which keys are significant.
 *
 * The method used here is a bit brute-force: add the sort columns to a list
 * one at a time and note when the resulting pathkey list gets longer.  But
 * it's a sufficiently uncommon case that a faster way doesn't seem worth
 * the amount of code refactoring that'd be needed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_column_info_for_window</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>wc</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
                           <parameter><decl><type><name>int</name></type> <name>numSortCols</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl></parameter>,
                           <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>partNumCols</name></decl></parameter>,
                           <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier><modifier>*</modifier></type><name>partColIdx</name></decl></parameter>,
                           <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>partOperators</name></decl></parameter>,
                           <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ordNumCols</name></decl></parameter>,
                           <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier><modifier>*</modifier></type><name>ordColIdx</name></decl></parameter>,
                           <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>ordOperators</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>numPart</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numOrder</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>numSortCols</name> <operator>==</operator> <name>numPart</name> <operator>+</operator> <name>numOrder</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* easy case */</comment>
        <expr_stmt><expr><operator>*</operator><name>partNumCols</name> <operator>=</operator> <name>numPart</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>partColIdx</name> <operator>=</operator> <name>sortColIdx</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>partOperators</name> <operator>=</operator> <call><name>extract_grouping_ops</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>ordNumCols</name> <operator>=</operator> <name>numOrder</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>ordColIdx</name> <operator>=</operator> <name>sortColIdx</name> <operator>+</operator> <name>numPart</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>ordOperators</name> <operator>=</operator> <call><name>extract_grouping_ops</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>sortclauses</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>pathkeys</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>scidx</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

        <comment type="block">/* first, allocate what's certainly enough space for the arrays */</comment>
        <expr_stmt><expr><operator>*</operator><name>partNumCols</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>partColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numPart</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>partOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numPart</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>ordNumCols</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>ordColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numOrder</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>ordOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numOrder</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sortclauses</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pathkeys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>scidx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>wc-&gt;partitionClause</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgc</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>new_pathkeys</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>sortclauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>sortclauses</name></expr></argument>, <argument><expr><name>sgc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>new_pathkeys</name> <operator>=</operator> <call><name>make_pathkeys_for_sortclauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                         <argument><expr><name>sortclauses</name></expr></argument>,
                                                         <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>new_pathkeys</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* this sort clause is actually significant */</comment>
                <expr_stmt><expr><operator>(</operator><operator>*</operator><name>partColIdx</name><operator>)</operator><index>[<expr><operator>*</operator><name>partNumCols</name></expr>]</index> <operator>=</operator> <name><name>sortColIdx</name><index>[<expr><name>scidx</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>(</operator><operator>*</operator><name>partOperators</name><operator>)</operator><index>[<expr><operator>*</operator><name>partNumCols</name></expr>]</index> <operator>=</operator> <name><name>sgc</name><operator>-&gt;</operator><name>eqop</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>(</operator><operator>*</operator><name>partNumCols</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>pathkeys</name> <operator>=</operator> <name>new_pathkeys</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>wc-&gt;orderClause</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgc</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>new_pathkeys</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>sortclauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>sortclauses</name></expr></argument>, <argument><expr><name>sgc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>new_pathkeys</name> <operator>=</operator> <call><name>make_pathkeys_for_sortclauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                         <argument><expr><name>sortclauses</name></expr></argument>,
                                                         <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>new_pathkeys</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* this sort clause is actually significant */</comment>
                <expr_stmt><expr><operator>(</operator><operator>*</operator><name>ordColIdx</name><operator>)</operator><index>[<expr><operator>*</operator><name>ordNumCols</name></expr>]</index> <operator>=</operator> <name><name>sortColIdx</name><index>[<expr><name>scidx</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>(</operator><operator>*</operator><name>ordOperators</name><operator>)</operator><index>[<expr><operator>*</operator><name>ordNumCols</name></expr>]</index> <operator>=</operator> <name><name>sgc</name><operator>-&gt;</operator><name>eqop</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>(</operator><operator>*</operator><name>ordNumCols</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>pathkeys</name> <operator>=</operator> <name>new_pathkeys</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <comment type="block">/* complain if we didn't eat exactly the right number of sort cols */</comment>
        <if_stmt><if>if <condition>(<expr><name>scidx</name> <operator>!=</operator> <name>numSortCols</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to deconstruct sort operators into partitioning/ordering operators"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * create_setop_plan
 *
 *      Create a SetOp plan for 'best_path' and (recursively) plans
 *      for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>SetOp</name> <modifier>*</modifier></type>
<name>create_setop_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SetOpPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SetOp</name>       <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>numGroups</name></decl>;</decl_stmt>

    <comment type="block">/*
     * SetOp doesn't project, so tlist requirements pass through; moreover we
     * need grouping columns to be labeled.
     */</comment>
    <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>,
                                  <argument><expr><name>flags</name> <operator>|</operator> <name>CP_LABEL_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Convert numGroups to long int --- but 'ware overflow! */</comment>
    <expr_stmt><expr><name>numGroups</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>numGroups</name></name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>LONG_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_setop</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>cmd</name></name></expr></argument>,
                      <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>,
                      <argument><expr><name>subplan</name></expr></argument>,
                      <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>distinctList</name></name></expr></argument>,
                      <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>flagColIdx</name></name></expr></argument>,
                      <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>firstFlag</name></name></expr></argument>,
                      <argument><expr><name>numGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_recursiveunion_plan
 *
 *      Create a RecursiveUnion plan for 'best_path' and (recursively) plans
 *      for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>RecursiveUnion</name> <modifier>*</modifier></type>
<name>create_recursiveunion_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RecursiveUnionPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RecursiveUnion</name> <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>leftplan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>rightplan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>numGroups</name></decl>;</decl_stmt>

    <comment type="block">/* Need both children to produce same tlist, so force it */</comment>
    <expr_stmt><expr><name>leftplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>leftpath</name></name></expr></argument>, <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rightplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>rightpath</name></name></expr></argument>, <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Convert numGroups to long int --- but 'ware overflow! */</comment>
    <expr_stmt><expr><name>numGroups</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>numGroups</name></name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>LONG_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_recursive_union</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                <argument><expr><name>tlist</name></expr></argument>,
                                <argument><expr><name>leftplan</name></expr></argument>,
                                <argument><expr><name>rightplan</name></expr></argument>,
                                <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>wtParam</name></name></expr></argument>,
                                <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>distinctList</name></name></expr></argument>,
                                <argument><expr><name>numGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_lockrows_plan
 *
 *      Create a LockRows plan for 'best_path' and (recursively) plans
 *      for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>LockRows</name> <modifier>*</modifier></type>
<name>create_lockrows_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>LockRowsPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                     <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LockRows</name>   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>

    <comment type="block">/* LockRows doesn't project, so tlist requirements pass through */</comment>
    <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_lockrows</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>epqParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_modifytable_plan
 *      Create a ModifyTable plan for 'best_path'.
 *
 *      Returns a Plan node.
 */</comment>
<function><type><specifier>static</specifier> <name>ModifyTable</name> <modifier>*</modifier></type>
<name>create_modifytable_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>ModifyTablePath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subplans</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>subpaths</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>subroots</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>RangeTblEntry</name>   <modifier>*</modifier></type><name>audit_rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>            <modifier>*</modifier></type><name>audit_fga_quals_stmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name>need_audit_fga_quals</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>operation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>        <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

    <comment type="block">/* Build the plan for each input path */</comment>
    <macro><name>forboth</name><argument_list>(<argument>subpaths</argument>, <argument>best_path-&gt;subpaths</argument>,
            <argument>subroots</argument>, <argument>best_path-&gt;subroots</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name> <init>= <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>subroots</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>

        <comment type="block">/*
         * In an inherited UPDATE/DELETE, reference the per-child modified
         * subroot while creating Plans from Paths for the child rel.  This is
         * a kluge, but otherwise it's too hard to ensure that Plan creation
         * functions (particularly in FDWs) don't depend on the contents of
         * "root" matching what they saw at Path creation time.  The main
         * downside is that creation functions for Plans that might appear
         * below a ModifyTable cannot expect to modify the contents of "root"
         * and have it "stick" for subsequent processing such as setrefs.c.
         * That's not great, but it seems better than the alternative.
         */</comment>
        <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Transfer resname/resjunk labeling, too, to keep executor happy */</comment>
        <expr_stmt><expr><call><name>apply_tlist_labeling</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name><name>subroot</name><operator>-&gt;</operator><name>processed_tlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>subplans</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_modifytable</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                            <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>operation</name></name></expr></argument>,
                            <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>,
                            <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>nominalRelation</name></name></expr></argument>,
                            <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>partitioned_rels</name></name></expr></argument>,
							<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>partColsUpdated</name></name></expr></argument>,
                            <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>resultRelations</name></name></expr></argument>,
                            <argument><expr><name>subplans</name></expr></argument>,
                            <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>withCheckOptionLists</name></name></expr></argument>,
                            <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>,
                            <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>rowMarks</name></name></expr></argument>,
                            <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>onconflict</name></name></expr></argument>,
                            <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>epqParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>enable_fga</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>audit_fga_quals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>audit_rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>CMD_INSERT</name></expr>:</case>
                <expr_stmt><expr><name>operation</name> <operator>=</operator> <literal type="string">"Insert"</literal></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
                <expr_stmt><expr><name>operation</name> <operator>=</operator> <literal type="string">"Update"</literal></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>CMD_DELETE</name></expr>:</case>
                <expr_stmt><expr><name>operation</name> <operator>=</operator> <literal type="string">"Delete"</literal></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><name>operation</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
            
        <expr_stmt><expr><name>need_audit_fga_quals</name> <operator>=</operator> <call><name>get_audit_fga_quals</name><argument_list>(<argument><expr><name><name>audit_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>operation</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>audit_fga_quals_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>need_audit_fga_quals</name></expr>)</condition>
        <block>{<block_content>
            <macro><name>foreach</name> <argument_list>(<argument>item</argument>, <argument>audit_fga_quals_stmt</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AuditFgaPolicy</name> <modifier>*</modifier></type><name>audit_fga_qual</name> <init>= <expr><operator>(</operator><name>AuditFgaPolicy</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>audit_fga_qual</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>audit_fga_log_policy_info</name><argument_list>(<argument><expr><name>audit_fga_qual</name></expr></argument>, <argument><expr><name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>audit_fga_quals_stmt</name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name>audit_fga_quals_stmt</name></expr></argument>, <argument><expr><name>audit_fga_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                   
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            
            <if_stmt><if>if <condition>(<expr><name>audit_fga_quals_stmt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>audit_fga_quals</name></name> <operator>=</operator> <name>audit_fga_quals_stmt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<comment type="block">/*
	 * If we have unshippable triggers, we have to do DML on coordinators,
	 * generate remote_dml plan now.
     */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>hasUnshippableTriggers</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>create_remotedml_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><name>plan</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>operation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_limit_plan
 *
 *      Create a Limit plan for 'best_path' and (recursively) plans
 *      for its subpaths.
 */</comment>
<function><type><specifier>static</specifier> <name>Limit</name> <modifier>*</modifier></type>
<name>create_limit_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>LimitPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
                  <parameter><decl><type><name>int64</name></type> <name>offset_est</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>count_est</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Limit</name>       <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>

    <comment type="block">/* Limit doesn't project, so tlist requirements pass through */</comment>
    <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_limit</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>,
                      <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>,
                      <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>,
					  <argument><expr><name>offset_est</name></expr></argument>, <argument><expr><name>count_est</name></expr></argument>,
					  <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>skipEarlyFinish</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<comment type="block">/*
 * adjust_subplan_distribution
 *     Make sure the distribution of the subplan is matching to the consumers.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>adjust_subplan_distribution</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Distribution</name> <modifier>*</modifier></type><name>pathd</name></decl></parameter>,
                          <parameter><decl><type><name>Distribution</name> <modifier>*</modifier></type><name>subd</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* Replace path restriction with actual */</comment>
    <if_stmt><if>if <condition>(<expr><name>pathd</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRestrict</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>pathd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathd</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRestrict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRestrict</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Set new restriction for the subpath.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>subd</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If subpath is replicated without restriction choose one execution
         * datanode and set it as current restriction.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsLocatorReplicated</name><argument_list>(<argument><expr><name><name>subd</name><operator>-&gt;</operator><name>distributionType</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                <call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>subd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>execute</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>common</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>node</name></decl>;</decl_stmt>

            <comment type="block">/*
             * We should choose one of the distribution nodes, but we can save
             * some network traffic if chosen execution node will be one of
             * the result nodes at the same time.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>pathd</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <ternary><condition><expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>pathd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then>
                                        <expr><name><name>pathd</name><operator>-&gt;</operator><name>nodes</name></name></expr> </then><else>: <expr><name><name>pathd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>execute</name> <operator>=</operator> <ternary><condition><expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>subd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then>
                                        <expr><name><name>subd</name><operator>-&gt;</operator><name>nodes</name></name></expr> </then><else>: <expr><name><name>subd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name>common</name> <operator>=</operator> <call><name>bms_intersect</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>execute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>common</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>subd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Check if any of the common nodes is preferred and choose one
             * of the preferred
             */</comment>
            <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>GetAnyDataNode</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* set restriction for the subplan */</comment>
            <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRestrict</name></name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* replace execution restriction for the generated  */</comment>
            <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>subd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>subd</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * create_remotescan_plan
 *      Create a RemoteSubquery plan for 'best_path' and (recursively) plans
 *      for its subpaths.
 *
 *      Returns a Plan node.
 */</comment>
<function><type><specifier>static</specifier> <name>RemoteSubplan</name> <modifier>*</modifier></type>
<name>create_remotescan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                       <parameter><decl><type><name>RemoteSubPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RemoteSubplan</name>  <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>              <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name>         <modifier>*</modifier></type><name>saverestrict</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>Path</name>           <modifier>*</modifier></type><name>subpath</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>           <modifier>*</modifier></type><name>pathkeys</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type>             <name>numsortkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name>       <modifier>*</modifier></type><name>sortColIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>               <modifier>*</modifier></type><name>sortOperators</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>               <modifier>*</modifier></type><name>collations</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>           <modifier>*</modifier></type><name>nullsFirst</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Subsequent code will modify current restriction, it needs to be restored
     * so other path nodes in the outer tree could see correct value.
     */</comment>
    <expr_stmt><expr><name>saverestrict</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>curOuterRestrict</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>adjust_subplan_distribution</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name></expr></argument>,
                                <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We don't want any excess columns in the remote tuples */</comment>
    <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>CP_SMALL_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* */</comment>
    <expr_stmt><expr><name>subplan</name> <operator>=</operator>  <call><name>prepare_sort_from_pathkeys</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><name>subplan</name></expr></argument>,
                                      <argument><expr><name>pathkeys</name></expr></argument>,
                                      <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
                                      <argument><expr><name>NULL</name></expr></argument>,
                                      <argument><expr><name>false</name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name>numsortkeys</name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name>sortColIdx</name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name>sortOperators</name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name>collations</name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now, insert a Sort node if subplan isn't sufficiently ordered */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>subplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_sort</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>numsortkeys</name></expr></argument>,
                                     <argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name>sortOperators</name></expr></argument>,
                                     <argument><expr><name>collations</name></expr></argument>, <argument><expr><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>label_sort_with_costsize</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Sort</name> <operator>*</operator><operator>)</operator><name>subplan</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>make_remotesubplan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>,
                              <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name></expr></argument>,
                              <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>,
                              <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>olap_optimizer</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator><name>best_path</name><operator>)</operator><operator>-&gt;</operator><name>startup_cost</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator><name>best_path</name><operator>)</operator><operator>-&gt;</operator><name>total_cost</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>plan_rows</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator><name>best_path</name><operator>)</operator><operator>-&gt;</operator><name>rows</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>plan_width</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator><name>best_path</name><operator>)</operator><operator>-&gt;</operator><name><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* restore current restrict */</comment>
    <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRestrict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRestrict</name></name> <operator>=</operator> <name>saverestrict</name></expr>;</expr_stmt>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>RemoteSubplan</name> <modifier>*</modifier></type>
<name>find_push_down_plan_int</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>delete</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier><modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>RemoteSubplan</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>(</operator><name>force</name> <operator>||</operator> <operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RemoteSubplan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>nodeList</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
                       <operator>(</operator><operator>(</operator><name>RemoteSubplan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>execOnAll</name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>delete</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>parent</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>parent</name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><operator>(</operator><name>RemoteSubplan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Hash</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Material</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Unique</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Limit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>find_push_down_plan_int</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>force</name></expr></argument>, <argument><expr><name>delete</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If its a subquery scan and we are looking to replace RemoteSubplan then
     * walk down the subplan to find a RemoteSubplan
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>parent</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator><name>plan</name><operator>)</operator><operator>-&gt;</operator><name>subplan</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RemoteSubplan</name> <modifier>*</modifier></type><name>remote_plan</name> <init>= <expr><call><name>find_push_down_plan_int</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                <argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>force</name></expr></argument>, <argument><expr><name>delete</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subplan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * XXX This used to update rel-&gt;subplan, but thanks to upper-planner
         * pathification the field was removed. But maybe this needs to tweak
         * subroot instead?
         */</comment>

        <return>return <expr><name>remote_plan</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RemoteSubplan</name> <modifier>*</modifier></type>
<name>find_push_down_plan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>find_push_down_plan_int</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>force</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block" format="doxygen">/*****************************************************************************
 *
 *    BASE-RELATION SCAN METHODS
 *
 *****************************************************************************/</comment>


<comment type="block">/*
 * create_seqscan_plan
 *     Returns a seqscan plan for the base relation scanned by 'best_path'
 *     with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>SeqScan</name> <modifier>*</modifier></type>
<name>create_seqscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                    <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>SeqScan</name>         <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name></type>            <name>scan_relid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>operation</name> <init>= <expr><literal type="string">"select"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name>   <modifier>*</modifier></type><name>audit_rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>            <modifier>*</modifier></type><name>audit_fga_quals_stmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>        <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name>need_audit_fga_quals</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* it should be a base rel... */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Sort clauses into best execution order */</comment>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name>make_seqscan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
                             <argument><expr><name>scan_clauses</name></expr></argument>,
                             <argument><expr><name>scan_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>enable_fga</name> <operator>&amp;&amp;</operator> <name>g_commandTag</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>g_commandTag</name></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>audit_fga_quals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>audit_rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>need_audit_fga_quals</name> <operator>=</operator> <call><name>get_audit_fga_quals</name><argument_list>(<argument><expr><name><name>audit_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>operation</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>audit_fga_quals_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>need_audit_fga_quals</name></expr>)</condition>
        <block>{<block_content>
            <macro><name>foreach</name> <argument_list>(<argument>item</argument>, <argument>audit_fga_quals_stmt</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AuditFgaPolicy</name> <modifier>*</modifier></type><name>audit_fga_qual</name> <init>= <expr><operator>(</operator><name>AuditFgaPolicy</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>audit_fga_qual</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>audit_fga_log_policy_info</name><argument_list>(<argument><expr><name>audit_fga_qual</name></expr></argument>, <argument><expr><name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>audit_fga_quals_stmt</name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name>audit_fga_quals_stmt</name></expr></argument>, <argument><expr><name>audit_fga_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                   
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>

            <if_stmt><if>if <condition>(<expr><name>audit_fga_quals_stmt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>audit_fga_quals</name></name> <operator>=</operator> <name>audit_fga_quals_stmt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_samplescan_plan
 *     Returns a samplescan plan for the base relation scanned by 'best_path'
 *     with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>SampleScan</name> <modifier>*</modifier></type>
<name>create_samplescan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                       <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>SampleScan</name> <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name></type>        <name>scan_relid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TableSampleClause</name> <modifier>*</modifier></type><name>tsc</name></decl>;</decl_stmt>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>operation</name> <init>= <expr><literal type="string">"select"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name>   <modifier>*</modifier></type><name>audit_rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>            <modifier>*</modifier></type><name>audit_fga_quals_stmt</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name>need_audit_fga_quals</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>        <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

    <comment type="block">/* it should be a base rel with a tablesample clause... */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tsc</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tsc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <comment type="block">/* Sort clauses into best execution order */</comment>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tsc</name> <operator>=</operator> <operator>(</operator><name>TableSampleClause</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name>make_samplescan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
                                <argument><expr><name>scan_clauses</name></expr></argument>,
                                <argument><expr><name>scan_relid</name></expr></argument>,
                                <argument><expr><name>tsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>enable_fga</name> <operator>&amp;&amp;</operator> <name>g_commandTag</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>g_commandTag</name></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>audit_fga_quals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>audit_rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>need_audit_fga_quals</name> <operator>=</operator> <call><name>get_audit_fga_quals</name><argument_list>(<argument><expr><name><name>audit_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>operation</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>audit_fga_quals_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>need_audit_fga_quals</name></expr>)</condition>
        <block>{<block_content>
            <macro><name>foreach</name> <argument_list>(<argument>item</argument>, <argument>audit_fga_quals_stmt</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AuditFgaPolicy</name> <modifier>*</modifier></type><name>audit_fga_qual</name> <init>= <expr><operator>(</operator><name>AuditFgaPolicy</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>audit_fga_qual</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>audit_fga_log_policy_info</name><argument_list>(<argument><expr><name>audit_fga_qual</name></expr></argument>, <argument><expr><name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>audit_fga_quals_stmt</name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name>audit_fga_quals_stmt</name></expr></argument>, <argument><expr><name>audit_fga_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                   
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>

            <if_stmt><if>if <condition>(<expr><name>audit_fga_quals_stmt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>audit_fga_quals</name></name> <operator>=</operator> <name>audit_fga_quals_stmt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_indexscan_plan
 *      Returns an indexscan plan for the base relation scanned by 'best_path'
 *      with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 *
 * We use this for both plain IndexScans and IndexOnlyScans, because the
 * qual preprocessing work is the same for both.  Note that the caller tells
 * us which to build --- we don't look at best_path-&gt;path.pathtype, because
 * create_bitmap_subplan needs to be able to override the prior decision.
 */</comment>
<function><type><specifier>static</specifier> <name>Scan</name> <modifier>*</modifier></type>
<name>create_indexscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                      <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name></type> <name>indexonly</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Scan</name>       <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>indexquals</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>indexquals</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>indexorderbys</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>indexorderbys</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name></type>        <name>baserelid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>indexoid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>indexinfo</name><operator>-&gt;</operator><name>indexoid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>qpqual</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>stripped_indexquals</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>fixed_indexquals</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>fixed_indexorderbys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>indexorderbyops</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>operation</name> <init>= <expr><literal type="string">"select"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name>   <modifier>*</modifier></type><name>audit_rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>            <modifier>*</modifier></type><name>audit_fga_quals_stmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name>need_audit_fga_quals</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>        <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* it should be a base rel... */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>baserelid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Build "stripped" indexquals structure (no RestrictInfos) to pass to
     * executor as indexqualorig
     */</comment>
    <expr_stmt><expr><name>stripped_indexquals</name> <operator>=</operator> <call><name>get_actual_clauses</name><argument_list>(<argument><expr><name>indexquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The executor needs a copy with the indexkey on the left of each clause
     * and with index Vars substituted for table ones.
     */</comment>
    <expr_stmt><expr><name>fixed_indexquals</name> <operator>=</operator> <call><name>fix_indexqual_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Likewise fix up index attr references in the ORDER BY expressions.
     */</comment>
    <expr_stmt><expr><name>fixed_indexorderbys</name> <operator>=</operator> <call><name>fix_indexorderby_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The qpqual list must contain all restrictions not automatically handled
     * by the index, other than pseudoconstant clauses which will be handled
     * by a separate gating plan node.  All the predicates in the indexquals
     * will be checked (either by the index itself, or by nodeIndexscan.c),
     * but if there are any "special" operators involved then they must be
     * included in qpqual.  The upshot is that qpqual must contain
     * scan_clauses minus whatever appears in indexquals.
     *
     * In normal cases simple pointer equality checks will be enough to spot
     * duplicate RestrictInfos, so we try that first.
     *
     * Another common case is that a scan_clauses entry is generated from the
     * same EquivalenceClass as some indexqual, and is therefore redundant
     * with it, though not equal.  (This happens when indxpath.c prefers a
     * different derived equality than what generate_join_implied_equalities
     * picked for a parameterized scan's ppi_clauses.)
     *
     * In some situations (particularly with OR'd index conditions) we may
     * have scan_clauses that are not equal to, but are logically implied by,
     * the index quals; so we also try a predicate_implied_by() check to see
     * if we can discard quals that way.  (predicate_implied_by assumes its
     * first input contains only immutable functions, so we have to check
     * that.)
     *
     * Note: if you change this bit of code you should also look at
     * extract_nonindex_conditions() in costsize.c.
     */</comment>
    <expr_stmt><expr><name>qpqual</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>scan_clauses</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* we may drop pseudoconstants here */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>list_member_ptr</name><argument_list>(<argument><expr><name>indexquals</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* simple duplicate */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>is_redundant_derived_clause</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>indexquals</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* derived from same EquivalenceClass */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>predicate_implied_by</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>indexquals</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* provably implied by indexquals */</comment>
        <expr_stmt><expr><name>qpqual</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>qpqual</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Sort clauses into best execution order */</comment>
    <expr_stmt><expr><name>qpqual</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>qpqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
    <expr_stmt><expr><name>qpqual</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>qpqual</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We have to replace any outer-relation variables with nestloop params in
     * the indexqualorig, qpqual, and indexorderbyorig expressions.  A bit
     * annoying to have to do this separately from the processing in
     * fix_indexqual_references --- rethink this when generalizing the inner
     * indexscan support.  But note we can't really do this earlier because
     * it'd break the comparisons to predicates above ... (or would it?  Those
     * wouldn't have outer refs)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>stripped_indexquals</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stripped_indexquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>qpqual</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>qpqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>indexorderbys</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>indexorderbys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If there are ORDER BY expressions, look up the sort operators for their
     * result datatypes.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>indexorderbys</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>pathkeyCell</name></decl>,
                   <decl><type ref="prev"><modifier>*</modifier></type><name>exprCell</name></decl>;</decl_stmt>

        <comment type="block">/*
         * PathKey contains OID of the btree opfamily we're sorting by, but
         * that's not quite enough because we need the expression's datatype
         * to look up the sort operator in the operator family.
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>indexorderbys</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>forboth</name><argument_list>(<argument>pathkeyCell</argument>, <argument>best_path-&gt;path.pathkeys</argument>, <argument>exprCell</argument>, <argument>indexorderbys</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>pathkey</name> <init>= <expr><operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>pathkeyCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>exprCell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>exprtype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>sortop</name></decl>;</decl_stmt>

            <comment type="block">/* Get sort operator from opfamily */</comment>
            <expr_stmt><expr><name>sortop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>,
                                         <argument><expr><name>exprtype</name></expr></argument>,
                                         <argument><expr><name>exprtype</name></expr></argument>,
                                         <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing operator %d(%u,%u) in opfamily %u"</literal></expr></argument>,
                     <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name></expr></argument>, <argument><expr><name>exprtype</name></expr></argument>, <argument><expr><name>exprtype</name></expr></argument>, <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>indexorderbyops</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>indexorderbyops</name></expr></argument>, <argument><expr><name>sortop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Finally ready to build the plan node */</comment>
    <if_stmt><if>if <condition>(<expr><name>indexonly</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <call><name>make_indexonlyscan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
                                                <argument><expr><name>qpqual</name></expr></argument>,
                                                <argument><expr><name>baserelid</name></expr></argument>,
                                                <argument><expr><name>indexoid</name></expr></argument>,
                                                <argument><expr><name>fixed_indexquals</name></expr></argument>,
                                                <argument><expr><name>fixed_indexorderbys</name></expr></argument>,
                                                <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>indexinfo</name><operator>-&gt;</operator><name>indextlist</name></name></expr></argument>,
                                                <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>indexscandir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <call><name>make_indexscan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
                                            <argument><expr><name>qpqual</name></expr></argument>,
                                            <argument><expr><name>baserelid</name></expr></argument>,
                                            <argument><expr><name>indexoid</name></expr></argument>,
                                            <argument><expr><name>fixed_indexquals</name></expr></argument>,
                                            <argument><expr><name>stripped_indexquals</name></expr></argument>,
                                            <argument><expr><name>fixed_indexorderbys</name></expr></argument>,
                                            <argument><expr><name>indexorderbys</name></expr></argument>,
                                            <argument><expr><name>indexorderbyops</name></expr></argument>,
                                            <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>indexscandir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>enable_fga</name> <operator>&amp;&amp;</operator> <name>g_commandTag</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>g_commandTag</name></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>audit_fga_quals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>audit_rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>baserelid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>need_audit_fga_quals</name> <operator>=</operator> <call><name>get_audit_fga_quals</name><argument_list>(<argument><expr><name><name>audit_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>operation</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>audit_fga_quals_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>need_audit_fga_quals</name></expr>)</condition>
        <block>{<block_content>
            <macro><name>foreach</name> <argument_list>(<argument>item</argument>, <argument>audit_fga_quals_stmt</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AuditFgaPolicy</name> <modifier>*</modifier></type><name>audit_fga_qual</name> <init>= <expr><operator>(</operator><name>AuditFgaPolicy</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>audit_fga_qual</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>audit_fga_log_policy_info</name><argument_list>(<argument><expr><name>audit_fga_qual</name></expr></argument>, <argument><expr><name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>audit_fga_quals_stmt</name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name>audit_fga_quals_stmt</name></expr></argument>, <argument><expr><name>audit_fga_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                   
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>

            <if_stmt><if>if <condition>(<expr><name>audit_fga_quals_stmt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>audit_fga_quals</name></name> <operator>=</operator> <name>audit_fga_quals_stmt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_bitmap_scan_plan
 *      Returns a bitmap scan plan for the base relation scanned by 'best_path'
 *      with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>BitmapHeapScan</name> <modifier>*</modifier></type>
<name>create_bitmap_scan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                        <parameter><decl><type><name>BitmapHeapPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                        <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
                        <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Index</name></type>        <name>baserelid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>bitmapqualplan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>bitmapqualorig</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>indexquals</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>indexECs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>qpqual</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BitmapHeapScan</name> <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>operation</name> <init>= <expr><literal type="string">"select"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name>   <modifier>*</modifier></type><name>audit_rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>            <modifier>*</modifier></type><name>audit_fga_quals_stmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name>need_audit_fga_quals</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>        <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

    <comment type="block">/* it should be a base rel... */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>baserelid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Process the bitmapqual tree into a Plan tree and qual lists */</comment>
    <expr_stmt><expr><name>bitmapqualplan</name> <operator>=</operator> <call><name>create_bitmap_subplan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>bitmapqual</name></name></expr></argument>,
                                           <argument><expr><operator>&amp;</operator><name>bitmapqualorig</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>indexquals</name></expr></argument>,
                                           <argument><expr><operator>&amp;</operator><name>indexECs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>bitmap_subplan_mark_shared</name><argument_list>(<argument><expr><name>bitmapqualplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * The qpqual list must contain all restrictions not automatically handled
     * by the index, other than pseudoconstant clauses which will be handled
     * by a separate gating plan node.  All the predicates in the indexquals
     * will be checked (either by the index itself, or by
     * nodeBitmapHeapscan.c), but if there are any "special" operators
     * involved then they must be added to qpqual.  The upshot is that qpqual
     * must contain scan_clauses minus whatever appears in indexquals.
     *
     * This loop is similar to the comparable code in create_indexscan_plan(),
     * but with some differences because it has to compare the scan clauses to
     * stripped (no RestrictInfos) indexquals.  See comments there for more
     * info.
     *
     * In normal cases simple equal() checks will be enough to spot duplicate
     * clauses, so we try that first.  We next see if the scan clause is
     * redundant with any top-level indexqual by virtue of being generated
     * from the same EC.  After that, try predicate_implied_by().
     *
     * Unlike create_indexscan_plan(), the predicate_implied_by() test here is
     * useful for getting rid of qpquals that are implied by index predicates,
     * because the predicate conditions are included in the "indexquals"
     * returned by create_bitmap_subplan().  Bitmap scans have to do it that
     * way because predicate conditions need to be rechecked if the scan
     * becomes lossy, so they have to be included in bitmapqualorig.
     */</comment>
    <expr_stmt><expr><name>qpqual</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>scan_clauses</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>pseudoconstant</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* we may drop pseudoconstants here */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>list_member</name><argument_list>(<argument><expr><name>indexquals</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* simple duplicate */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>parent_ec</name></name> <operator>&amp;&amp;</operator> <call><name>list_member_ptr</name><argument_list>(<argument><expr><name>indexECs</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>parent_ec</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* derived from same EquivalenceClass */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>predicate_implied_by</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>indexquals</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>            <comment type="block">/* provably implied by indexquals */</comment>
        <expr_stmt><expr><name>qpqual</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>qpqual</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Sort clauses into best execution order */</comment>
    <expr_stmt><expr><name>qpqual</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>qpqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
    <expr_stmt><expr><name>qpqual</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>qpqual</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * When dealing with special operators, we will at this point have
     * duplicate clauses in qpqual and bitmapqualorig.  We may as well drop
     * 'em from bitmapqualorig, since there's no point in making the tests
     * twice.
     */</comment>
    <expr_stmt><expr><name>bitmapqualorig</name> <operator>=</operator> <call><name>list_difference_ptr</name><argument_list>(<argument><expr><name>bitmapqualorig</name></expr></argument>, <argument><expr><name>qpqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We have to replace any outer-relation variables with nestloop params in
     * the qpqual and bitmapqualorig expressions.  (This was already done for
     * expressions attached to plan nodes in the bitmapqualplan tree.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>qpqual</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>qpqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bitmapqualorig</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>bitmapqualorig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Finally ready to build the plan node */</comment>
    <expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name>make_bitmap_heapscan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
                                     <argument><expr><name>qpqual</name></expr></argument>,
                                     <argument><expr><name>bitmapqualplan</name></expr></argument>,
                                     <argument><expr><name>bitmapqualorig</name></expr></argument>,
                                     <argument><expr><name>baserelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>enable_fga</name> <operator>&amp;&amp;</operator> <name>g_commandTag</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>g_commandTag</name></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>audit_fga_quals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>audit_rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>baserelid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>need_audit_fga_quals</name> <operator>=</operator> <call><name>get_audit_fga_quals</name><argument_list>(<argument><expr><name><name>audit_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>operation</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>audit_fga_quals_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>need_audit_fga_quals</name></expr>)</condition>
        <block>{<block_content>
            <macro><name>foreach</name> <argument_list>(<argument>item</argument>, <argument>audit_fga_quals_stmt</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AuditFgaPolicy</name> <modifier>*</modifier></type><name>audit_fga_qual</name> <init>= <expr><operator>(</operator><name>AuditFgaPolicy</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>audit_fga_qual</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>audit_fga_log_policy_info</name><argument_list>(<argument><expr><name>audit_fga_qual</name></expr></argument>, <argument><expr><name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>audit_fga_quals_stmt</name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name>audit_fga_quals_stmt</name></expr></argument>, <argument><expr><name>audit_fga_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                   
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>

            <if_stmt><if>if <condition>(<expr><name>audit_fga_quals_stmt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>audit_fga_quals</name></name> <operator>=</operator> <name>audit_fga_quals_stmt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a bitmapqual tree, generate the Plan tree that implements it
 *
 * As byproducts, we also return in *qual and *indexqual the qual lists
 * (in implicit-AND form, without RestrictInfos) describing the original index
 * conditions and the generated indexqual conditions.  (These are the same in
 * simple cases, but when special index operators are involved, the former
 * list includes the special conditions while the latter includes the actual
 * indexable conditions derived from them.)  Both lists include partial-index
 * predicates, because we have to recheck predicates as well as index
 * conditions if the bitmap scan becomes lossy.
 *
 * In addition, we return a list of EquivalenceClass pointers for all the
 * top-level indexquals that were possibly-redundantly derived from ECs.
 * This allows removal of scan_clauses that are redundant with such quals.
 * (We do not attempt to detect such redundancies for quals that are within
 * OR subtrees.  This could be done in a less hacky way if we returned the
 * indexquals in RestrictInfo form, but that would be slower and still pretty
 * messy, since we'd have to build new RestrictInfos in many cases.)
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>create_bitmap_subplan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>bitmapqual</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>indexqual</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>indexECs</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>bitmapqual</name></expr></argument>, <argument><expr><name>BitmapAndPath</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BitmapAndPath</name> <modifier>*</modifier></type><name>apath</name> <init>= <expr><operator>(</operator><name>BitmapAndPath</name> <operator>*</operator><operator>)</operator> <name>bitmapqual</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subplans</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subquals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subindexquals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subindexECs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>      <name>nodes</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>path_count_datanodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>apath</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * There may well be redundant quals among the subplans, since a
         * top-level WHERE qual might have gotten used to form several
         * different index quals.  We don't try exceedingly hard to eliminate
         * redundancies, but we do eliminate obvious duplicates by using
         * list_concat_unique.
         */</comment>
        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>apath-&gt;bitmapquals</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subqual</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subindexqual</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subindexEC</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_bitmap_subplan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>subqual</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subindexqual</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>subindexEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>subplans</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>subquals</name> <operator>=</operator> <call><name>list_concat_unique</name><argument_list>(<argument><expr><name>subquals</name></expr></argument>, <argument><expr><name>subqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>subindexquals</name> <operator>=</operator> <call><name>list_concat_unique</name><argument_list>(<argument><expr><name>subindexquals</name></expr></argument>, <argument><expr><name>subindexqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Duplicates in indexECs aren't worth getting rid of */</comment>
            <expr_stmt><expr><name>subindexECs</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>subindexECs</name></expr></argument>, <argument><expr><name>subindexEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_bitmap_and</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>=</operator>
			<call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>apath</name><operator>-&gt;</operator><name>bitmapselectivity</name></name> <operator>*</operator> <name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>tuples</name></name> <operator>/</operator> <name>nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_width</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    <comment type="block">/* meaningless */</comment>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>apath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>qual</name> <operator>=</operator> <name>subquals</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>indexqual</name> <operator>=</operator> <name>subindexquals</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>indexECs</name> <operator>=</operator> <name>subindexECs</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>bitmapqual</name></expr></argument>, <argument><expr><name>BitmapOrPath</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>BitmapOrPath</name> <modifier>*</modifier></type><name>opath</name> <init>= <expr><operator>(</operator><name>BitmapOrPath</name> <operator>*</operator><operator>)</operator> <name>bitmapqual</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subplans</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subquals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subindexquals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>const_true_subqual</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>const_true_subindexqual</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Here, we only detect qual-free subplans.  A qual-free subplan would
         * cause us to generate "... OR true ..."  which we may as well reduce
         * to just "true".  We do not try to eliminate redundant subclauses
         * because (a) it's not as likely as in the AND case, and (b) we might
         * well be working with hundreds or even thousands of OR conditions,
         * perhaps from a long IN list.  The performance of list_append_unique
         * would be unacceptable.
         */</comment>
        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>opath-&gt;bitmapquals</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subqual</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subindexqual</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subindexEC</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_bitmap_subplan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>subqual</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>subindexqual</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>subindexEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>subplans</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>subqual</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>const_true_subqual</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><operator>!</operator><name>const_true_subqual</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>subquals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subquals</name></expr></argument>,
                                   <argument><expr><call><name>make_ands_explicit</name><argument_list>(<argument><expr><name>subqual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>subindexqual</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>const_true_subindexqual</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><operator>!</operator><name>const_true_subindexqual</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>subindexquals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subindexquals</name></expr></argument>,
                                        <argument><expr><call><name>make_ands_explicit</name><argument_list>(<argument><expr><name>subindexqual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>

        <comment type="block">/*
         * In the presence of ScalarArrayOpExpr quals, we might have built
         * BitmapOrPaths with just one subpath; don't add an OR step.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
			<decl_stmt><decl><type><name>double</name></type>  <name>nodes</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>path_count_datanodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>opath</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_bitmap_or</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>opath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>opath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>=</operator>
				<call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>opath</name><operator>-&gt;</operator><name>bitmapselectivity</name></name> <operator>*</operator> <name><name>opath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>tuples</name></name> <operator>/</operator> <name>nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_width</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    <comment type="block">/* meaningless */</comment>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>opath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * If there were constant-TRUE subquals, the OR reduces to constant
         * TRUE.  Also, avoid generating one-element ORs, which could happen
         * due to redundancy elimination or ScalarArrayOpExpr quals.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>const_true_subqual</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>qual</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>subquals</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>qual</name> <operator>=</operator> <name>subquals</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>qual</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>make_orclause</name><argument_list>(<argument><expr><name>subquals</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>const_true_subindexqual</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>indexqual</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>subindexquals</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>indexqual</name> <operator>=</operator> <name>subindexquals</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>indexqual</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>make_orclause</name><argument_list>(<argument><expr><name>subindexquals</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><operator>*</operator><name>indexECs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>bitmapqual</name></expr></argument>, <argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>IndexPath</name>  <modifier>*</modifier></type><name>ipath</name> <init>= <expr><operator>(</operator><name>IndexPath</name> <operator>*</operator><operator>)</operator> <name>bitmapqual</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IndexScan</name>  <modifier>*</modifier></type><name>iscan</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>subindexECs</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>      <name>nodes</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>path_count_datanodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ipath</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Use the regular indexscan plan build machinery... */</comment>
        <expr_stmt><expr><name>iscan</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>IndexScan</name></expr></argument>,
                         <argument><expr><call><name>create_indexscan_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ipath</name></expr></argument>,
                                               <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* then convert to a bitmap indexscan */</comment>
        <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_bitmap_indexscan</name><argument_list>(<argument><expr><name><name>iscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr></argument>,
                                              <argument><expr><name><name>iscan</name><operator>-&gt;</operator><name>indexid</name></name></expr></argument>,
                                              <argument><expr><name><name>iscan</name><operator>-&gt;</operator><name>indexqual</name></name></expr></argument>,
                                              <argument><expr><name><name>iscan</name><operator>-&gt;</operator><name>indexqualorig</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* and set its cost/width fields appropriately */</comment>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>ipath</name><operator>-&gt;</operator><name>indextotalcost</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>=</operator>
			<call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>ipath</name><operator>-&gt;</operator><name>indexselectivity</name></name> <operator>*</operator> <name><name>ipath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>tuples</name></name> <operator>/</operator> <name>nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_width</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    <comment type="block">/* meaningless */</comment>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>ipath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>qual</name> <operator>=</operator> <call><name>get_actual_clauses</name><argument_list>(<argument><expr><name><name>ipath</name><operator>-&gt;</operator><name>indexclauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>indexqual</name> <operator>=</operator> <call><name>get_actual_clauses</name><argument_list>(<argument><expr><name><name>ipath</name><operator>-&gt;</operator><name>indexquals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>ipath-&gt;indexinfo-&gt;indpred</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>pred</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * We know that the index predicate must have been implied by the
             * query condition as a whole, but it may or may not be implied by
             * the conditions that got pushed into the bitmapqual.  Avoid
             * generating redundant conditions.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>predicate_implied_by</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>pred</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ipath</name><operator>-&gt;</operator><name>indexclauses</name></name></expr></argument>,
                                      <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>qual</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>qual</name></expr></argument>, <argument><expr><name>pred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>indexqual</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>indexqual</name></expr></argument>, <argument><expr><name>pred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <expr_stmt><expr><name>subindexECs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>ipath-&gt;indexquals</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>parent_ec</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>subindexECs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subindexECs</name></expr></argument>, <argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>parent_ec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>
        <expr_stmt><expr><operator>*</operator><name>indexECs</name> <operator>=</operator> <name>subindexECs</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>bitmapqual</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>plan</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>            <comment type="block">/* keep compiler quiet */</comment>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_tidscan_plan
 *     Returns a tidscan plan for the base relation scanned by 'best_path'
 *     with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>TidScan</name> <modifier>*</modifier></type>
<name>create_tidscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>TidPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                    <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>TidScan</name>    <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name></type>        <name>scan_relid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tidquals</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>tidquals</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>ortidquals</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>operation</name> <init>= <expr><literal type="string">"select"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name>   <modifier>*</modifier></type><name>audit_rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>            <modifier>*</modifier></type><name>audit_fga_quals_stmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name>need_audit_fga_quals</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>        <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

    <comment type="block">/* it should be a base rel... */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <comment type="block">/* Sort clauses into best execution order */</comment>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>tidquals</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tidquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Remove any clauses that are TID quals.  This is a bit tricky since the
     * tidquals list has implicit OR semantics.
     */</comment>
    <expr_stmt><expr><name>ortidquals</name> <operator>=</operator> <name>tidquals</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>ortidquals</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ortidquals</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>make_orclause</name><argument_list>(<argument><expr><name>ortidquals</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>list_difference</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>ortidquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name>make_tidscan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
                             <argument><expr><name>scan_clauses</name></expr></argument>,
                             <argument><expr><name>scan_relid</name></expr></argument>,
                             <argument><expr><name>tidquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>enable_fga</name> <operator>&amp;&amp;</operator> <name>g_commandTag</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>g_commandTag</name></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>audit_fga_quals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>audit_rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>need_audit_fga_quals</name> <operator>=</operator> <call><name>get_audit_fga_quals</name><argument_list>(<argument><expr><name><name>audit_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>operation</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>audit_fga_quals_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>need_audit_fga_quals</name></expr>)</condition>
        <block>{<block_content>
            <macro><name>foreach</name> <argument_list>(<argument>item</argument>, <argument>audit_fga_quals_stmt</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AuditFgaPolicy</name> <modifier>*</modifier></type><name>audit_fga_qual</name> <init>= <expr><operator>(</operator><name>AuditFgaPolicy</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>audit_fga_qual</name><operator>-&gt;</operator><name>qual</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>audit_fga_log_policy_info</name><argument_list>(<argument><expr><name>audit_fga_qual</name></expr></argument>, <argument><expr><name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>audit_fga_quals_stmt</name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name>audit_fga_quals_stmt</name></expr></argument>, <argument><expr><name>audit_fga_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                   
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
        
            <if_stmt><if>if <condition>(<expr><name>audit_fga_quals_stmt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>audit_fga_quals</name></name> <operator>=</operator> <name>audit_fga_quals_stmt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_subqueryscan_plan
 *     Returns a subqueryscan plan for the base relation scanned by 'best_path'
 *     with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>SubqueryScan</name> <modifier>*</modifier></type>
<name>create_subqueryscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SubqueryScanPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                         <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name></type>        <name>scan_relid</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>

    <comment type="block">/* it should be a subquery base rel... */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Recursively create Plan from Path for subquery.  Since we are entering
     * a different planner context (subroot), recurse to create_plan not
     * create_plan_recurse.
     */</comment>
    <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>create_plan</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>subroot</name></name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Sort clauses into best execution order */</comment>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>process_subquery_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                         <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>subplan_params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name>make_subqueryscan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
                                  <argument><expr><name>scan_clauses</name></expr></argument>,
                                  <argument><expr><name>scan_relid</name></expr></argument>,
                                  <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_functionscan_plan
 *     Returns a functionscan plan for the base relation scanned by 'best_path'
 *     with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>FunctionScan</name> <modifier>*</modifier></type>
<name>create_functionscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                         <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FunctionScan</name> <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name></type>        <name>scan_relid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>functions</name></decl>;</decl_stmt>

    <comment type="block">/* it should be a function base rel... */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>functions</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr>;</expr_stmt>

    <comment type="block">/* Sort clauses into best execution order */</comment>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* The function expressions could contain nestloop params, too */</comment>
        <expr_stmt><expr><name>functions</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name>make_functionscan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>scan_relid</name></expr></argument>,
                                  <argument><expr><name>functions</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>funcordinality</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_tablefuncscan_plan
 *     Returns a tablefuncscan plan for the base relation scanned by 'best_path'
 *     with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>TableFuncScan</name> <modifier>*</modifier></type>
<name>create_tablefuncscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                          <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TableFuncScan</name> <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name></type>        <name>scan_relid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TableFunc</name>  <modifier>*</modifier></type><name>tablefunc</name></decl>;</decl_stmt>

    <comment type="block">/* it should be a function base rel... */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_TABLEFUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tablefunc</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablefunc</name></name></expr>;</expr_stmt>

    <comment type="block">/* Sort clauses into best execution order */</comment>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* The function expressions could contain nestloop params, too */</comment>
        <expr_stmt><expr><name>tablefunc</name> <operator>=</operator> <operator>(</operator><name>TableFunc</name> <operator>*</operator><operator>)</operator> <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tablefunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name>make_tablefuncscan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>scan_relid</name></expr></argument>,
                                   <argument><expr><name>tablefunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_valuesscan_plan
 *     Returns a valuesscan plan for the base relation scanned by 'best_path'
 *     with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>ValuesScan</name> <modifier>*</modifier></type>
<name>create_valuesscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                       <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ValuesScan</name> <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name></type>        <name>scan_relid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>values_lists</name></decl>;</decl_stmt>

    <comment type="block">/* it should be a values base rel... */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>values_lists</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr>;</expr_stmt>

    <comment type="block">/* Sort clauses into best execution order */</comment>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* The values lists could contain nestloop params, too */</comment>
        <expr_stmt><expr><name>values_lists</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>values_lists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name>make_valuesscan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>scan_relid</name></expr></argument>,
                                <argument><expr><name>values_lists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_ctescan_plan
 *     Returns a ctescan plan for the base relation scanned by 'best_path'
 *     with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>CteScan</name> <modifier>*</modifier></type>
<name>create_ctescan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                    <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CteScan</name>    <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name></type>        <name>scan_relid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>ctesplan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>plan_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>cte_param_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>cteroot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name></type>        <name>levelsup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ndx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>rte</name><operator>-&gt;</operator><name>self_reference</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Find the referenced CTE, and locate the SubPlan previously made for it.
     */</comment>
    <expr_stmt><expr><name>levelsup</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>cteroot</name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>levelsup</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>cteroot</name> <operator>=</operator> <name><name>cteroot</name><operator>-&gt;</operator><name>parent_root</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>cteroot</name></expr>)</condition><block type="pseudo"><block_content>            <comment type="block">/* shouldn't happen */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bad levelsup for CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * Note: cte_plan_ids can be shorter than cteList, if we are still working
     * on planning the CTEs (ie, this is a side-reference from another CTE).
     * So we mustn't use forboth here.
     */</comment>
    <expr_stmt><expr><name>ndx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>cteroot-&gt;parse-&gt;cteList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>ndx</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>
    <if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>                <comment type="block">/* shouldn't happen */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>ndx</name> <operator>&gt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>cteroot</name><operator>-&gt;</operator><name>cte_plan_ids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find plan for CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>plan_id</name> <operator>=</operator> <call><name>list_nth_int</name><argument_list>(<argument><expr><name><name>cteroot</name><operator>-&gt;</operator><name>cte_plan_ids</name></name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>plan_id</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>cteroot-&gt;init_plans</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>ctesplan</name> <operator>=</operator> <operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>ctesplan</name><operator>-&gt;</operator><name>plan_id</name></name> <operator>==</operator> <name>plan_id</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block>
    <if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>                <comment type="block">/* shouldn't happen */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find plan for CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We need the CTE param ID, which is the sole member of the SubPlan's
     * setParam list.
     */</comment>
    <expr_stmt><expr><name>cte_param_id</name> <operator>=</operator> <call><name>linitial_int</name><argument_list>(<argument><expr><name><name>ctesplan</name><operator>-&gt;</operator><name>setParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Sort clauses into best execution order */</comment>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name>make_ctescan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>scan_relid</name></expr></argument>,
                             <argument><expr><name>plan_id</name></expr></argument>, <argument><expr><name>cte_param_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_namedtuplestorescan_plan
 *     Returns a tuplestorescan plan for the base relation scanned by
 *    'best_path' with restriction clauses 'scan_clauses' and targetlist
 *    'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>NamedTuplestoreScan</name> <modifier>*</modifier></type>
<name>create_namedtuplestorescan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                                <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NamedTuplestoreScan</name> <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name></type>        <name>scan_relid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_NAMEDTUPLESTORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Sort clauses into best execution order */</comment>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name>make_namedtuplestorescan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>scan_relid</name></expr></argument>,
                                         <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>enrname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_worktablescan_plan
 *     Returns a worktablescan plan for the base relation scanned by 'best_path'
 *     with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>WorkTableScan</name> <modifier>*</modifier></type>
<name>create_worktablescan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                          <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>WorkTableScan</name> <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name></type>        <name>scan_relid</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name></type>        <name>levelsup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>cteroot</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>self_reference</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We need to find the worktable param ID, which is in the plan level
     * that's processing the recursive UNION, which is one level *below* where
     * the CTE comes from.
     */</comment>
    <expr_stmt><expr><name>levelsup</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>levelsup</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>            <comment type="block">/* shouldn't happen */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bad levelsup for CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>levelsup</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>cteroot</name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>levelsup</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>cteroot</name> <operator>=</operator> <name><name>cteroot</name><operator>-&gt;</operator><name>parent_root</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>cteroot</name></expr>)</condition><block type="pseudo"><block_content>            <comment type="block">/* shouldn't happen */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bad levelsup for CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><name><name>cteroot</name><operator>-&gt;</operator><name>wt_param_id</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* shouldn't happen */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find param ID for CTE \"%s\""</literal></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Sort clauses into best execution order */</comment>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reduce RestrictInfo list to bare expressions; ignore pseudoconstants */</comment>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name>make_worktablescan</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>, <argument><expr><name>scan_relid</name></expr></argument>,
                                   <argument><expr><name><name>cteroot</name><operator>-&gt;</operator><name>wt_param_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_foreignscan_plan
 *     Returns a foreignscan plan for the relation scanned by 'best_path'
 *     with restriction clauses 'scan_clauses' and targetlist 'tlist'.
 */</comment>
<function><type><specifier>static</specifier> <name>ForeignScan</name> <modifier>*</modifier></type>
<name>create_foreignscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>ForeignPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                        <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>scan_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Index</name></type>        <name>scan_relid</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>rel_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>outer_plan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>fdwroutine</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* transform the child path if any */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>fdw_outerpath</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>outer_plan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>fdw_outerpath</name></name></expr></argument>,
                                         <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If we're scanning a base relation, fetch its OID.  (Irrelevant if
     * scanning a join relation.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rel_oid</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Sort clauses into best execution order.  We do this first since the FDW
     * might have more info than we do and wish to adjust the ordering.
     */</comment>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Let the FDW perform its processing on the restriction clauses and
     * generate the plan node.  Note that the FDW might remove restriction
     * clauses that it intends to execute remotely, or even add more (if it
     * has selected some join clauses for remote use but also wants them
     * rechecked locally).
     */</comment>
    <expr_stmt><expr><name>scan_plan</name> <operator>=</operator> <call><name><name>rel</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>GetForeignPlan</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rel_oid</name></expr></argument>,
                                                <argument><expr><name>best_path</name></expr></argument>,
                                                <argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>,
                                                <argument><expr><name>outer_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Copy cost data from Path to Plan; no need to make FDW do this */</comment>
    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Copy foreign server OID; likewise, no need to make FDW do this */</comment>
    <expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>fs_server</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>serverid</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Likewise, copy the relids that are represented by this foreign scan. An
     * upper rel doesn't have relids set, but it covers all the base relations
     * participating in the underlying scan, so use root's all_baserels.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IS_UPPER_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>fs_relids</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>all_baserels</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>fs_relids</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * If this is a foreign join, and to make it valid to push down we had to
     * assume that the current user is the same as some user explicitly named
     * in the query, mark the finished plan as depending on the current user.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>useridiscurrent</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>dependsOnRole</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Replace any outer-relation variables with nestloop params in the qual,
     * fdw_exprs and fdw_recheck_quals expressions.  We do this last so that
     * the FDW doesn't have to be involved.  (Note that parts of fdw_exprs or
     * fdw_recheck_quals could have come from join clauses, so doing this
     * beforehand on the scan_clauses wouldn't work.)  We assume
     * fdw_scan_tlist contains no such variables.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>scan_plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>fdw_exprs</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>scan_plan</name><operator>-&gt;</operator><name>fdw_exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>fdw_recheck_quals</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                    <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>scan_plan</name><operator>-&gt;</operator><name>fdw_recheck_quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If rel is a base relation, detect whether any system columns are
     * requested from the rel.  (If rel is a join relation, rel-&gt;relid will be
     * 0, but there can be no Var with relid 0 in the rel's targetlist or the
     * restriction clauses, so we skip this in that case.  Note that any such
     * columns in base relations that were joined are assumed to be contained
     * in fdw_scan_tlist.)    This is a bit of a kluge and might go away
     * someday, so we intentionally leave it out of the API presented to FDWs.
     */</comment>
    <expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>fsSystemCol</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>scan_relid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>attrs_used</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <comment type="block">/*
         * First, examine all the attributes needed for joins or final output.
         * Note: we must look at rel's targetlist, not the attr_needed data,
         * because attr_needed isn't computed for inheritance child rels.
         */</comment>
        <expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Add all the attributes used by restriction clauses. */</comment>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;baserestrictinfo</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>pull_varattnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name>scan_relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <comment type="block">/* Now, are any system columns requested from rel? */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FirstLowInvalidHeapAttributeNumber</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>, <argument><expr><name>attrs_used</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>scan_plan</name><operator>-&gt;</operator><name>fsSystemCol</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>attrs_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>scan_plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_custom_plan
 *
 * Transform a CustomPath into a Plan.
 */</comment>
<function><type><specifier>static</specifier> <name>CustomScan</name> <modifier>*</modifier></type>
<name>create_customscan_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>CustomPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
                       <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>scan_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cplan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>custom_plans</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* Recursively transform child paths. */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>best_path-&gt;custom_paths</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>,
                                               <argument><expr><name>CP_EXACT_TLIST</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>custom_plans</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Sort clauses into the best execution order, although custom-scan
     * provider can reorder them again.
     */</comment>
    <expr_stmt><expr><name>scan_clauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>scan_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Invoke custom plan provider to create the Plan node represented by the
     * CustomPath.
     */</comment>
    <expr_stmt><expr><name>cplan</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>,
                     <argument><expr><call><name><name>best_path</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>PlanCustomPath</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                        <argument><expr><name>rel</name></expr></argument>,
                                                        <argument><expr><name>best_path</name></expr></argument>,
                                                        <argument><expr><name>tlist</name></expr></argument>,
                                                        <argument><expr><name>scan_clauses</name></expr></argument>,
                                                        <argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Copy cost data from Path to Plan; no need to make custom-plan providers
     * do this
     */</comment>
    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cplan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Likewise, copy the relids that are represented by this custom scan */</comment>
    <expr_stmt><expr><name><name>cplan</name><operator>-&gt;</operator><name>custom_relids</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Replace any outer-relation variables with nestloop params in the qual
     * and custom_exprs expressions.  We do this last so that the custom-plan
     * provider doesn't have to be involved.  (Note that parts of custom_exprs
     * could have come from join clauses, so doing this beforehand on the
     * scan_clauses wouldn't work.)  We assume custom_scan_tlist contains no
     * such variables.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>cplan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cplan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cplan</name><operator>-&gt;</operator><name>custom_exprs</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cplan</name><operator>-&gt;</operator><name>custom_exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>cplan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *
 *    JOIN METHODS
 *
 *****************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>NestLoop</name> <modifier>*</modifier></type>
<name>create_nestloop_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                     <parameter><decl><type><name>NestPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>NestLoop</name>   <modifier>*</modifier></type><name>join_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>outer_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>inner_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name> <init>= <expr><call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>joinrestrictclauses</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>joinrestrictinfo</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>joinclauses</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>otherclauses</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relids</name></type>        <name>outerrelids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>nestParams</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relids</name></type>        <name>saveOuterRels</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

    <comment type="block">/* NestLoop can project, so no need to be picky about child tlists */</comment>
    <expr_stmt><expr><name>outer_plan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>outerjoinpath</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* For a nestloop, include outer relids in curOuterRels for inner side */</comment>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name></expr></argument>,
                                   <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>inner_plan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>innerjoinpath</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Restore curOuterRels */</comment>
    <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name> <operator>=</operator> <name>saveOuterRels</name></expr>;</expr_stmt>

    <comment type="block">/* Sort join qual clauses into best execution order */</comment>
    <expr_stmt><expr><name>joinrestrictclauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>joinrestrictclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get the join qual clauses (in plain expression form) */</comment>
    <comment type="block">/* Any pseudoconstant clauses are ignored here */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>extract_actual_join_clauses</name><argument_list>(<argument><expr><name>joinrestrictclauses</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>joinclauses</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>otherclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* We can treat all clauses alike for an inner join */</comment>
        <expr_stmt><expr><name>joinclauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>joinrestrictclauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>otherclauses</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Replace any outer-relation variables with nestloop params */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>joinclauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>joinclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>otherclauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>otherclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Identify any nestloop parameters that should be supplied by this join
     * node, and move them from root-&gt;curOuterParams to the nestParams list.
     */</comment>
    <expr_stmt><expr><name>outerrelids</name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nestParams</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name>next</name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>NestLoopParam</name> <modifier>*</modifier></type><name>nlp</name> <init>= <expr><operator>(</operator><name>NestLoopParam</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name>outerrelids</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name></expr></argument>,
                                                    <argument><expr><name>cell</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nestParams</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>nestParams</name></expr></argument>, <argument><expr><name>nlp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                 <call><name>bms_overlap</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name><operator>)</operator><operator>-&gt;</operator><name>phrels</name></expr></argument>,
                             <argument><expr><name>outerrelids</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                 <call><name>bms_is_subset</name><argument_list>(<argument><expr><call><name>find_placeholder_info</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                     <argument><expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name></expr></argument>,
                                                     <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ph_eval_at</name></expr></argument>,
                               <argument><expr><name>outerrelids</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name></expr></argument>,
                                                    <argument><expr><name>cell</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nestParams</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>nestParams</name></expr></argument>, <argument><expr><name>nlp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>prev</name> <operator>=</operator> <name>cell</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <comment type="block">/*
     * While NestLoop is executed it rescans inner plan. We do not want to
     * rescan RemoteSubplan and do not support it.
     * So if inner_plan is a RemoteSubplan, materialize it.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>inner_plan</name></expr></argument>, <argument><expr><name>Material</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>contain_remote_subplan_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>inner_plan</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>inner_plan</name> <operator>=</operator> <call><name>materialize_top_remote_subplan</name><argument_list>(<argument><expr><name>inner_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>inner_plan</name></expr></argument>, <argument><expr><name>RemoteSubplan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>matplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_material</name><argument_list>(<argument><expr><name>inner_plan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * We assume the materialize will not spill to disk, and therefore
         * charge just cpu_operator_cost per tuple.  (Keep this estimate in
         * sync with cost_mergejoin.)
         */</comment>
        <expr_stmt><expr><call><name>copy_plan_costsize</name><argument_list>(<argument><expr><name>matplan</name></expr></argument>, <argument><expr><name>inner_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>matplan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+=</operator> <name>cpu_operator_cost</name> <operator>*</operator> <name><name>matplan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>inner_plan</name> <operator>=</operator> <name>matplan</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>join_plan</name> <operator>=</operator> <call><name>make_nestloop</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
                              <argument><expr><name>joinclauses</name></expr></argument>,
                              <argument><expr><name>otherclauses</name></expr></argument>,
                              <argument><expr><name>nestParams</name></expr></argument>,
                              <argument><expr><name>outer_plan</name></expr></argument>,
                              <argument><expr><name>inner_plan</name></expr></argument>,
                              <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>,
                              <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>inner_unique</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>join_plan</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>MergeJoin</name> <modifier>*</modifier></type>
<name>create_mergejoin_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                      <parameter><decl><type><name>MergePath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>MergeJoin</name>  <modifier>*</modifier></type><name>join_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>outer_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>inner_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name> <init>= <expr><call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>joinclauses</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>otherclauses</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>mergeclauses</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>outerpathkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>innerpathkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nClauses</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>mergefamilies</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>mergecollations</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name>           <modifier>*</modifier></type><name>mergestrategies</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>mergenullsfirst</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lip</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>outer_path</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>inner_path</name> <init>= <expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name></name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type>       <name>reset</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>mergejoin</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>mergejoin</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>reset</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * MergeJoin can project, so we don't have to demand exact tlists from the
     * inputs.  However, if we're intending to sort an input's result, it's
     * best to request a small tlist so we aren't sorting more data than
     * necessary.
     */</comment>
    <expr_stmt><expr><name>outer_plan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name></name></expr></argument>,
                                     <argument><expr><ternary><condition><expr><operator>(</operator><name><name>best_path</name><operator>-&gt;</operator><name>outersortkeys</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr> ?</condition><then> <expr><name>CP_SMALL_TLIST</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>inner_plan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name></name></expr></argument>,
                                     <argument><expr><ternary><condition><expr><operator>(</operator><name><name>best_path</name><operator>-&gt;</operator><name>innersortkeys</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr> ?</condition><then> <expr><name>CP_SMALL_TLIST</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Sort join qual clauses into best execution order */</comment>
    <comment type="block">/* NB: do NOT reorder the mergeclauses */</comment>
    <expr_stmt><expr><name>joinclauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>joinrestrictinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get the join qual clauses (in plain expression form) */</comment>
    <comment type="block">/* Any pseudoconstant clauses are ignored here */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>extract_actual_join_clauses</name><argument_list>(<argument><expr><name>joinclauses</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>joinclauses</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>otherclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* We can treat all clauses alike for an inner join */</comment>
        <expr_stmt><expr><name>joinclauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>joinclauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>otherclauses</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Remove the mergeclauses from the list of join qual clauses, leaving the
     * list of quals that must be checked as qpquals.
     */</comment>
    <expr_stmt><expr><name>mergeclauses</name> <operator>=</operator> <call><name>get_actual_clauses</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path_mergeclauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>joinclauses</name> <operator>=</operator> <call><name>list_difference</name><argument_list>(<argument><expr><name>joinclauses</name></expr></argument>, <argument><expr><name>mergeclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Replace any outer-relation variables with nestloop params.  There
     * should not be any in the mergeclauses.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>joinclauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>joinclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>otherclauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>otherclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Rearrange mergeclauses, if needed, so that the outer variable is always
     * on the left; mark the mergeclause restrictinfos with correct
     * outer_is_left status.
     */</comment>
    <expr_stmt><expr><name>mergeclauses</name> <operator>=</operator> <call><name>get_switched_clauses</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path_mergeclauses</name></name></expr></argument>,
                                        <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create explicit sort nodes for the outer and inner paths if necessary.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>outersortkeys</name></name></expr>)</condition>
    <block>{<block_content>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>outer_relids</name> <init>= <expr><name><name>outer_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Sort</name>       <modifier>*</modifier></type><name>sort</name> <init>= <expr><call><name>make_sort_from_pathkeys</name><argument_list>(<argument><expr><name>outer_plan</name></expr></argument>,
												   <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>outersortkeys</name></name></expr></argument>,
												   <argument><expr><name>outer_relids</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>label_sort_with_costsize</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>outer_plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>sort</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>outerpathkeys</name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>outersortkeys</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>outerpathkeys</name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>innersortkeys</name></name></expr>)</condition>
    <block>{<block_content>
		<decl_stmt><decl><type><name>Relids</name></type>		<name>inner_relids</name> <init>= <expr><name><name>inner_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Sort</name>       <modifier>*</modifier></type><name>sort</name> <init>= <expr><call><name>make_sort_from_pathkeys</name><argument_list>(<argument><expr><name>inner_plan</name></expr></argument>,
												   <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>innersortkeys</name></name></expr></argument>,
												   <argument><expr><name>inner_relids</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>label_sort_with_costsize</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>inner_plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>sort</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>innerpathkeys</name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>innersortkeys</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>innerpathkeys</name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * If specified, add a materialize node to shield the inner plan from the
     * need to handle mark/restore.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>materialize_inner</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>matplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_material</name><argument_list>(<argument><expr><name>inner_plan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * We assume the materialize will not spill to disk, and therefore
         * charge just cpu_operator_cost per tuple.  (Keep this estimate in
         * sync with final_cost_mergejoin.)
         */</comment>
        <expr_stmt><expr><call><name>copy_plan_costsize</name><argument_list>(<argument><expr><name>matplan</name></expr></argument>, <argument><expr><name>inner_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>matplan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+=</operator> <name>cpu_operator_cost</name> <operator>*</operator> <name><name>matplan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>inner_plan</name> <operator>=</operator> <name>matplan</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Compute the opfamily/collation/strategy/nullsfirst arrays needed by the
     * executor.  The information is in the pathkeys for the two inputs, but
     * we need to be careful about the possibility of mergeclauses sharing a
     * pathkey (compare find_mergeclauses_for_pathkeys()).
     */</comment>
    <expr_stmt><expr><name>nClauses</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>mergeclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nClauses</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path_mergeclauses</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mergefamilies</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nClauses</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mergecollations</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nClauses</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mergestrategies</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nClauses</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>mergenullsfirst</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nClauses</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>lop</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>outerpathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lip</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>innerpathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>best_path-&gt;path_mergeclauses</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>oeclass</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ieclass</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>opathkey</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>ipathkey</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>opeclass</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ipeclass</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>

        <comment type="block">/* fetch outer/inner eclass from mergeclause */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>outer_is_left</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>oeclass</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>left_ec</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ieclass</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>right_ec</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>oeclass</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>right_ec</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ieclass</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>left_ec</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oeclass</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ieclass</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * For debugging purposes, we check that the eclasses match the paths'
         * pathkeys.  In typical cases the merge clauses are one-to-one with
         * the pathkeys, but when dealing with partially redundant query
         * conditions, we might have clauses that re-reference earlier path
         * keys.  The case that we need to reject is where a pathkey is
         * entirely skipped over.
         *
         * lop and lip reference the first as-yet-unused pathkey elements;
         * it's okay to match them, or any element before them.  If they're
         * NULL then we have found all pathkey elements to be used.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>lop</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>opathkey</name> <operator>=</operator> <operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>opeclass</name> <operator>=</operator> <name><name>opathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>oeclass</name> <operator>==</operator> <name>opeclass</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* fast path for typical case */</comment>
                <expr_stmt><expr><name>lop</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* redundant clauses ... must match something before lop */</comment>
                <macro><name>foreach</name><argument_list>(<argument>l2</argument>, <argument>outerpathkeys</argument>)</argument_list></macro>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>l2</name> <operator>==</operator> <name>lop</name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>opathkey</name> <operator>=</operator> <operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>opeclass</name> <operator>=</operator> <name><name>opathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>oeclass</name> <operator>==</operator> <name>opeclass</name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                </block_content>}</block>
                <if_stmt><if>if <condition>(<expr><name>oeclass</name> <operator>!=</operator> <name>opeclass</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"outer pathkeys do not match mergeclauses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* redundant clauses ... must match some already-used pathkey */</comment>
            <expr_stmt><expr><name>opathkey</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>opeclass</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <macro><name>foreach</name><argument_list>(<argument>l2</argument>, <argument>outerpathkeys</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>opathkey</name> <operator>=</operator> <operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>opeclass</name> <operator>=</operator> <name><name>opathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>oeclass</name> <operator>==</operator> <name>opeclass</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block>
            <if_stmt><if>if <condition>(<expr><name>l2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"outer pathkeys do not match mergeclauses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>lip</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>ipathkey</name> <operator>=</operator> <operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ipeclass</name> <operator>=</operator> <name><name>ipathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ieclass</name> <operator>==</operator> <name>ipeclass</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* fast path for typical case */</comment>
                <expr_stmt><expr><name>lip</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* redundant clauses ... must match something before lip */</comment>
                <macro><name>foreach</name><argument_list>(<argument>l2</argument>, <argument>innerpathkeys</argument>)</argument_list></macro>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>l2</name> <operator>==</operator> <name>lip</name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>ipathkey</name> <operator>=</operator> <operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ipeclass</name> <operator>=</operator> <name><name>ipathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>ieclass</name> <operator>==</operator> <name>ipeclass</name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                </block_content>}</block>
                <if_stmt><if>if <condition>(<expr><name>ieclass</name> <operator>!=</operator> <name>ipeclass</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"inner pathkeys do not match mergeclauses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* redundant clauses ... must match some already-used pathkey */</comment>
            <expr_stmt><expr><name>ipathkey</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ipeclass</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <macro><name>foreach</name><argument_list>(<argument>l2</argument>, <argument>innerpathkeys</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>ipathkey</name> <operator>=</operator> <operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>ipeclass</name> <operator>=</operator> <name><name>ipathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>ieclass</name> <operator>==</operator> <name>ipeclass</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block>
            <if_stmt><if>if <condition>(<expr><name>l2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"inner pathkeys do not match mergeclauses"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* pathkeys should match each other too (more debugging) */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>opathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name> <operator>!=</operator> <name><name>ipathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name> <operator>||</operator>
            <name><name>opathkey</name><operator>-&gt;</operator><name>pk_eclass</name><operator>-&gt;</operator><name>ec_collation</name></name> <operator>!=</operator> <name><name>ipathkey</name><operator>-&gt;</operator><name>pk_eclass</name><operator>-&gt;</operator><name>ec_collation</name></name> <operator>||</operator>
            <name><name>opathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name> <operator>!=</operator> <name><name>ipathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name> <operator>||</operator>
            <name><name>opathkey</name><operator>-&gt;</operator><name>pk_nulls_first</name></name> <operator>!=</operator> <name><name>ipathkey</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"left and right pathkeys do not match in mergejoin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* OK, save info for executor */</comment>
        <expr_stmt><expr><name><name>mergefamilies</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>opathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mergecollations</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>opathkey</name><operator>-&gt;</operator><name>pk_eclass</name><operator>-&gt;</operator><name>ec_collation</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mergestrategies</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>opathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mergenullsfirst</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>opathkey</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Note: it is not an error if we have additional pathkey elements (i.e.,
     * lop or lip isn't NULL here).  The input paths might be better-sorted
     * than we need for the current mergejoin.
     */</comment>

    <comment type="block">/*
     * Now we can build the mergejoin node.
     */</comment>
    <expr_stmt><expr><name>join_plan</name> <operator>=</operator> <call><name>make_mergejoin</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
                               <argument><expr><name>joinclauses</name></expr></argument>,
                               <argument><expr><name>otherclauses</name></expr></argument>,
                               <argument><expr><name>mergeclauses</name></expr></argument>,
                               <argument><expr><name>mergefamilies</name></expr></argument>,
                               <argument><expr><name>mergecollations</name></expr></argument>,
                               <argument><expr><name>mergestrategies</name></expr></argument>,
                               <argument><expr><name>mergenullsfirst</name></expr></argument>,
                               <argument><expr><name>outer_plan</name></expr></argument>,
                               <argument><expr><name>inner_plan</name></expr></argument>,
                               <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>jointype</name></name></expr></argument>,
                               <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>inner_unique</name></name></expr></argument>,
                               <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>skip_mark_restore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Costs of sort and material steps are included in path cost already */</comment>
    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>reset</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>mergejoin</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>join_plan</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>HashJoin</name> <modifier>*</modifier></type>
<name>create_hashjoin_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                     <parameter><decl><type><name>HashPath</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HashJoin</name>   <modifier>*</modifier></type><name>join_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Hash</name>       <modifier>*</modifier></type><name>hash_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>outer_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>inner_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name> <init>= <expr><call><name>build_path_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>joinclauses</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>otherclauses</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>hashclauses</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>skewTable</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>skewColumn</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>skewInherit</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type>       <name>outer_parallel_aware</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>       <name>hashjoin_parallel_aware</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * HashJoin can project, so we don't have to demand exact tlists from the
     * inputs.  However, it's best to request a small tlist from the inner
     * side, so that we aren't storing more data than necessary.  Likewise, if
     * we anticipate batching, request a small tlist from the outer side so
     * that we don't put extra data in the outer batch files.
     */</comment>
    <expr_stmt><expr><name>outer_plan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name></name></expr></argument>,
                                     <argument><expr><ternary><condition><expr><operator>(</operator><name><name>best_path</name><operator>-&gt;</operator><name>num_batches</name></name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><name>CP_SMALL_TLIST</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>inner_plan</name> <operator>=</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name></name></expr></argument>,
                                     <argument><expr><name>CP_SMALL_TLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Sort join qual clauses into best execution order */</comment>
    <expr_stmt><expr><name>joinclauses</name> <operator>=</operator> <call><name>order_qual_clauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>joinrestrictinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* There's no point in sorting the hash clauses ... */</comment>

    <comment type="block">/* Get the join qual clauses (in plain expression form) */</comment>
    <comment type="block">/* Any pseudoconstant clauses are ignored here */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>extract_actual_join_clauses</name><argument_list>(<argument><expr><name>joinclauses</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name>joinclauses</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>otherclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* We can treat all clauses alike for an inner join */</comment>
        <expr_stmt><expr><name>joinclauses</name> <operator>=</operator> <call><name>extract_actual_clauses</name><argument_list>(<argument><expr><name>joinclauses</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>otherclauses</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Remove the hashclauses from the list of join qual clauses, leaving the
     * list of quals that must be checked as qpquals.
     */</comment>
    <expr_stmt><expr><name>hashclauses</name> <operator>=</operator> <call><name>get_actual_clauses</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path_hashclauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>joinclauses</name> <operator>=</operator> <call><name>list_difference</name><argument_list>(<argument><expr><name>joinclauses</name></expr></argument>, <argument><expr><name>hashclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Replace any outer-relation variables with nestloop params.  There
     * should not be any in the hashclauses.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>joinclauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>joinclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>otherclauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
            <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>otherclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Rearrange hashclauses, if needed, so that the outer variable is always
     * on the left.
     */</comment>
    <expr_stmt><expr><name>hashclauses</name> <operator>=</operator> <call><name>get_switched_clauses</name><argument_list>(<argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>path_hashclauses</name></name></expr></argument>,
                                       <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If there is a single join clause and we can identify the outer variable
     * as a simple column reference, supply its identity for possible use in
     * skew optimization.  (Note: in principle we could do skew optimization
     * with multiple join clauses, but we'd have to be able to determine the
     * most common combinations of outer values, which we don't currently have
     * enough stats for.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>hashclauses</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>OpExpr</name>       <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>hashclauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>is_opclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Var</name>           <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>rte</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr>]</index></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>skewTable</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>skewColumn</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>skewInherit</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>inh</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Build the hash node and hash join node.
     */</comment>
    <expr_stmt><expr><name>hash_plan</name> <operator>=</operator> <call><name>make_hash</name><argument_list>(<argument><expr><name>inner_plan</name></expr></argument>,
                          <argument><expr><name>skewTable</name></expr></argument>,
                          <argument><expr><name>skewColumn</name></expr></argument>,
                          <argument><expr><name>skewInherit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Set Hash node's startup &amp; total costs equal to total cost of input
     * plan; this only affects EXPLAIN display not decisions.
     */</comment>
    <expr_stmt><expr><call><name>copy_plan_costsize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hash_plan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>inner_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hash_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>hash_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/*
      * In parallel hashjoin, we need to set hash plan be parallel plan.
         */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>outer_plan</name></expr></argument>, <argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>sub</name> <init>= <expr><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator><name>outer_plan</name></expr></init></decl>;</decl_stmt>
        
        <expr_stmt><expr><name>subplan</name> <operator>=</operator> <name><name>sub</name><operator>-&gt;</operator><name>subplan</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>outer_plan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>||</operator>
        <call><name>IsA</name><argument_list>(<argument><expr><name>outer_plan</name></expr></argument>, <argument><expr><name>Gather</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>subplan</name> <operator>&amp;&amp;</operator> <name><name>subplan</name><operator>-&gt;</operator><name>parallel_aware</name></name><operator>)</operator>
        <operator>)</operator> <operator>&amp;&amp;</operator> <name>olap_optimizer</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>outer_parallel_aware</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        
        <if_stmt><if>if <condition>(<expr><name><name>inner_plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>hash_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>hashjoin_parallel_aware</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    
    <if_stmt><if>if <condition>(<expr><name>outer_parallel_aware</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>hash_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_aware</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>set_plan_parallel</name><argument_list>(<argument><expr><name>inner_plan</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>hash_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>hashjoin_parallel_aware</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>set_plan_nonparallel</name><argument_list>(<argument><expr><name>inner_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>set_plan_nonparallel</name><argument_list>(<argument><expr><name>outer_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>hashjoin_parallel_aware</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>join_plan</name> <operator>=</operator> <call><name>make_hashjoin</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>,
                              <argument><expr><name>joinclauses</name></expr></argument>,
                              <argument><expr><name>otherclauses</name></expr></argument>,
                              <argument><expr><name>hashclauses</name></expr></argument>,
                              <argument><expr><name>outer_plan</name></expr></argument>,
                              <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>hash_plan</name></expr></argument>,
                              <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>jointype</name></name></expr></argument>,
                              <argument><expr><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>inner_unique</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>copy_generic_path_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>best_path</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>outer_parallel_aware</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>plan</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>hashjoin_parallel_aware</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>join_plan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *
 *    SUPPORTING ROUTINES
 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * replace_nestloop_params
 *      Replace outer-relation Vars and PlaceHolderVars in the given expression
 *      with nestloop Params
 *
 * All Vars and PlaceHolderVars belonging to the relation(s) identified by
 * root-&gt;curOuterRels are replaced by Params, and entries are added to
 * root-&gt;curOuterParams if not already present.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>replace_nestloop_params</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* No setup needed for tree walk, so away we go */</comment>
    <return>return <expr><call><name>replace_nestloop_params_mutator</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>replace_nestloop_params_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Var</name>           <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Param</name>       <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>NestLoopParam</name> <modifier>*</modifier></type><name>nlp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

        <comment type="block">/* Upper-level Vars should be long gone at this point */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* If not to be replaced, we can just return the Var unmodified */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>
        <comment type="block">/* Create a Param representing the Var */</comment>
        <expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>assign_nestloop_param_var</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Is this param already listed in root-&gt;curOuterParams? */</comment>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;curOuterParams</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>nlp</name> <operator>=</operator> <operator>(</operator><name>NestLoopParam</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>nlp</name><operator>-&gt;</operator><name>paramno</name></name> <operator>==</operator> <name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>equal</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Present, so we can just return the Param */</comment>
                <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>param</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <comment type="block">/* No, so add it */</comment>
        <expr_stmt><expr><name>nlp</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>NestLoopParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramno</name></name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name> <operator>=</operator> <name>var</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name></expr></argument>, <argument><expr><name>nlp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* And return the replacement Param */</comment>
        <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>param</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Param</name>       <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>NestLoopParam</name> <modifier>*</modifier></type><name>nlp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

        <comment type="block">/* Upper-level PlaceHolderVars should be long gone at this point */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Check whether we need to replace the PHV.  We use bms_overlap as a
         * cheap/quick test to see if the PHV might be evaluated in the outer
         * rels, and then grab its PlaceHolderInfo to tell for sure.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>phv</name><operator>-&gt;</operator><name>phrels</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
            <operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><call><name>find_placeholder_info</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>phv</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ph_eval_at</name></expr></argument>,
                           <argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We can't replace the whole PHV, but we might still need to
             * replace Vars or PHVs within its expression, in case it ends up
             * actually getting evaluated here.  (It might get evaluated in
             * this plan node, or some child node; in the latter case we don't
             * really need to process the expression here, but we haven't got
             * enough info to tell if that's the case.)  Flat-copy the PHV
             * node and then recurse on its expression.
             *
             * Note that after doing this, we might have different
             * representations of the contents of the same PHV in different
             * parts of the plan tree.  This is OK because equal() will just
             * match on phid/phlevelsup, so setrefs.c will still recognize an
             * upper-level reference to a lower-level copy of the same PHV.
             */</comment>
            <decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>newphv</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newphv</name></expr></argument>, <argument><expr><name>phv</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newphv</name><operator>-&gt;</operator><name>phexpr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
                <call><name>replace_nestloop_params_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>phv</name><operator>-&gt;</operator><name>phexpr</name></name></expr></argument>,
                                                <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newphv</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Create a Param representing the PlaceHolderVar */</comment>
        <expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>assign_nestloop_param_placeholdervar</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>phv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Is this param already listed in root-&gt;curOuterParams? */</comment>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;curOuterParams</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>nlp</name> <operator>=</operator> <operator>(</operator><name>NestLoopParam</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>nlp</name><operator>-&gt;</operator><name>paramno</name></name> <operator>==</operator> <name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>equal</name><argument_list>(<argument><expr><name>phv</name></expr></argument>, <argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Present, so we can just return the Param */</comment>
                <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>param</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <comment type="block">/* No, so add it */</comment>
        <expr_stmt><expr><name>nlp</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>NestLoopParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramno</name></name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>phv</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name></expr></argument>, <argument><expr><name>nlp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* And return the replacement Param */</comment>
        <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>param</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
                                   <argument><expr><name>replace_nestloop_params_mutator</name></expr></argument>,
                                   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>root</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * process_subquery_nestloop_params
 *      Handle params of a parameterized subquery that need to be fed
 *      from an outer nestloop.
 *
 * Currently, that would be *all* params that a subquery in FROM has demanded
 * from the current query level, since they must be LATERAL references.
 *
 * The subplan's references to the outer variables are already represented
 * as PARAM_EXEC Params, so we need not modify the subplan here.  What we
 * do need to do is add entries to root-&gt;curOuterParams to signal the parent
 * nestloop plan node that it must provide these values.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_subquery_nestloop_params</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subplan_params</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ppl</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>ppl</argument>, <argument>subplan_params</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PlannerParamItem</name> <modifier>*</modifier></type><name>pitem</name> <init>= <expr><operator>(</operator><name>PlannerParamItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ppl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>pitem</name><operator>-&gt;</operator><name>item</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Var</name>           <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>pitem</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>NestLoopParam</name> <modifier>*</modifier></type><name>nlp</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

            <comment type="block">/* If not from a nestloop outer rel, complain */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"non-LATERAL parameter required by subquery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* Is this param already listed in root-&gt;curOuterParams? */</comment>
            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;curOuterParams</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>nlp</name> <operator>=</operator> <operator>(</operator><name>NestLoopParam</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>nlp</name><operator>-&gt;</operator><name>paramno</name></name> <operator>==</operator> <name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>equal</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* Present, so nothing to do */</comment>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* No, so add it */</comment>
                <expr_stmt><expr><name>nlp</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>NestLoopParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramno</name></name> <operator>=</operator> <name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name></expr></argument>, <argument><expr><name>nlp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>pitem</name><operator>-&gt;</operator><name>item</name></name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PlaceHolderVar</name> <modifier>*</modifier></type><name>phv</name> <init>= <expr><operator>(</operator><name>PlaceHolderVar</name> <operator>*</operator><operator>)</operator> <name><name>pitem</name><operator>-&gt;</operator><name>item</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>NestLoopParam</name> <modifier>*</modifier></type><name>nlp</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

            <comment type="block">/* If not from a nestloop outer rel, complain */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><call><name>find_placeholder_info</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>phv</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ph_eval_at</name></expr></argument>,
                               <argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterRels</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"non-LATERAL parameter required by subquery"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* Is this param already listed in root-&gt;curOuterParams? */</comment>
            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;curOuterParams</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>nlp</name> <operator>=</operator> <operator>(</operator><name>NestLoopParam</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>nlp</name><operator>-&gt;</operator><name>paramno</name></name> <operator>==</operator> <name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>equal</name><argument_list>(<argument><expr><name>phv</name></expr></argument>, <argument><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* Present, so nothing to do */</comment>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* No, so add it */</comment>
                <expr_stmt><expr><name>nlp</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>NestLoopParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramno</name></name> <operator>=</operator> <name><name>pitem</name><operator>-&gt;</operator><name>paramId</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>nlp</name><operator>-&gt;</operator><name>paramval</name></name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>phv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>curOuterParams</name></name></expr></argument>, <argument><expr><name>nlp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected type of subquery parameter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * fix_indexqual_references
 *      Adjust indexqual clauses to the form the executor's indexqual
 *      machinery needs.
 *
 * We have four tasks here:
 *    * Remove RestrictInfo nodes from the input clauses.
 *    * Replace any outer-relation Var or PHV nodes with nestloop Params.
 *      (XXX eventually, that responsibility should go elsewhere?)
 *    * Index keys must be represented by Var nodes with varattno set to the
 *      index's attribute number, not the attribute number in the original rel.
 *    * If the index key is on the right, commute the clause to put it on the
 *      left.
 *
 * The result is a modified copy of the path's indexquals list --- the
 * original is not changed.  Note also that the copy shares no substructure
 * with the original; this is needed in case there is a subplan in it (we need
 * two separate copies of the subplan tree, or things will go awry).
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>fix_indexqual_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>index_path</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name> <init>= <expr><name><name>index_path</name><operator>-&gt;</operator><name>indexinfo</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>fixed_indexquals</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcc</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>lci</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>fixed_indexquals</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <macro><name>forboth</name><argument_list>(<argument>lcc</argument>, <argument>index_path-&gt;indexquals</argument>, <argument>lci</argument>, <argument>index_path-&gt;indexqualcols</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lcc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>indexcol</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lci</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>clause</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Replace any outer-relation variables with nestloop params.
         *
         * This also makes a copy of the clause, so it's safe to modify it
         * in-place below.
         */</comment>
        <expr_stmt><expr><name>clause</name> <operator>=</operator> <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>OpExpr</name>       <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"indexqual clause is not binary opclause"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Check to see if the indexkey is on the right; if so, commute
             * the clause.  The indexkey should be the side that refers to
             * (only) the base relation.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>, <argument><expr><name><name>index</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>CommuteOpExpr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Now replace the indexkey expression with an index Var.
             */</comment>
            <expr_stmt><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>fix_indexqual_operand</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                                       <argument><expr><name>index</name></expr></argument>,
                                                       <argument><expr><name>indexcol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>RowCompareExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><operator>(</operator><name>RowCompareExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>newrc</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>indexcolnos</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>var_on_left</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lca</name></decl>,
                       <decl><type ref="prev"><modifier>*</modifier></type><name>lcai</name></decl>;</decl_stmt>

            <comment type="block">/*
             * Re-discover which index columns are used in the rowcompare.
             */</comment>
            <expr_stmt><expr><name>newrc</name> <operator>=</operator> <call><name>adjust_rowcompare_for_index</name><argument_list>(<argument><expr><name>rc</name></expr></argument>,
                                                <argument><expr><name>index</name></expr></argument>,
                                                <argument><expr><name>indexcol</name></expr></argument>,
                                                <argument><expr><operator>&amp;</operator><name>indexcolnos</name></expr></argument>,
                                                <argument><expr><operator>&amp;</operator><name>var_on_left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Trouble if adjust_rowcompare_for_index thought the
             * RowCompareExpr didn't match the index as-is; the clause should
             * have gone through that routine already.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>newrc</name> <operator>!=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>rc</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"inconsistent results from adjust_rowcompare_for_index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Check to see if the indexkey is on the right; if so, commute
             * the clause.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>var_on_left</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>CommuteRowCompareExpr</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Now replace the indexkey expressions with index Vars.
             */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>largs</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>indexcolnos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <macro><name>forboth</name><argument_list>(<argument>lca</argument>, <argument>rc-&gt;largs</argument>, <argument>lcai</argument>, <argument>indexcolnos</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lca</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>fix_indexqual_operand</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lca</name></expr></argument>)</argument_list></call></expr></argument>,
                                                    <argument><expr><name>index</name></expr></argument>,
                                                    <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lcai</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>saop</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Never need to commute... */</comment>

            <comment type="block">/* Replace the indexkey expression with an index Var. */</comment>
            <expr_stmt><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>saop</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>fix_indexqual_operand</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>saop</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                                         <argument><expr><name>index</name></expr></argument>,
                                                         <argument><expr><name>indexcol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>nt</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Replace the indexkey expression with an index Var. */</comment>
            <expr_stmt><expr><name><name>nt</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>fix_indexqual_operand</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>nt</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>,
                                                     <argument><expr><name>index</name></expr></argument>,
                                                     <argument><expr><name>indexcol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported indexqual type: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>fixed_indexquals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fixed_indexquals</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>fixed_indexquals</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fix_indexorderby_references
 *      Adjust indexorderby clauses to the form the executor's index
 *      machinery needs.
 *
 * This is a simplified version of fix_indexqual_references.  The input does
 * not have RestrictInfo nodes, and we assume that indxpath.c already
 * commuted the clauses to put the index keys on the left.  Also, we don't
 * bother to support any cases except simple OpExprs, since nothing else
 * is allowed for ordering operators.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>fix_indexorderby_references</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>index_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name> <init>= <expr><name><name>index_path</name><operator>-&gt;</operator><name>indexinfo</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>fixed_indexorderbys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcc</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>lci</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>fixed_indexorderbys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <macro><name>forboth</name><argument_list>(<argument>lcc</argument>, <argument>index_path-&gt;indexorderbys</argument>, <argument>lci</argument>, <argument>index_path-&gt;indexorderbycols</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>indexcol</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lci</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Replace any outer-relation variables with nestloop params.
         *
         * This also makes a copy of the clause, so it's safe to modify it
         * in-place below.
         */</comment>
        <expr_stmt><expr><name>clause</name> <operator>=</operator> <call><name>replace_nestloop_params</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>OpExpr</name>       <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"indexorderby clause is not binary opclause"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Now replace the indexkey expression with an index Var.
             */</comment>
            <expr_stmt><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>fix_indexqual_operand</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                                       <argument><expr><name>index</name></expr></argument>,
                                                       <argument><expr><name>indexcol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported indexorderby type: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>fixed_indexorderbys</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fixed_indexorderbys</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>fixed_indexorderbys</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fix_indexqual_operand
 *      Convert an indexqual expression to a Var referencing the index column.
 *
 * We represent index keys by Var nodes having varno == INDEX_VAR and varattno
 * equal to the index's attribute number (index column position).
 *
 * Most of the code here is just for sanity cross-checking that the given
 * expression actually matches the index column it's claimed to.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>fix_indexqual_operand</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indexcol</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Var</name>           <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexpr_item</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Remove any binary-compatible relabeling of the indexkey
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>indexcol</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>indexcol</name> <operator>&lt;</operator> <name><name>index</name><operator>-&gt;</operator><name>ncolumns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>indexcol</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* It's a simple index column */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>varno</name> <operator>==</operator> <name><name>index</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&amp;&amp;</operator>
            <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>==</operator> <name><name>index</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>indexcol</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name>INDEX_VAR</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name>indexcol</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>result</name></expr>;</return>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"index key does not match expected index column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* It's an index expression, so find and cross-check the expression */</comment>
    <expr_stmt><expr><name>indexpr_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name><name>index</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>;</condition> <incr><expr><name>pos</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>indexpr_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too few entries in indexprs list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <name>indexcol</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>indexkey</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>indexkey</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>indexkey</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>indexkey</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>indexkey</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>indexkey</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>indexkey</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>INDEX_VAR</name></expr></argument>, <argument><expr><name>indexcol</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                                     <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                                     <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>result</name></expr>;</return>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"index key does not match expected index column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>indexpr_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Oops... */</comment>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"index key does not match expected index column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>                <comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * get_switched_clauses
 *      Given a list of merge or hash joinclauses (as RestrictInfo nodes),
 *      extract the bare clauses, and rearrange the elements within the
 *      clauses, if needed, so the outer join variable is on the left and
 *      the inner is on the right.  The original clause data structure is not
 *      touched; a modified list is returned.  We do, however, set the transient
 *      outer_is_left field in each RestrictInfo to show which side was which.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_switched_clauses</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>outerrelids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>t_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>clauses</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OpExpr</name>       <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name><name>restrictinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>is_opclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>, <argument><expr><name>outerrelids</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Duplicate just enough of the structure to allow commuting the
             * clause without changing the original list.  Could use
             * copyObject, but a complete deep copy is overkill.
             */</comment>
            <decl_stmt><decl><type><name>OpExpr</name>       <modifier>*</modifier></type><name>temp</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>temp</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name><name>clause</name><operator>-&gt;</operator><name>opno</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>temp</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>temp</name><operator>-&gt;</operator><name>opresulttype</name></name> <operator>=</operator> <name><name>clause</name><operator>-&gt;</operator><name>opresulttype</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>temp</name><operator>-&gt;</operator><name>opretset</name></name> <operator>=</operator> <name><name>clause</name><operator>-&gt;</operator><name>opretset</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>temp</name><operator>-&gt;</operator><name>opcollid</name></name> <operator>=</operator> <name><name>clause</name><operator>-&gt;</operator><name>opcollid</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>temp</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name><name>clause</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>temp</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>temp</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>clause</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
            <comment type="block">/* Commute it --- note this modifies the temp node in-place. */</comment>
            <expr_stmt><expr><call><name>CommuteOpExpr</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>t_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>t_list</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>outer_is_left</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>, <argument><expr><name>outerrelids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>t_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>t_list</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>outer_is_left</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <return>return <expr><name>t_list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * order_qual_clauses
 *        Given a list of qual clauses that will all be evaluated at the same
 *        plan node, sort the list into the order we want to check the quals
 *        in at runtime.
 *
 * When security barrier quals are used in the query, we may have quals with
 * different security levels in the list.  Quals of lower security_level
 * must go before quals of higher security_level, except that we can grant
 * exceptions to move up quals that are leakproof.  When security level
 * doesn't force the decision, we prefer to order clauses by estimated
 * execution cost, cheapest first.
 *
 * Ideally the order should be driven by a combination of execution cost and
 * selectivity, but it's not immediately clear how to account for both,
 * and given the uncertainty of the estimates the reliability of the decisions
 * would be doubtful anyway.  So we just order by security level then
 * estimated per-tuple cost, being careful not to change the order when
 * (as is often the case) the estimates are identical.
 *
 * Although this will work on either bare clauses or RestrictInfos, it's
 * much faster to apply it to RestrictInfos, since it can re-use cost
 * information that is cached in RestrictInfos.  XXX in the bare-clause
 * case, we are also not able to apply security considerations.  That is
 * all right for the moment, because the bare-clause case doesn't occur
 * anywhere that barrier quals could be present, but it would be better to
 * get rid of it.
 *
 * Note: some callers pass lists that contain entries that will later be
 * removed; this is the easiest way to let this routine see RestrictInfos
 * instead of bare clauses.  This is another reason why trying to consider
 * selectivity in the ordering would likely do the wrong thing.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>order_qual_clauses</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <typedef>typedef <type><struct>struct
    <block>{
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>clause</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Cost</name></type>        <name>cost</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Index</name></type>        <name>security_level</name></decl>;</decl_stmt>
    }</block></struct></type> <name>QualItem</name>;</typedef>
    <decl_stmt><decl><type><name>int</name></type>            <name>nitems</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>clauses</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>QualItem</name>   <modifier>*</modifier></type><name>items</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <comment type="block">/* No need to work hard for 0 or 1 clause */</comment>
    <if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>clauses</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Collect the items and costs into an array.  This is to avoid repeated
     * cost_qual_eval work if the inputs aren't RestrictInfos.
     */</comment>
    <expr_stmt><expr><name>items</name> <operator>=</operator> <operator>(</operator><name>QualItem</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nitems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>QualItem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>clauses</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>QualCost</name></type>    <name>qcost</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>cost_qual_eval_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qcost</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>clause</name> <operator>=</operator> <name>clause</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cost</name> <operator>=</operator> <name><name>qcost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * If a clause is leakproof, it doesn't have to be constrained by
             * its nominal security level.  If it's also reasonably cheap
             * (here defined as 10X cpu_operator_cost), pretend it has
             * security_level 0, which will allow it to go in front of
             * more-expensive quals of lower security levels.  Of course, that
             * will also force it to go in front of cheaper quals of its own
             * security level, which is not so great, but we can alleviate
             * that risk by applying the cost limit cutoff.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>leakproof</name></name> <operator>&amp;&amp;</operator> <name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cost</name> <operator>&lt;</operator> <literal type="number">10</literal> <operator>*</operator> <name>cpu_operator_cost</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>security_level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>security_level</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>security_level</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>security_level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Sort.  We don't use qsort() because it's not guaranteed stable for
     * equal keys.  The expected number of entries is small enough that a
     * simple insertion sort should be good enough.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>QualItem</name></type>    <name>newitem</name> <init>= <expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

        <comment type="block">/* insert newitem into the already-sorted subarray */</comment>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</init> <condition><expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name><operator>--</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>QualItem</name>   <modifier>*</modifier></type><name>olditem</name> <init>= <expr><operator>&amp;</operator><name><name>items</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>newitem</name><operator>.</operator><name>security_level</name></name> <operator>&gt;</operator> <name><name>olditem</name><operator>-&gt;</operator><name>security_level</name></name> <operator>||</operator>
                <operator>(</operator><name><name>newitem</name><operator>.</operator><name>security_level</name></name> <operator>==</operator> <name><name>olditem</name><operator>-&gt;</operator><name>security_level</name></name> <operator>&amp;&amp;</operator>
                 <name><name>newitem</name><operator>.</operator><name>cost</name></name> <operator>&gt;=</operator> <name><name>olditem</name><operator>-&gt;</operator><name>cost</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>items</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>olditem</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>items</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>newitem</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Convert back to a list */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy cost and size info from a Path node to the Plan node created from it.
 * The executor usually won't use this info, but it's needed by EXPLAIN.
 * Also copy the parallel-related flags, which the executor *will* use.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_generic_path_info</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>plan_width</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Copy cost and size info from a lower plan node to an inserted node.
 * (Most callers alter the info after copying it.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_plan_costsize</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>plan_width</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>plan_width</name></name></expr>;</expr_stmt>
    <comment type="block">/* Assume the inserted node is not parallel-aware. */</comment>
    <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <comment type="block">/* Assume the inserted node is parallel-safe, if child plan is. */</comment>
    <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Some places in this file build Sort nodes that don't have a directly
 * corresponding Path node.  The cost of the sort is, or should have been,
 * included in the cost of the Path node we're working from, but since it's
 * not split out, we have to re-figure it using cost_sort().  This is just
 * to label the Sort node nicely for EXPLAIN.
 *
 * limit_tuples is as for cost_sort (in particular, pass -1 if no limit)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>label_sort_with_costsize</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Sort</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>limit_tuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>lefttree</name> <init>= <expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Path</name></type>        <name>sort_path</name></decl>;</decl_stmt>        <comment type="block">/* dummy for result of cost_sort */</comment>

    <expr_stmt><expr><call><name>cost_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sort_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
              <argument><expr><name><name>lefttree</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
              <argument><expr><name><name>lefttree</name><operator>-&gt;</operator><name>plan_rows</name></name></expr></argument>,
              <argument><expr><name><name>lefttree</name><operator>-&gt;</operator><name>plan_width</name></name></expr></argument>,
              <argument><expr><literal type="number">0.0</literal></expr></argument>,
              <argument><expr><name>work_mem</name></expr></argument>,
              <argument><expr><name>limit_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>sort_path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>sort_path</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>plan_rows</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>plan_width</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>plan_width</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * bitmap_subplan_mark_shared
 *     Set isshared flag in bitmap subplan so that it will be created in
 *     shared memory.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bitmap_subplan_mark_shared</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>BitmapAnd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>bitmap_subplan_mark_shared</name><argument_list>(
                                   <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>BitmapAnd</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>bitmapplans</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>BitmapOr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>BitmapOr</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>isshared</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>BitmapIndexScan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>BitmapIndexScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>isshared</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *
 *    PLAN NODE BUILDING ROUTINES
 *
 * In general, these functions are not passed the original Path and therefore
 * leave it to the caller to fill in the cost/width fields from the Path,
 * typically by calling copy_generic_path_info().  This convention is
 * somewhat historical, but it does support a few places above where we build
 * a plan node without having an exactly corresponding Path node.  Under no
 * circumstances should one of these functions do its own cost calculations,
 * as that would be redundant with calculations done while building Paths.
 *
 *****************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>SeqScan</name> <modifier>*</modifier></type>
<name>make_seqscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
             <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
             <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SeqScan</name>    <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SeqScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SampleScan</name> <modifier>*</modifier></type>
<name>make_samplescan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
                <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
                <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
                <parameter><decl><type><name>TableSampleClause</name> <modifier>*</modifier></type><name>tsc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SampleScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SampleScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tablesample</name></name> <operator>=</operator> <name>tsc</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>IndexScan</name> <modifier>*</modifier></type>
<name>make_indexscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
               <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
               <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
               <parameter><decl><type><name>Oid</name></type> <name>indexid</name></decl></parameter>,
               <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexqual</name></decl></parameter>,
               <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexqualorig</name></decl></parameter>,
               <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexorderby</name></decl></parameter>,
               <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexorderbyorig</name></decl></parameter>,
               <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexorderbyops</name></decl></parameter>,
               <parameter><decl><type><name>ScanDirection</name></type> <name>indexscandir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>IndexScan</name>  <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>IndexScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexid</name></name> <operator>=</operator> <name>indexid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexqual</name></name> <operator>=</operator> <name>indexqual</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexqualorig</name></name> <operator>=</operator> <name>indexqualorig</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexorderby</name></name> <operator>=</operator> <name>indexorderby</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexorderbyorig</name></name> <operator>=</operator> <name>indexorderbyorig</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexorderbyops</name></name> <operator>=</operator> <name>indexorderbyops</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexorderdir</name></name> <operator>=</operator> <name>indexscandir</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>IndexOnlyScan</name> <modifier>*</modifier></type>
<name>make_indexonlyscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
                   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
                   <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
                   <parameter><decl><type><name>Oid</name></type> <name>indexid</name></decl></parameter>,
                   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexqual</name></decl></parameter>,
                   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexorderby</name></decl></parameter>,
                   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indextlist</name></decl></parameter>,
                   <parameter><decl><type><name>ScanDirection</name></type> <name>indexscandir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>IndexOnlyScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>IndexOnlyScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexid</name></name> <operator>=</operator> <name>indexid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexqual</name></name> <operator>=</operator> <name>indexqual</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexorderby</name></name> <operator>=</operator> <name>indexorderby</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indextlist</name></name> <operator>=</operator> <name>indextlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexorderdir</name></name> <operator>=</operator> <name>indexscandir</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BitmapIndexScan</name> <modifier>*</modifier></type>
<name>make_bitmap_indexscan</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
                      <parameter><decl><type><name>Oid</name></type> <name>indexid</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexqual</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexqualorig</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BitmapIndexScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>BitmapIndexScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>        <comment type="block">/* not used */</comment>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>            <comment type="block">/* not used */</comment>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexid</name></name> <operator>=</operator> <name>indexid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexqual</name></name> <operator>=</operator> <name>indexqual</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>indexqualorig</name></name> <operator>=</operator> <name>indexqualorig</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BitmapHeapScan</name> <modifier>*</modifier></type>
<name>make_bitmap_heapscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
                     <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
                     <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
                     <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>bitmapqualorig</name></decl></parameter>,
                     <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BitmapHeapScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>BitmapHeapScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>bitmapqualorig</name></name> <operator>=</operator> <name>bitmapqualorig</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TidScan</name> <modifier>*</modifier></type>
<name>make_tidscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
             <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
             <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
             <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tidquals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TidScan</name>    <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TidScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tidquals</name></name> <operator>=</operator> <name>tidquals</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SubqueryScan</name> <modifier>*</modifier></type>
<name>make_subqueryscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
                  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
                  <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
                  <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>subplan</name></name> <operator>=</operator> <name>subplan</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FunctionScan</name> <modifier>*</modifier></type>
<name>make_functionscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
                  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
                  <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
                  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>functions</name></decl></parameter>,
                  <parameter><decl><type><name>bool</name></type> <name>funcordinality</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FunctionScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>FunctionScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>functions</name></name> <operator>=</operator> <name>functions</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>funcordinality</name></name> <operator>=</operator> <name>funcordinality</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TableFuncScan</name> <modifier>*</modifier></type>
<name>make_tablefuncscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
                   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
                   <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
                   <parameter><decl><type><name>TableFunc</name> <modifier>*</modifier></type><name>tablefunc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TableFuncScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TableFuncScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tablefunc</name></name> <operator>=</operator> <name>tablefunc</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ValuesScan</name> <modifier>*</modifier></type>
<name>make_valuesscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
                <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
                <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
                <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>values_lists</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ValuesScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ValuesScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>values_lists</name></name> <operator>=</operator> <name>values_lists</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CteScan</name> <modifier>*</modifier></type>
<name>make_ctescan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
             <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
             <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
             <parameter><decl><type><name>int</name></type> <name>ctePlanId</name></decl></parameter>,
             <parameter><decl><type><name>int</name></type> <name>cteParam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>CteScan</name>    <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CteScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ctePlanId</name></name> <operator>=</operator> <name>ctePlanId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>cteParam</name></name> <operator>=</operator> <name>cteParam</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>NamedTuplestoreScan</name> <modifier>*</modifier></type>
<name>make_namedtuplestorescan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
                         <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
                         <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
                         <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>enrname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NamedTuplestoreScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>NamedTuplestoreScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* cost should be inserted by caller */</comment>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>enrname</name></name> <operator>=</operator> <name>enrname</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>WorkTableScan</name> <modifier>*</modifier></type>
<name>make_worktablescan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
                   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
                   <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
                   <parameter><decl><type><name>int</name></type> <name>wtParam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>WorkTableScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>WorkTableScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>wtParam</name></name> <operator>=</operator> <name>wtParam</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<comment type="block">/*
 * make_remotesubplan
 *     Create a RemoteSubplan node to execute subplan on remote nodes.
 *  leftree - the subplan which we want to push down to remote node.
 *  resultDistribution - the distribution of the remote result. May be NULL -
 * results are coming to the invoking node
 *  execDistribution - determines how source data of the subplan are
 * distributed, where we should send the subplan and how combine results.
 *    pathkeys - the remote subplan is sorted according to these keys, executor
 *         should perform merge sort of incoming tuples
 */</comment>
<function><type><name>RemoteSubplan</name> <modifier>*</modifier></type>
<name>make_remotesubplan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                   <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
                   <parameter><decl><type><name>Distribution</name> <modifier>*</modifier></type><name>resultDistribution</name></decl></parameter>,
                   <parameter><decl><type><name>Distribution</name> <modifier>*</modifier></type><name>execDistribution</name></decl></parameter>,
                   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>RemoteSubplan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteSubplan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>tmpset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nodenum</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>char</name></type> <name>distributionType</name> <init>= <expr><ternary><condition><expr><name>resultDistribution</name></expr> ?</condition><then> <expr><name><name>resultDistribution</name><operator>-&gt;</operator><name>distributionType</name></name></expr> </then><else>:
                                                 <expr><name>LOCATOR_TYPE_NONE</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>gather_left</name> <init>= <expr><name>lefttree</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>gather_parent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>need_sort</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>nodes</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Sanity checks */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>resultDistribution</name></expr></argument>, <argument><expr><name>execDistribution</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>RemoteSubplan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<comment type="block">/* do things like path_count_datanodes, but we have only distribution here */</comment>
	<if_stmt><if>if <condition>(<expr><name>execDistribution</name> <operator>&amp;&amp;</operator>
	    <operator>(</operator><name><name>execDistribution</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_HASH</name> <operator>||</operator>
	     <name><name>execDistribution</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>execDistribution</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nodes</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* should not happen, but for safety */</comment>
			<expr_stmt><expr><name>nodes</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	
	<if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>HashJoin</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>NestLoop</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>SeqScan</name></expr></argument>)</argument_list></call> 
        <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>Agg</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>Group</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>IsA</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>Sort</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>Limit</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>Gather</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> 
        <name>max_parallel_workers_per_gather</name> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>parallelModeOK</name></name> <operator>&amp;&amp;</operator>
        <name>olap_optimizer</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>mergejoin</name> <operator>&amp;&amp;</operator> <call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>distributionType</name> <operator>==</operator> <name>LOCATOR_TYPE_HASH</name> <operator>||</operator>
         <name>distributionType</name> <operator>==</operator> <name>LOCATOR_TYPE_NONE</name> <operator>||</operator>
         <name>distributionType</name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>Gather</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Gather</name> <modifier>*</modifier></type><name>gather</name> <init>= <expr><operator>(</operator><name>Gather</name> <operator>*</operator><operator>)</operator><name>lefttree</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>nWorkers</name> <init>= <expr><name><name>gather</name><operator>-&gt;</operator><name>num_workers</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>leftplan</name> <init>= <expr><name><name>lefttree</name><operator>-&gt;</operator><name>lefttree</name></name></expr></init></decl>;</decl_stmt>
            <comment type="block">/* if contain nonparallel hashjoin, set num_workers to 1 */</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>contain_nonparallel_hashjoin</name> <init>= <expr><call><name>contain_node_walker</name><argument_list>(<argument><expr><name>leftplan</name></expr></argument>, <argument><expr><name>T_HashJoin</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>contain_nonparallel_hashjoin</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
			<comment type="block">/* rows estimate is cut down to per data nodes, set it to all nodes for parallel estimate. */</comment>
			<decl_stmt><decl><type><name>double</name></type> <name>rows</name> <init>= <expr><call><name>GetPlanRows</name><argument_list>(<argument><expr><name>leftplan</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>nodes</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>    <name>heap_parallel_threshold</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>    <name>heap_parallel_workers</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type> <name>contain_gather</name> <init>= <expr><call><name>contain_node_walker</name><argument_list>(<argument><expr><name>leftplan</name></expr></argument>, <argument><expr><name>T_Gather</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>heap_parallel_threshold</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>min_parallel_rows_size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>rows</name> <operator>&gt;=</operator> <operator>(</operator><name>heap_parallel_threshold</name> <operator>*</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>heap_parallel_workers</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>heap_parallel_threshold</name> <operator>*=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>heap_parallel_threshold</name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>/</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>        <comment type="block">/* avoid overflow */</comment>
            </block_content>}</block></while>

            <expr_stmt><expr><name>heap_parallel_workers</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>heap_parallel_workers</name></expr></argument>, <argument><expr><name>max_parallel_workers_per_gather</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>heap_parallel_workers</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>heap_parallel_workers</name></expr></argument>, <argument><expr><name>nWorkers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* if contain gather, need compare the workers with min_workers_of_hashjon_gather */</comment>
                <expr_stmt><expr><name><name>gather</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>contain_gather</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>Min</name><argument_list>(<argument><expr><name>heap_parallel_workers</name></expr></argument>, <argument><expr><name>min_workers_of_hashjon_gather</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>heap_parallel_workers</name></expr></else></ternary></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
              * calculation of parallel workers is from compute_parallel_worker
              */</comment>
            <decl_stmt><decl><type><name>double</name></type> <name>outer_rows</name>              <init>= <expr><ternary><condition><expr><name><name>lefttree</name><operator>-&gt;</operator><name>lefttree</name></name></expr> ?</condition><then> <expr><name><name>lefttree</name><operator>-&gt;</operator><name>lefttree</name><operator>-&gt;</operator><name>plan_rows</name></name></expr> </then><else>: <expr><name><name>lefttree</name><operator>-&gt;</operator><name>plan_rows</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type> <name>inner_rows</name>              <init>= <expr><ternary><condition><expr><name><name>lefttree</name><operator>-&gt;</operator><name>righttree</name></name></expr> ?</condition><then> <expr><name><name>lefttree</name><operator>-&gt;</operator><name>righttree</name><operator>-&gt;</operator><name>plan_rows</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type> <name>rows</name>                    <init>= <expr><ternary><condition><expr><name>outer_rows</name> <operator>&gt;</operator> <name>inner_rows</name></expr> ?</condition><then> 
                                             <expr><name>outer_rows</name></expr> </then><else>: <expr><name>inner_rows</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>contain_nonparallel_hashjoin</name> <init>= <expr><call><name>contain_node_walker</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>T_HashJoin</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>   <name>need_parallel</name>           <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>parallel_workers</name>           <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <comment type="block">/* if contain nonparallel hashjoin, don't add gather plan */</comment>
			<if_stmt><if>if <condition>(<expr><name>contain_nonparallel_hashjoin</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>need_parallel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* only add gather to remote_subplan at top */</comment>
            <if_stmt><if>if <condition>(<expr><name>need_parallel</name> <operator>&amp;&amp;</operator> <name>distributionType</name> <operator>==</operator> <name>LOCATOR_TYPE_NONE</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>remote_subplan_depth</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>need_parallel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>need_parallel</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* make decision whether we indeed need parallel execution or not ? */</comment>
                <switch>switch<condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>T_SeqScan</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><name>rows</name> <operator>&gt;=</operator> <name>min_parallel_rows_size</name> <operator>*</operator> <literal type="number">3</literal></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>lefttree</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <break>break;</break>
                    <case>case <expr><name>T_HashJoin</name></expr>:</case>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lefttree</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>need_parallel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <break>break;</break>
                    <case>case <expr><name>T_Agg</name></expr>:</case>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lefttree</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>Agg</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Agg</name> <operator>*</operator><operator>)</operator><name>lefttree</name></expr></init></decl>;</decl_stmt>

                            <comment type="block">/* do not parallel if it's not safe */</comment>
							<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>==</operator> <name>AGGSPLIT_INITIAL_SERIAL</name>
							    <operator>&amp;&amp;</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition>
                            <block>{<block_content>
                                <switch>switch<condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name></expr>)</condition>
                                <block>{<block_content>
                                    <case>case <expr><name>AGG_PLAIN</name></expr>:</case>
                                    <case>case <expr><name>AGG_HASHED</name></expr>:</case>
                                        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>lefttree</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call></expr>)</condition>
                                        <block>{<block_content>
                                            <decl_stmt><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>subscan</name> <init>= <expr><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator><name><name>lefttree</name><operator>-&gt;</operator><name>lefttree</name></name></expr></init></decl>;</decl_stmt>

                                            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>subscan</name><operator>-&gt;</operator><name>subplan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
                                            <block>{<block_content>
                                                <expr_stmt><expr><name>need_parallel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                                            </block_content>}</block></if></if_stmt>
                                        </block_content>}</block></if>
                                        <else>else
                                        <block>{<block_content>
                                            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lefttree</name><operator>-&gt;</operator><name>lefttree</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
                                            <block>{<block_content>
                                                <expr_stmt><expr><name>need_parallel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                                            </block_content>}</block></if></if_stmt>
                                        </block_content>}</block></else></if_stmt>
                                        <break>break;</break>
                                    <case>case <expr><name>AGG_SORTED</name></expr>:</case>
                                        <block>{<block_content>
                                            <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lplan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                                            
                                            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>lefttree</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>Sort</name></expr></argument>)</argument_list></call></expr>)</condition>
                                            <block>{<block_content>
                                                <expr_stmt><expr><name>lplan</name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>lefttree</name><operator>-&gt;</operator><name>lefttree</name></name></expr>;</expr_stmt>
                                            </block_content>}</block></if>
                                            <else>else
                                            <block>{<block_content>
                                                <expr_stmt><expr><name>lplan</name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>lefttree</name></name></expr>;</expr_stmt>
                                            </block_content>}</block></else></if_stmt>

                                            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>lplan</name></expr></argument>, <argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call></expr>)</condition>
                                            <block>{<block_content>
                                                <decl_stmt><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>subscan</name> <init>= <expr><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator><name>lplan</name></expr></init></decl>;</decl_stmt>

                                                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>subscan</name><operator>-&gt;</operator><name>subplan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
                                                <block>{<block_content>
                                                    <expr_stmt><expr><name>need_parallel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                                                </block_content>}</block></if></if_stmt>
                                            </block_content>}</block></if>
                                            <else>else
                                            <block>{<block_content>
                                                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lplan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
                                                <block>{<block_content>
                                                    <expr_stmt><expr><name>need_parallel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                                                </block_content>}</block></if></if_stmt>
                                            </block_content>}</block></else></if_stmt>
                                        </block_content>}</block>
                                        <break>break;</break>
                                    <default>default:</default>
                                        <expr_stmt><expr><name>need_parallel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                                        <break>break;</break>
                                </block_content>}</block></switch>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <expr_stmt><expr><name>need_parallel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block></if></if_stmt>
                        <break>break;</break>
                    <case>case <expr><name>T_Group</name></expr>:</case>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lefttree</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>need_parallel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <break>break;</break>
                    <case>case <expr><name>T_Limit</name></expr>:</case>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>left</name> <init>= <expr><name><name>lefttree</name><operator>-&gt;</operator><name>lefttree</name></name></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><name>gather_parent</name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_Sort</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>gather_parent</name> <operator>=</operator> <name>left</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>left</name> <operator>=</operator> <name><name>left</name><operator>-&gt;</operator><name>lefttree</name></name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>need_sort</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>

                            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>left</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
                            <block>{<block_content>
                                <if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_Agg</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>gather_left</name> <operator>=</operator> <name>left</name></expr>;</expr_stmt>
                                    
                                    <expr_stmt><expr><name>left</name> <operator>=</operator> <name><name>left</name><operator>-&gt;</operator><name>lefttree</name></name></expr>;</expr_stmt>

                                    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call></expr>)</condition>
                                    <block>{<block_content>
                                        <decl_stmt><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>subscan</name> <init>= <expr><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator><name>left</name></expr></init></decl>;</decl_stmt>

                                        <expr_stmt><expr><name>left</name> <operator>=</operator> <name><name>subscan</name><operator>-&gt;</operator><name>subplan</name></name></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>

                                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>left</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
                                        <expr_stmt><expr><name>need_parallel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
                                    <else>else
                                    <block>{<block_content>
                                        <expr_stmt><expr><name>rows</name> <operator>=</operator> <name><name>left</name><operator>-&gt;</operator><name>lefttree</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>
                                    </block_content>}</block></else></if_stmt>
                                </block_content>}</block></if>
                                <else>else<block type="pseudo"><block_content>
                                    <expr_stmt><expr><name>need_parallel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_Agg</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>rows</name> <operator>=</operator> <name><name>left</name><operator>-&gt;</operator><name>lefttree</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>

                                <expr_stmt><expr><name>gather_left</name> <operator>=</operator> <name>left</name></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block>
                        <break>break;</break>
                    <case>case <expr><name>T_Sort</name></expr>:</case>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>left</name> <init>= <expr><name><name>lefttree</name><operator>-&gt;</operator><name>lefttree</name></name></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><name>gather_parent</name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>need_sort</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>left</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
                            <block>{<block_content>
                                <if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_Agg</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>gather_left</name> <operator>=</operator> <name>left</name></expr>;</expr_stmt>
                                    
                                    <expr_stmt><expr><name>left</name> <operator>=</operator> <name><name>left</name><operator>-&gt;</operator><name>lefttree</name></name></expr>;</expr_stmt>

                                    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call></expr>)</condition>
                                    <block>{<block_content>
                                        <decl_stmt><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>subscan</name> <init>= <expr><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator><name>left</name></expr></init></decl>;</decl_stmt>

                                        <expr_stmt><expr><name>left</name> <operator>=</operator> <name><name>subscan</name><operator>-&gt;</operator><name>subplan</name></name></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>

                                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>left</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
                                        <expr_stmt><expr><name>need_parallel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
                                    <else>else
                                    <block>{<block_content>
                                        <expr_stmt><expr><name>rows</name> <operator>=</operator> <name><name>left</name><operator>-&gt;</operator><name>lefttree</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>
                                    </block_content>}</block></else></if_stmt>
                                </block_content>}</block></if>
                                <else>else<block type="pseudo"><block_content>
                                    <expr_stmt><expr><name>need_parallel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_Agg</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>rows</name> <operator>=</operator> <name><name>left</name><operator>-&gt;</operator><name>lefttree</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>

                                <expr_stmt><expr><name>gather_left</name> <operator>=</operator> <name>left</name></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block>
                        <break>break;</break>
                    <default>default:</default>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lefttree</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>need_parallel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block></if></if_stmt>

			<comment type="block">/* rows estimate is cut down to per data nodes, set it to all nodes for parallel estimate. */</comment>
			<expr_stmt><expr><name>rows</name> <operator>*=</operator> <name>nodes</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>rows</name> <operator>&lt;</operator> <name>min_parallel_rows_size</name> <operator>*</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>need_parallel</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>need_parallel</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>            <name>heap_parallel_threshold</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>heap_parallel_workers</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Gather</name>       <modifier>*</modifier></type><name>gather_plan</name>           <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>subplan</name>               <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>heap_parallel_threshold</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>min_parallel_rows_size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <while>while <condition>(<expr><name>rows</name> <operator>&gt;=</operator> <operator>(</operator><name>heap_parallel_threshold</name> <operator>*</operator> <literal type="number">3</literal><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>heap_parallel_workers</name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name>heap_parallel_threshold</name> <operator>*=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>heap_parallel_threshold</name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>/</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>        <comment type="block">/* avoid overflow */</comment>
                </block_content>}</block></while>

                <expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <name>heap_parallel_workers</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>parallel_workers</name></expr></argument>, <argument><expr><name>max_parallel_workers_per_gather</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* launched parallel workers must less than hashjoin's parallel workers under it */</comment>
                <expr_stmt><expr><name>parallel_workers</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>parallel_workers</name></expr></argument>, <argument><expr><name>min_workers_of_hashjon_gather</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
				<expr_stmt><expr><name>gather_plan</name> <operator>=</operator> <call><name>make_gather</name><argument_list>(<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>gather_left</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>NIL</name></expr></argument>,
                                          <argument><expr><name>parallel_workers</name></expr></argument>,
                                          <argument><expr><name>false</name></expr></argument>,
                                          <argument><expr><name>gather_left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>gather_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>gather_left</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>gather_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>gather_left</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>gather_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>plan_rows</name></name> <operator>=</operator> <name><name>gather_left</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>*</operator> <name>parallel_workers</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>gather_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>plan_width</name></name> <operator>=</operator> <name><name>gather_left</name><operator>-&gt;</operator><name>plan_width</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>gather_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>gather_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>gather_left</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>subplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><name>gather_plan</name></expr>;</expr_stmt>

                <comment type="block">/* need sort */</comment>
                <if_stmt><if>if <condition>(<expr><name>distributionType</name> <operator>==</operator> <name>LOCATOR_TYPE_NONE</name> <operator>&amp;&amp;</operator> <name>pathkeys</name> <operator>&amp;&amp;</operator> <name>need_sort</name></expr>)</condition>
                <block>{<block_content>
					<expr_stmt><expr><name>subplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><call><name>make_sort_from_pathkeys</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>subplan</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>gather_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>subplan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>gather_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>subplan</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>=</operator> <name><name>gather_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>plan_rows</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>subplan</name><operator>-&gt;</operator><name>plan_width</name></name> <operator>=</operator> <name><name>gather_plan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>plan_width</name></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                
                <if_stmt><if>if <condition>(<expr><name>gather_parent</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>gather_parent</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><name>subplan</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>lefttree</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><name>subplan</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>min_workers_of_hashjon_gather</name> <operator>=</operator> <name>PG_INT32_MAX</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>resultDistribution</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>=</operator> <name><name>resultDistribution</name><operator>-&gt;</operator><name>distributionType</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>distributionKey</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>resultDistribution</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

            <comment type="block">/* XXX Is that correct to reference a column of different type? */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>resultDistribution</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name><name>resultDistribution</name><operator>-&gt;</operator><name>distributionExpr</name></name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>resultDistribution</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="block">/* Find distribution expression in the target list */</comment>
            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>lefttree-&gt;targetlist</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>distributionKey</name></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>

            <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>distributionKey</name></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>newtle</name></decl>;</decl_stmt>

                <comment type="block">/* The expression is not found, need to add junk */</comment>
                <expr_stmt><expr><name>newtle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>expr</name></expr></argument>,
                                         <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                                         <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>is_projection_capable_plan</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Ok to modify subplan's target list */</comment>
                    <expr_stmt><expr><name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>newtle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>Gather</name></expr></argument>)</argument_list></call><operator>&amp;&amp;</operator> <name>g_UseDataPump</name> <operator>&amp;&amp;</operator> <name>olap_optimizer</name> <operator>&amp;&amp;</operator>
						<operator>(</operator><name>distributionType</name> <operator>==</operator> <name>LOCATOR_TYPE_HASH</name> <operator>||</operator> <name>distributionType</name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>leftchild</name> <init>= <expr><name><name>lefttree</name><operator>-&gt;</operator><name>lefttree</name></name></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name>newtle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>expr</name></expr></argument>,
										 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>leftchild</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
									     <argument><expr><name>NULL</name></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					
						<if_stmt><if>if <condition>(<expr><call><name>is_projection_capable_plan</name><argument_list>(<argument><expr><name>leftchild</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>leftchild</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>leftchild</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>newtle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newtlist</name> <init>= <expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>leftchild</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
							<expr_stmt><expr><name>newtlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newtlist</name></expr></argument>, <argument><expr><name>newtle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>leftchild</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_result</name><argument_list>(<argument><expr><name>newtlist</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>leftchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>lefttree</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>leftchild</name></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
					</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Use Result node to calculate expression */</comment>
                    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newtlist</name> <init>= <expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>newtlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newtlist</name></expr></argument>, <argument><expr><name>newtle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>lefttree</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_result</name><argument_list>(<argument><expr><name>newtlist</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lefttree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>distributionKey</name></name> <operator>=</operator> <name><name>newtle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/*
         * The distributionNodes describes result distribution
         */</comment>
        <expr_stmt><expr><name>tmpset</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>resultDistribution</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>distributionNodes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>nodenum</name> <operator>=</operator> <call><name>bms_first_member</name><argument_list>(<argument><expr><name>tmpset</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>distributionNodes</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>distributionNodes</name></name></expr></argument>,
                                                  <argument><expr><name>nodenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>tmpset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * The distributionRestrict defines the set of nodes where results are
         * actually shipped. These are the nodes where upper level step
         * is executed.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>resultDistribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>tmpset</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>resultDistribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>distributionRestrict</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
            <while>while <condition>(<expr><operator>(</operator><name>nodenum</name> <operator>=</operator> <call><name>bms_first_member</name><argument_list>(<argument><expr><name>tmpset</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>distributionRestrict</name></name> <operator>=</operator>
                        <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>distributionRestrict</name></name></expr></argument>, <argument><expr><name>nodenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
            <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>tmpset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>distributionRestrict</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>distributionNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>=</operator> <name>LOCATOR_TYPE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>distributionKey</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>distributionNodes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* determine where subplan will be executed */</comment>
    <if_stmt><if>if <condition>(<expr><name>execDistribution</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>execDistribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>tmpset</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>execDistribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>tmpset</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>execDistribution</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>nodenum</name> <operator>=</operator> <call><name>bms_first_member</name><argument_list>(<argument><expr><name>tmpset</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><name>nodenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>tmpset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>execOnAll</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator>
                <operator>!</operator><call><name>IsLocatorReplicated</name><argument_list>(<argument><expr><name><name>execDistribution</name><operator>-&gt;</operator><name>distributionType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * Prepare single execution of replicated subplan. Choose one node from
         * the execution node list, preferrably the node is also a member of
         * the list of result nodes, so later all node executors contact the
         * same node to get tuples
         */</comment>
        <expr_stmt><expr><name>tmpset</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>resultDistribution</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>resultDistribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>tmpset</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>resultDistribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>tmpset</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>resultDistribution</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/*
         * If result goes on single node execute subplan locally
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>tmpset</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* get one execution node TODO: load balancing */</comment>
            <expr_stmt><expr><name>nodenum</name> <operator>=</operator> <call><name>bms_any_member</name><argument_list>(<argument><expr><name>tmpset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name>nodenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>execOnAll</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>execOnAll</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>tmpset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* We do not need to merge sort if only one node is yielding tuples */</comment>
    <if_stmt><if>if <condition>(<expr><name>pathkeys</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>execOnAll</name></name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>numsortkeys</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>sortOperators</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>collations</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nullsFirst</name></decl>;</decl_stmt>

        <comment type="block">/*
         * We will need at most list_length(pathkeys) sort columns; possibly less
         */</comment>
        <expr_stmt><expr><name>numsortkeys</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sortColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sortOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>collations</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nullsFirst</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>numsortkeys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <macro><name>foreach</name><argument_list>(<argument>i</argument>, <argument>pathkeys</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>pathkey</name> <init>= <expr><operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>pk_datatype</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>            <name>sortop</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * If the pathkey's EquivalenceClass is volatile, then it must
                 * have come from an ORDER BY clause, and we have to match it to
                 * that same targetlist entry.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_sortref</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* can't happen */</comment>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"volatile EquivalenceClass has no sortref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_sortgroupref_tle</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_sortref</name></name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>pk_datatype</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>em_datatype</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * Otherwise, we can sort by any non-constant expression listed in
                 * the pathkey's EquivalenceClass.  For now, we take the first one
                 * that corresponds to an available item in the tlist.    If there
                 * isn't any, use the first one that is an expression in the
                 * input's vars.  (The non-const restriction only matters if the
                 * EC is below_outer_join; but if it isn't, it won't contain
                 * consts anyway, else we'd have discarded the pathkey as
                 * redundant.)
                 *
                 * XXX if we have a choice, is there any way of figuring out which
                 * might be cheapest to execute?  (For example, int4lt is likely
                 * much cheaper to execute than numericlt, but both might appear
                 * in the same equivalence class...)  Not clear that we ever will
                 * have an interesting choice in practice, so it may not matter.
                 */</comment>
                <macro><name>foreach</name><argument_list>(<argument>j</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>em</name><operator>-&gt;</operator><name>em_is_const</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <continue>continue;</continue></block_content></block></if></if_stmt>

                    <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>tlist_member</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>tle</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>pk_datatype</name> <operator>=</operator> <name><name>em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr>;</expr_stmt>
                        <break>break;</break>        <comment type="block">/* found expr already in tlist */</comment>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/*
                     * We can also use it if the pathkey expression is a relabel
                     * of the tlist entry, or vice versa.  This is needed for
                     * binary-compatible cases (cf. make_pathkey_from_sortinfo).
                     * We prefer an exact match, though, so we do the basic search
                     * first.
                     */</comment>
                    <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>tlist_member_ignore_relabel</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>tle</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>pk_datatype</name> <operator>=</operator> <name><name>em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr>;</expr_stmt>
                        <break>break;</break>        <comment type="block">/* found expr already in tlist */</comment>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* No matching tlist item; look for a computable expression */</comment>
                    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>sortexpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                    <macro><name>foreach</name><argument_list>(<argument>j</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>exprvars</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>k</name></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><name><name>em</name><operator>-&gt;</operator><name>em_is_const</name></name></expr>)</condition><block type="pseudo"><block_content>
                            <continue>continue;</continue></block_content></block></if></if_stmt>
                        <expr_stmt><expr><name>sortexpr</name> <operator>=</operator> <name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>exprvars</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sortexpr</name></expr></argument>,
                                                   <argument><expr><name>PVC_INCLUDE_AGGREGATES</name> <operator>|</operator>
                                                   <name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <macro><name>foreach</name><argument_list>(<argument>k</argument>, <argument>exprvars</argument>)</argument_list></macro>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tlist_member_ignore_relabel</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                <break>break;</break></block_content></block></if></if_stmt>
                        </block_content>}</block>
                        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>exprvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>k</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>pk_datatype</name> <operator>=</operator> <name><name>em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr>;</expr_stmt>
                            <break>break;</break>    <comment type="block">/* found usable expression */</comment>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>j</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find pathkey item to sort"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="block">/*
                     * Do we need to insert a Result node?
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_projection_capable_plan</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* copy needed so we don't modify input's tlist below */</comment>
                        <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>lefttree</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_result</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lefttree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/*
                     * Add resjunk entry to input's tlist
                     */</comment>
                    <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>sortexpr</name></expr></argument>,
                                          <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                                          <argument><expr><name>NULL</name></expr></argument>,
                                          <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>    <comment type="block">/* just in case NIL before */</comment>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/*
             * Look up the correct sort operator from the PathKey's slightly
             * abstracted representation.
             */</comment>
            <expr_stmt><expr><name>sortop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>,
                                         <argument><expr><name>pk_datatype</name></expr></argument>,
                                         <argument><expr><name>pk_datatype</name></expr></argument>,
                                         <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* should not happen */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find member %d(%u,%u) of opfamily %u"</literal></expr></argument>,
                     <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name></expr></argument>, <argument><expr><name>pk_datatype</name></expr></argument>, <argument><expr><name>pk_datatype</name></expr></argument>,
                     <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * The column might already be selected as a sort key, if the pathkeys
             * contain duplicate entries.  (This can happen in scenarios where
             * multiple mergejoinable clauses mention the same var, for example.)
             * So enter it only once in the sort arrays.
             */</comment>
            <expr_stmt><expr><name>numsortkeys</name> <operator>=</operator> <call><name>add_sort_column</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>,
                                          <argument><expr><name>sortop</name></expr></argument>,
                                          <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_eclass</name><operator>-&gt;</operator><name>ec_collation</name></name></expr></argument>,
                                          <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr></argument>,
                                          <argument><expr><name>numsortkeys</name></expr></argument>,
                                          <argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name>sortOperators</name></expr></argument>,
                                          <argument><expr><name>collations</name></expr></argument>, <argument><expr><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sort</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SimpleSort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sort</name><operator>-&gt;</operator><name>numCols</name></name> <operator>=</operator> <name>numsortkeys</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sort</name><operator>-&gt;</operator><name>sortColIdx</name></name> <operator>=</operator> <name>sortColIdx</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sort</name><operator>-&gt;</operator><name>sortOperators</name></name> <operator>=</operator> <name>sortOperators</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sort</name><operator>-&gt;</operator><name>sortCollations</name></name> <operator>=</operator> <name>collations</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sort</name><operator>-&gt;</operator><name>nullsFirst</name></name> <operator>=</operator> <name>nullsFirst</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copy_plan_costsize</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>lefttree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>cursor</name></name> <operator>=</operator> <call><name>get_internal_cursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>unique</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* 
      * if gather node is under remotesubplan, parallel workers can send tuples directly
      * without gather motion to speed up the data transfering.
      */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>distributionType</name> <operator>==</operator> <name>LOCATOR_TYPE_HASH</name> <operator>||</operator> <name>distributionType</name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name><operator>)</operator> 
		<operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>Gather</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>g_UseDataPump</name> <operator>&amp;&amp;</operator> <name>olap_optimizer</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>distributionRestrict</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Gather</name> <modifier>*</modifier></type><name>gather_plan</name> <init>= <expr><operator>(</operator><name>Gather</name> <operator>*</operator><operator>)</operator><name>lefttree</name></expr></init></decl>;</decl_stmt>
        
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>parallelWorkerSendTuple</name></name>         <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>gather_plan</name><operator>-&gt;</operator><name>parallelWorker_sendTuple</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>IsA</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>Gather</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>||</operator> <name>child_of_gather</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <name>olap_optimizer</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_safe</name></name>  <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* XCP */</comment>


<function><type><name>ForeignScan</name> <modifier>*</modifier></type>
<name>make_foreignscan</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
                 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
                 <parameter><decl><type><name>Index</name></type> <name>scanrelid</name></decl></parameter>,
                 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_exprs</name></decl></parameter>,
                 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_private</name></decl></parameter>,
                 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_scan_tlist</name></decl></parameter>,
                 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_recheck_quals</name></decl></parameter>,
                 <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>outer_plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ForeignScan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* cost will be filled in by create_foreignscan_plan */</comment>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>outer_plan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>scanrelid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>operation</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>
    <comment type="block">/* fs_server will be filled in by create_foreignscan_plan */</comment>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fs_server</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fdw_exprs</name></name> <operator>=</operator> <name>fdw_exprs</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fdw_private</name></name> <operator>=</operator> <name>fdw_private</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fdw_scan_tlist</name></name> <operator>=</operator> <name>fdw_scan_tlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fdw_recheck_quals</name></name> <operator>=</operator> <name>fdw_recheck_quals</name></expr>;</expr_stmt>
    <comment type="block">/* fs_relids will be filled in by create_foreignscan_plan */</comment>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fs_relids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <comment type="block">/* fsSystemCol will be filled in by create_foreignscan_plan */</comment>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fsSystemCol</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Append</name> <modifier>*</modifier></type>
<name>make_append</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>appendplans</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitioned_rels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Append</name>       <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Append</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>partitioned_rels</name></name> <operator>=</operator> <name>partitioned_rels</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>appendplans</name></name> <operator>=</operator> <name>appendplans</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RecursiveUnion</name> <modifier>*</modifier></type>
<name>make_recursive_union</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                     <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
                     <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
                     <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>righttree</name></decl></parameter>,
                     <parameter><decl><type><name>int</name></type> <name>wtParam</name></decl></parameter>,
                     <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctList</name></decl></parameter>,
                     <parameter><decl><type><name>long</name></type> <name>numGroups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RecursiveUnion</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RecursiveUnion</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numCols</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>distinctList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>righttree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>wtParam</name></name> <operator>=</operator> <name>wtParam</name></expr>;</expr_stmt>

    <comment type="block">/*
     * convert SortGroupClause list into arrays of attr indexes and equality
     * operators, as wanted by executor
     */</comment>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>=</operator> <name>numCols</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>numCols</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>keyno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>dupColIdx</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>dupOperators</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>slitem</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>dupColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dupOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>foreach</name><argument_list>(<argument>slitem</argument>, <argument>distinctList</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>slitem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sortcl</name></expr></argument>,
                                                       <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>dupColIdx</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>dupOperators</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <name><name>sortcl</name><operator>-&gt;</operator><name>eqop</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>dupOperators</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>keyno</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>dupColIdx</name></name> <operator>=</operator> <name>dupColIdx</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>dupOperators</name></name> <operator>=</operator> <name>dupOperators</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <name>numGroups</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BitmapAnd</name> <modifier>*</modifier></type>
<name>make_bitmap_and</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>bitmapplans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BitmapAnd</name>  <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>BitmapAnd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>bitmapplans</name></name> <operator>=</operator> <name>bitmapplans</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>BitmapOr</name> <modifier>*</modifier></type>
<name>make_bitmap_or</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>bitmapplans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BitmapOr</name>   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>BitmapOr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>bitmapplans</name></name> <operator>=</operator> <name>bitmapplans</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>NestLoop</name> <modifier>*</modifier></type>
<name>make_nestloop</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
              <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinclauses</name></decl></parameter>,
              <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>otherclauses</name></decl></parameter>,
              <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nestParams</name></decl></parameter>,
              <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
              <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>righttree</name></decl></parameter>,
              <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
              <parameter><decl><type><name>bool</name></type> <name>inner_unique</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NestLoop</name>   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>NestLoop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>otherclauses</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>righttree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>jointype</name></name> <operator>=</operator> <name>jointype</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>inner_unique</name></name> <operator>=</operator> <name>inner_unique</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>joinqual</name></name> <operator>=</operator> <name>joinclauses</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nestParams</name></name> <operator>=</operator> <name>nestParams</name></expr>;</expr_stmt>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* we prefetch the inner plan data to avoid deadlock */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>contain_remote_subplan_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>lefttree</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>        
        <if_stmt><if>if <condition>(<expr><call><name>contain_remote_subplan_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>righttree</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_inner</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>HashJoin</name> <modifier>*</modifier></type>
<name>make_hashjoin</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
              <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinclauses</name></decl></parameter>,
              <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>otherclauses</name></decl></parameter>,
              <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashclauses</name></decl></parameter>,
              <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
              <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>righttree</name></decl></parameter>,
              <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
              <parameter><decl><type><name>bool</name></type> <name>inner_unique</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HashJoin</name>   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>HashJoin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>otherclauses</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>righttree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hashclauses</name></name> <operator>=</operator> <name>hashclauses</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>jointype</name></name> <operator>=</operator> <name>jointype</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>inner_unique</name></name> <operator>=</operator> <name>inner_unique</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>joinqual</name></name> <operator>=</operator> <name>joinclauses</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* we prefetch the inner plan data to avoid deadlock */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>contain_remote_subplan_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>lefttree</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_inner</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Hash</name> <modifier>*</modifier></type>
<name>make_hash</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
          <parameter><decl><type><name>Oid</name></type> <name>skewTable</name></decl></parameter>,
          <parameter><decl><type><name>AttrNumber</name></type> <name>skewColumn</name></decl></parameter>,
          <parameter><decl><type><name>bool</name></type> <name>skewInherit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Hash</name>       <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>skewTable</name></name> <operator>=</operator> <name>skewTable</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>skewColumn</name></name> <operator>=</operator> <name>skewColumn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>skewInherit</name></name> <operator>=</operator> <name>skewInherit</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>MergeJoin</name> <modifier>*</modifier></type>
<name>make_mergejoin</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
               <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>joinclauses</name></decl></parameter>,
               <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>otherclauses</name></decl></parameter>,
               <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeclauses</name></decl></parameter>,
               <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>mergefamilies</name></decl></parameter>,
               <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>mergecollations</name></decl></parameter>,
               <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>mergestrategies</name></decl></parameter>,
               <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>mergenullsfirst</name></decl></parameter>,
               <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
               <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>righttree</name></decl></parameter>,
               <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
               <parameter><decl><type><name>bool</name></type> <name>inner_unique</name></decl></parameter>,
               <parameter><decl><type><name>bool</name></type> <name>skip_mark_restore</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MergeJoin</name>  <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>MergeJoin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>otherclauses</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>righttree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>skip_mark_restore</name></name> <operator>=</operator> <name>skip_mark_restore</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mergeclauses</name></name> <operator>=</operator> <name>mergeclauses</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mergeFamilies</name></name> <operator>=</operator> <name>mergefamilies</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mergeCollations</name></name> <operator>=</operator> <name>mergecollations</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mergeStrategies</name></name> <operator>=</operator> <name>mergestrategies</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>mergeNullsFirst</name></name> <operator>=</operator> <name>mergenullsfirst</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>jointype</name></name> <operator>=</operator> <name>jointype</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>inner_unique</name></name> <operator>=</operator> <name>inner_unique</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>joinqual</name></name> <operator>=</operator> <name>joinclauses</name></expr>;</expr_stmt>

    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* we prefetch the inner plan data to avoid deadlock */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>contain_remote_subplan_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>lefttree</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>        
        <if_stmt><if>if <condition>(<expr><call><name>contain_remote_subplan_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>righttree</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_inner</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_sort --- basic routine to build a Sort plan node
 *
 * Caller must have built the sortColIdx, sortOperators, collations, and
 * nullsFirst arrays already.
 */</comment>
<function><type><specifier>static</specifier> <name>Sort</name> <modifier>*</modifier></type>
<name>make_sort</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>,
          <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sortOperators</name></decl></parameter>,
          <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collations</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nullsFirst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Sort</name>       <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Sort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>=</operator> <name>numCols</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sortColIdx</name></name> <operator>=</operator> <name>sortColIdx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sortOperators</name></name> <operator>=</operator> <name>sortOperators</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>collations</name></name> <operator>=</operator> <name>collations</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nullsFirst</name></name> <operator>=</operator> <name>nullsFirst</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * add_sort_column --- utility subroutine for building sort info arrays
 *
 * We need this routine because the same column might be selected more than
 * once as a sort key column; if so, the extra mentions are redundant.
 *
 * Caller is assumed to have allocated the arrays large enough for the
 * max possible number of columns.    Return value is the new column count.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_sort_column</name><parameter_list>(<parameter><decl><type><name>AttrNumber</name></type> <name>colIdx</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sortOp</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>coll</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nulls_first</name></decl></parameter>,
                <parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl></parameter>,
                <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sortOperators</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collations</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nullsFirst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>sortOp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numCols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * Note: we check sortOp because it's conceivable that "ORDER BY foo
         * USING &lt;, foo USING &lt;&lt;&lt;" is not redundant, if &lt;&lt;&lt; distinguishes
         * values that &lt; considers equal.  We need not check nulls_first
         * however because a lower-order column with the same sortop but
         * opposite nulls direction is redundant.
         *
         * We could probably consider sort keys with the same sortop and
         * different collations to be redundant too, but for the moment treat
         * them as not redundant.  This will be needed if we ever support
         * collations with different notions of equality.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>sortColIdx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>colIdx</name> <operator>&amp;&amp;</operator>
            <name><name>sortOperators</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>sortOp</name> <operator>&amp;&amp;</operator>
            <name><name>collations</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>coll</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Already sorting by this col, so extra sort key is useless */</comment>
            <return>return <expr><name>numCols</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Add the column */</comment>
    <expr_stmt><expr><name><name>sortColIdx</name><index>[<expr><name>numCols</name></expr>]</index></name> <operator>=</operator> <name>colIdx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sortOperators</name><index>[<expr><name>numCols</name></expr>]</index></name> <operator>=</operator> <name>sortOp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>collations</name><index>[<expr><name>numCols</name></expr>]</index></name> <operator>=</operator> <name>coll</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nullsFirst</name><index>[<expr><name>numCols</name></expr>]</index></name> <operator>=</operator> <name>nulls_first</name></expr>;</expr_stmt>
    <return>return <expr><name>numCols</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * prepare_sort_from_pathkeys
 *      Prepare to sort according to given pathkeys
 *
 * This is used to set up for Sort, MergeAppend, and Gather Merge nodes.  It
 * calculates the executor's representation of the sort key information, and
 * adjusts the plan targetlist if needed to add resjunk sort columns.
 *
 * Input parameters:
 *      'lefttree' is the plan node which yields input tuples
 *      'pathkeys' is the list of pathkeys by which the result is to be sorted
 *      'relids' identifies the child relation being sorted, if any
 *      'reqColIdx' is NULL or an array of required sort key column numbers
 *      'adjust_tlist_in_place' is TRUE if lefttree must be modified in-place
 *
 * We must convert the pathkey information into arrays of sort key column
 * numbers, sort operator OIDs, collation OIDs, and nulls-first flags,
 * which is the representation the executor wants.  These are returned into
 * the output parameters *p_numsortkeys etc.
 *
 * When looking for matches to an EquivalenceClass's members, we will only
 * consider child EC members if they belong to given 'relids'.  This protects
 * against possible incorrect matches to child expressions that contain no
 * Vars.
 *
 * If reqColIdx isn't NULL then it contains sort key column numbers that
 * we should match.  This is used when making child plans for a MergeAppend;
 * it's an error if we can't match the columns.
 *
 * If the pathkeys include expressions that aren't simple Vars, we will
 * usually need to add resjunk items to the input plan's targetlist to
 * compute these expressions, since a Sort or MergeAppend node itself won't
 * do any such calculations.  If the input plan type isn't one that can do
 * projections, this means adding a Result node just to do the projection.
 * However, the caller can pass adjust_tlist_in_place = TRUE to force the
 * lefttree tlist to be modified in-place regardless of whether the node type
 * can project --- we use this for fixing the tlist of MergeAppend itself.
 *
 * Returns the node which is to be the input to the Sort (either lefttree,
 * or a Result stacked atop lefttree).
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>prepare_sort_from_pathkeys</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
                           <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>AttrNumber</name> <modifier>*</modifier></type><name>reqColIdx</name></decl></parameter>,
                           <parameter><decl><type><name>bool</name></type> <name>adjust_tlist_in_place</name></decl></parameter>,
                           <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>p_numsortkeys</name></decl></parameter>,
                           <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_sortColIdx</name></decl></parameter>,
                           <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_sortOperators</name></decl></parameter>,
                           <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_collations</name></decl></parameter>,
                           <parameter><decl><type><name>bool</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_nullsFirst</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numsortkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>sortOperators</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>collations</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nullsFirst</name></decl>;</decl_stmt>

    <comment type="block">/*
     * We will need at most list_length(pathkeys) sort columns; possibly less
     */</comment>
    <expr_stmt><expr><name>numsortkeys</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sortColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sortOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>collations</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nullsFirst</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>numsortkeys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>i</argument>, <argument>pathkeys</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>pathkey</name> <init>= <expr><operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>pk_datatype</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>sortop</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If the pathkey's EquivalenceClass is volatile, then it must
             * have come from an ORDER BY clause, and we have to match it to
             * that same targetlist entry.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_sortref</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* can't happen */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"volatile EquivalenceClass has no sortref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_sortgroupref_tle</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_sortref</name></name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pk_datatype</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>em_datatype</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>reqColIdx</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If we are given a sort column number to match, only consider
             * the single TLE at that position.  It's possible that there is
             * no such TLE, in which case fall through and generate a resjunk
             * targetentry (we assume this must have happened in the parent
             * plan as well).  If there is a TLE but it doesn't match the
             * pathkey's EC, we do the same, which is probably the wrong thing
             * but we'll leave it to caller to complain about the mismatch.
             */</comment>
            <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name><name>reqColIdx</name><index>[<expr><name>numsortkeys</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>tle</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>em</name> <operator>=</operator> <call><name>find_ec_member_for_tle</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>em</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* found expr at right place in tlist */</comment>
                    <expr_stmt><expr><name>pk_datatype</name> <operator>=</operator> <name><name>em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>tle</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * Otherwise, we can sort by any non-constant expression listed in
             * the pathkey's EquivalenceClass.  For now, we take the first
             * tlist item found in the EC. If there's no match, we'll generate
             * a resjunk entry using the first EC member that is an expression
             * in the input's vars.  (The non-const restriction only matters
             * if the EC is below_outer_join; but if it isn't, it won't
             * contain consts anyway, else we'd have discarded the pathkey as
             * redundant.)
             *
             * XXX if we have a choice, is there any way of figuring out which
             * might be cheapest to execute?  (For example, int4lt is likely
             * much cheaper to execute than numericlt, but both might appear
             * in the same equivalence class...)  Not clear that we ever will
             * have an interesting choice in practice, so it may not matter.
             */</comment>
            <macro><name>foreach</name><argument_list>(<argument>j</argument>, <argument>tlist</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>tle</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>em</name> <operator>=</operator> <call><name>find_ec_member_for_tle</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>em</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* found expr already in tlist */</comment>
                    <expr_stmt><expr><name>pk_datatype</name> <operator>=</operator> <name><name>em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>tle</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * No matching tlist item; look for a computable expression. Note
             * that we treat Aggrefs as if they were variables; this is
             * necessary when attempting to sort the output from an Agg node
             * for use in a WindowFunc (since grouping_planner will have
             * treated the Aggrefs as variables, too).  Likewise, if we find a
             * WindowFunc in a sort expression, treat it as a variable.
             */</comment>
            <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>sortexpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <macro><name>foreach</name><argument_list>(<argument>j</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>exprvars</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>k</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * We shouldn't be trying to sort by an equivalence class that
                 * contains a constant, so no need to consider such cases any
                 * further.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>em</name><operator>-&gt;</operator><name>em_is_const</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <comment type="block">/*
				 * Ignore child members unless they belong to the rel being
                 * sorted.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>em</name><operator>-&gt;</operator><name>em_is_child</name></name> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>sortexpr</name> <operator>=</operator> <name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>exprvars</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sortexpr</name></expr></argument>,
                                           <argument><expr><name>PVC_INCLUDE_AGGREGATES</name> <operator>|</operator>
                                           <name>PVC_INCLUDE_WINDOWFUNCS</name> <operator>|</operator>
                                           <name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <macro><name>foreach</name><argument_list>(<argument>k</argument>, <argument>exprvars</argument>)</argument_list></macro>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tlist_member_ignore_relabel</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                </block_content>}</block>
                <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>exprvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>k</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>pk_datatype</name> <operator>=</operator> <name><name>em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr>;</expr_stmt>
                    <break>break;</break>        <comment type="block">/* found usable expression */</comment>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>j</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find pathkey item to sort"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Do we need to insert a Result node?
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>adjust_tlist_in_place</name> <operator>&amp;&amp;</operator>
                <operator>!</operator><call><name>is_projection_capable_plan</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* copy needed so we don't modify input's tlist below */</comment>
                <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>lefttree</name> <operator>=</operator> <call><name>inject_projection_plan</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>,
                                                  <argument><expr><name><name>lefttree</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Don't bother testing is_projection_capable_plan again */</comment>
            <expr_stmt><expr><name>adjust_tlist_in_place</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <comment type="block">/*
             * Add resjunk entry to input's tlist
             */</comment>
            <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>sortexpr</name></expr></argument>,
                                  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                                  <argument><expr><name>NULL</name></expr></argument>,
                                  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>    <comment type="block">/* just in case NIL before */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
            <comment type="block">/*
             * RemoteSubplan is conditionally projection capable - it is
             * pushing projection to the data nodes
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>RemoteSubplan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>lefttree</name><operator>-&gt;</operator><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Look up the correct sort operator from the PathKey's slightly
         * abstracted representation.
         */</comment>
        <expr_stmt><expr><name>sortop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>,
                                     <argument><expr><name>pk_datatype</name></expr></argument>,
                                     <argument><expr><name>pk_datatype</name></expr></argument>,
                                     <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* should not happen */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing operator %d(%u,%u) in opfamily %u"</literal></expr></argument>,
                 <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_strategy</name></name></expr></argument>, <argument><expr><name>pk_datatype</name></expr></argument>, <argument><expr><name>pk_datatype</name></expr></argument>,
                 <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Add the column to the sort arrays */</comment>
        <expr_stmt><expr><name><name>sortColIdx</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sortOperators</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name>sortop</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>collations</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>ec_collation</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nullsFirst</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name><name>pathkey</name><operator>-&gt;</operator><name>pk_nulls_first</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>numsortkeys</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Return results */</comment>
    <expr_stmt><expr><operator>*</operator><name>p_numsortkeys</name> <operator>=</operator> <name>numsortkeys</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>p_sortColIdx</name> <operator>=</operator> <name>sortColIdx</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>p_sortOperators</name> <operator>=</operator> <name>sortOperators</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>p_collations</name> <operator>=</operator> <name>collations</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>p_nullsFirst</name> <operator>=</operator> <name>nullsFirst</name></expr>;</expr_stmt>

    <return>return <expr><name>lefttree</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_ec_member_for_tle
 *        Locate an EquivalenceClass member matching the given TLE, if any
 *
 * Child EC members are ignored unless they belong to given 'relids'.
 */</comment>
<function><type><specifier>static</specifier> <name>EquivalenceMember</name> <modifier>*</modifier></type>
<name>find_ec_member_for_tle</name><parameter_list>(<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>,
                       <parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl></parameter>,
                       <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>tlexpr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* We ignore binary-compatible relabeling on both ends */</comment>
    <expr_stmt><expr><name>tlexpr</name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>tlexpr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>tlexpr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>tlexpr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>tlexpr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>emexpr</name></decl>;</decl_stmt>

        <comment type="block">/*
         * We shouldn't be trying to sort by an equivalence class that
         * contains a constant, so no need to consider such cases any further.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>em</name><operator>-&gt;</operator><name>em_is_const</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
		 * Ignore child members unless they belong to the rel being sorted.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>em</name><operator>-&gt;</operator><name>em_is_child</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Match if same expression (after stripping relabel) */</comment>
        <expr_stmt><expr><name>emexpr</name> <operator>=</operator> <name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>emexpr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>emexpr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>emexpr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>emexpr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

        <if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>emexpr</name></expr></argument>, <argument><expr><name>tlexpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>em</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_sort_from_pathkeys
 *      Create sort plan to sort according to given pathkeys
 *
 *      'lefttree' is the node which yields input tuples
 *      'pathkeys' is the list of pathkeys by which the result is to be sorted
 *	  'relids' is the set of relations required by prepare_sort_from_pathkeys()
 */</comment>
<function><type><specifier>static</specifier> <name>Sort</name> <modifier>*</modifier></type>
<name>make_sort_from_pathkeys</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>numsortkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>sortOperators</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>collations</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nullsFirst</name></decl>;</decl_stmt>

    <comment type="block">/* Compute sort column info, and adjust lefttree as needed */</comment>
    <expr_stmt><expr><name>lefttree</name> <operator>=</operator> <call><name>prepare_sort_from_pathkeys</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>,
										  <argument><expr><name>relids</name></expr></argument>,
                                          <argument><expr><name>NULL</name></expr></argument>,
                                          <argument><expr><name>false</name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name>numsortkeys</name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name>sortColIdx</name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name>sortOperators</name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name>collations</name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now build the Sort node */</comment>
    <return>return <expr><call><name>make_sort</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>numsortkeys</name></expr></argument>,
                     <argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name>sortOperators</name></expr></argument>,
                     <argument><expr><name>collations</name></expr></argument>, <argument><expr><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_sort_from_sortclauses
 *      Create sort plan to sort according to given sortclauses
 *
 *      'sortcls' is a list of SortGroupClauses
 *      'lefttree' is the node which yields input tuples
 */</comment>
<function><type><name>Sort</name> <modifier>*</modifier></type>
<name>make_sort_from_sortclauses</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortcls</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>sub_tlist</name> <init>= <expr><name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numsortkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>sortOperators</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>collations</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nullsFirst</name></decl>;</decl_stmt>

    <comment type="block">/* Convert list-ish representation to arrays wanted by executor */</comment>
    <expr_stmt><expr><name>numsortkeys</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>sortcls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sortColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sortOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>collations</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nullsFirst</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>numsortkeys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>sortcls</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sortcl</name></expr></argument>, <argument><expr><name>sub_tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>sortColIdx</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sortOperators</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name><name>sortcl</name><operator>-&gt;</operator><name>sortop</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>collations</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nullsFirst</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name><name>sortcl</name><operator>-&gt;</operator><name>nulls_first</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>numsortkeys</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><call><name>make_sort</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>numsortkeys</name></expr></argument>,
                     <argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name>sortOperators</name></expr></argument>,
                     <argument><expr><name>collations</name></expr></argument>, <argument><expr><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_sort_from_groupcols
 *      Create sort plan to sort based on grouping columns
 *
 * 'groupcls' is the list of SortGroupClauses
 * 'grpColIdx' gives the column numbers to use
 *
 * This might look like it could be merged with make_sort_from_sortclauses,
 * but presently we *must* use the grpColIdx[] array to locate sort columns,
 * because the child plan's tlist is not marked with ressortgroupref info
 * appropriate to the grouping node.  So, only the sort ordering info
 * is used from the SortGroupClause entries.
 */</comment>
<function><type><specifier>static</specifier> <name>Sort</name> <modifier>*</modifier></type>
<name>make_sort_from_groupcols</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupcls</name></decl></parameter>,
                         <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>grpColIdx</name></decl></parameter>,
                         <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>sub_tlist</name> <init>= <expr><name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numsortkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>sortOperators</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>collations</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nullsFirst</name></decl>;</decl_stmt>

    <comment type="block">/* Convert list-ish representation to arrays wanted by executor */</comment>
    <expr_stmt><expr><name>numsortkeys</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>groupcls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sortColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sortOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>collations</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nullsFirst</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numsortkeys</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>numsortkeys</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>groupcls</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grpcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name>sub_tlist</name></expr></argument>, <argument><expr><name><name>grpColIdx</name><index>[<expr><name>numsortkeys</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not retrieve tle for sort-from-groupcols"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>sortColIdx</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sortOperators</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name><name>grpcl</name><operator>-&gt;</operator><name>sortop</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>collations</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nullsFirst</name><index>[<expr><name>numsortkeys</name></expr>]</index></name> <operator>=</operator> <name><name>grpcl</name><operator>-&gt;</operator><name>nulls_first</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>numsortkeys</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><call><name>make_sort</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>numsortkeys</name></expr></argument>,
                     <argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name>sortOperators</name></expr></argument>,
                     <argument><expr><name>collations</name></expr></argument>, <argument><expr><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Material</name> <modifier>*</modifier></type>
<name>make_material</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Material</name>   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Material</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * materialize_finished_plan: stick a Material node atop a completed plan
 *
 * There are a couple of places where we want to attach a Material node
 * after completion of create_plan(), without any MaterialPath path.
 * Those places should probably be refactored someday to do this on the
 * Path representation, but it's not worth the trouble yet.
 */</comment>
<function><type><name>Plan</name> <modifier>*</modifier></type>
<name>materialize_finished_plan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>matplan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Path</name></type>        <name>matpath</name></decl>;</decl_stmt>        <comment type="block">/* dummy for result of cost_material */</comment>

    <expr_stmt><expr><name>matplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_material</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * XXX horrid kluge: if there are any initPlans attached to the subplan,
     * move them up to the Material node, which is now effectively the top
     * plan node in its query level.  This prevents failure in
     * SS_finalize_plan(), which see for comments.  We don't bother adjusting
     * the subplan's cost estimate for this.
     */</comment>
    <expr_stmt><expr><name><name>matplan</name><operator>-&gt;</operator><name>initPlan</name></name> <operator>=</operator> <name><name>subplan</name><operator>-&gt;</operator><name>initPlan</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>subplan</name><operator>-&gt;</operator><name>initPlan</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <comment type="block">/* Set cost data */</comment>
    <expr_stmt><expr><call><name>cost_material</name><argument_list>(<argument><expr><operator>&amp;</operator><name>matpath</name></expr></argument>,
                  <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>,
                  <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
                  <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr></argument>,
                  <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>plan_width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>matplan</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>matpath</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>matplan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>=</operator> <name><name>matpath</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>matplan</name><operator>-&gt;</operator><name>plan_rows</name></name> <operator>=</operator> <name><name>subplan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>matplan</name><operator>-&gt;</operator><name>plan_width</name></name> <operator>=</operator> <name><name>subplan</name><operator>-&gt;</operator><name>plan_width</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>matplan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>matplan</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>subplan</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>

    <return>return <expr><name>matplan</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Agg</name> <modifier>*</modifier></type>
<name>make_agg</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>,
         <parameter><decl><type><name>AggStrategy</name></type> <name>aggstrategy</name></decl></parameter>, <parameter><decl><type><name>AggSplit</name></type> <name>aggsplit</name></decl></parameter>,
         <parameter><decl><type><name>int</name></type> <name>numGroupCols</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>grpColIdx</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>grpOperators</name></decl></parameter>,
         <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupingSets</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>chain</name></decl></parameter>,
         <parameter><decl><type><name>double</name></type> <name>dNumGroups</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Agg</name>           <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Agg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>numGroups</name></decl>;</decl_stmt>

    <comment type="block">/* Reduce to long, but 'ware overflow! */</comment>
    <expr_stmt><expr><name>numGroups</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator> <call><name>Min</name><argument_list>(<argument><expr><name>dNumGroups</name></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>LONG_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>=</operator> <name>aggstrategy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>aggsplit</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>=</operator> <name>numGroupCols</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>grpColIdx</name></name> <operator>=</operator> <name>grpColIdx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>grpOperators</name></name> <operator>=</operator> <name>grpOperators</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <name>numGroups</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>aggParams</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>        <comment type="block">/* SS_finalize_plan() will fill this */</comment>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>=</operator> <name>groupingSets</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>chain</name></name> <operator>=</operator> <name>chain</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>hybrid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>entrySize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>noDistinct</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qual</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>WindowAgg</name> <modifier>*</modifier></type>
<name>make_windowagg</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>winref</name></decl></parameter>,
               <parameter><decl><type><name>int</name></type> <name>partNumCols</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>partColIdx</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partOperators</name></decl></parameter>,
               <parameter><decl><type><name>int</name></type> <name>ordNumCols</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>ordColIdx</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>ordOperators</name></decl></parameter>,
               <parameter><decl><type><name>int</name></type> <name>frameOptions</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>startOffset</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>endOffset</name></decl></parameter>,
               <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>WindowAgg</name>  <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>WindowAgg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>winref</name></name> <operator>=</operator> <name>winref</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>partNumCols</name></name> <operator>=</operator> <name>partNumCols</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>partColIdx</name></name> <operator>=</operator> <name>partColIdx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>partOperators</name></name> <operator>=</operator> <name>partOperators</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ordNumCols</name></name> <operator>=</operator> <name>ordNumCols</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ordColIdx</name></name> <operator>=</operator> <name>ordColIdx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ordOperators</name></name> <operator>=</operator> <name>ordOperators</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>frameOptions</name></name> <operator>=</operator> <name>frameOptions</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>startOffset</name></name> <operator>=</operator> <name>startOffset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>endOffset</name></name> <operator>=</operator> <name>endOffset</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <comment type="block">/* WindowAgg nodes never have a qual clause */</comment>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Group</name> <modifier>*</modifier></type>
<name>make_group</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
           <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>,
           <parameter><decl><type><name>int</name></type> <name>numGroupCols</name></decl></parameter>,
           <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>grpColIdx</name></decl></parameter>,
           <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>grpOperators</name></decl></parameter>,
           <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Group</name>       <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Group</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>=</operator> <name>numGroupCols</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>grpColIdx</name></name> <operator>=</operator> <name>grpColIdx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>grpOperators</name></name> <operator>=</operator> <name>grpOperators</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qual</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * distinctList is a list of SortGroupClauses, identifying the targetlist items
 * that should be considered by the Unique filter.  The input path must
 * already be sorted accordingly.
 */</comment>
<function><type><specifier>static</specifier> <name>Unique</name> <modifier>*</modifier></type>
<name>make_unique_from_sortclauses</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Unique</name>       <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Unique</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numCols</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>distinctList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>keyno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>uniqColIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>uniqOperators</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>slitem</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <decl_stmt><decl><type><name>RemoteSubplan</name> <modifier>*</modifier></type><name>pushdown</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * convert SortGroupClause list into arrays of attr indexes and equality
     * operators, as wanted by executor
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numCols</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>uniqColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>uniqOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>slitem</argument>, <argument>distinctList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>slitem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sortcl</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>uniqColIdx</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>uniqOperators</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <name><name>sortcl</name><operator>-&gt;</operator><name>eqop</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>uniqOperators</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>keyno</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>=</operator> <name>numCols</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>uniqColIdx</name></name> <operator>=</operator> <name>uniqColIdx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>uniqOperators</name></name> <operator>=</operator> <name>uniqOperators</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <comment type="block">/*
     * We want to filter out duplicates on nodes to reduce amount of data sent
     * over network and reduce coordinator load.
     */</comment>
    <expr_stmt><expr><name>pushdown</name> <operator>=</operator> <call><name>find_push_down_plan</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>pushdown</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Unique</name>       <modifier>*</modifier></type><name>node1</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Unique</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan1</name> <init>= <expr><operator>&amp;</operator><name><name>node1</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>copy_plan_costsize</name><argument_list>(<argument><expr><name>plan1</name></expr></argument>, <argument><expr><name><name>pushdown</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan1</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name><name>pushdown</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan1</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan1</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name><name>pushdown</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>lefttree</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pushdown</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>lefttree</name></name> <operator>=</operator> <name>plan1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>plan1</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>node1</name><operator>-&gt;</operator><name>numCols</name></name> <operator>=</operator> <name>numCols</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node1</name><operator>-&gt;</operator><name>uniqColIdx</name></name> <operator>=</operator> <name>uniqColIdx</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node1</name><operator>-&gt;</operator><name>uniqOperators</name></name> <operator>=</operator> <name>uniqOperators</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * as above, but use pathkeys to identify the sort columns and semantics
 */</comment>
<function><type><specifier>static</specifier> <name>Unique</name> <modifier>*</modifier></type>
<name>make_unique_from_pathkeys</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Unique</name>       <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Unique</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>keyno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>uniqColIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>uniqOperators</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Convert pathkeys list into arrays of attr indexes and equality
     * operators, as wanted by executor.  This has a lot in common with
     * prepare_sort_from_pathkeys ... maybe unify sometime?
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numCols</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>numCols</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>uniqColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>uniqOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pathkeys</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PathKey</name>    <modifier>*</modifier></type><name>pathkey</name> <init>= <expr><operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>pk_datatype</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>eqop</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>

        <comment type="block">/* Ignore pathkeys beyond the specified number of columns */</comment>
        <if_stmt><if>if <condition>(<expr><name>keyno</name> <operator>&gt;=</operator> <name>numCols</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_has_volatile</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If the pathkey's EquivalenceClass is volatile, then it must
             * have come from an ORDER BY clause, and we have to match it to
             * that same targetlist entry.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_sortref</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* can't happen */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"volatile EquivalenceClass has no sortref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>get_sortgroupref_tle</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_sortref</name></name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pk_datatype</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>ec</name><operator>-&gt;</operator><name>ec_members</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>em_datatype</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * Otherwise, we can use any non-constant expression listed in the
             * pathkey's EquivalenceClass.  For now, we take the first tlist
             * item found in the EC.
             */</comment>
            <macro><name>foreach</name><argument_list>(<argument>j</argument>, <argument>plan-&gt;targetlist</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>tle</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>em</name> <operator>=</operator> <call><name>find_ec_member_for_tle</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>em</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* found expr already in tlist */</comment>
                    <expr_stmt><expr><name>pk_datatype</name> <operator>=</operator> <name><name>em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>tle</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find pathkey item to sort"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Look up the correct equality operator from the PathKey's slightly
         * abstracted representation.
         */</comment>
        <expr_stmt><expr><name>eqop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>,
                                   <argument><expr><name>pk_datatype</name></expr></argument>,
                                   <argument><expr><name>pk_datatype</name></expr></argument>,
                                   <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>eqop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* should not happen */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing operator %d(%u,%u) in opfamily %u"</literal></expr></argument>,
                 <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>pk_datatype</name></expr></argument>, <argument><expr><name>pk_datatype</name></expr></argument>,
                 <argument><expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_opfamily</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>uniqColIdx</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>uniqOperators</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <name>eqop</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>keyno</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>=</operator> <name>numCols</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>uniqColIdx</name></name> <operator>=</operator> <name>uniqColIdx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>uniqOperators</name></name> <operator>=</operator> <name>uniqOperators</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Gather</name> <modifier>*</modifier></type>
<name>make_gather</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qptlist</name></decl></parameter>,
            <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qpqual</name></decl></parameter>,
            <parameter><decl><type><name>int</name></type> <name>nworkers</name></decl></parameter>,
            <parameter><decl><type><name>bool</name></type> <name>single_copy</name></decl></parameter>,
            <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Gather</name>       <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Gather</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>qptlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qpqual</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>subplan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>=</operator> <name>nworkers</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>single_copy</name></name> <operator>=</operator> <name>single_copy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>invisible</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<comment type="block">/*
	 * if there has hashjoin in the lower layer, write down the smallest workers
	 */</comment>
    <if_stmt><if>if <condition>(<expr><name>min_workers_of_hashjon_gather</name> <operator>&gt;</operator> <name>nworkers</name> <operator>&amp;&amp;</operator> <call><name>contain_node_walker</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>T_HashJoin</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>min_workers_of_hashjon_gather</name> <operator>=</operator> <name>nworkers</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * distinctList is a list of SortGroupClauses, identifying the targetlist
 * items that should be considered by the SetOp filter.  The input path must
 * already be sorted accordingly.
 */</comment>
<function><type><specifier>static</specifier> <name>SetOp</name> <modifier>*</modifier></type>
<name>make_setop</name><parameter_list>(<parameter><decl><type><name>SetOpCmd</name></type> <name>cmd</name></decl></parameter>, <parameter><decl><type><name>SetOpStrategy</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
           <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctList</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>flagColIdx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>firstFlag</name></decl></parameter>,
           <parameter><decl><type><name>long</name></type> <name>numGroups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SetOp</name>       <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SetOp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numCols</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>distinctList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>keyno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>dupColIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>dupOperators</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>slitem</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * convert SortGroupClause list into arrays of attr indexes and equality
     * operators, as wanted by executor
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numCols</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dupColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dupOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>slitem</argument>, <argument>distinctList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>slitem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sortcl</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>dupColIdx</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dupOperators</name><index>[<expr><name>keyno</name></expr>]</index></name> <operator>=</operator> <name><name>sortcl</name><operator>-&gt;</operator><name>eqop</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>dupOperators</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>keyno</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>cmd</name></name> <operator>=</operator> <name>cmd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>strategy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name> <operator>=</operator> <name>numCols</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>dupColIdx</name></name> <operator>=</operator> <name>dupColIdx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>dupOperators</name></name> <operator>=</operator> <name>dupOperators</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>flagColIdx</name></name> <operator>=</operator> <name>flagColIdx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>firstFlag</name></name> <operator>=</operator> <name>firstFlag</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <name>numGroups</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_lockrows
 *      Build a LockRows plan node
 */</comment>
<function><type><specifier>static</specifier> <name>LockRows</name> <modifier>*</modifier></type>
<name>make_lockrows</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rowMarks</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>epqParam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LockRows</name>   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>LockRows</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <name>rowMarks</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>epqParam</name></name> <operator>=</operator> <name>epqParam</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_limit
 *      Build a Limit plan node
 */</comment>
<function><type><name>Limit</name> <modifier>*</modifier></type>
<name>make_limit</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>limitOffset</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>limitCount</name></decl></parameter>,
		   <parameter><decl><type><name>int64</name></type> <name>offset_est</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>count_est</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipEarlyFinish</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Limit</name>       <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Limit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>lefttree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <name>limitOffset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <name>limitCount</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>skipEarlyFinish</name></name> <operator>=</operator> <name>skipEarlyFinish</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_result
 *      Build a Result plan node
 */</comment>
<function><type><specifier>static</specifier> <name>Result</name> <modifier>*</modifier></type>
<name>make_result</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
            <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>resconstantqual</name></decl></parameter>,
            <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Result</name>       <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>subplan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>resconstantqual</name></name> <operator>=</operator> <name>resconstantqual</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>subplan</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We do not gain performance when pushing down Result, but Result on
         * top of RemoteSubplan would not allow to push down other plan nodes
         */</comment>
        <decl_stmt><decl><type><name>RemoteSubplan</name> <modifier>*</modifier></type><name>pushdown</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>pushdown</name> <operator>=</operator> <call><name>find_push_down_plan</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>pushdown</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Avoid pushing down results if the RemoteSubplan performs merge
             * sort.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>pushdown</name><operator>-&gt;</operator><name>sort</name></name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>

            <comment type="block">/*
             * If remote subplan is generating distribution we should keep it
             * correct. Set valid expression as a distribution key.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>pushdown</name><operator>-&gt;</operator><name>distributionKey</name></name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name>       <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>TargetEntry</name>    <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>pushdown</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                               <argument><expr><name><name>pushdown</name><operator>-&gt;</operator><name>distributionKey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pushdown</name><operator>-&gt;</operator><name>distributionKey</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tlist</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>TargetEntry</name>    <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name><name>key</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>pushdown</name><operator>-&gt;</operator><name>distributionKey</name></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block>

                <if_stmt><if>if <condition>(<expr><name><name>pushdown</name><operator>-&gt;</operator><name>distributionKey</name></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Not found, adding */</comment>
                    <decl_stmt><decl><type><name>TargetEntry</name>    <modifier>*</modifier></type><name>newtle</name></decl>;</decl_stmt>
                    <comment type="block">/*
                     * The target entry is *NOT* junk to ensure it is not
                     * filtered out before sending from the data node.
                     */</comment>
                    <expr_stmt><expr><name>newtle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                                             <argument><expr><name><name>key</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>,
                                             <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>newtle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* just in case if it was NIL */</comment>
                    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pushdown</name><operator>-&gt;</operator><name>distributionKey</name></name> <operator>=</operator> <name><name>newtle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* This will be set as lefttree of the Result plan */</comment>
            <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name><name>pushdown</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>lefttree</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pushdown</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>lefttree</name></name> <operator>=</operator> <name>plan</name></expr>;</expr_stmt>
            <comment type="block">/* Now RemoteSubplan returns different values */</comment>
            <expr_stmt><expr><name><name>pushdown</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
            <return>return <expr><operator>(</operator><name>Result</name> <operator>*</operator><operator>)</operator> <name>subplan</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* XCP */</comment>
    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_project_set
 *      Build a ProjectSet plan node
 */</comment>
<function><type><specifier>static</specifier> <name>ProjectSet</name> <modifier>*</modifier></type>
<name>make_project_set</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
                 <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ProjectSet</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ProjectSet</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>       <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <name>subplan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_modifytable
 *      Build a ModifyTable plan node
 */</comment>
<function><type><specifier>static</specifier> <name>ModifyTable</name> <modifier>*</modifier></type>
<name>make_modifytable</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                 <parameter><decl><type><name>CmdType</name></type> <name>operation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>,
                 <parameter><decl><type><name>Index</name></type> <name>nominalRelation</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitioned_rels</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>partColsUpdated</name></decl></parameter>,
                 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>resultRelations</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subplans</name></decl></parameter>,
                 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>withCheckOptionLists</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningLists</name></decl></parameter>,
                 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rowMarks</name></decl></parameter>, <parameter><decl><type><name>OnConflictExpr</name> <modifier>*</modifier></type><name>onconflict</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>epqParam</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ModifyTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>fdw_private_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>direct_modify_plans</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type>         <name>partoffset</name></decl>;</decl_stmt>         
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>withCheckOptionLists</name> <operator>==</operator> <name>NIL</name> <operator>||</operator>
           <call><name>list_length</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>withCheckOptionLists</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>returningLists</name> <operator>==</operator> <name>NIL</name> <operator>||</operator>
           <call><name>list_length</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>returningLists</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>righttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <comment type="block">/* setrefs.c will fill in the targetlist, if needed */</comment>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>operation</name></name> <operator>=</operator> <name>operation</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>canSetTag</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nominalRelation</name></name> <operator>=</operator> <name>nominalRelation</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>partitioned_rels</name></name> <operator>=</operator> <name>partitioned_rels</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>partColsUpdated</name></name> <operator>=</operator> <name>partColsUpdated</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>resultRelations</name></name> <operator>=</operator> <name>resultRelations</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>resultRelIndex</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* will be set correctly in setrefs.c */</comment>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>rootResultRelIndex</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* will be set correctly in setrefs.c */</comment>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>plans</name></name> <operator>=</operator> <name>subplans</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>onconflict</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>=</operator> <name>ONCONFLICT_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>onConflictSet</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>onConflictWhere</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>arbiterIndexes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>exclRelRTI</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>exclRelTlist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>=</operator> <name><name>onconflict</name><operator>-&gt;</operator><name>action</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>onConflictSet</name></name> <operator>=</operator> <name><name>onconflict</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>onConflictWhere</name></name> <operator>=</operator> <name><name>onconflict</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * If a set of unique index inference elements was provided (an
         * INSERT...ON CONFLICT "inference specification"), then infer
         * appropriate unique indexes (or throw an error if none are
         * available).
         */</comment>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>arbiterIndexes</name></name> <operator>=</operator> <call><name>infer_arbiter_indexes</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>exclRelRTI</name></name> <operator>=</operator> <name><name>onconflict</name><operator>-&gt;</operator><name>exclRelIndex</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>exclRelTlist</name></name> <operator>=</operator> <name><name>onconflict</name><operator>-&gt;</operator><name>exclRelTlist</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>withCheckOptionLists</name></name> <operator>=</operator> <name>withCheckOptionLists</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>returningLists</name></name> <operator>=</operator> <name>returningLists</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <name>rowMarks</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>epqParam</name></name> <operator>=</operator> <name>epqParam</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>haspartparent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>parentplanidx</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>partplans</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>partpruning</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>partrelidx</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>partoffset</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * For each result relation that is a foreign table, allow the FDW to
     * construct private plan data, and accumulate it all into a list.
     */</comment>
    <expr_stmt><expr><name>fdw_private_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>direct_modify_plans</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>resultRelations</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Index</name></type>        <name>rti</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>fdw_private</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>direct_modify</name></decl>;</decl_stmt>

        <comment type="block">/*
         * If possible, we want to get the FdwRoutine from our RelOptInfo for
         * the table.  But sometimes we don't have a RelOptInfo and must get
         * it the hard way.  (In INSERT, the target relation is not scanned,
         * so it's not a baserel; and there are also corner cases for
         * updatable views where the target rel isn't a baserel.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>rti</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name> <operator>&amp;&amp;</operator>
            <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>resultRel</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>rti</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>fdwroutine</name> <operator>=</operator> <name><name>resultRel</name><operator>-&gt;</operator><name>fdwroutine</name></name></expr>;</expr_stmt>
            
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <comment type="block">/* for update or delete */</comment>
            <if_stmt><if>if<condition>(<expr><name><name>resultRel</name><operator>-&gt;</operator><name>intervalparent</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parent_root</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"ModifyTable: subquery cannot INSERT/UPDATE/DELETE on interval partition table."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                
                <if_stmt><if>if<condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>haspartparent</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"ModifyTable: a sql statement must have one partitioned result relation at most."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>haspartparent</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>partrelidx</name></name> <operator>=</operator> <name>rti</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>partpruning</name></name> <operator>=</operator> <name><name>resultRel</name><operator>-&gt;</operator><name>childs</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>partoffset</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>rti</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>fdwroutine</name> <operator>=</operator> <call><name>GetFdwRoutineByRelId</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>fdwroutine</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <comment type="block">/* for insert */</comment>
            <if_stmt><if>if<condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Relation</name></type> <name>tempresultrel</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>AttrNumber</name></type> <name>partkey</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>tempresultrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if<condition>(<expr><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>tempresultrel</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parent_root</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"ModifyTable: subquery cannot INSERT/UPDATE/DELETE on interval partition table."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <if_stmt><if>if<condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>haspartparent</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"ModifyTable: a sql statement must have one partitioned result relation at most."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><name>partoffset</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>haspartparent</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>partrelidx</name></name> <operator>=</operator> <name>rti</name></expr>;</expr_stmt>
                    <comment type="block">/* pruning */</comment>
                    <if_stmt><if>if<condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_INSERT</name> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>isSingleValues</name></name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type> <name>targetentry</name></decl>;</decl_stmt>
                        
                        <expr_stmt><expr><name>partkey</name> <operator>=</operator> <call><name>RelationGetPartitionColumnIndex</name><argument_list>(<argument><expr><name>tempresultrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>targetentry</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,<argument><expr><name>partkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if<condition>(<expr><operator>!</operator><name>targetentry</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>targetentry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,<argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"the row inserted to partitioned table must have const value in partition key."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        
                        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>partpruning</name></name> <operator>=</operator> <call><name>RelationGetPartitionByValue</name><argument_list>(<argument><expr><name>tempresultrel</name></expr></argument>,<argument><expr><operator>(</operator><name>Const</name><operator>*</operator><operator>)</operator><name><name>targetentry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>partpruning</name></name> <operator>=</operator> <call><name>RelationGetPartitionsByQuals</name><argument_list>(<argument><expr><name>tempresultrel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>

                    <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>partpruning</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"value to inserted execeed range of partitioned table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                
                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>tempresultrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * Try to modify the foreign table directly if (1) the FDW provides
         * callback functions needed for that, (2) there are no row-level
         * triggers on the foreign table, and (3) there are no WITH CHECK
         * OPTIONs from parent views.
         */</comment>
        <expr_stmt><expr><name>direct_modify</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>fdwroutine</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
            <name><name>fdwroutine</name><operator>-&gt;</operator><name>PlanDirectModify</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
            <name><name>fdwroutine</name><operator>-&gt;</operator><name>BeginDirectModify</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
            <name><name>fdwroutine</name><operator>-&gt;</operator><name>IterateDirectModify</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
            <name><name>fdwroutine</name><operator>-&gt;</operator><name>EndDirectModify</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
            <name>withCheckOptionLists</name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name>has_row_triggers</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>operation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>direct_modify</name> <operator>=</operator> <call><name><name>fdwroutine</name><operator>-&gt;</operator><name>PlanDirectModify</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>direct_modify</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>direct_modify_plans</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>direct_modify_plans</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>direct_modify</name> <operator>&amp;&amp;</operator>
            <name>fdwroutine</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
            <name><name>fdwroutine</name><operator>-&gt;</operator><name>PlanForeignModify</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>fdw_private</name> <operator>=</operator> <call><name><name>fdwroutine</name><operator>-&gt;</operator><name>PlanForeignModify</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>fdw_private</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>fdw_private_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fdw_private_list</name></expr></argument>, <argument><expr><name>fdw_private</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fdwPrivLists</name></name> <operator>=</operator> <name>fdw_private_list</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>fdwDirectModifyPlans</name></name> <operator>=</operator> <name>direct_modify_plans</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* expand partitioned table */</comment>
    <if_stmt><if>if<condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>haspartparent</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>parentplanidx</name></name> <operator>=</operator> <name>partoffset</name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator> <name>operation</name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type> <name>parentplan</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type> <name>nextplan</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Relation</name></type> <name>parentrel</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>temp_bms</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>nextpart</name></decl>;</decl_stmt>            
            
            <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>partrelidx</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>parentrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,<argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>parentplan</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>,<argument><expr><name><name>node</name><operator>-&gt;</operator><name>parentplanidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>temp_bms</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>partpruning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>nextpart</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <while>while<condition>(<expr><operator>(</operator><name>nextpart</name> <operator>=</operator> <call><name>bms_first_member</name><argument_list>(<argument><expr><name>temp_bms</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>nextplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><call><name>copyObject</name><argument_list>(<argument><expr><name>parentplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>replace_target_relation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>nextplan</name></expr></argument>,<argument><expr><name><name>node</name><operator>-&gt;</operator><name>partrelidx</name></name></expr></argument>,<argument><expr><name>parentrel</name></expr></argument>,<argument><expr><name>nextpart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>partplans</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>partplans</name></name></expr></argument>, <argument><expr><name>nextplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>

            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>parentrel</name></expr></argument>,<argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>temp_bms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* remembered in PlannerInfo */</comment>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>haspart_tobe_modify</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>partrelindex</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>partrelidx</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>partpruning</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>partpruning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * is_projection_capable_path
 *        Check whether a given Path node is able to do projection.
 */</comment>
<function><type><name>bool</name></type>
<name>is_projection_capable_path</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* Most plan types can project, so just list the ones that can't */</comment>
    <switch>switch <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>pathtype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_Hash</name></expr>:</case>
        <case>case <expr><name>T_Material</name></expr>:</case>
        <case>case <expr><name>T_Sort</name></expr>:</case>
        <case>case <expr><name>T_Unique</name></expr>:</case>
        <case>case <expr><name>T_SetOp</name></expr>:</case>
        <case>case <expr><name>T_LockRows</name></expr>:</case>
        <case>case <expr><name>T_Limit</name></expr>:</case>
        <case>case <expr><name>T_ModifyTable</name></expr>:</case>
        <case>case <expr><name>T_MergeAppend</name></expr>:</case>
        <case>case <expr><name>T_RecursiveUnion</name></expr>:</case>
            <return>return <expr><name>false</name></expr>;</return>
        <case>case <expr><name>T_Append</name></expr>:</case>

            <comment type="block">/*
             * Append can't project, but if it's being used to represent a
             * dummy path, claim that it can project.  This prevents us from
             * converting a rel from dummy to non-dummy status by applying a
             * projection to its dummy path.
             */</comment>
            <return>return <expr><call><name>IS_DUMMY_PATH</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>T_ProjectSet</name></expr>:</case>

            <comment type="block">/*
             * Although ProjectSet certainly projects, say "no" because we
             * don't want the planner to randomly replace its tlist with
             * something else; the SRFs have to stay at top level.  This might
             * get relaxed later.
             */</comment>
            <return>return <expr><name>false</name></expr>;</return>
        <default>default:</default>
            <break>break;</break>
    </block_content>}</block></switch>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * is_projection_capable_plan
 *        Check whether a given Plan node is able to do projection.
 */</comment>
<function><type><name>bool</name></type>
<name>is_projection_capable_plan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* Most plan types can project, so just list the ones that can't */</comment>
    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_Hash</name></expr>:</case>
        <case>case <expr><name>T_Material</name></expr>:</case>
        <case>case <expr><name>T_Sort</name></expr>:</case>
        <case>case <expr><name>T_Unique</name></expr>:</case>
        <case>case <expr><name>T_SetOp</name></expr>:</case>
        <case>case <expr><name>T_LockRows</name></expr>:</case>
        <case>case <expr><name>T_Limit</name></expr>:</case>
        <case>case <expr><name>T_ModifyTable</name></expr>:</case>
        <case>case <expr><name>T_Append</name></expr>:</case>
        <case>case <expr><name>T_MergeAppend</name></expr>:</case>
        <case>case <expr><name>T_RecursiveUnion</name></expr>:</case>
            <return>return <expr><name>false</name></expr>;</return>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
        <comment type="block">/*
         * Remote subplan may push down projection to the data nodes if do not
         * performs merge sort
         */</comment>
        <case>case <expr><name>T_RemoteSubplan</name></expr>:</case>
            <return>return <expr><operator>(</operator><operator>(</operator><name>RemoteSubplan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>sort</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                    <call><name>is_projection_capable_plan</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>T_ProjectSet</name></expr>:</case>

            <comment type="block">/*
             * Although ProjectSet certainly projects, say "no" because we
             * don't want the planner to randomly replace its tlist with
             * something else; the SRFs have to stay at top level.  This might
             * get relaxed later.
             */</comment>
            <return>return <expr><name>false</name></expr>;</return>
        <default>default:</default>
            <break>break;</break>
    </block_content>}</block></switch>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CNAME_MAXLEN</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>cursor_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * Return a name unique for the cluster
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_internal_cursor</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cursor</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>random_id</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cursor</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>CNAME_MAXLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>cursor_id</name><operator>++</operator> <operator>==</operator> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>cursor_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>random_id</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call> <operator>%</operator> <name>INT_MAX</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>CNAME_MAXLEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"p_%d_%x_%x_%x"</literal></expr></argument>,
             <argument><expr><name>PGXCNodeId</name></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>cursor_id</name></expr></argument>, <argument><expr><name>random_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>cursor</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>bool</name></type>
<name>contain_remote_subplan_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>include_cte</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><name>node</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>plan</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RemoteSubplan</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>include_cte</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CteScan</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>subquery</name> <init>= <expr><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>subquery</name><operator>-&gt;</operator><name>subplan</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Append</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Append</name> <modifier>*</modifier></type><name>append</name> <init>= <expr><operator>(</operator><name>Append</name> <operator>*</operator><operator>)</operator><name>plan</name></expr></init></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>append-&gt;appendplans</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>appendplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>appendplan</name> <operator>&amp;&amp;</operator> <call><name>contain_remote_subplan_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>appendplan</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>include_cte</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>MergeAppend</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MergeAppend</name> <modifier>*</modifier></type><name>mergeappend</name> <init>= <expr><operator>(</operator><name>MergeAppend</name> <operator>*</operator><operator>)</operator><name>plan</name></expr></init></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>mergeappend-&gt;mergeplans</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>mergeappendplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>mergeappendplan</name> <operator>&amp;&amp;</operator> <call><name>contain_remote_subplan_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>mergeappendplan</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>include_cte</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>contain_remote_subplan_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><call><name>outerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>include_cte</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>innerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>contain_remote_subplan_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><call><name>innerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>include_cte</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check if contain the type node in the plan, only support
 * T_HashJoin and T_Gather now
 * search_nonparallel only work if type is T_HashJoin
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_node_walker</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>NodeTag</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>search_nonparallel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><name>node</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>plan</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RemoteSubplan</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>T_HashJoin</name></expr>)</condition>
    <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>HashJoin</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>search_nonparallel</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* return if contain non parallel hashjoin */</comment>
                <decl_stmt><decl><type><name>HashJoin</name> <modifier>*</modifier></type><name>join_plan</name> <init>= <expr><operator>(</operator><name>HashJoin</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
                <return>return <expr><operator>!</operator><name><name>join_plan</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>plan</name><operator>.</operator><name>parallel_aware</name></name></expr>;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>T_Gather</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Gather</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>subquery</name> <init>= <expr><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>plan</name> <operator>=</operator> <name><name>subquery</name><operator>-&gt;</operator><name>subplan</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Append</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Append</name> <modifier>*</modifier></type><name>append</name> <init>= <expr><operator>(</operator><name>Append</name> <operator>*</operator><operator>)</operator><name>plan</name></expr></init></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>append-&gt;appendplans</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>appendplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>appendplan</name> <operator>&amp;&amp;</operator> <call><name>contain_node_walker</name><argument_list>(<argument><expr><name>appendplan</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>search_nonparallel</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>MergeAppend</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MergeAppend</name> <modifier>*</modifier></type><name>mergeappend</name> <init>= <expr><operator>(</operator><name>MergeAppend</name> <operator>*</operator><operator>)</operator><name>plan</name></expr></init></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>mergeappend-&gt;mergeplans</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>mergeappendplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>mergeappendplan</name> <operator>&amp;&amp;</operator> <call><name>contain_node_walker</name><argument_list>(<argument><expr><name>mergeappendplan</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>search_nonparallel</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>contain_node_walker</name><argument_list>(<argument><expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>search_nonparallel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>innerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>contain_node_walker</name><argument_list>(<argument><expr><call><name>innerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>search_nonparallel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Plan</name><modifier>*</modifier></type>
<name>materialize_top_remote_subplan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>plan</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Material</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>node</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RemoteSubplan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>matplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_material</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * We assume the materialize will not spill to disk, and therefore
         * charge just cpu_operator_cost per tuple.  (Keep this estimate in
         * sync with cost_mergejoin.)
         */</comment>
        <expr_stmt><expr><call><name>copy_plan_costsize</name><argument_list>(<argument><expr><name>matplan</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>matplan</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+=</operator> <name>cpu_operator_cost</name> <operator>*</operator> <name><name>matplan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>

        <return>return <expr><name>matplan</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>subquery</name> <init>= <expr><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>subquery</name><operator>-&gt;</operator><name>subplan</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Append</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Append</name> <modifier>*</modifier></type><name>append</name> <init>= <expr><operator>(</operator><name>Append</name> <operator>*</operator><operator>)</operator><name>plan</name></expr></init></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>append-&gt;appendplans</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>appendplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>appendplan</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>tmpplan</name> <init>= <expr><call><name>materialize_top_remote_subplan</name><argument_list>(<argument><expr><name>appendplan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>tmpplan</name> <operator>&amp;&amp;</operator> <name>tmpplan</name> <operator>!=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>tmpplan</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <return>return <expr><name>node</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>MergeAppend</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MergeAppend</name> <modifier>*</modifier></type><name>mergeappend</name> <init>= <expr><operator>(</operator><name>MergeAppend</name> <operator>*</operator><operator>)</operator><name>plan</name></expr></init></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>mergeappend-&gt;mergeplans</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>mergeappendplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>mergeappendplan</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>tmpplan</name> <init>= <expr><call><name>materialize_top_remote_subplan</name><argument_list>(<argument><expr><name>mergeappendplan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>tmpplan</name> <operator>&amp;&amp;</operator> <name>tmpplan</name> <operator>!=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>tmpplan</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <return>return <expr><name>node</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>tmpplan</name> <init>= <expr><call><name>materialize_top_remote_subplan</name><argument_list>(<argument><expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>tmpplan</name> <operator>&amp;&amp;</operator> <name>tmpplan</name> <operator>!=</operator> <call><name>outerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>tmpplan</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>innerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>tmpplan</name> <init>= <expr><call><name>materialize_top_remote_subplan</name><argument_list>(<argument><expr><call><name>innerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>tmpplan</name> <operator>&amp;&amp;</operator> <name>tmpplan</name> <operator>!=</operator> <call><name>innerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>innerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>tmpplan</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_remotequery_for_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>mt</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>res_rel</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>resultRelationIndex</name></decl></parameter>,
                                   <parameter><decl><type><name>int</name></type> <name>relcount</name></decl></parameter>, <parameter><decl><type><name>CmdType</name></type> <name>cmdtyp</name></decl></parameter>, <parameter><decl><type><name>RelationAccessType</name></type>    <name>accessType</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>partindex</name></decl></parameter>,
                                   <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQuery</name>     <modifier>*</modifier></type><name>fstep</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelationLocInfo</name>    <modifier>*</modifier></type><name>rel_loc_info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>            <modifier>*</modifier></type><name>sourceDataPlan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name>    <modifier>*</modifier></type><name>dummy_rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>child_relname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>             <name>child_reloid</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>res_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get location info of the target table */</comment>
    <expr_stmt><expr><name>rel_loc_info</name> <operator>=</operator> <call><name>GetRelationLocInfo</name><argument_list>(<argument><expr><name><name>res_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rel_loc_info</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>partindex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>child_relname</name> <operator>=</operator> <call><name>GetPartitionName</name><argument_list>(<argument><expr><name><name>res_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>partindex</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>child_reloid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name>child_relname</name></expr></argument>, <argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>child_reloid</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name>child_relname</name></expr>)</condition>
			<block>{<block_content>
			    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>child_relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>fstep</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fstep</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <name>resultRelationIndex</name></expr>;</expr_stmt>

    <comment type="block">/*
     * DML planning generates its own parameters that refer to the source
     * data plan.
     */</comment>

    <expr_stmt><expr><name><name>fstep</name><operator>-&gt;</operator><name>is_temp</name></name> <operator>=</operator> <call><name>IsTempTable</name><argument_list>(<argument><expr><name><name>res_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fstep</name><operator>-&gt;</operator><name>read_only</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fstep</name><operator>-&gt;</operator><name>dml_on_coordinator</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>mt</name><operator>-&gt;</operator><name>returningLists</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pgxc_add_returning_list</name><argument_list>(<argument><expr><name>fstep</name></expr></argument>,
                                <argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>mt</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>, <argument><expr><name>relcount</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>resultRelationIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>partindex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeTblEntry</name>    <modifier>*</modifier></type><name>child_rte</name></decl>;</decl_stmt>
        <comment type="block">/* Get the plan that is supposed to supply source data to this plan */</comment>
        <expr_stmt><expr><name>sourceDataPlan</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>mt</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>, <argument><expr><name>relcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>child_rte</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>res_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>child_rte</name><operator>-&gt;</operator><name>intervalparent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>child_rte</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <name>child_relname</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>child_rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>child_reloid</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>child_rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pgxc_build_dml_statement</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>cmdtyp</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fstep</name></expr></argument>,
                                    <argument><expr><name><name>sourceDataPlan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Get the plan that is supposed to supply source data to this plan */</comment>
        <expr_stmt><expr><name>sourceDataPlan</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>mt</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>, <argument><expr><name>relcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pgxc_build_dml_statement</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>cmdtyp</name></expr></argument>, <argument><expr><name>resultRelationIndex</name></expr></argument>, <argument><expr><name>fstep</name></expr></argument>,
                                    <argument><expr><name><name>sourceDataPlan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <switch>switch <condition>(<expr><name>cmdtyp</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>CMD_INSERT</name></expr>:</case>
        <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
        <case>case <expr><name>CMD_DELETE</name></expr>:</case>
            <expr_stmt><expr><name><name>fstep</name><operator>-&gt;</operator><name>combine_type</name></name>  <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_REPLICATED</name><operator>)</operator></expr> ?</condition><then>
                    <expr><name>COMBINE_TYPE_SAME</name></expr> </then><else>: <expr><name>COMBINE_TYPE_SUM</name></expr></else></ternary></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><name><name>fstep</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>=</operator> <name>COMBINE_TYPE_NONE</name></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><name>cmdtyp</name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>fstep</name><operator>-&gt;</operator><name>exec_nodes</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fstep</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>accesstype</name></name> <operator>=</operator> <name>accessType</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fstep</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fstep</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>primarynodelist</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fstep</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name><name>rel_loc_info</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>fstep</name><operator>-&gt;</operator><name>exec_nodes</name></name> <operator>=</operator> <call><name>GetRelationNodes</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>, 
                                             <argument><expr><literal type="number">0</literal></expr></argument>, 
                                             <argument><expr><name>true</name></expr></argument>,
                                             <argument><expr><literal type="number">0</literal></expr></argument>,
                                             <argument><expr><name>true</name></expr></argument>,
                                             <argument><expr><name>accessType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>fstep</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>en_relid</name></name> <operator>=</operator> <name><name>res_rel</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fstep</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>EXEC_ON_DATANODES</name></expr>;</expr_stmt>
    <comment type="line">//if (cmdtyp != CMD_DELETE)</comment>
    <block>{<block_content>
        
        <expr_stmt><expr><name><name>fstep</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>en_expr</name></name>       <operator>=</operator> <call><name>pgxc_set_en_expr</name><argument_list>(<argument><expr><name><name>res_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>resultRelationIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//fstep-&gt;exec_nodes-&gt;sec_en_expr = pgxc_set_sec_en_expr(res_rel-&gt;relid, resultRelationIndex);</comment>

        <comment type="block">/* delete is a little different, distributed column is the last output column */</comment>
        <if_stmt><if>if <condition>(<expr><name>cmdtyp</name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name><name>fstep</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>en_expr</name></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varoattno</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>sourceDataPlan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <expr_stmt><expr><name>dummy_rte</name> <operator>=</operator> <call><name>make_dummy_remote_rte</name><argument_list>(<argument><expr><name>relname</name></expr></argument>,
                                    <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"REMOTE_DML_QUERY"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>dummy_rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fstep</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get cursor for insert/update/delete/UPSERT */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>upsert</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cursor</name> <init>= <expr><call><name>get_internal_cursor</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        
        <comment type="line">//fstep-&gt;cursor = (char *)palloc(sizeof(char) * CNAME_MAXLEN);</comment>
        <expr_stmt><expr><name><name>fstep</name><operator>-&gt;</operator><name>statement</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>CNAME_MAXLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fstep</name><operator>-&gt;</operator><name>update_cursor</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <comment type="line">//snprintf(fstep-&gt;cursor, CNAME_MAXLEN - 1, "%s", cursor);</comment>

        <if_stmt><if>if <condition>(<expr><name>cmdtyp</name> <operator>==</operator> <name>CMD_INSERT</name> <operator>&amp;&amp;</operator> <name><name>mt</name><operator>-&gt;</operator><name>onConflictAction</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>upsert</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <comment type="line">//fstep-&gt;select_cursor = (char *)palloc(sizeof(char) * CNAME_MAXLEN);</comment>
            <expr_stmt><expr><name><name>fstep</name><operator>-&gt;</operator><name>select_cursor</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fstep</name><operator>-&gt;</operator><name>update_cursor</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>CNAME_MAXLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>fstep</name><operator>-&gt;</operator><name>statement</name></name></expr></argument>, <argument><expr><name>CNAME_MAXLEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>INSERT_TRIGGER</name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">//snprintf(fstep-&gt;select_cursor, CNAME_MAXLEN - 1, "select_%s", cursor);</comment>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>fstep</name><operator>-&gt;</operator><name>update_cursor</name></name></expr></argument>, <argument><expr><name>CNAME_MAXLEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>UPDATE_TRIGGER</name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>cmdtyp</name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>fstep</name><operator>-&gt;</operator><name>statement</name></name></expr></argument>, <argument><expr><name>CNAME_MAXLEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>INSERT_TRIGGER</name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>cmdtyp</name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>fstep</name><operator>-&gt;</operator><name>statement</name></name></expr></argument>, <argument><expr><name>CNAME_MAXLEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>UPDATE_TRIGGER</name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>cmdtyp</name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>fstep</name><operator>-&gt;</operator><name>statement</name></name></expr></argument>, <argument><expr><name>CNAME_MAXLEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>DELETE_TRIGGER</name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>fstep</name><operator>-&gt;</operator><name>statement</name></name></expr></argument>, <argument><expr><name>CNAME_MAXLEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* prepare statements */</comment>
        <expr_stmt><expr><call><name>PrepareRemoteDMLStatement</name><argument_list>(<argument><expr><name>upsert</name></expr></argument>, <argument><expr><name><name>fstep</name><operator>-&gt;</operator><name>statement</name></name></expr></argument>, 
                                  <argument><expr><name><name>fstep</name><operator>-&gt;</operator><name>select_cursor</name></name></expr></argument>, <argument><expr><name><name>fstep</name><operator>-&gt;</operator><name>update_cursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name><name>fstep</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>UPSERT_NONE</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>mt</name><operator>-&gt;</operator><name>remote_plans</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>mt</name><operator>-&gt;</operator><name>remote_plans</name></name></expr></argument>, <argument><expr><name>fstep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * create_remotedml_plan()
 *
 * For every target relation, add a remote query node to carry out remote
 * operations.
 */</comment>
<function><type><name>Plan</name> <modifier>*</modifier></type>
<name>create_remotedml_plan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>topplan</name></decl></parameter>, <parameter><decl><type><name>CmdType</name></type> <name>cmdtyp</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ModifyTable</name>            <modifier>*</modifier></type><name>mt</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator><name>topplan</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>            <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                    <name>relcount</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelationAccessType</name></type>    <name>accessType</name></decl>;</decl_stmt>

    <comment type="block">/* We expect to work only on ModifyTable node */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>topplan</name></expr></argument>, <argument><expr><name>ModifyTable</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unexpected node type: %d"</literal></expr></argument>, <argument><expr><name><name>topplan</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <switch>switch<condition>(<expr><name>cmdtyp</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
        <case>case <expr><name>CMD_DELETE</name></expr>:</case>
            <expr_stmt><expr><name>accessType</name> <operator>=</operator> <name>RELATION_ACCESS_UPDATE</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>CMD_INSERT</name></expr>:</case>
            <expr_stmt><expr><name>accessType</name> <operator>=</operator> <name>RELATION_ACCESS_INSERT</name></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unexpected command type: %d"</literal></expr></argument>, <argument><expr><name>cmdtyp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></switch>

    <comment type="block">/*
     * For every result relation, build a remote plan to execute remote DML.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>rel</argument>, <argument>mt-&gt;resultRelations</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Index</name></type>            <name>resultRelationIndex</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RangeTblEntry</name>    <modifier>*</modifier></type><name>res_rel</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Relation</name></type>        <name>relation</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>relcount</name><operator>++</operator></expr>;</expr_stmt>

        <expr_stmt><expr><name>res_rel</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>resultRelationIndex</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Bad relation ? */</comment>
        <if_stmt><if>if <condition>(<expr><name>res_rel</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>res_rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>res_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>

            <expr_stmt><expr><call><name>create_remotequery_for_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>mt</name></expr></argument>, <argument><expr><name>res_rel</name></expr></argument>, <argument><expr><name>resultRelationIndex</name></expr></argument>, 
                                       <argument><expr><name>relcount</name></expr></argument>, <argument><expr><name>cmdtyp</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
            relname = get_rel_name(res_rel-&gt;relid);

            <comment type="block">/* Get location info of the target table */</comment>
            rel_loc_info = GetRelationLocInfo(res_rel-&gt;relid);
            if (rel_loc_info == NULL)
                continue;

            fstep = makeNode(RemoteQuery);
            fstep-&gt;scan.scanrelid = resultRelationIndex;

            <comment type="block">/*
             * DML planning generates its own parameters that refer to the source
             * data plan.
             */</comment>

            fstep-&gt;is_temp = IsTempTable(res_rel-&gt;relid);
            fstep-&gt;read_only = false;
            fstep-&gt;dml_on_coordinator = true;

            if (mt-&gt;returningLists)
                pgxc_add_returning_list(fstep,
                                        list_nth(mt-&gt;returningLists, relcount),
                                        resultRelationIndex);

            <comment type="block">/* Get the plan that is supposed to supply source data to this plan */</comment>
            sourceDataPlan = list_nth(mt-&gt;plans, relcount);

            pgxc_build_dml_statement(root, cmdtyp, resultRelationIndex, fstep,
                                        sourceDataPlan-&gt;targetlist, false);

            switch (cmdtyp)
            {
                case CMD_INSERT:
                case CMD_UPDATE:
                case CMD_DELETE:
                    fstep-&gt;combine_type  = (rel_loc_info-&gt;locatorType == LOCATOR_TYPE_REPLICATED) ?
                            COMBINE_TYPE_SAME : COMBINE_TYPE_SUM;
                    break;
                default:
                    fstep-&gt;combine_type = COMBINE_TYPE_NONE;
                    break;
            }

            if (cmdtyp == CMD_INSERT)
            {
                fstep-&gt;exec_nodes = makeNode(ExecNodes);
                fstep-&gt;exec_nodes-&gt;accesstype = accessType;
                fstep-&gt;exec_nodes-&gt;baselocatortype = rel_loc_info-&gt;locatorType;
                fstep-&gt;exec_nodes-&gt;primarynodelist = NULL;
                fstep-&gt;exec_nodes-&gt;nodeList = rel_loc_info-&gt;rl_nodeList;
            }
            else
            {
                fstep-&gt;exec_nodes = GetRelationNodes(rel_loc_info, 
                                                     0, 
                                                     true,
                                                     accessType);
            }
            fstep-&gt;exec_nodes-&gt;en_relid = res_rel-&gt;relid;
            fstep-&gt;exec_type = EXEC_ON_DATANODES;
            <comment type="line">//if (cmdtyp != CMD_DELETE)</comment>
            {
                
                fstep-&gt;exec_nodes-&gt;en_expr     = pgxc_set_en_expr(res_rel-&gt;relid, resultRelationIndex);
                <comment type="line">//fstep-&gt;exec_nodes-&gt;sec_en_expr = pgxc_set_sec_en_expr(res_rel-&gt;relid, resultRelationIndex);</comment>

                <comment type="block">/* delete is a little different, distributed column is the last output column */</comment>
                if (cmdtyp == CMD_DELETE)
                {
                    Var *var = (Var *)fstep-&gt;exec_nodes-&gt;en_expr;

                    var-&gt;varattno = var-&gt;varoattno = list_length(sourceDataPlan-&gt;targetlist);
                }
            }
            dummy_rte = make_dummy_remote_rte(relname,
                                            makeAlias("REMOTE_DML_QUERY", NIL));
            root-&gt;parse-&gt;rtable = lappend(root-&gt;parse-&gt;rtable, dummy_rte);
            fstep-&gt;scan.scanrelid = list_length(root-&gt;parse-&gt;rtable);

            <comment type="block">/* get cursor for insert/update/delete/UPSERT */</comment>
            {
                bool upsert = false;
                char *cursor = get_internal_cursor();
                
                <comment type="line">//fstep-&gt;cursor = (char *)palloc(sizeof(char) * CNAME_MAXLEN);</comment>
                fstep-&gt;statement = (char *)palloc(sizeof(char) * CNAME_MAXLEN);

                <comment type="line">//snprintf(fstep-&gt;cursor, CNAME_MAXLEN - 1, "%s", cursor);</comment>

                if (cmdtyp == CMD_INSERT &amp;&amp; mt-&gt;onConflictAction == ONCONFLICT_UPDATE)
                {
                    upsert = true;
                    <comment type="line">//fstep-&gt;select_cursor = (char *)palloc(sizeof(char) * CNAME_MAXLEN);</comment>
                    fstep-&gt;select_cursor = NULL;
                    fstep-&gt;update_cursor = (char *)palloc(sizeof(char) * CNAME_MAXLEN);

                    snprintf(fstep-&gt;statement, CNAME_MAXLEN - 1, "insert_%s", cursor);
                    <comment type="line">//snprintf(fstep-&gt;select_cursor, CNAME_MAXLEN - 1, "select_%s", cursor);</comment>
                    snprintf(fstep-&gt;update_cursor, CNAME_MAXLEN - 1, "update_%s", cursor);
                }
                else
                {
                    snprintf(fstep-&gt;statement, CNAME_MAXLEN - 1, "%s", cursor);
                }

                <comment type="block">/* prepare statements */</comment>
                PrepareRemoteDMLStatement(upsert, fstep-&gt;statement, 
                                          fstep-&gt;select_cursor, fstep-&gt;update_cursor);
            }
            
            fstep-&gt;action = UPSERT_NONE;
            
            mt-&gt;remote_plans = lappend(mt-&gt;remote_plans, fstep);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if>
        <else>else<comment type="block">/* interval partition */</comment>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>nextpart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <while>while<condition>(<expr><operator>(</operator><name>nextpart</name> <operator>=</operator> <call><name>bms_first_member</name><argument_list>(<argument><expr><name><name>mt</name><operator>-&gt;</operator><name>partpruning</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>

                <expr_stmt><expr><call><name>create_remotequery_for_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>mt</name></expr></argument>, <argument><expr><name>res_rel</name></expr></argument>, <argument><expr><name>resultRelationIndex</name></expr></argument>, <argument><expr><name>relcount</name></expr></argument>, <argument><expr><name>cmdtyp</name></expr></argument>,
                                           <argument><expr><name>accessType</name></expr></argument>, <argument><expr><name>nextpart</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
                RangeTblEntry    *child_rte;
                
                relname = get_rel_name(res_rel-&gt;relid);

                <comment type="block">/* Get location info of the target table */</comment>
                rel_loc_info = GetRelationLocInfo(res_rel-&gt;relid);
                if (rel_loc_info == NULL)
                    continue;

                fstep = makeNode(RemoteQuery);
                fstep-&gt;scan.scanrelid = resultRelationIndex;

                <comment type="block">/*
                 * DML planning generates its own parameters that refer to the source
                 * data plan.
                 */</comment>

                fstep-&gt;is_temp = IsTempTable(res_rel-&gt;relid);
                fstep-&gt;read_only = false;
                fstep-&gt;dml_on_coordinator = true;

                if (mt-&gt;returningLists)
                    pgxc_add_returning_list(fstep,
                                            list_nth(mt-&gt;returningLists, relcount),
                                            resultRelationIndex);

                <comment type="block">/* Get the plan that is supposed to supply source data to this plan */</comment>
                sourceDataPlan = list_nth(mt-&gt;plans, relcount);

                child_rte = copyObject(res_rel);
                child_rte-&gt;intervalparent = false;
                child_rte-&gt;relname = GetPartitionName(res_rel-&gt;relid, nextpart, false);
                child_rte-&gt;relid = get_relname_relid(child_rte-&gt;relname, RelationGetNamespace(relation));

                root-&gt;parse-&gt;rtable = lappend(root-&gt;parse-&gt;rtable, child_rte);

                pgxc_build_dml_statement(root, cmdtyp, list_length(root-&gt;parse-&gt;rtable), fstep,
                                            sourceDataPlan-&gt;targetlist, true);

                switch (cmdtyp)
                {
                    case CMD_INSERT:
                    case CMD_UPDATE:
                    case CMD_DELETE:
                        fstep-&gt;combine_type  = (rel_loc_info-&gt;locatorType == LOCATOR_TYPE_REPLICATED) ?
                                COMBINE_TYPE_SAME : COMBINE_TYPE_SUM;
                        break;
                    default:
                        fstep-&gt;combine_type = COMBINE_TYPE_NONE;
                        break;
                }

                if (cmdtyp == CMD_INSERT)
                {
                    fstep-&gt;exec_nodes = makeNode(ExecNodes);
                    fstep-&gt;exec_nodes-&gt;accesstype = accessType;
                    fstep-&gt;exec_nodes-&gt;baselocatortype = rel_loc_info-&gt;locatorType;
                    fstep-&gt;exec_nodes-&gt;primarynodelist = NULL;
                    fstep-&gt;exec_nodes-&gt;nodeList = rel_loc_info-&gt;rl_nodeList;
                }
                else
                {
                    fstep-&gt;exec_nodes = GetRelationNodes(rel_loc_info, 
                                                         0, 
                                                         true,
                                                         accessType);
                }
                fstep-&gt;exec_nodes-&gt;en_relid = res_rel-&gt;relid;
                fstep-&gt;exec_type = EXEC_ON_DATANODES;
                <comment type="line">//if (cmdtyp != CMD_DELETE)</comment>
                {
                    
                    fstep-&gt;exec_nodes-&gt;en_expr     = pgxc_set_en_expr(res_rel-&gt;relid, resultRelationIndex);
                    <comment type="line">//fstep-&gt;exec_nodes-&gt;sec_en_expr = pgxc_set_sec_en_expr(res_rel-&gt;relid, resultRelationIndex);</comment>

                    <comment type="block">/* delete is a little different, distributed column is the last output column */</comment>
                    if (cmdtyp == CMD_DELETE)
                    {
                        Var *var = (Var *)fstep-&gt;exec_nodes-&gt;en_expr;

                        var-&gt;varattno = var-&gt;varoattno = list_length(sourceDataPlan-&gt;targetlist);
                    }
                }
                dummy_rte = make_dummy_remote_rte(relname,
                                                makeAlias("REMOTE_DML_QUERY", NIL));
                root-&gt;parse-&gt;rtable = lappend(root-&gt;parse-&gt;rtable, dummy_rte);
                fstep-&gt;scan.scanrelid = list_length(root-&gt;parse-&gt;rtable);

                <comment type="block">/* get cursor for insert/update/delete/UPSERT */</comment>
                {
                    bool upsert = false;
                    char *cursor = get_internal_cursor();
                    
                    <comment type="line">//fstep-&gt;cursor = (char *)palloc(sizeof(char) * CNAME_MAXLEN);</comment>
                    fstep-&gt;statement = (char *)palloc(sizeof(char) * CNAME_MAXLEN);

                    <comment type="line">//snprintf(fstep-&gt;cursor, CNAME_MAXLEN - 1, "%s", cursor);</comment>

                    if (cmdtyp == CMD_INSERT &amp;&amp; mt-&gt;onConflictAction == ONCONFLICT_UPDATE)
                    {
                        upsert = true;
                        <comment type="line">//fstep-&gt;select_cursor = (char *)palloc(sizeof(char) * CNAME_MAXLEN);</comment>
                        fstep-&gt;select_cursor = NULL;
                        fstep-&gt;update_cursor = (char *)palloc(sizeof(char) * CNAME_MAXLEN);

                        snprintf(fstep-&gt;statement, CNAME_MAXLEN - 1, "insert_%s", cursor);
                        <comment type="line">//snprintf(fstep-&gt;select_cursor, CNAME_MAXLEN - 1, "select_%s", cursor);</comment>
                        snprintf(fstep-&gt;update_cursor, CNAME_MAXLEN - 1, "update_%s", cursor);
                    }
                    else
                    {
                        snprintf(fstep-&gt;statement, CNAME_MAXLEN - 1, "%s", cursor);
                    }

                    <comment type="block">/* prepare statements */</comment>
                    PrepareRemoteDMLStatement(upsert, fstep-&gt;statement, 
                                              fstep-&gt;select_cursor, fstep-&gt;update_cursor);
                }
                
                fstep-&gt;action = UPSERT_NONE;
                
                mt-&gt;remote_plans = lappend(mt-&gt;remote_plans, fstep);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></while>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><name>mt</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>double</name></type>
<name>GetPlanRows</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>double</name></type> <name>rows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    
    <switch>switch<condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_SeqScan</name></expr>:</case>
        <case>case <expr><name>T_IndexScan</name></expr>:</case>
        <case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
        <case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
            <expr_stmt><expr><name>rows</name> <operator>=</operator>  <name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_Group</name></expr>:</case>
        <case>case <expr><name>T_Agg</name></expr>:</case>
        <case>case <expr><name>T_Sort</name></expr>:</case>
        <case>case <expr><name>T_Limit</name></expr>:</case>
            <expr_stmt><expr><name>rows</name> <operator>=</operator> <call><name>GetPlanRows</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_HashJoin</name></expr>:</case>
        <case>case <expr><name>T_NestLoop</name></expr>:</case>
        <case>case <expr><name>T_MergeJoin</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>double</name></type> <name>left</name> <init>= <expr><call><name>GetPlanRows</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>double</name></type> <name>right</name> <init>= <expr><call><name>GetPlanRows</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>rows</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><name>rows</name> <operator>=</operator>  <name><name>plan</name><operator>-&gt;</operator><name>plan_rows</name></name></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>rows</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>partkey_match_index</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexoid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>partkey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type> <name>indexrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexinfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>    <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>indexrel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>indexinfo</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>indexrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>indexinfo</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>indexinfo</name><operator>-&gt;</operator><name>ii_KeyAttrNumbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>partkey</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>indexinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>build_physical_tlist_with_sysattr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relation_tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>physical_tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
    <comment type="line">//TargetEntry *te_copy;</comment>
    <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>relation_tlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>te</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name><operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
          * find all vars from targetlist, and extract system attrs only
          */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>

            <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
                                                     <argument><expr><name>offset</name></expr></argument>,
                                                     <argument><expr><name>NULL</name></expr></argument>,
                                                     <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>offset</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
            
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>vars</name> <init>= <expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>PVC_RECURSE_AGGREGATES</name> <operator>|</operator> 
                                                           <name>PVC_RECURSE_WINDOWFUNCS</name> <operator>|</operator>
                                                           <name>PVC_RECURSE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>vars</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected node %d in targetlist."</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name>node</name></expr>;</expr_stmt>

                <if_stmt><if>if<condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
                                         <argument><expr><name>offset</name></expr></argument>,
                                         <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>offset</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>,<argument>physical_tlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>te</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name><operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>resno</name></name> <operator>+=</operator> <name>offset</name></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>physical_tlist</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bitmap_subplan_set_shared</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>shared</name></decl></parameter>)</parameter_list>
<block>{<block_content>
       <if_stmt><if>if <condition>(<expr><operator>!</operator><name>plan</name></expr>)</condition>
       <block>{<block_content>
               <return>return;</return>
       </block_content>}</block></if></if_stmt>
       <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>BitmapAnd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
               <expr_stmt><expr><call><name>bitmap_subplan_set_shared</name><argument_list>(
                                 <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>BitmapAnd</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>bitmapplans</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
       <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>BitmapOr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
               <expr_stmt><expr><operator>(</operator><operator>(</operator><name>BitmapOr</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>isshared</name> <operator>=</operator> <name>shared</name></expr>;</expr_stmt></block_content></block></if>
       <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>BitmapIndexScan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
               <expr_stmt><expr><operator>(</operator><operator>(</operator><name>BitmapIndexScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>isshared</name> <operator>=</operator> <name>shared</name></expr>;</expr_stmt></block_content></block></if>
       <else>else<block type="pseudo"><block_content>
               <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>set_plan_parallel</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>plan</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <switch>switch<condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_SeqScan</name></expr>:</case>
        <case>case <expr><name>T_IndexScan</name></expr>:</case>
        <case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
        <case>case <expr><name>T_RemoteSubplan</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
		<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><call><name>bitmap_subplan_set_shared</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
        <case>case <expr><name>T_NestLoop</name></expr>:</case>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>set_plan_parallel</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_HashJoin</name></expr>:</case>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>set_plan_parallel</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> 
                    <call><name>set_plan_parallel</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_Gather</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_Hash</name></expr>:</case>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>set_plan_parallel</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_SubqueryScan</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator><name>plan</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>subplan</name></name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>set_plan_parallel</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_Append</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Append</name> <modifier>*</modifier></type><name>append</name> <init>= <expr><operator>(</operator><name>Append</name> <operator>*</operator><operator>)</operator><name>plan</name></expr></init></decl>;</decl_stmt>

                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>append-&gt;appendplans</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>appendplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>set_plan_parallel</name><argument_list>(<argument><expr><name>appendplan</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <return>return <expr><name>false</name></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block>

                <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_MergeAppend</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>MergeAppend</name> <modifier>*</modifier></type><name>mergeappend</name> <init>= <expr><operator>(</operator><name>MergeAppend</name> <operator>*</operator><operator>)</operator><name>plan</name></expr></init></decl>;</decl_stmt>
        
                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>mergeappend-&gt;mergeplans</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>mergeappendplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>set_plan_parallel</name><argument_list>(<argument><expr><name>mergeappendplan</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <return>return <expr><name>false</name></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block>
        
                <expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_Agg</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Agg</name> <modifier>*</modifier></type><name>aggplan</name> <init>= <expr><operator>(</operator><name>Agg</name> <operator>*</operator><operator>)</operator><name>plan</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>aggplan</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>==</operator> <name>AGGSPLIT_FINAL_DESERIAL</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>aggplan</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name> <operator>&amp;&amp;</operator> <name><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name><name>aggplan</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_SORTED</name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name> <init>= <expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>, <argument><expr><name>Sort</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>lefttree</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>
        <default>default:</default>
            <break>break;</break>
    </block_content>}</block></switch>


    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_plan_nonparallel</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name> <init>= <expr><name>plan</name></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>plan</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator><name>plan</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>subplan</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>subplan</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Gather</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Append</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Append</name> <modifier>*</modifier></type><name>append</name> <init>= <expr><operator>(</operator><name>Append</name> <operator>*</operator><operator>)</operator><name>plan</name></expr></init></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>append-&gt;appendplans</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>appendplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>set_plan_nonparallel</name><argument_list>(<argument><expr><name>appendplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <expr_stmt><expr><name><name>append</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <return>return;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>MergeAppend</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MergeAppend</name> <modifier>*</modifier></type><name>mergeappend</name> <init>= <expr><operator>(</operator><name>MergeAppend</name> <operator>*</operator><operator>)</operator><name>plan</name></expr></init></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>mergeappend-&gt;mergeplans</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>mergeappendplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>set_plan_nonparallel</name><argument_list>(<argument><expr><name>mergeappendplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <expr_stmt><expr><name><name>mergeappend</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <return>return;</return>
    </block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>BitmapHeapScan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>bitmap_subplan_set_shared</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>set_plan_nonparallel</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_plan_nonparallel</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>subplan</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</unit>
