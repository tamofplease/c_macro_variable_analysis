<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/optimizer/util/tlist.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<comment type="block">/*-------------------------------------------------------------------------
 *
 * tlist.c
 *      Target list manipulation routines
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/optimizer/util/tlist.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>


<comment type="block">/* Test if an expression node represents a SRF call.  Beware multiple eval! */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SRF_CALL</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>((IsA(node, FuncExpr) &amp;&amp; ((FuncExpr *) (node))-&gt;funcretset) || \
     (IsA(node, OpExpr) &amp;&amp; ((OpExpr *) (node))-&gt;opretset))</cpp:value></cpp:define>

<comment type="block">/* Workspace for split_pathtarget_walker */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>input_target_exprs</name></decl>;</decl_stmt> <comment type="block">/* exprs available from input */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>level_srfs</name></decl>;</decl_stmt>        <comment type="block">/* list of lists of SRF exprs */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>level_input_vars</name></decl>;</decl_stmt>    <comment type="block">/* vars needed by SRFs of each level */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>level_input_srfs</name></decl>;</decl_stmt>    <comment type="block">/* SRFs needed by SRFs of each level */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>current_input_vars</name></decl>;</decl_stmt> <comment type="block">/* vars needed in current subexpr */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>current_input_srfs</name></decl>;</decl_stmt> <comment type="block">/* SRFs needed in current subexpr */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>current_depth</name></decl>;</decl_stmt>    <comment type="block">/* max SRF depth in current subexpr */</comment>
}</block></struct></type> <name>split_pathtarget_context</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>split_pathtarget_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                        <parameter><decl><type><name>split_pathtarget_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block" format="doxygen">/*****************************************************************************
 *        Target list creation and searching utilities
 *****************************************************************************/</comment>

<comment type="block">/*
 * tlist_member
 *      Finds the (first) member of the given tlist whose expression is
 *      equal() to the given expression.  Result is NULL if no such member.
 */</comment>
<function><type><name>TargetEntry</name> <modifier>*</modifier></type>
<name>tlist_member</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>targetlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tlentry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>tlentry</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>tlentry</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tlist_member_ignore_relabel
 *      Same as above, except that we ignore top-level RelabelType nodes
 *      while checking for a match.  This is needed for some scenarios
 *      involving binary-compatible sort operations.
 */</comment>
<function><type><name>TargetEntry</name> <modifier>*</modifier></type>
<name>tlist_member_ignore_relabel</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

    <macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>targetlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tlentry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>tlexpr</name> <init>= <expr><name><name>tlentry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><name>tlexpr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>tlexpr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>tlexpr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>tlexpr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

        <if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>tlexpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>tlentry</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tlist_member_match_var
 *      Same as above, except that we match the provided Var on the basis
 *      of varno/varattno/varlevelsup/vartype only, rather than full equal().
 *
 * This is needed in some cases where we can't be sure of an exact typmod
 * match.  For safety, though, we insist on vartype match.
 */</comment>
<function><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type>
<name>tlist_member_match_var</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>targetlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tlentry</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Var</name>           <modifier>*</modifier></type><name>tlvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tlentry</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tlvar</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>tlvar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>tlvar</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator>
            <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>tlvar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&amp;&amp;</operator>
            <name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <name><name>tlvar</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>&amp;&amp;</operator>
            <name><name>var</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name><name>tlvar</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>tlentry</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * add_to_flat_tlist
 *        Add more items to a flattened tlist (if they're not already in it)
 *
 * 'tlist' is the flattened tlist
 * 'exprs' is a list of expressions (usually, but not necessarily, Vars)
 *
 * Returns the extended tlist.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>add_to_flat_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>next_resno</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>exprs</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tlist_member</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>, <comment type="block">/* copy needed?? */</comment>
                                  <argument><expr><name>next_resno</name><operator>++</operator></expr></argument>,
                                  <argument><expr><name>NULL</name></expr></argument>,
                                  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_tlist_exprs
 *        Get just the expression subtrees of a tlist
 *
 * Resjunk columns are ignored unless includeJunk is true
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>get_tlist_exprs</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>includeJunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>includeJunk</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * count_nonjunk_tlist_entries
 *        What it says ...
 */</comment>
<function><type><name>int</name></type>
<name>count_nonjunk_tlist_entries</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * tlist_same_exprs
 *        Check whether two target lists contain the same expressions
 *
 * Note: this function is used to decide whether it's safe to jam a new tlist
 * into a non-projection-capable plan node.  Obviously we can't do that unless
 * the node's tlist shows it already returns the column values we want.
 * However, we can ignore the TargetEntry attributes resname, ressortgroupref,
 * resorigtbl, resorigcol, and resjunk, because those are only labelings that
 * don't affect the row values computed by the node.  (Moreover, if we didn't
 * ignore them, we'd frequently fail to make the desired optimization, since
 * the planner tends to not bother to make resname etc. valid in intermediate
 * plan nodes.)  Note that on success, the caller must still jam the desired
 * tlist into the plan node, else it won't have the desired labeling fields.
 */</comment>
<function><type><name>bool</name></type>
<name>tlist_same_exprs</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist1</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>tlist2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* not same length, so can't match */</comment>

    <macro><name>forboth</name><argument_list>(<argument>lc1</argument>, <argument>tlist1</argument>, <argument>lc2</argument>, <argument>tlist2</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle1</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle2</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>tle1</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name><name>tle2</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Does tlist have same output datatypes as listed in colTypes?
 *
 * Resjunk columns are ignored if junkOK is true; otherwise presence of
 * a resjunk column will always cause a 'false' result.
 *
 * Note: currently no callers care about comparing typmods.
 */</comment>
<function><type><name>bool</name></type>
<name>tlist_same_datatypes</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colTypes</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>junkOK</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>curColType</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name>colTypes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>junkOK</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>curColType</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* tlist longer than colTypes */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>curColType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>curColType</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>curColType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <if_stmt><if>if <condition>(<expr><name>curColType</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* tlist shorter than colTypes */</comment>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Does tlist have same exposed collations as listed in colCollations?
 *
 * Identical logic to the above, but for collations.
 */</comment>
<function><type><name>bool</name></type>
<name>tlist_same_collations</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>colCollations</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>junkOK</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>curColColl</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name>colCollations</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>junkOK</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>curColColl</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>    <comment type="block">/* tlist longer than colCollations */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>curColColl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>curColColl</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>curColColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <if_stmt><if>if <condition>(<expr><name>curColColl</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* tlist shorter than colCollations */</comment>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * apply_tlist_labeling
 *        Apply the TargetEntry labeling attributes of src_tlist to dest_tlist
 *
 * This is useful for reattaching column names etc to a plan's final output
 * targetlist.
 */</comment>
<function><type><name>void</name></type>
<name>apply_tlist_labeling</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dest_tlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>src_tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ld</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>ls</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>dest_tlist</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>src_tlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>forboth</name><argument_list>(<argument>ld</argument>, <argument>dest_tlist</argument>, <argument>ls</argument>, <argument>src_tlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>dest_tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ld</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>src_tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ls</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dest_tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>==</operator> <name><name>src_tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dest_tle</name><operator>-&gt;</operator><name>resname</name></name> <operator>=</operator> <name><name>src_tle</name><operator>-&gt;</operator><name>resname</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dest_tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name><name>src_tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dest_tle</name><operator>-&gt;</operator><name>resorigtbl</name></name> <operator>=</operator> <name><name>src_tle</name><operator>-&gt;</operator><name>resorigtbl</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dest_tle</name><operator>-&gt;</operator><name>resorigcol</name></name> <operator>=</operator> <name><name>src_tle</name><operator>-&gt;</operator><name>resorigcol</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dest_tle</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>=</operator> <name><name>src_tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * get_sortgroupref_tle
 *        Find the targetlist entry matching the given SortGroupRef index,
 *        and return it.
 */</comment>
<function><type><name>TargetEntry</name> <modifier>*</modifier></type>
<name>get_sortgroupref_tle</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>sortref</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>targetList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>==</operator> <name>sortref</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>tle</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ORDER/GROUP BY expression not found in targetlist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>                <comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * get_sortgroupclause_tle
 *        Find the targetlist entry matching the given SortGroupClause
 *        by ressortgroupref, and return it.
 */</comment>
<function><type><name>TargetEntry</name> <modifier>*</modifier></type>
<name>get_sortgroupclause_tle</name><parameter_list>(<parameter><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgClause</name></decl></parameter>,
                        <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>get_sortgroupref_tle</name><argument_list>(<argument><expr><name><name>sgClause</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_sortgroupclause_expr
 *        Find the targetlist entry matching the given SortGroupClause
 *        by ressortgroupref, and return its expression.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>get_sortgroupclause_expr</name><parameter_list>(<parameter><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sgClause</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>sgClause</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_sortgrouplist_exprs
 *        Given a list of SortGroupClauses, build a list
 *        of the referenced targetlist expressions.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>get_sortgrouplist_exprs</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sgClauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>sgClauses</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>sortexpr</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>sortexpr</name> <operator>=</operator> <call><name>get_sortgroupclause_expr</name><argument_list>(<argument><expr><name>sortcl</name></expr></argument>, <argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>sortexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_distinct_agg_sortgroupclause
 *		Given a pathtarget , acquire distinct clause
 *		for aggref with distinct.
 * Notice: only one distinct agg clause with one col
 * 		is allowed.
 */</comment>
<function><type><name>Aggref</name> <modifier>*</modifier></type>
<name>get_optimize_distinct_agg</name><parameter_list>(<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>pathtarget</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>pathtarget-&gt;exprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>aggref</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggdistinct</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>aggref</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *        Functions to extract data from a list of SortGroupClauses
 *
 * These don't really belong in tlist.c, but they are sort of related to the
 * functions just above, and they don't seem to deserve their own file.
 *****************************************************************************/</comment>

<comment type="block">/*
 * get_sortgroupref_clause
 *        Find the SortGroupClause matching the given SortGroupRef index,
 *        and return it.
 */</comment>
<function><type><name>SortGroupClause</name> <modifier>*</modifier></type>
<name>get_sortgroupref_clause</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>sortref</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>clauses</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>cl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>==</operator> <name>sortref</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>cl</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ORDER/GROUP BY expression not found in list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>                <comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * get_sortgroupref_clause_noerr
 *        As above, but return NULL rather than throwing an error if not found.
 */</comment>
<function><type><name>SortGroupClause</name> <modifier>*</modifier></type>
<name>get_sortgroupref_clause_noerr</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>sortref</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>clauses</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>cl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>==</operator> <name>sortref</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>cl</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * extract_grouping_ops - make an array of the equality operator OIDs
 *        for a SortGroupClause list
 */</comment>
<function><type><name>Oid</name> <modifier>*</modifier></type>
<name>extract_grouping_ops</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>numCols</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>colno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>groupOperators</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>glitem</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>groupOperators</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>glitem</argument>, <argument>groupClause</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>groupcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>glitem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>groupOperators</name><index>[<expr><name>colno</name></expr>]</index></name> <operator>=</operator> <name><name>groupcl</name><operator>-&gt;</operator><name>eqop</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>groupOperators</name><index>[<expr><name>colno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>colno</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>groupOperators</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * extract_grouping_cols - make an array of the grouping column resnos
 *        for a SortGroupClause list
 */</comment>
<function><type><name>AttrNumber</name> <modifier>*</modifier></type>
<name>extract_grouping_cols</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>grpColIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numCols</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>colno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>glitem</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>grpColIdx</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>glitem</argument>, <argument>groupClause</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>groupcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>glitem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>groupcl</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>grpColIdx</name><index>[<expr><name>colno</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>grpColIdx</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * grouping_is_sortable - is it possible to implement grouping list by sorting?
 *
 * This is easy since the parser will have included a sortop if one exists.
 */</comment>
<function><type><name>bool</name></type>
<name>grouping_is_sortable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>glitem</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>glitem</argument>, <argument>groupClause</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>groupcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>glitem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>groupcl</name><operator>-&gt;</operator><name>sortop</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * grouping_is_hashable - is it possible to implement grouping list by hashing?
 *
 * We rely on the parser to have set the hashable flag correctly.
 */</comment>
<function><type><name>bool</name></type>
<name>grouping_is_hashable</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>glitem</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>glitem</argument>, <argument>groupClause</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>groupcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>glitem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>groupcl</name><operator>-&gt;</operator><name>hashable</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *        PathTarget manipulation functions
 *
 * PathTarget is a somewhat stripped-down version of a full targetlist; it
 * omits all the TargetEntry decoration except (optionally) sortgroupref data,
 * and it adds evaluation cost and output data width info.
 *****************************************************************************/</comment>

<comment type="block">/*
 * make_pathtarget_from_tlist
 *      Construct a PathTarget equivalent to the given targetlist.
 *
 * This leaves the cost and width fields as zeroes.  Most callers will want
 * to use create_pathtarget(), so as to get those set.
 */</comment>
<function><type><name>PathTarget</name> <modifier>*</modifier></type>
<name>make_pathtarget_from_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PathTarget</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name></name> <operator>=</operator> <operator>(</operator><name>Index</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>target</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_tlist_from_pathtarget
 *      Construct a targetlist from a PathTarget.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>make_tlist_from_pathtarget</name><parameter_list>(<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>target-&gt;exprs</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>expr</name></expr></argument>,
                              <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * copy_pathtarget
 *      Copy a PathTarget.
 *
 * The new PathTarget has its own List cells, but shares the underlying
 * target expression trees with the old one.  We duplicate the List cells
 * so that items can be added to one target without damaging the other.
 */</comment>
<function><type><name>PathTarget</name> <modifier>*</modifier></type>
<name>copy_pathtarget</name><parameter_list>(<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PathTarget</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Copy scalar fields */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PathTarget</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Shallow-copy the expression list */</comment>
    <expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Duplicate sortgrouprefs if any (if not, the memcpy handled this) */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Size</name></type>        <name>nbytes</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>sortgrouprefs</name></name> <operator>=</operator> <operator>(</operator><name>Index</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>dst</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_empty_pathtarget
 *      Create an empty (zero columns, zero cost) PathTarget.
 */</comment>
<function><type><name>PathTarget</name> <modifier>*</modifier></type>
<name>create_empty_pathtarget</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* This is easy, but we don't want callers to hard-wire this ... */</comment>
    <return>return <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>PathTarget</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * add_column_to_pathtarget
 *        Append a target column to the PathTarget.
 *
 * As with make_pathtarget_from_tlist, we leave it to the caller to update
 * the cost and width fields.
 */</comment>
<function><type><name>void</name></type>
<name>add_column_to_pathtarget</name><parameter_list>(<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>sortgroupref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Updating the exprs list is easy ... */</comment>
    <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* ... the sortgroupref data, a bit less so */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>nexprs</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* This might look inefficient, but actually it's usually cheap */</comment>
        <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name></name> <operator>=</operator> <operator>(</operator><name>Index</name> <operator>*</operator><operator>)</operator>
            <call><name>repalloc</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr></argument>, <argument><expr><name>nexprs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>nexprs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>sortgroupref</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>sortgroupref</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Adding sortgroupref labeling to a previously unlabeled target */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>nexprs</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name></name> <operator>=</operator> <operator>(</operator><name>Index</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nexprs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>nexprs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>sortgroupref</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * add_new_column_to_pathtarget
 *        Append a target column to the PathTarget, but only if it's not
 *        equal() to any pre-existing target expression.
 *
 * The caller cannot specify a sortgroupref, since it would be unclear how
 * to merge that with a pre-existing column.
 *
 * As with make_pathtarget_from_tlist, we leave it to the caller to update
 * the cost and width fields.
 */</comment>
<function><type><name>void</name></type>
<name>add_new_column_to_pathtarget</name><parameter_list>(<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * add_new_columns_to_pathtarget
 *        Apply add_new_column_to_pathtarget() for each element of the list.
 */</comment>
<function><type><name>void</name></type>
<name>add_new_columns_to_pathtarget</name><parameter_list>(<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>exprs</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>add_new_column_to_pathtarget</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * apply_pathtarget_labeling_to_tlist
 *        Apply any sortgrouprefs in the PathTarget to matching tlist entries
 *
 * Here, we do not assume that the tlist entries are one-for-one with the
 * PathTarget.  The intended use of this function is to deal with cases
 * where createplan.c has decided to use some other tlist and we have
 * to identify what matches exist.
 */</comment>
<function><type><name>void</name></type>
<name>apply_pathtarget_labeling_to_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* Nothing to do if PathTarget has no sortgrouprefs data */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>target-&gt;exprs</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * For Vars, use tlist_member_match_var's weakened matching rule;
             * this allows us to deal with some cases where a set-returning
             * function has been inlined, so that we now have more knowledge
             * about what it returns than we did when the original Var was
             * created.  Otherwise, use regular equal() to find the matching
             * TLE.  (In current usage, only the Var case is actually needed;
             * but it seems best to have sane behavior here for non-Vars too.)
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>tlist_member_match_var</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>tlist_member</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="block">/*
             * Complain if noplace for the sortgrouprefs label, or if we'd
             * have to label a column twice.  (The case where it already has
             * the desired label probably can't happen, but we may as well
             * allow for it.)
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ORDER/GROUP BY expression not found in targetlist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                <name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>!=</operator> <name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"targetlist item has multiple sortgroupref labels"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
  * set corresponding sort/group refnos to each target acoording to source
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_sortgrouprefs_to_pathtarget</name><parameter_list>(<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>dest</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>source</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>source</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>dest</name> <operator>==</operator> <name>source</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dest</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>sortgrouprefs</name></name> <operator>=</operator> <operator>(</operator><name>Index</name> <operator>*</operator><operator>)</operator>
            <call><name>palloc0</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>dest</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* 
      * check each target to see if it also appears in source
      * if so, set sortgrouprefs according to source
      */</comment>
    <macro><name>foreach</name><argument_list>(<argument>d</argument>, <argument>dest-&gt;exprs</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>d_expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        
        <macro><name>foreach</name><argument_list>(<argument>s</argument>, <argument>source-&gt;exprs</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>s_expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>s_expr</name></expr></argument>, <argument><expr><name>d_expr</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>source</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block>
        
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * split_pathtarget_at_srfs
 *        Split given PathTarget into multiple levels to position SRFs safely
 *
 * The executor can only handle set-returning functions that appear at the
 * top level of the targetlist of a ProjectSet plan node.  If we have any SRFs
 * that are not at top level, we need to split up the evaluation into multiple
 * plan levels in which each level satisfies this constraint.  This function
 * creates appropriate PathTarget(s) for each level.
 *
 * As an example, consider the tlist expression
 *        x + srf1(srf2(y + z))
 * This expression should appear as-is in the top PathTarget, but below that
 * we must have a PathTarget containing
 *        x, srf1(srf2(y + z))
 * and below that, another PathTarget containing
 *        x, srf2(y + z)
 * and below that, another PathTarget containing
 *        x, y, z
 * When these tlists are processed by setrefs.c, subexpressions that match
 * output expressions of the next lower tlist will be replaced by Vars,
 * so that what the executor gets are tlists looking like
 *        Var1 + Var2
 *        Var1, srf1(Var2)
 *        Var1, srf2(Var2 + Var3)
 *        x, y, z
 * which satisfy the desired property.
 *
 * Another example is
 *        srf1(x), srf2(srf3(y))
 * That must appear as-is in the top PathTarget, but below that we need
 *        srf1(x), srf3(y)
 * That is, each SRF must be computed at a level corresponding to the nesting
 * depth of SRFs within its arguments.
 *
 * In some cases, a SRF has already been evaluated in some previous plan level
 * and we shouldn't expand it again (that is, what we see in the target is
 * already meant as a reference to a lower subexpression).  So, don't expand
 * any tlist expressions that appear in input_target, if that's not NULL.
 *
 * The outputs of this function are two parallel lists, one a list of
 * PathTargets and the other an integer list of bool flags indicating
 * whether the corresponding PathTarget contains any evaluatable SRFs.
 * The lists are given in the order they'd need to be evaluated in, with
 * the "lowest" PathTarget first.  So the last list entry is always the
 * originally given PathTarget, and any entries before it indicate evaluation
 * levels that must be inserted below it.  The first list entry must not
 * contain any SRFs (other than ones duplicating input_target entries), since
 * it will typically be attached to a plan node that cannot evaluate SRFs.
 *
 * Note: using a list for the flags may seem like overkill, since there
 * are only a few possible patterns for which levels contain SRFs.
 * But this representation decouples callers from that knowledge.
 */</comment>
<function><type><name>void</name></type>
<name>split_pathtarget_at_srfs</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                         <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>input_target</name></decl></parameter>,
                         <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targets</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targets_contain_srfs</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>split_pathtarget_context</name></type> <name>context</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>max_depth</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>need_extra_projection</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>prev_level_tlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>lc1</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>lc2</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>lc3</name></decl>;</decl_stmt>

    <comment type="block">/*
     * It's not unusual for planner.c to pass us two physically identical
     * targets, in which case we can conclude without further ado that all
     * expressions are available from the input.  (The logic below would
     * arrive at the same conclusion, but much more tediously.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>target</name> <operator>==</operator> <name>input_target</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>targets</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>targets_contain_srfs</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Pass any input_target exprs down to split_pathtarget_walker() */</comment>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>input_target_exprs</name></name> <operator>=</operator> <ternary><condition><expr><name>input_target</name></expr> ?</condition><then> <expr><name><name>input_target</name><operator>-&gt;</operator><name>exprs</name></name></expr> </then><else>: <expr><name>NIL</name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize with empty level-zero lists, and no levels after that.
     * (Note: we could dispense with representing level zero explicitly, since
     * it will never receive any SRFs, but then we'd have to special-case that
     * level when we get to building result PathTargets.  Level zero describes
     * the SRF-free PathTarget that will be given to the input plan node.)
     */</comment>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>level_srfs</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>level_input_vars</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>level_input_srfs</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Initialize data we'll accumulate across all the target expressions */</comment>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>current_input_vars</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>current_input_srfs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>max_depth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>need_extra_projection</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* Scan each expression in the PathTarget looking for SRFs */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>target-&gt;exprs</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Find all SRFs and Vars (and Var-like nodes) in this expression, and
         * enter them into appropriate lists within the context struct.
         */</comment>
        <expr_stmt><expr><name><name>context</name><operator>.</operator><name>current_depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>split_pathtarget_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* An expression containing no SRFs is of no further interest */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>.</operator><name>current_depth</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Track max SRF nesting depth over the whole PathTarget.  Also, if
         * this expression establishes a new max depth, we no longer care
         * whether previous expressions contained nested SRFs; we can handle
         * any required projection for them in the final ProjectSet node.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>max_depth</name> <operator>&lt;</operator> <name><name>context</name><operator>.</operator><name>current_depth</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>max_depth</name> <operator>=</operator> <name><name>context</name><operator>.</operator><name>current_depth</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>need_extra_projection</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If any maximum-depth SRF is not at the top level of its expression,
         * we'll need an extra Result node to compute the top-level scalar
         * expression.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>max_depth</name> <operator>==</operator> <name><name>context</name><operator>.</operator><name>current_depth</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_SRF_CALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>need_extra_projection</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * If we found no SRFs needing evaluation (maybe they were all present in
     * input_target, or maybe they were all removed by const-simplification),
     * then no ProjectSet is needed; fall out.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>max_depth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>targets</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>targets_contain_srfs</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * The Vars and SRF outputs needed at top level can be added to the last
     * level_input lists if we don't need an extra projection step.  If we do
     * need one, add a SRF-free level to the lists.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>need_extra_projection</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>context</name><operator>.</operator><name>level_srfs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>level_srfs</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>context</name><operator>.</operator><name>level_input_vars</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>level_input_vars</name></name></expr></argument>,
                                           <argument><expr><name><name>context</name><operator>.</operator><name>current_input_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>context</name><operator>.</operator><name>level_input_srfs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>level_input_srfs</name></name></expr></argument>,
                                           <argument><expr><name><name>context</name><operator>.</operator><name>current_input_srfs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_nth_cell</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>level_input_vars</name></name></expr></argument>, <argument><expr><name>max_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>current_input_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_nth_cell</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>level_input_srfs</name></name></expr></argument>, <argument><expr><name>max_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>current_input_srfs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Now construct the output PathTargets.  The original target can be used
     * as-is for the last one, but we need to construct a new SRF-free target
     * representing what the preceding plan node has to emit, as well as a
     * target for each intermediate ProjectSet node.
     */</comment>
    <expr_stmt><expr><operator>*</operator><name>targets</name> <operator>=</operator> <operator>*</operator><name>targets_contain_srfs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>prev_level_tlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <macro><name>forthree</name><argument_list>(<argument>lc1</argument>, <argument>context.level_srfs</argument>,
             <argument>lc2</argument>, <argument>context.level_input_vars</argument>,
             <argument>lc3</argument>, <argument>context.level_input_srfs</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>level_srfs</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>ntarget</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>ntarget</name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>ntarget</name> <operator>=</operator> <call><name>create_empty_pathtarget</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * This target should actually evaluate any SRFs of the current
             * level, and it needs to propagate forward any Vars needed by
             * later levels, as well as SRFs computed earlier and needed by
             * later levels.  We rely on add_new_columns_to_pathtarget() to
             * remove duplicate items.  Also, for safety, make a separate copy
             * of each item for each PathTarget.
             */</comment>
            <expr_stmt><expr><call><name>add_new_columns_to_pathtarget</name><argument_list>(<argument><expr><name>ntarget</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>level_srfs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>lnext(lc2)</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>input_vars</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>add_new_columns_to_pathtarget</name><argument_list>(<argument><expr><name>ntarget</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>input_vars</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>lnext(lc3)</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>input_srfs</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcx</name></decl>;</decl_stmt>

                <macro><name>foreach</name><argument_list>(<argument>lcx</argument>, <argument>input_srfs</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>srf</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>list_member</name><argument_list>(<argument><expr><name>prev_level_tlist</name></expr></argument>, <argument><expr><name>srf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>add_new_column_to_pathtarget</name><argument_list>(<argument><expr><name>ntarget</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>srf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block>
            </block_content>}</block>
            <expr_stmt><expr><call><name>set_pathtarget_cost_width</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ntarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* set sortgrouprefs if needed */</comment>
        <expr_stmt><expr><call><name>set_sortgrouprefs_to_pathtarget</name><argument_list>(<argument><expr><name>ntarget</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Add current target and does-it-compute-SRFs flag to output lists.
         */</comment>
        <expr_stmt><expr><operator>*</operator><name>targets</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targets</name></expr></argument>, <argument><expr><name>ntarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>targets_contain_srfs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><operator>*</operator><name>targets_contain_srfs</name></expr></argument>,
                                            <argument><expr><operator>(</operator><name>level_srfs</name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Remember this level's output for next pass */</comment>
        <expr_stmt><expr><name>prev_level_tlist</name> <operator>=</operator> <name><name>ntarget</name><operator>-&gt;</operator><name>exprs</name></name></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Recursively examine expressions for split_pathtarget_at_srfs.
 *
 * Note we make no effort here to prevent duplicate entries in the output
 * lists.  Duplicates will be gotten rid of later.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>split_pathtarget_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>split_pathtarget_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * A subexpression that matches an expression already computed in
     * input_target can be treated like a Var (which indeed it will be after
     * setrefs.c gets done with it), even if it's actually a SRF.  Record it
     * as being needed for the current expression, and ignore any
     * substructure.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_member</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>input_target_exprs</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_vars</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_vars</name></name></expr></argument>,
                                              <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Vars and Var-like constructs are expected to be gotten from the input,
     * too.  We assume that these constructs cannot contain any SRFs (if one
     * does, there will be an executor failure from a misplaced SRF).
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_vars</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_vars</name></name></expr></argument>,
                                              <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If it's a SRF, recursively examine its inputs, determine its level, and
     * make appropriate entries in the output lists.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IS_SRF_CALL</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>save_input_vars</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>current_input_vars</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>save_input_srfs</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>current_input_srfs</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>save_current_depth</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>current_depth</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>srf_depth</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_vars</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_srfs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>split_pathtarget_walker</name></expr></argument>,
                                      <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Depth is one more than any SRF below it */</comment>
        <expr_stmt><expr><name>srf_depth</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>current_depth</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <comment type="block">/* If new record depth, initialize another level of output lists */</comment>
        <if_stmt><if>if <condition>(<expr><name>srf_depth</name> <operator>&gt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>level_srfs</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>level_srfs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>level_srfs</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>level_input_vars</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>level_input_vars</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>level_input_srfs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>level_input_srfs</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Record this SRF as needing to be evaluated at appropriate level */</comment>
        <expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_nth_cell</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>level_srfs</name></name></expr></argument>, <argument><expr><name>srf_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Record its inputs as being needed at the same level */</comment>
        <expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_nth_cell</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>level_input_vars</name></name></expr></argument>, <argument><expr><name>srf_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_nth_cell</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>level_input_srfs</name></name></expr></argument>, <argument><expr><name>srf_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_srfs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Restore caller-level state and update it for presence of this SRF.
         * Notice we report the SRF itself as being needed for evaluation of
         * surrounding expression.
         */</comment>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_vars</name></name> <operator>=</operator> <name>save_input_vars</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_input_srfs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>save_input_srfs</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>current_depth</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>save_current_depth</name></expr></argument>, <argument><expr><name>srf_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* We're done here */</comment>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Otherwise, the node is a scalar (non-set) expression, so recurse to
     * examine its inputs.
     */</comment>
    <return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>split_pathtarget_walker</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
