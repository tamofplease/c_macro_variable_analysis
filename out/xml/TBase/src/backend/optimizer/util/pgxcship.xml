<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/optimizer/util/pgxcship.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pgxcship.c
 *        Routines to evaluate expression shippability to remote nodes
 *
 * Portions Copyright (c) 1996-2012, PostgreSQL Global Development Group
 * Portions Copyright (c) 2010-2012, Postgres-XC Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/optimizer/util/pgxcship.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_trigger.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pgxcship.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/locator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxcnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/nodemgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_key_values.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
 * Shippability_context
 * This context structure is used by the Fast Query Shipping walker, to gather
 * information during analysing query for Fast Query Shipping.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>bool</name></type>        <name>sc_for_expr</name></decl>;</decl_stmt>        <comment type="block">/* if false, the we are checking shippability
                                     * of the Query, otherwise, we are checking
                                     * shippability of a stand-alone expression.
                                     */</comment>
    <decl_stmt><decl><type><name>Bitmapset</name>    <modifier>*</modifier></type><name>sc_shippability</name></decl>;</decl_stmt>    <comment type="block">/* The conditions for (un)shippability of the
                                     * query.
                                     */</comment>
    <decl_stmt><decl><type><name>Query</name>        <modifier>*</modifier></type><name>sc_query</name></decl>;</decl_stmt>            <comment type="block">/* the query being analysed for FQS */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>sc_query_level</name></decl>;</decl_stmt>        <comment type="block">/* level of the query */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>sc_max_varlevelsup</name></decl>;</decl_stmt>    <comment type="block">/* maximum upper level referred to by any
                                     * variable reference in the query. If this
                                     * value is greater than 0, the query is not
                                     * shippable, if shipped alone.
                                     */</comment>
    <decl_stmt><decl><type><name>ExecNodes</name>    <modifier>*</modifier></type><name>sc_exec_nodes</name></decl>;</decl_stmt>        <comment type="block">/* nodes where the query should be executed */</comment>
    <decl_stmt><decl><type><name>ExecNodes</name>    <modifier>*</modifier></type><name>sc_subquery_en</name></decl>;</decl_stmt>    <comment type="block">/* ExecNodes produced by merging the ExecNodes
                                     * for individual subqueries. This gets
                                     * ultimately merged with sc_exec_nodes.
                                     */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>sc_groupby_has_distcol</name></decl>;</decl_stmt>    <comment type="block">/* GROUP BY clause has distribution column */</comment>
}</block></struct></type> <name>Shippability_context</name>;</typedef>

<comment type="block">/*
 * ShippabilityStat
 * List of reasons why a query/expression is not shippable to remote nodes.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
    <decl><name>SS_UNSHIPPABLE_EXPR</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,    <comment type="block">/* it has unshippable expression */</comment>
    <decl><name>SS_NEED_SINGLENODE</name></decl>,            <comment type="block">/* Has expressions which can be evaluated when
                                 * there is only a single node involved.
                                 * Athought aggregates too fit in this class, we
                                 * have a separate status to report aggregates,
                                 * see below.
                                 */</comment>
    <decl><name>SS_NEEDS_COORD</name></decl>,                <comment type="block">/* the query needs Coordinator */</comment>
    <decl><name>SS_VARLEVEL</name></decl>,                <comment type="block">/* one of its subqueries has a VAR
                                 * referencing an upper level query
                                 * relation
                                 */</comment>
    <decl><name>SS_NO_NODES</name></decl>,                <comment type="block">/* no suitable nodes can be found to ship
                                 * the query
                                 */</comment>
    <decl><name>SS_UNSUPPORTED_EXPR</name></decl>,        <comment type="block">/* it has expressions currently unsupported
                                 * by FQS, but such expressions might be
                                 * supported by FQS in future
                                 */</comment>
    <decl><name>SS_HAS_AGG_EXPR</name></decl>,            <comment type="block">/* it has aggregate expressions */</comment>
    <decl><name>SS_UNSHIPPABLE_TYPE</name></decl>,        <comment type="block">/* the type of expression is unshippable */</comment>
    <decl><name>SS_UNSHIPPABLE_TRIGGER</name></decl>,        <comment type="block">/* the type of trigger is unshippable */</comment>
	<decl><name>SS_UPDATES_DISTRIBUTION_COLUMN</name></decl>,	<comment type="block">/* query updates the distribution column */</comment>
	<decl><name>SS_NEED_FUNC_REWRITE</name></decl>		<comment type="block">/* exist func expression of distribution column,
								 * we should rewrite the expr for FQS 
								 */</comment>
}</block></enum></type> <name>ShippabilityStat</name>;</typedef>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>PoolPingNodes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* Determine if given function is shippable */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgxc_is_func_shippable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* Check equijoin conditions on given relations */</comment>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>pgxc_find_dist_equijoin_qual</name><parameter_list>(<parameter><decl><type><name>Relids</name></type> <name>varnos_1</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>varnos_2</name></decl></parameter>,
                                <parameter><decl><type><name>Oid</name></type> <name>distcol_type</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* Merge given execution nodes based on join shippability conditions */</comment>
<function_decl><type><specifier>static</specifier> <name>ExecNodes</name> <modifier>*</modifier></type><name>pgxc_merge_exec_nodes</name><parameter_list>(<parameter><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>en1</name></decl></parameter>, <parameter><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>en2</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* Check if given Query includes distribution column */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgxc_query_has_distcolgrouping</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Manipulation of shippability reason */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgxc_test_shippability_reason</name><parameter_list>(<parameter><decl><type><name>Shippability_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
                                          <parameter><decl><type><name>ShippabilityStat</name></type> <name>reason</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgxc_set_shippability_reason</name><parameter_list>(<parameter><decl><type><name>Shippability_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
                                         <parameter><decl><type><name>ShippabilityStat</name></type> <name>reason</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgxc_reset_shippability_reason</name><parameter_list>(<parameter><decl><type><name>Shippability_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
                                           <parameter><decl><type><name>ShippabilityStat</name></type> <name>reason</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Evaluation of shippability */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgxc_shippability_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Shippability_context</name> <modifier>*</modifier></type><name>sc_context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgxc_set_exprtype_shippability</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>exprtype</name></decl></parameter>, <parameter><decl><type><name>Shippability_context</name> <modifier>*</modifier></type><name>sc_context</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>ExecNodes</name> <modifier>*</modifier></type><name>pgxc_is_join_shippable</name><parameter_list>(<parameter><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>inner_en</name></decl></parameter>, <parameter><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>outer_en</name></decl></parameter>,
                        <parameter><decl><type><name>Relids</name></type> <name>in_relids</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>out_relids</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
                        <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>join_quals</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtables</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Fast-query shipping (FQS) functions */</comment>
<function_decl><type><specifier>static</specifier> <name>ExecNodes</name> <modifier>*</modifier></type><name>pgxc_FQS_get_relation_nodes</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
                                              <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>,
                                              <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ExecNodes</name> <modifier>*</modifier></type><name>pgxc_FQS_find_datanodes</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgxc_query_needs_coord</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgxc_query_contains_only_pg_catalog</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgxc_is_var_distrib_column</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgxc_distinct_has_distcol</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgxc_targetlist_has_distcol</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ExecNodes</name> <modifier>*</modifier></type><name>pgxc_FQS_find_datanodes_recurse</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
                                            <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>relids</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ExecNodes</name> <modifier>*</modifier></type><name>pgxc_FQS_datanodes_for_rtr</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>ExecNodes</name><modifier>*</modifier></type> <name>pgxc_is_group_subquery_shippable</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>Shippability_context</name> <modifier>*</modifier></type><name>sc_context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgxc_is_rte_subquery_shippable</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Shippability_context</name> <modifier>*</modifier></type><name>sc_context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgxc_is_simple_subquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgxc_FQS_check_subquery_const</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ExecNodes</name> <modifier>*</modifier></type><name>make_FQS_single_node</name><parameter_list>()</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
 * Set the given reason in Shippability_context indicating why the query can not be
 * shipped directly to remote nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgxc_set_shippability_reason</name><parameter_list>(<parameter><decl><type><name>Shippability_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>ShippabilityStat</name></type> <name>reason</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sc_shippability</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>sc_shippability</name></name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pgxc_reset_shippability_reason
 * Reset reason why the query cannot be shipped to remote nodes
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgxc_reset_shippability_reason</name><parameter_list>(<parameter><decl><type><name>Shippability_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>ShippabilityStat</name></type> <name>reason</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sc_shippability</name></name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>sc_shippability</name></name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
</block_content>}</block></function>


<comment type="block">/*
 * See if a given reason is why the query can not be shipped directly
 * to the remote nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgxc_test_shippability_reason</name><parameter_list>(<parameter><decl><type><name>Shippability_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>ShippabilityStat</name></type> <name>reason</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>reason</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>sc_shippability</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pgxc_set_exprtype_shippability
 * Set the expression type shippability. For now composite types
 * derived from view definitions are not shippable.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgxc_set_exprtype_shippability</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>exprtype</name></decl></parameter>, <parameter><decl><type><name>Shippability_context</name> <modifier>*</modifier></type><name>sc_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>    <name>typerelkind</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>typerelkind</name> <operator>=</operator> <call><name>get_rel_relkind</name><argument_list>(<argument><expr><call><name>typeidTypeRelid</name><argument_list>(<argument><expr><name>exprtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>typerelkind</name> <operator>==</operator> <name>RELKIND_SEQUENCE</name> <operator>||</operator>
        <name>typerelkind</name> <operator>==</operator> <name>RELKIND_VIEW</name>        <operator>||</operator>
        <name>typerelkind</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UNSHIPPABLE_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
 * pgxc_FQS_check_const_recurse
 * Recursively check the query node to see if it only contains constant values.
 * We only support all constant values in same leaf nodes, correlated cases are
 * not supported.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgxc_FQS_check_const_recurse</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch<condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_FromExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FromExpr</name>	<modifier>*</modifier></type><name>from_expr</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>	<modifier>*</modifier></type><name>lcell</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		 <name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Only support SELECT for now
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Check the SetOperation to cover the case of
			 * '(const subquery) UNION (const subquery)...'
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>from_expr</name><operator>-&gt;</operator><name>fromlist</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>&amp;&amp;</operator>
					<call><name>IsA</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><call><name>pgxc_FQS_check_const_recurse</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Check if all RTEs contains only constant values */</comment>
			<macro><name>foreach</name> <argument_list>(<argument>lcell</argument>, <argument>from_expr-&gt;fromlist</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	<modifier>*</modifier></type><name>fromlist_entry</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgxc_FQS_check_const_recurse</name><argument_list>(<argument><expr><name>fromlist_entry</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block>
		<case>case <expr><name>T_RangeTblRef</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><call><name>pgxc_FQS_check_subquery_const</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block>
		<case>case <expr><name>T_JoinExpr</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/* TODO: Not supported yet */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block>
		<case>case <expr><name>T_SetOperationStmt</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>setOp</name> <init>= <expr><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Only handle UNION cases */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>setOp</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_UNION</name> <operator>&amp;&amp;</operator>
				<call><name>pgxc_FQS_check_const_recurse</name><argument_list>(<argument><expr><name><name>setOp</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>pgxc_FQS_check_const_recurse</name><argument_list>(<argument><expr><name><name>setOp</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block>
		<default>default:</default>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
	<comment type="block">/* Keep compiler happy */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pgxc_FQS_check_subquery_const
 * Check the query node to see if it only contains constant values, we could
 * provide more shipping optimizations based on this hint.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgxc_FQS_check_subquery_const</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* If all target list entries are T_Const, then we are done. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>query-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Otherwise, check if all RTEs are const */</comment>
	<return>return <expr><call><name>pgxc_FQS_check_const_recurse</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * pgxc_FQS_datanodes_for_rtr
 * For a given RangeTblRef find the datanodes where corresponding data is
 * located.
 */</comment>
<function><type><specifier>static</specifier> <name>ExecNodes</name> <modifier>*</modifier></type>
<name>pgxc_FQS_datanodes_for_rtr</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>RTE_RELATION</name></expr>:</case>
        <block>{<block_content>
            <comment type="block">/* For anything, other than a table, we can't find the datanodes */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
				<name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/*
             * In case of inheritance, child tables can have completely different
             * Datanode distribution than parent. To handle inheritance we need
             * to merge the Datanodes of the children table as well. The inheritance
             * is resolved during planning, so we may not have the RTEs of the
             * children here. Also, the exact method of merging Datanodes of the
             * children is not known yet. So, when inheritance is requested, query
             * can not be shipped.
             * See prologue of has_subclass, we might miss on the optimization
             * because has_subclass can return true even if there aren't any
             * subclasses, but it's ok.
             */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<comment type="block">/* 
			 * all partitioned tables should have the same distribution, try to 
			 * get execution datanodes
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>&amp;&amp;</operator> <call><name>has_subclass</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>&amp;&amp;</operator> <call><name>has_subclass</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<return>return <expr><call><name>pgxc_FQS_get_relation_nodes</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block>
		<break>break;</break>
		<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Query</name> 		<modifier>*</modifier></type><name>subquery</name> <init>= <expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ExecNodes</name> 	<modifier>*</modifier></type><name>exec_nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Consider the case if subquery only contains constant values.
			 * If so, we can treat them as replicated RTE.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>enable_subquery_shipping</name> <operator>&amp;&amp;</operator>
				<call><name>pgxc_FQS_check_subquery_const</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>exec_nodes</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name>LOCATOR_TYPE_REPLICATED</name></expr>;</expr_stmt>
				<comment type="block">/*
				 * No locate info stored for such subquery RTEs, we use this
				 * flag to force using the other hand locate info.
				 */</comment>
				<expr_stmt><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>const_subquery</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<return>return <expr><name>exec_nodes</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Try to process exec_nodes for simple Subquery */</comment>
			<if_stmt><if>if <condition>(<expr><name>enable_subquery_shipping</name> <operator>&amp;&amp;</operator>
				<call><name>pgxc_is_simple_subquery</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Bitmapset</name>	<modifier>*</modifier></type><name>relids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* Recurse into the subquery to find executable datanodes. */</comment>
				<expr_stmt><expr><name>exec_nodes</name> <operator>=</operator> <call><name>pgxc_FQS_find_datanodes_recurse</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>subquery</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>,
															 <argument><expr><name>subquery</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Clean up the relids used in recursion function */</comment>
				<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>relids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Currently we only support Subquery push down to single DN.
				 * Multiple DN pushdown will have cross-phase issues between
				 * main query and subquery, it needs more complicate
				 * calculation. So we just skip the case by now.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>exec_nodes</name> <operator>&amp;&amp;</operator> <name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>&amp;&amp;</operator>
					<operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>exec_nodes</name></expr>;</return></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<comment type="block">/* For any other type of RTE, we return NULL for now */</comment>
		<case>case <expr><name>RTE_JOIN</name></expr>:</case>
		<case>case <expr><name>RTE_CTE</name></expr>:</case>
		<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
		<case>case <expr><name>RTE_VALUES</name></expr>:</case>
		<default>default:</default>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * pgxc_FQS_find_datanodes_recurse
 * Recursively find whether the sub-tree of From Expr rooted under given node is
 * pushable and if yes where.
 */</comment>
<function><type><specifier>static</specifier> <name>ExecNodes</name> <modifier>*</modifier></type>
<name>pgxc_FQS_find_datanodes_recurse</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>		<modifier>*</modifier></type><name>query_rtable</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch<condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_FromExpr</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FromExpr</name>	<modifier>*</modifier></type><name>from_expr</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>	<modifier>*</modifier></type><name>lcell</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>first</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Bitmapset</name>	<modifier>*</modifier></type><name>from_relids</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ExecNodes</name>	<modifier>*</modifier></type><name>result_en</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * For INSERT commands, we won't have any entries in the from list.
			 * Get the datanodes using the resultRelation index.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>from_expr</name><operator>-&gt;</operator><name>fromlist</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>relids</name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><call><name>pgxc_FQS_datanodes_for_rtr</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>,
														<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * All the entries in the From list are considered to be INNER
			 * joined with the quals as the JOIN condition. Get the datanodes
			 * for the first entry in the From list. For every subsequent entry
			 * determine whether the join between the relation in that entry and
			 * the cumulative JOIN of previous entries can be pushed down to the
			 * datanodes and the corresponding set of datanodes where the join
			 * can be pushed down.
			 */</comment>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result_en</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>from_relids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<macro><name>foreach</name> <argument_list>(<argument>lcell</argument>, <argument>from_expr-&gt;fromlist</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>fromlist_entry</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>fle_relids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>tmp_en</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>en</name> <init>= <expr><call><name>pgxc_FQS_find_datanodes_recurse</name><argument_list>(<argument><expr><name>fromlist_entry</name></expr></argument>,
																<argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fle_relids</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<comment type="block">/*
				 * If any entry in fromlist is not shippable, jointree is not
				 * shippable
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>en</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>FreeExecNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_en</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* FQS does't ship a DML with more than one relation involved */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name> <operator>&amp;&amp;</operator> <name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>FreeExecNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_en</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>result_en</name> <operator>=</operator> <name>en</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>from_relids</name> <operator>=</operator> <name>fle_relids</name></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>tmp_en</name> <operator>=</operator> <name>result_en</name></expr>;</expr_stmt>
				<comment type="block">/*
				 * Check whether the JOIN is pushable to the datanodes and
				 * find the datanodes where the JOIN can be pushed to
				 */</comment>
				<expr_stmt><expr><name>result_en</name> <operator>=</operator> <call><name>pgxc_is_join_shippable</name><argument_list>(<argument><expr><name>result_en</name></expr></argument>, <argument><expr><name>en</name></expr></argument>, <argument><expr><name>from_relids</name></expr></argument>,
										<argument><expr><name>fle_relids</name></expr></argument>, <argument><expr><name>JOIN_INNER</name></expr></argument>,
										<argument><expr><call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name><name>from_expr</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                                        <argument><expr><name>query</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                        <argument><expr><name>query_rtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>from_relids</name> <operator>=</operator> <call><name>bms_join</name><argument_list>(<argument><expr><name>from_relids</name></expr></argument>, <argument><expr><name>fle_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>FreeExecNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp_en</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>

            <expr_stmt><expr><operator>*</operator><name>relids</name> <operator>=</operator> <name>from_relids</name></expr>;</expr_stmt>
            <return>return <expr><name>result_en</name></expr>;</return>
        </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_RangeTblRef</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><operator>*</operator><name>relids</name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>pgxc_FQS_datanodes_for_rtr</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_JoinExpr</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>join_expr</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>l_relids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>r_relids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>len</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>ren</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>result_en</name></decl>;</decl_stmt>

            <comment type="block">/* FQS does't ship a DML with more than one relation involved */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pgxc_FQS_find_datanodes_recurse</name><argument_list>(<argument><expr><name><name>join_expr</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
                                                                <argument><expr><operator>&amp;</operator><name>l_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ren</name> <operator>=</operator> <call><name>pgxc_FQS_find_datanodes_recurse</name><argument_list>(<argument><expr><name><name>join_expr</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
                                                                <argument><expr><operator>&amp;</operator><name>r_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* If either side of JOIN is unshippable, JOIN is unshippable */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name> <operator>||</operator> <operator>!</operator><name>ren</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>FreeExecNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>FreeExecNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ren</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/*
             * Check whether the JOIN is pushable or not, and find the datanodes
             * where the JOIN can be pushed to.
             */</comment>
            <expr_stmt><expr><name>result_en</name> <operator>=</operator> <call><name>pgxc_is_join_shippable</name><argument_list>(<argument><expr><name>ren</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>r_relids</name></expr></argument>, <argument><expr><name>l_relids</name></expr></argument>,
                                                <argument><expr><name><name>join_expr</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>,
                                                <argument><expr><call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name><name>join_expr</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                                                <argument><expr><name>query</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                                <argument><expr><name>query_rtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FreeExecNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FreeExecNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ren</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>relids</name> <operator>=</operator> <call><name>bms_join</name><argument_list>(<argument><expr><name>l_relids</name></expr></argument>, <argument><expr><name>r_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>result_en</name></expr>;</return>
        </block_content>}</block>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><operator>*</operator><name>relids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
            <break>break;</break>
    </block_content>}</block></switch>
    <comment type="block">/* Keep compiler happy */</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pgxc_FQS_find_datanodes
 * Find the list of nodes where to ship query.
 */</comment>
<function><type><specifier>static</specifier> <name>ExecNodes</name> <modifier>*</modifier></type>
<name>pgxc_FQS_find_datanodes</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Bitmapset</name>    <modifier>*</modifier></type><name>relids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExecNodes</name>    <modifier>*</modifier></type><name>exec_nodes</name></decl>;</decl_stmt>

    <comment type="block">/*
     * For SELECT, the datanodes required to execute the query is obtained from
     * the join tree of the query
     */</comment>
    <expr_stmt><expr><name>exec_nodes</name> <operator>=</operator> <call><name>pgxc_FQS_find_datanodes_recurse</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>,
                                                        <argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>relids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* If we found the datanodes to ship, use them */</comment>
    <if_stmt><if>if <condition>(<expr><name>exec_nodes</name> <operator>&amp;&amp;</operator> <name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If relations involved in the query are such that ultimate JOIN is
         * replicated JOIN, choose only one of them. If one of them is a
         * preferred node choose that one, otherwise choose the first one.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsLocatorReplicated</name><argument_list>(<argument><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>baselocatortype</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>exec_nodes</name><operator>-&gt;</operator><name>accesstype</name></name> <operator>==</operator> <name>RELATION_ACCESS_READ</name> <operator>||</operator>
            <name><name>exec_nodes</name><operator>-&gt;</operator><name>accesstype</name></name> <operator>==</operator> <name>RELATION_ACCESS_READ_FQS</name> <operator>||</operator>
            <name><name>exec_nodes</name><operator>-&gt;</operator><name>accesstype</name></name> <operator>==</operator> <name>RELATION_ACCESS_READ_FOR_UPDATE</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>tmp_list</name> <init>= <expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>GetPreferredReplicationNode</name><argument_list>(<argument><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>tmp_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>exec_nodes</name></expr>;</return>
    </block_content>}</block></if>
    <comment type="block">/*
     * If we found the expression which can decide which can be used to decide
     * where to ship the query, use that
     */</comment>
    <if type="elseif">else if <condition>(<expr><name>exec_nodes</name> <operator>&amp;&amp;</operator> <name><name>exec_nodes</name><operator>-&gt;</operator><name>en_expr</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>exec_nodes</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* No way to figure out datanodes to ship the query to */</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>create_dis_col_eval</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>discol</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>quals</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
    
    <if_stmt><if>if<condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>lexpr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>rexpr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type> <name>op</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator><name>quals</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* could not be '=' */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
                
        <expr_stmt><expr><name>lexpr</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rexpr</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>lexpr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name><operator>*</operator><operator>)</operator><name>lexpr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>rexpr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name><operator>*</operator><operator>)</operator><name>rexpr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><name>discol</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name>lexpr</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* must be '=' */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_mergejoinable</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>lexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                    <operator>!</operator><call><name>op_hashjoinable</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>lexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>result</name></expr>;</return></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>copyObject</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><name>discol</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name>rexpr</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* must be '=' */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_mergejoinable</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>lexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                    <operator>!</operator><call><name>op_hashjoinable</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>lexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>result</name></expr>;</return></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>copyObject</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator><name>quals</name><operator>)</operator><operator>-&gt;</operator><name>boolop</name> <operator>==</operator> <name>AND_EXPR</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BoolExpr</name> <modifier>*</modifier></type> <name>bexpr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator><name>quals</name></expr></init></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>bexpr-&gt;args</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>lexpr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>create_dis_col_eval</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>lexpr</name></expr></argument>, <argument><expr><name>discol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if<condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>


    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pgxc_FQS_get_relation_nodes
 * Return ExecNodes structure so as to decide which node the query should
 * execute on. If it is possible to set the node list directly, set it.
 * Otherwise set the appropriate distribution column expression or relid in
 * ExecNodes structure.
 */</comment>
<function><type><specifier>static</specifier> <name>ExecNodes</name> <modifier>*</modifier></type>
<name>pgxc_FQS_get_relation_nodes</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CmdType</name></type> <name>command_type</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>for_update</name> <init>= <expr><ternary><condition><expr><name><name>query</name><operator>-&gt;</operator><name>rowMarks</name></name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExecNodes</name>    <modifier>*</modifier></type><name>rel_exec_nodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelationAccessType</name></type> <name>rel_access</name> <init>= <expr><name>RELATION_ACCESS_READ</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rel_loc_info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>retry</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name> <operator>==</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><operator>(</operator><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name>command_type</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>CMD_SELECT</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>for_update</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_READ_FOR_UPDATE</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_READ_FQS</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>

        <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
        <case>case <expr><name>CMD_DELETE</name></expr>:</case>
            <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_UPDATE</name></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>CMD_INSERT</name></expr>:</case>
            <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_INSERT</name></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <comment type="block">/* should not happen, but */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unrecognised command type %d"</literal></expr></argument>, <argument><expr><name>command_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><name>rel_loc_info</name> <operator>=</operator> <call><name>GetRelationLocInfo</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* If we don't know about the distribution of relation, bail out */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>rel_loc_info</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Find out the datanodes to execute this query on.
     * But first if it's a replicated table, identify and remove
     * unhealthy nodes from the rel_loc_info. Only for SELECTs!
     *
     * PGXC_FQS_TODO: for now, we apply node reduction only when there is only
     * one relation involved in the query. If there are multiple distributed
     * tables in the query and we apply node reduction here, we may fail to ship
     * the entire join. We should apply node reduction transitively.
     */</comment>
<label><name>retry_pools</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>command_type</name> <operator>==</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator>
            <name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_REPLICATED</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>healthmap</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>healthmap</name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>TBASE_MAX_DATANODE_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>healthmap</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory for healthmap"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><call><name>PgxcNodeDnListHealth</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr></argument>, <argument><expr><name>healthmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel_loc_info-&gt;rl_nodeList</argument>)</argument_list></macro>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>healthmap</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>newlist</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>newlist</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>

        <if_stmt><if>if <condition>(<expr><name>healthmap</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>healthmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>healthmap</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>newlist</name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>rl_nodeList</name></name> <operator>=</operator> <call><name>list_difference_int</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr></argument>,
                                                     <argument><expr><name>newlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/*
         * If all nodes are down, cannot do much, just return NULL here
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>rl_nodeList</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Try an on-demand pool maintenance just to see if some nodes
             * have come back.
             *
             * Try once and error out if datanodes are still down
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>retry</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>rl_nodeList</name></name> <operator>=</operator> <name>newlist</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>newlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PoolPingNodes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>retry</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <goto>goto <name>retry_pools</name>;</goto>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                 <argument><expr><literal type="string">"Could not find healthy datanodes for replicated table. Exiting!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>rel_exec_nodes</name> <operator>=</operator> <call><name>GetRelationNodesByQuals</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>,
                                                 <argument><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>rel_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
        <decl_stmt><decl><type><name>int32</name></type>    <name>nGroup</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name>     <modifier>*</modifier></type><name>groups</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>command_type</name> <operator>==</operator> <name>CMD_INSERT</name> <operator>&amp;&amp;</operator> <name><name>query</name><operator>-&gt;</operator><name>onConflict</name></name><operator>)</operator> <operator>||</operator> <name>command_type</name> <operator>==</operator> <name>CMD_SELECT</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>GetRelationSecondGroup</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>groups</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>nGroup</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name>nGroup</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"table in cold-hot group or key-value group could not join with other tables."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name>rel_exec_nodes</name> <operator>=</operator> <call><name>GetRelationNodes</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
                                  <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>rel_access</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>rel_exec_nodes</name> <operator>=</operator> <call><name>GetRelationNodes</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
                                          <argument><expr><name>true</name></expr></argument>, <argument><expr><name>rel_access</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>rel_exec_nodes</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>rel_access</name> <operator>==</operator> <name>RELATION_ACCESS_INSERT</name> <operator>||</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator><operator>&amp;&amp;</operator>
             <call><name>IsRelationDistributedByValue</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
        <comment type="block">/*
         * If the INSERT is happening on a table distributed by value of a
         * column, find out the
         * expression for distribution column in the targetlist, and stick in
         * in ExecNodes, and clear the nodelist. Execution will find
         * out where to insert the row.
         */</comment>
        <comment type="block">/* It is a partitioned table, get value by looking in targetList */</comment>
        <if_stmt><if>if<condition>(<expr><name>rel_access</name> <operator>==</operator> <name>RELATION_ACCESS_INSERT</name></expr>)</condition>
        <block>{<block_content>
            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>query-&gt;targetList</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>tle</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>, <argument><expr><call><name>GetRelationDistribColumn</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <if_stmt><if>if <condition>(<expr><call><name>expression_returns_set</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>rel_exec_nodes</name><operator>-&gt;</operator><name>en_expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <expr_stmt><expr><name><name>rel_exec_nodes</name><operator>-&gt;</operator><name>en_expr</name></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifndef>
                    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>, <argument><expr><call><name>GetRelationSecDistribColumn</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><call><name>expression_returns_set</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>rel_exec_nodes</name><operator>-&gt;</operator><name>sec_en_expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>rel_exec_nodes</name><operator>-&gt;</operator><name>sec_en_expr</name></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* got both distribute key, done */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>rel_exec_nodes</name><operator>-&gt;</operator><name>en_expr</name></name> <operator>&amp;&amp;</operator> <name><name>rel_exec_nodes</name><operator>-&gt;</operator><name>sec_en_expr</name></name></expr>)</condition>
                <block>{<block_content>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            </block_content>}</block>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_HASH</name> <operator>||</operator> <name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>quals</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>rel_exec_nodes</name><operator>-&gt;</operator><name>en_expr</name></name> <operator>=</operator> <call><name>create_dis_col_eval</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>partAttrNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>rel_exec_nodes</name><operator>-&gt;</operator><name>sec_en_expr</name></name> <operator>=</operator> <call><name>create_dis_col_eval</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/* Not found, bail out */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rel_exec_nodes</name><operator>-&gt;</operator><name>en_expr</name></name></expr>)</condition>        
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><name>rel_access</name> <operator>!=</operator> <name>RELATION_ACCESS_INSERT</name></expr>)</condition><block type="pseudo"><block_content>                
                <return>return <expr><name>rel_exec_nodes</name></expr>;</return></block_content></block></if>        
            <else>else<block type="pseudo"><block_content>                
                <return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/* We found the TargetEntry for the partition column */</comment>
        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>rel_exec_nodes</name><operator>-&gt;</operator><name>primarynodelist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rel_exec_nodes</name><operator>-&gt;</operator><name>primarynodelist</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>rel_exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rel_exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rel_exec_nodes</name><operator>-&gt;</operator><name>en_relid</name></name> <operator>=</operator> <name><name>rel_loc_info</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>rel_exec_nodes</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgxc_query_has_distcolgrouping</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>lcell</name></decl>;</decl_stmt>
    <macro><name>foreach</name> <argument_list>(<argument>lcell</argument>, <argument>query-&gt;groupClause</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name>     <modifier>*</modifier></type><name>sgc</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name>                <modifier>*</modifier></type><name>sgc_expr</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>sgc</name></expr></argument>, <argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>sgc_expr</name> <operator>=</operator> <call><name>get_sortgroupclause_expr</name><argument_list>(<argument><expr><name>sgc</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>sgc_expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name>sgc_expr</name><operator>)</operator><operator>-&gt;</operator><name>varlevelsup</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
            <call><name>pgxc_is_var_distrib_column</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name>sgc_expr</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgxc_distinct_has_distcol</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>lcell</name></decl>;</decl_stmt>
    <macro><name>foreach</name> <argument_list>(<argument>lcell</argument>, <argument>query-&gt;distinctClause</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name>     <modifier>*</modifier></type><name>sgc</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name>                <modifier>*</modifier></type><name>sgc_expr</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>sgc</name></expr></argument>, <argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>sgc_expr</name> <operator>=</operator> <call><name>get_sortgroupclause_expr</name><argument_list>(<argument><expr><name>sgc</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>sgc_expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name>sgc_expr</name><operator>)</operator><operator>-&gt;</operator><name>varlevelsup</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
            <call><name>pgxc_is_var_distrib_column</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name>sgc_expr</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pgxc_shippability_walker
 * walks the query/expression tree routed at the node passed in, gathering
 * information which will help decide whether the query to which this node
 * belongs is shippable to the Datanodes.
 *
 * The function should try to walk the entire tree analysing each subquery for
 * shippability. If a subquery is shippable but not the whole query, we would be
 * able to create a RemoteQuery node for that subquery, shipping it to the
 * Datanode.
 *
 * Return value of this function is governed by the same rules as
 * expression_tree_walker(), see prologue of that function for details.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgxc_shippability_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Shippability_context</name> <modifier>*</modifier></type><name>sc_context</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Below is the list of nodes that can appear in a query, examine each
     * kind of node and find out under what conditions query with this node can
     * be shippable. For each node, update the context (add fields if
     * necessary) so that decision whether to FQS the query or not can be made.
     * Every node which has a result is checked to see if the result type of that
     * expression is shippable.
     */</comment>
    <switch>switch<condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Constants are always shippable */</comment>
        <case>case <expr><name>T_Const</name></expr>:</case>
            <expr_stmt><expr><call><name>pgxc_set_exprtype_shippability</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sc_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

            <comment type="block">/*
             * For placeholder nodes the shippability of the node, depends upon the
             * expression which they refer to. It will be checked separately, when
             * that expression is encountered.
             */</comment>
        <case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
            <expr_stmt><expr><call><name>pgxc_set_exprtype_shippability</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sc_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

            <comment type="block">/*
             * record_in() function throws error, thus requesting a result in the
             * form of anonymous record from datanode gets into error. Hence, if the
             * top expression of a target entry is ROW(), it's not shippable.
             */</comment>
        <case>case <expr><name>T_TargetEntry</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name></type> <name>typtype</name> <init>= <expr><call><name>get_typtype</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>typtype</name> <operator>||</operator> <name>typtype</name> <operator>==</operator> <name>TYPTYPE_PSEUDO</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UNSHIPPABLE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <break>break;</break>

        <case>case <expr><name>T_SortGroupClause</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_for_expr</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UNSUPPORTED_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>CoerceViaIO</name>        <modifier>*</modifier></type><name>cvio</name> <init>= <expr><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>                <name>input_type</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>cvio</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>                <name>output_type</name> <init>= <expr><name><name>cvio</name><operator>-&gt;</operator><name>resulttype</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>CoercionContext</name></type>    <name>cc</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>cc</name> <operator>=</operator> <ternary><condition><expr><name><name>cvio</name><operator>-&gt;</operator><name>coerceformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name></expr> ?</condition><then> <expr><name>COERCION_IMPLICIT</name></expr> </then><else>:
                <expr><name>COERCION_EXPLICIT</name></expr></else></ternary></expr>;</expr_stmt>

            <comment type="block">/* now we decide to push down the const value type cast */</comment>
            <if_stmt><if>if <condition>(<expr><name>COERCION_IMPLICIT</name> <operator>==</operator> <name>cc</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>cvio</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>

            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>can_coerce_type</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output_type</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Internally we use IO coercion for types which do not have casting
                 * defined for them e.g. cstring::date. If such casts are sent to
                 * the datanode, those won't be accepted. Hence such casts are
                 * unshippable. Since it will be shown as an explicit cast.
                 */</comment>
                <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UNSHIPPABLE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>pgxc_set_exprtype_shippability</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sc_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <break>break;</break>
        <comment type="block">/*
         * Nodes, which are shippable if the tree rooted under these nodes is
         * shippable
         */</comment>
        <case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
            <comment type="block">/*
             * PGXCTODO: mostly, CoerceToDomainValue node appears in DDLs,
             * do we handle DDLs here?
             */</comment>
        <case>case <expr><name>T_FieldSelect</name></expr>:</case>
        <case>case <expr><name>T_NamedArgExpr</name></expr>:</case>
        <case>case <expr><name>T_RelabelType</name></expr>:</case>
        <case>case <expr><name>T_BoolExpr</name></expr>:</case>
            <comment type="block">/*
             * PGXCTODO: we might need to take into account the kind of boolean
             * operator we have in the quals and see if the corresponding
             * function is immutable.
             */</comment>
        <case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
        <case>case <expr><name>T_ConvertRowtypeExpr</name></expr>:</case>
        <case>case <expr><name>T_CaseExpr</name></expr>:</case>
        <case>case <expr><name>T_ArrayExpr</name></expr>:</case>
        <case>case <expr><name>T_RowExpr</name></expr>:</case>
        <case>case <expr><name>T_CollateExpr</name></expr>:</case>
        <case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
        <case>case <expr><name>T_XmlExpr</name></expr>:</case>
        <case>case <expr><name>T_NullTest</name></expr>:</case>
        <case>case <expr><name>T_BooleanTest</name></expr>:</case>
        <case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
            <expr_stmt><expr><call><name>pgxc_set_exprtype_shippability</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sc_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_List</name></expr>:</case>
            <break>break;</break>
            
        <case>case <expr><name>T_RangeTblRef</name></expr>:</case>
            <block>{<block_content>
                <comment type="block">/* Check whether we are in a subquery, if we are check the shippable of the subquery. */</comment>
                <expr_stmt><expr><call><name>pgxc_is_rte_subquery_shippable</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>sc_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_ArrayRef</name></expr>:</case>
            <comment type="block">/*
             * When multiple values of of an array are updated at once
             * FQS planner cannot yet handle SQL representation correctly.
             * So disable FQS in this case and let standard planner manage it.
             */</comment>
        <case>case <expr><name>T_FieldStore</name></expr>:</case>
            <comment type="block">/*
             * PostgreSQL deparsing logic does not handle the FieldStore
             * for more than one fields (see processIndirection()). So, let's
             * handle it through standard planner, where whole row will be
             * constructed.
             */</comment>
        <case>case <expr><name>T_SetToDefault</name></expr>:</case>
            <comment type="block">/*
             * PGXCTODO: we should actually check whether the default value to
             * be substituted is shippable to the Datanode. Some cases like
             * nextval() of a sequence can not be shipped to the Datanode, hence
             * for now default values can not be shipped to the Datanodes
             */</comment>
            <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UNSUPPORTED_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pgxc_set_exprtype_shippability</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sc_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_Var</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Var</name>    <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
            <comment type="block">/*
             * if a subquery references an upper level variable, that query is
             * not shippable, if shipped alone.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>&gt;</operator> <name><name>sc_context</name><operator>-&gt;</operator><name>sc_max_varlevelsup</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_max_varlevelsup</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>pgxc_set_exprtype_shippability</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sc_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <break>break;</break>

        <case>case <expr><name>T_Param</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Param</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
            <comment type="block">/* PGXCTODO: Can we handle internally generated parameters? */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>!=</operator> <name>PARAM_EXTERN</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UNSUPPORTED_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>pgxc_set_exprtype_shippability</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sc_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <break>break;</break>

        <case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
        <block>{<block_content>
            <comment type="block">/*
             * Ideally we should not see CurrentOf expression here, it
             * should have been replaced by the CTID = ? expression. But
             * still, no harm in shipping it as is.
             */</comment>
            <expr_stmt><expr><call><name>pgxc_set_exprtype_shippability</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sc_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <break>break;</break>

        <case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
            <comment type="block">/*
             * XXX PG10MERGE: Do we really need to do any checks here?
             * Shouldn't all SQLValueFunctions be shippable?
             */</comment>
            <expr_stmt><expr><call><name>pgxc_set_exprtype_shippability</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sc_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_NextValueExpr</name></expr>:</case>
            <comment type="block">/*
             * We must not FQS NextValueExpr since it could be used for
             * distribution key and it should get mapped to the correct
             * datanode.
             */</comment>
            <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UNSHIPPABLE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_Aggref</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
            <comment type="block">/*
             * An aggregate is completely shippable to the Datanode, if the
             * whole group resides on that Datanode. This will be clear when
             * we see the GROUP BY clause.
             * agglevelsup is minimum of variable's varlevelsup, so we will
             * set the sc_max_varlevelsup when we reach the appropriate
             * VARs in the tree.
             */</comment>
            <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_HAS_AGG_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/*
             * If a stand-alone expression to be shipped, is an
             * 1. aggregate with ORDER BY, DISTINCT directives, it needs all
             * the qualifying rows
             * 2. aggregate without collection function
             * 3. (PGXCTODO:)aggregate with polymorphic transition type, the
             *    the transition type needs to be resolved to correctly interpret
             *    the transition results from Datanodes.
             * Hence, such an expression can not be shipped to the datanodes.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggorder</name></name> <operator>||</operator>
                <name><name>aggref</name><operator>-&gt;</operator><name>aggdistinct</name></name> <operator>||</operator>
                <name><name>aggref</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>||</operator>
                <operator>!</operator><name><name>aggref</name><operator>-&gt;</operator><name>agghas_collectfn</name></name> <operator>||</operator>
                <call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggtrantype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_NEED_SINGLENODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>pgxc_set_exprtype_shippability</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sc_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <break>break;</break>

        <case>case <expr><name>T_FuncExpr</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>FuncExpr</name>    <modifier>*</modifier></type><name>funcexpr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
            <comment type="block">/*
             * PGXC_FQS_TODO: it's too restrictive not to ship non-immutable
             * functions to the Datanode. We need a better way to see what
             * can be shipped to the Datanode and what can not be.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgxc_is_func_shippable</name><argument_list>(<argument><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Ship insert if function doesn't return set */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_query</name></name> <operator>&amp;&amp;</operator>
					<name><name>sc_context</name><operator>-&gt;</operator><name>sc_query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><operator>(</operator><name><name>funcexpr</name><operator>-&gt;</operator><name>funcretset</name></name> <operator>&amp;&amp;</operator> <name><name>sc_context</name><operator>-&gt;</operator><name>sc_for_expr</name></name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_NEED_FUNC_REWRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UNSHIPPABLE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>funcexpr</name><operator>-&gt;</operator><name>funcretset</name></name> <operator>&amp;&amp;</operator> <name><name>sc_context</name><operator>-&gt;</operator><name>sc_for_expr</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UNSHIPPABLE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>pgxc_set_exprtype_shippability</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sc_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <break>break;</break>

        <case>case <expr><name>T_OpExpr</name></expr>:</case>
        <case>case <expr><name>T_DistinctExpr</name></expr>:</case>    <comment type="block">/* struct-equivalent to OpExpr */</comment>
        <case>case <expr><name>T_NullIfExpr</name></expr>:</case>        <comment type="block">/* struct-equivalent to OpExpr */</comment>
        <block>{<block_content>
            <comment type="block">/*
             * All of these three are structurally equivalent to OpExpr, so
             * cast the node to OpExpr and check if the operator function is
             * immutable. See PGXC_FQS_TODO item for FuncExpr.
             */</comment>
            <decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op_expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>        <name>opfuncid</name> <init>= <expr><ternary><condition><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>op_expr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then>
                <expr><name><name>op_expr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr> </then><else>: <expr><call><name>get_opcode</name><argument_list>(<argument><expr><name><name>op_expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call> <operator>||</operator>
                <operator>!</operator><call><name>pgxc_is_func_shippable</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UNSHIPPABLE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>pgxc_set_exprtype_shippability</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sc_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <break>break;</break>

        <case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
        <block>{<block_content>
            <comment type="block">/*
             * Check if the operator function is shippable to the Datanode
             * PGXC_FQS_TODO: see immutability note for FuncExpr above
             */</comment>
            <decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>sao_expr</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>        <name>opfuncid</name> <init>= <expr><ternary><condition><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>sao_expr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then>
                <expr><name><name>sao_expr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr> </then><else>: <expr><call><name>get_opcode</name><argument_list>(<argument><expr><name><name>sao_expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call> <operator>||</operator>
                <operator>!</operator><call><name>pgxc_is_func_shippable</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UNSHIPPABLE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>
        <break>break;</break>

        <case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
        <case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
        <block>{<block_content>
            <comment type="block">/*
             * PGXCTODO should we be checking the comparision operator
             * functions as well, as we did for OpExpr OR that check is
             * unnecessary. Operator functions are always shippable?
             * Otherwise this node should be treated similar to other
             * "shell" nodes.
             */</comment>
            <expr_stmt><expr><call><name>pgxc_set_exprtype_shippability</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sc_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <break>break;</break>

        <case>case <expr><name>T_Query</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type>   <name>tree_examine_ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>exec_nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* A stand-alone expression containing Query is not shippable */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_for_expr</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UNSHIPPABLE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/*
             * We are checking shippability of whole query, go ahead. The query
             * in the context should be same as the query being checked
             */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>query</name> <operator>==</operator> <name><name>sc_context</name><operator>-&gt;</operator><name>sc_query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* CREATE TABLE AS is not supported in FQS */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name> <operator>&amp;&amp;</operator>
                <call><name>IsA</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>CreateTableAsStmt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UNSUPPORTED_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasRecursive</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UNSUPPORTED_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* Queries with FOR UPDATE/SHARE can't be shipped */</comment>
        <comment type="line">//    if (query-&gt;hasForUpdate || query-&gt;rowMarks)</comment>
            <comment type="line">//    pgxc_set_shippability_reason(sc_context, SS_UNSUPPORTED_EXPR);</comment>

            <comment type="block">/*
             * If the query needs Coordinator for evaluation or the query can be
             * completed on Coordinator itself, we don't ship it to the Datanode
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>pgxc_query_needs_coord</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_NEEDS_COORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* PGXCTODO: It should be possible to look at the Query and find out
             * whether it can be completely evaluated on the Datanode just like SELECT
             * queries. But we need to be careful while finding out the Datanodes to
             * execute the query on, esp. for the result relations. If one happens to
             * remove/change this restriction, make sure you change
             * pgxc_FQS_get_relation_nodes appropriately.
             * For now DMLs with single rtable entry are candidates for FQS
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
				 * Try to shipping insert with multiple rtables. Skip FQS if it
				 * contains subquery.
				 */</comment>
                <if_stmt><if>if<condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name> <operator>&amp;&amp;</operator> <name><name>query</name><operator>-&gt;</operator><name>onConflict</name></name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
                    
                    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>query-&gt;rtable</argument>)</argument_list></macro>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>tbl</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if<condition>(<expr><name><name>tbl</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UNSUPPORTED_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block>

                    <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UNSUPPORTED_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UNSUPPORTED_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * In following conditions query is shippable when there is only one
             * Datanode involved
             * 1. the query has aggregagtes without grouping by distribution
             *    column
             * 2. the query has window functions
             * 3. the query has ORDER BY clause
             * 4. the query has Distinct clause without distribution column in
             *    distinct clause
             * 5. the query has limit and offset clause
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>||</operator>
                <name><name>query</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_NEED_SINGLENODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Presence of aggregates or having clause, implies grouping. In
             * such cases, the query won't be shippable unless 1. there is only
             * a single node involved 2. GROUP BY clause has distribution column
             * in it. In the later case aggregates for a given group are entirely
             * computable on a single datanode, because all the rows
             * participating in particular group reside on that datanode.
             * The distribution column can be of any relation
             * participating in the query. All the rows of that relation with
             * the same value of distribution column reside on same node.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>query</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name><operator>)</operator></expr>)</condition>
            <block>{<block_content>    
                <comment type="block">/* Check whether the sub query is shippable */</comment>
                <expr_stmt><expr><name>exec_nodes</name> <operator>=</operator> <call><name>pgxc_is_group_subquery_shippable</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>sc_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>exec_nodes</name></expr>)</condition>
                <block>{<block_content>
                    
                </block_content>}</block></if>
                <if type="elseif">else if<condition>(<expr><operator>!</operator><call><name>pgxc_query_has_distcolgrouping</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_NEED_SINGLENODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            

            <comment type="block">/*
             * If distribution column of any relation is present in the distinct
             * clause, values for that column across nodes will differ, thus two
             * nodes won't be able to produce same result row. Hence in such
             * case, we can execute the queries on many nodes managing to have
             * distinct result.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>pgxc_distinct_has_distcol</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_NEED_SINGLENODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name><operator>)</operator> <operator>&amp;&amp;</operator>
                    <call><name>pgxc_targetlist_has_distcol</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UPDATES_DISTRIBUTION_COLUMN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <comment type="block">/*
             * Check shippability of triggers on this query. Don't consider
             * TRUNCATE triggers; it's a utility statement and triggers are
             * handled explicitly in ExecuteTruncate()
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator>
                <name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name> <operator>||</operator>
                <name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator>
                    <call><name>list_nth</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgxc_check_triggers_shippability</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
                                                      <argument><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>hasUnshippableTriggers</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>,
                                                 <argument><expr><name>SS_UNSHIPPABLE_TRIGGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* We have to check update triggers if insert...on conflict do update... */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>onConflict</name></name> <operator>&amp;&amp;</operator> <name><name>query</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgxc_check_triggers_shippability</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
                                      <argument><expr><name>CMD_UPDATE</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>hasUnshippableTriggers</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>,
                                                     <argument><expr><name>SS_UNSHIPPABLE_TRIGGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * PGXCTODO: For the time being Postgres-XC does not support
                 * global constraints, but once it does it will be necessary
                 * to add here evaluation of the shippability of indexes and
                 * constraints of the relation used for INSERT/UPDATE/DELETE.
                 */</comment>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="block">/*
             * walk the entire query tree to analyse the query. We will walk the
             * range table, when examining the FROM clause. No need to do it
             * here
             */</comment>
            <expr_stmt><expr><name>tree_examine_ret</name> <operator>=</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>pgxc_shippability_walker</name></expr></argument>,
                                    <argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>QTW_IGNORE_RANGE_TABLE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>tree_examine_ret</name></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>exec_nodes</name> <operator>=</operator> <name><name>sc_context</name><operator>-&gt;</operator><name>sc_exec_nodes</name></name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/*
             * PGXC_FQS_TODO:
             * There is a subquery in this query, which references Vars in the upper
             * query. For now stop shipping such queries. We should get rid of this
             * condition.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_max_varlevelsup</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_VARLEVEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Walk the join tree of the query and find the
             * Datanodes needed for evaluating this query
             */</comment>
            <expr_stmt><expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_exec_nodes</name></name> <operator>=</operator> <call><name>pgxc_FQS_find_datanodes</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
            sc_context-&gt;sc_exec_nodes = pgxc_merge_exec_nodes(exec_nodes, sc_context-&gt;sc_exec_nodes);            
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block>
        <break>break;</break>

        <case>case <expr><name>T_FromExpr</name></expr>:</case>
        <block>{<block_content>
            <comment type="block">/* We don't expect FromExpr in a stand-alone expression */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_for_expr</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UNSUPPORTED_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * We will examine the jointree of query separately to determine the
             * set of datanodes where to execute the query.
             * If this is an INSERT query with quals, resulting from say
             * conditional rule, we can not handle those in FQS, since there is
             * not SQL representation for such quals.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name> <operator>&amp;&amp;</operator>
                <operator>(</operator><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator><name>node</name><operator>)</operator><operator>-&gt;</operator><name>quals</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UNSUPPORTED_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        </block_content>}</block>
        <break>break;</break>

        <case>case <expr><name>T_WindowFunc</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>winf</name> <init>= <expr><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
            <comment type="block">/*
             * A window function can be evaluated on a Datanode if there is
             * only one Datanode involved.
             */</comment>
            <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_NEED_SINGLENODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * A window function is not shippable as part of a stand-alone
             * expression. If the window function is non-immutable, it can not
             * be shipped to the datanodes.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_for_expr</name></name> <operator>||</operator>
                <operator>!</operator><call><name>pgxc_is_func_shippable</name><argument_list>(<argument><expr><name><name>winf</name><operator>-&gt;</operator><name>winfnoid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UNSHIPPABLE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>pgxc_set_exprtype_shippability</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sc_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <break>break;</break>

        <case>case <expr><name>T_WindowClause</name></expr>:</case>
        <block>{<block_content>
            <comment type="block">/*
             * A window function can be evaluated on a Datanode if there is
             * only one Datanode involved.
             */</comment>
            <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_NEED_SINGLENODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * A window function is not shippable as part of a stand-alone
             * expression
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_for_expr</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UNSHIPPABLE_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>
        <break>break;</break>

        <case>case <expr><name>T_JoinExpr</name></expr>:</case>
            <comment type="block">/* We don't expect JoinExpr in a stand-alone expression */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_for_expr</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UNSUPPORTED_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * The shippability of join will be deduced while
             * examining the jointree of the query. Nothing to do here
             */</comment>
            <break>break;</break>

        <case>case <expr><name>T_SubLink</name></expr>:</case>
        <block>{<block_content>
            <comment type="block">/*
             * We need to walk the tree in sublink to check for its
             * shippability. We need to call pgxc_is_query_shippable() on Query
             * instead of this function so that every subquery gets a different
             * context for itself. We should avoid the default expression walker
             * getting called on the subquery. At the same time we don't want to
             * miss any other member (current or future) of this structure, from
             * being scanned. So, copy the SubLink structure with subselect
             * being NULL and call expression_tree_walker on the copied
             * structure.
             */</comment>
            <decl_stmt><decl><type><name>SubLink</name></type>        <name>sublink</name> <init>= <expr><operator>*</operator><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ExecNodes</name>    <modifier>*</modifier></type><name>sublink_en</name></decl>;</decl_stmt>
            <comment type="block">/*
             * Walk the query and find the nodes where the query should be
             * executed and node distribution. Merge this with the existing
             * node list obtained for other subqueries. If merging fails, we
             * can not ship the whole query.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>sublink</name><operator>.</operator><name>subselect</name></name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>sublink_en</name> <operator>=</operator> <call><name>pgxc_is_query_shippable</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>sublink</name><operator>.</operator><name>subselect</name></name><operator>)</operator></expr></argument>,
                                                     <argument><expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_query_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>sublink_en</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="block">/* PGXCTODO free the old sc_subquery_en. */</comment>
            <comment type="block">/* If we already know that this query does not have a set of nodes
             * to evaluate on, don't bother to merge again.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgxc_test_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_NO_NODES</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * If this is the first time we are finding out the nodes for
                 * SubLink, we don't have anything to merge, just assign.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sc_context</name><operator>-&gt;</operator><name>sc_subquery_en</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_subquery_en</name></name> <operator>=</operator> <name>sublink_en</name></expr>;</expr_stmt></block_content></block></if>
                <comment type="block">/*
                 * Merge if only the accumulated SubLink ExecNodes and the
                 * ExecNodes for this subquery are both replicated.
                 */</comment>
                <if type="elseif">else if <condition>(<expr><name>sublink_en</name> <operator>&amp;&amp;</operator> <call><name>IsExecNodesReplicated</name><argument_list>(<argument><expr><name>sublink_en</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                            <call><name>IsExecNodesReplicated</name><argument_list>(<argument><expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_subquery_en</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_subquery_en</name></name> <operator>=</operator> <call><name>pgxc_merge_exec_nodes</name><argument_list>(<argument><expr><name>sublink_en</name></expr></argument>,
                                                                   <argument><expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_subquery_en</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_subquery_en</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <comment type="block">/*
                 * If we didn't find a cumulative ExecNodes, set shippability
                 * reason, so that we don't bother merging future sublinks.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sc_context</name><operator>-&gt;</operator><name>sc_subquery_en</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_NO_NODES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>sc_context</name><operator>-&gt;</operator><name>sc_subquery_en</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="block">/* Check if the type of sublink result is shippable */</comment>
            <expr_stmt><expr><call><name>pgxc_set_exprtype_shippability</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sc_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Wipe out subselect as explained above and walk the copied tree */</comment>
            <expr_stmt><expr><name><name>sublink</name><operator>.</operator><name>subselect</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sublink</name></expr></argument>, <argument><expr><name>pgxc_shippability_walker</name></expr></argument>,
                                            <argument><expr><name>sc_context</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <break>break;</break>

        <case>case <expr><name>T_OnConflictExpr</name></expr>:</case>
        <block>{<block_content>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block>

        <case>case <expr><name>T_SubPlan</name></expr>:</case>
        <case>case <expr><name>T_AlternativeSubPlan</name></expr>:</case>
        <case>case <expr><name>T_CommonTableExpr</name></expr>:</case>
        <case>case <expr><name>T_SetOperationStmt</name></expr>:</case>
        <case>case <expr><name>T_PlaceHolderVar</name></expr>:</case>
        <case>case <expr><name>T_AppendRelInfo</name></expr>:</case>
        <case>case <expr><name>T_PlaceHolderInfo</name></expr>:</case>
        <case>case <expr><name>T_WithCheckOption</name></expr>:</case>
        <block>{<block_content>
            <comment type="block">/* PGXCTODO: till we exhaust this list */</comment>
            <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_UNSUPPORTED_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/*
             * These expressions are not supported for shippability entirely, so
             * there is no need to walk trees underneath those. If we do so, we
             * might walk the trees with wrong context there.
             */</comment>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block>
        <break>break;</break>

        <case>case <expr><name>T_GroupingFunc</name></expr>:</case>
            <comment type="block">/*
             * Let expression tree walker inspect the arguments. Not sure if
             * that's necessary, as those are just references to grouping
             * expressions of the query (and thus likely examined as part
             * of another node).
             */</comment>
            <return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>pgxc_shippability_walker</name></expr></argument>,
                                          <argument><expr><name>sc_context</name></expr></argument>)</argument_list></call></expr>;</return>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>pgxc_shippability_walker</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>sc_context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pgxc_query_needs_coord
 * Check if the query needs Coordinator for evaluation or it can be completely
 * evaluated on Coordinator. Return true if so, otherwise return false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgxc_query_needs_coord</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * If the query involves just the catalog tables, and is not an EXEC DIRECT
     * statement, it can be evaluated completely on the Coordinator. No need to
     * involve Datanodes.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>pgxc_query_contains_only_pg_catalog</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pgxc_is_var_distrib_column
 * Check if given var is a distribution key.
 */</comment>
<function><type><specifier>static</specifier>
<name>bool</name></type> <name>pgxc_is_var_distrib_column</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>RangeTblEntry</name>   <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelationLocInfo</name>    <modifier>*</modifier></type><name>rel_loc_info</name></decl>;</decl_stmt>

    <comment type="block">/* distribution column only applies to the relations */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name> <operator>||</operator>
        <name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rel_loc_info</name> <operator>=</operator> <call><name>GetRelationLocInfo</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>rel_loc_info</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>rel_loc_info</name><operator>-&gt;</operator><name>partAttrNum</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>rel_loc_info</name><operator>-&gt;</operator><name>partAttrNum</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgxc_is_shard_in_same_group</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var1</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var2</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name>   <modifier>*</modifier></type><name>rte1</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>var1</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelationLocInfo</name>    <modifier>*</modifier></type><name>rel_loc_info1</name> <init>= <expr><call><name>GetRelationLocInfo</name><argument_list>(<argument><expr><name><name>rte1</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name>   <modifier>*</modifier></type><name>rte2</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>var2</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelationLocInfo</name>    <modifier>*</modifier></type><name>rel_loc_info2</name> <init>= <expr><call><name>GetRelationLocInfo</name><argument_list>(<argument><expr><name><name>rte2</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>rel_loc_info1</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name> <operator>&amp;&amp;</operator>
        <name><name>rel_loc_info2</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>rel_loc_info1</name><operator>-&gt;</operator><name>groupId</name></name> <operator>!=</operator> <name><name>rel_loc_info2</name><operator>-&gt;</operator><name>groupId</name></name> <operator>||</operator>
            <call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info1</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info2</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>rel_loc_info1</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name> <operator>&amp;&amp;</operator>
             <name><name>rel_loc_info2</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>!=</operator> <name>LOCATOR_TYPE_SHARD</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>rel_loc_info1</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>!=</operator> <name>LOCATOR_TYPE_SHARD</name> <operator>&amp;&amp;</operator>
             <name><name>rel_loc_info2</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check is the subquery is simple enough to pushdown to DN
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgxc_is_simple_subquery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Let's just make sure it's a valid select ...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Can't currently pushdown a query with setops (unless it's simple UNION
	 * ALL, which is handled by a different code path).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Can't pushdown a subquery involving grouping, aggregation, SRFs,
	 * sorting, limiting, or WITH.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>hasForUpdate</name></name> <operator>||</operator>
		<name><name>query</name><operator>-&gt;</operator><name>cteList</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't pushdown a subquery that has any volatile functions in its
	 * targetlist.  Otherwise we might introduce multiple evaluations of these
	 * functions, if they get copied to multiple places in the upper query,
	 * leading to surprising results.  (Note: the PlaceHolderVar mechanism
	 * doesn't quite guarantee single evaluation; else we could pull up anyway
	 * and just wrap such items in PlaceHolderVars ...)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Returns whether or not the rtable (and its subqueries)
 * only contain pg_catalog entries.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgxc_query_contains_only_pg_catalog</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

    <comment type="block">/* May be complicated. Before giving up, just check for pg_catalog usage */</comment>
    <macro><name>foreach</name><argument_list>(<argument>item</argument>, <argument>rtable</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PG_CATALOG_NAMESPACE</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name> <operator>&amp;&amp;</operator>
                 <operator>!</operator><call><name>pgxc_query_contains_only_pg_catalog</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Construct ExecNodes for single datanode to fqs
 */</comment>
<function><type><specifier>static</specifier> <name>ExecNodes</name> <modifier>*</modifier></type>
<name>make_FQS_single_node</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExecNodes</name>       <modifier>*</modifier></type><name>exec_nodes</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>exec_nodes</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>accesstype</name></name> <operator>=</operator> <name>RELATION_ACCESS_READ_FQS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>exec_nodes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pgxc_is_query_shippable
 * This function calls the query walker to analyse the query to gather
 * information like  Constraints under which the query can be shippable, nodes
 * on which the query is going to be executed etc.
 * Based on the information gathered, it decides whether the query can be
 * executed on Datanodes directly without involving Coordinator.
 * If the query is shippable this routine also returns the nodes where the query
 * should be shipped. If the query is not shippable, it returns NULL.
 */</comment>
<function><type><name>ExecNodes</name> <modifier>*</modifier></type>
<name>pgxc_is_query_shippable</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>query_level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Shippability_context</name></type> <name>sc_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecNodes</name>	<modifier>*</modifier></type><name>exec_nodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>canShip</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>	<modifier>*</modifier></type><name>shippability</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sc_context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sc_context</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* let's assume that by default query is shippable */</comment>
	<expr_stmt><expr><name><name>sc_context</name><operator>.</operator><name>sc_query</name></name> <operator>=</operator> <name>query</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sc_context</name><operator>.</operator><name>sc_query_level</name></name> <operator>=</operator> <name>query_level</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sc_context</name><operator>.</operator><name>sc_for_expr</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We might have already decided not to ship the query to the Datanodes, but
	 * still walk it anyway to find out if there are any subqueries which can be
	 * shipped.
	 */</comment>
	<expr_stmt><expr><call><name>pgxc_shippability_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sc_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>exec_nodes</name> <operator>=</operator> <name><name>sc_context</name><operator>.</operator><name>sc_exec_nodes</name></name></expr>;</expr_stmt>

	<comment type="block">/* For single datanode and select command, if we don't need coord
	 * and exec_nodes exists, return it directly. But if exec_nodes is
	 * NULL we make exec_nodes for FQS;
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>SS_NEEDS_COORD</name></expr></argument>, <argument><expr><name><name>sc_context</name><operator>.</operator><name>sc_shippability</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>NumDataNodes</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>exec_nodes</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>exec_nodes</name></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><call><name>make_FQS_single_node</name><argument_list>()</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
		
	<comment type="block">/*
	 * The shippability context contains two ExecNodes, one for the subLinks
	 * involved in the Query and other for the relation involved in FromClause.
	 * They are computed at different times while scanning the query. Merge both
	 * of them if they are both replicated. If query doesn't have SubLinks, we
	 * don't need to consider corresponding ExecNodes.
	 * PGXC_FQS_TODO:
	 * Merge the subquery ExecNodes if both of them are replicated.
	 * The logic to merge node lists with other distribution
	 * strategy is not clear yet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>)</condition>
	<block>{<block_content>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<decl_stmt><decl><type><name>int</name></type> <name>num_fromclause_nodes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>num_sublink_nodes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Get number of DN nodes for Main Query result */</comment>
		<if_stmt><if>if <condition>(<expr><name>exec_nodes</name> <operator>&amp;&amp;</operator> <name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>num_fromclause_nodes</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Get number of DN nodes for Sublink result */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>sc_context</name><operator>.</operator><name>sc_subquery_en</name></name> <operator>&amp;&amp;</operator> <name><name>sc_context</name><operator>.</operator><name>sc_subquery_en</name><operator>-&gt;</operator><name>nodeList</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>num_sublink_nodes</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>sc_context</name><operator>.</operator><name>sc_subquery_en</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Try to merge sublink nodelist only if:
		 * XXX Only cover CMD_SELECT
		 * XXX Both main query and sublink results got single DN node
		 * XXX With same column distributed type
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>enable_subquery_shipping</name> <operator>&amp;&amp;</operator>
			<name>exec_nodes</name> <operator>&amp;&amp;</operator> <name><name>sc_context</name><operator>.</operator><name>sc_subquery_en</name></name> <operator>&amp;&amp;</operator>
			<name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator>
			<call><name>IsExecNodesColumnDistributed</name><argument_list>(<argument><expr><name>exec_nodes</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>IsExecNodesColumnDistributed</name><argument_list>(<argument><expr><name><name>sc_context</name><operator>.</operator><name>sc_subquery_en</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>exec_nodes</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>==</operator> <name><name>sc_context</name><operator>.</operator><name>sc_subquery_en</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>num_fromclause_nodes</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>num_sublink_nodes</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>exec_nodes</name> <operator>=</operator> <call><name>pgxc_merge_exec_nodes</name><argument_list>(<argument><expr><name>exec_nodes</name></expr></argument>, <argument><expr><name><name>sc_context</name><operator>.</operator><name>sc_subquery_en</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<comment type="block">/* Fall back to PGXC logic that only try with replicated type */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if type="elseif">else if <condition>(<expr><name>exec_nodes</name> <operator>&amp;&amp;</operator> <call><name>IsExecNodesReplicated</name><argument_list>(<argument><expr><name>exec_nodes</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <name><name>sc_context</name><operator>.</operator><name>sc_subquery_en</name></name> <operator>&amp;&amp;</operator>
				 <call><name>IsExecNodesReplicated</name><argument_list>(<argument><expr><name><name>sc_context</name><operator>.</operator><name>sc_subquery_en</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>exec_nodes</name> <operator>=</operator> <call><name>pgxc_merge_exec_nodes</name><argument_list>(<argument><expr><name>exec_nodes</name></expr></argument>, <argument><expr><name><name>sc_context</name><operator>.</operator><name>sc_subquery_en</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>exec_nodes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Look at the information gathered by the walker in Shippability_context and that
	 * in the Query structure to decide whether we should ship this query
	 * directly to the Datanode or not
	 */</comment>

	<comment type="block">/*
	 * If the planner was not able to find the Datanodes to the execute the
	 * query, the query is not completely shippable. So, return NULL
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>exec_nodes</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Copy the shippability reasons. We modify the copy for easier handling.
     * The original can be saved away */</comment>
    <expr_stmt><expr><name>shippability</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>sc_context</name><operator>.</operator><name>sc_shippability</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If the query has an expression which renders the shippability to single
     * node, and query needs to be shipped to more than one node, it can not be
     * shipped
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>SS_NEED_SINGLENODE</name></expr></argument>, <argument><expr><name>shippability</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * if nodeList has no nodes, it ExecNodes will have other means to know
         * the nodes where to execute like distribution column expression. We
         * can't tell how many nodes the query will be executed on, hence treat
         * that as multiple nodes.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator>
            <operator>!</operator><operator>(</operator><operator>(</operator><name><name>exec_nodes</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>==</operator> <name>LOCATOR_TYPE_HASH</name>
                <operator>||</operator> <name><name>exec_nodes</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name><operator>)</operator>
                <operator>&amp;&amp;</operator> <operator>(</operator><name><name>exec_nodes</name><operator>-&gt;</operator><name>en_expr</name></name> <operator>||</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>canShip</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* We handled the reason here, reset it */</comment>
        <expr_stmt><expr><name>shippability</name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name>shippability</name></expr></argument>, <argument><expr><name>SS_NEED_SINGLENODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If HAS_AGG_EXPR is set but NEED_SINGLENODE is not set, it means the
     * aggregates are entirely shippable, so don't worry about it.
     */</comment>
    <expr_stmt><expr><name>shippability</name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name>shippability</name></expr></argument>, <argument><expr><name>SS_HAS_AGG_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If an insert sql command whose distribute key's value is a
	 * function, we allow it to be shipped to datanode. But we must
	 * must know the function's result before real execute. So set
	 * the flag to identify rewrite in ExecutePlan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>SS_NEED_FUNC_REWRITE</name></expr></argument>, <argument><expr><name>shippability</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>IsLocatorColumnDistributed</name><argument_list>(<argument><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>baselocatortype</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsLocatorDistributedByValue</name><argument_list>(<argument><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>baselocatortype</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>need_rewrite</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>shippability</name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name>shippability</name></expr></argument>, <argument><expr><name>SS_NEED_FUNC_REWRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>need_rewrite</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Can not ship the query for some reason */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>shippability</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>canShip</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Always keep this at the end before checking canShip and return */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>canShip</name> <operator>&amp;&amp;</operator> <name>exec_nodes</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FreeExecNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>exec_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* If query is to be shipped, we should know where to execute the query */</comment>
    <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><operator>!</operator><name>canShip</name> <operator>||</operator> <name>exec_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>shippability</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>shippability</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <return>return <expr><name>exec_nodes</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pgxc_is_expr_shippable
 * Check whether the given expression can be shipped to datanodes.
 *
 * Note on has_aggs
 * The aggregate expressions are not shippable if they can not be completely
 * evaluated on a single datanode. But this function does not have enough
 * context to determine the set of datanodes where the expression will be
 * evaluated. Hence, the caller of this function can handle aggregate
 * expressions, it passes a non-NULL value for has_aggs. This function returns
 * whether the expression has any aggregates or not through this argument. If a
 * caller passes NULL value for has_aggs, this function assumes that the caller
 * can not handle the aggregates and deems the expression has unshippable.
 */</comment>
<function><type><name>bool</name></type>
<name>pgxc_is_expr_shippable</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>has_aggs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Shippability_context</name></type> <name>sc_context</name></decl>;</decl_stmt>

    <comment type="block">/* Create the FQS context */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sc_context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sc_context</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sc_context</name><operator>.</operator><name>sc_query</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sc_context</name><operator>.</operator><name>sc_query_level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sc_context</name><operator>.</operator><name>sc_for_expr</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/* Walk the expression to check its shippability */</comment>
    <expr_stmt><expr><call><name>pgxc_shippability_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sc_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If caller is interested in knowing, whether the expression has aggregates
     * let the caller know about it. The caller is capable of handling such
     * expressions. Otherwise assume such an expression as not shippable.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>has_aggs</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>has_aggs</name> <operator>=</operator> <call><name>pgxc_test_shippability_reason</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sc_context</name></expr></argument>, <argument><expr><name>SS_HAS_AGG_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>pgxc_test_shippability_reason</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sc_context</name></expr></argument>, <argument><expr><name>SS_HAS_AGG_EXPR</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* Done with aggregate expression shippability. Delete the status */</comment>
    <expr_stmt><expr><call><name>pgxc_reset_shippability_reason</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sc_context</name></expr></argument>, <argument><expr><name>SS_HAS_AGG_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If there are reasons why the expression is unshippable, return false */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>sc_context</name><operator>.</operator><name>sc_shippability</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If nothing wrong found, the expression is shippable */</comment>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pgxc_is_func_shippable
 * Determine if a function is shippable
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgxc_is_func_shippable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives    </comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    
    <switch>switch<condition>(<expr><name>funcid</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* convert function */</comment>
        <case>case  <expr><literal type="number">395</literal></expr> :</case> <comment type="block">/* array_to_string */</comment>
        <case>case  <expr><literal type="number">384</literal></expr> :</case> <comment type="block">/* array_to_string */</comment>
        <case>case <expr><literal type="number">1171</literal></expr> :</case> <comment type="block">/* date_part       */</comment>
        <case>case <expr><literal type="number">1717</literal></expr> :</case> <comment type="block">/* convert_to       */</comment>
        <case>case <expr><literal type="number">1770</literal></expr> :</case> <comment type="block">/* to_char           */</comment>
        <case>case <expr><literal type="number">1772</literal></expr> :</case> <comment type="block">/* to_char           */</comment>
        <case>case <expr><literal type="number">1773</literal></expr> :</case> <comment type="block">/* to_char           */</comment>
        <case>case <expr><literal type="number">1774</literal></expr> :</case> <comment type="block">/* to_char           */</comment>
        <case>case <expr><literal type="number">1775</literal></expr> :</case> <comment type="block">/* to_char           */</comment>
        <case>case <expr><literal type="number">1776</literal></expr> :</case> <comment type="block">/* to_char           */</comment>
        <case>case <expr><literal type="number">1777</literal></expr> :</case> <comment type="block">/* to_number       */</comment>
        <case>case <expr><literal type="number">1778</literal></expr> :</case> <comment type="block">/* to_timestamp    */</comment>
        <case>case <expr><literal type="number">1780</literal></expr> :</case> <comment type="block">/* to_date           */</comment>
        <case>case <expr><literal type="number">1768</literal></expr> :</case> <comment type="block">/* to_char           */</comment>
        <case>case <expr><literal type="number">2049</literal></expr> :</case> <comment type="block">/* to_char           */</comment>
        <case>case <expr><literal type="number">3153</literal></expr> :</case> <comment type="block">/* array_to_json   */</comment>
        <case>case <expr><literal type="number">3154</literal></expr> :</case> <comment type="block">/* array_to_json   */</comment>
        <case>case <expr><literal type="number">3155</literal></expr> :</case> <comment type="block">/* row_to_json       */</comment>
        <case>case <expr><literal type="number">3156</literal></expr> :</case> <comment type="block">/* row_to_json       */</comment>
        <case>case <expr><literal type="number">3176</literal></expr> :</case> <comment type="block">/* to_json           */</comment>
        <case>case <expr><literal type="number">3714</literal></expr> :</case> <comment type="block">/* ts_token_type   */</comment>
        <case>case <expr><literal type="number">3749</literal></expr> :</case> <comment type="block">/* to_tsvector       */</comment>
        <case>case <expr><literal type="number">3750</literal></expr> :</case> <comment type="block">/* to_tsquery       */</comment>
        <case>case <expr><literal type="number">3751</literal></expr> :</case> <comment type="block">/* plainto_tsquery */</comment>

        <case>case <expr><literal type="number">1299</literal></expr> :</case> <comment type="block">/* now() */</comment>
        <case>case <expr><literal type="number">1174</literal></expr> :</case> <comment type="block">/* convert date to timestamp with time zone */</comment>
        <case>case <expr><literal type="number">2024</literal></expr> :</case> <comment type="block">/* convert date to timestamp */</comment>
        <case>case <expr><literal type="number">2019</literal></expr> :</case> <comment type="block">/* convert timestamp with time zone to time */</comment>
        <case>case <expr><literal type="number">1178</literal></expr> :</case> <comment type="block">/* convert timestamp with time zone to date */</comment>
        <case>case <expr><literal type="number">2027</literal></expr> :</case> <comment type="block">/* convert timestamp with time zone to timestamp */</comment>
        <case>case <expr><literal type="number">2029</literal></expr> :</case> <comment type="block">/* convert timestamp to date */</comment>
        <case>case <expr><literal type="number">2028</literal></expr> :</case> <comment type="block">/* convert timestamp to timestamp with time zone */</comment>
        <case>case <expr><literal type="number">1316</literal></expr> :</case> <comment type="block">/* convert timestamp to time */</comment>

        <case>case <expr><literal type="number">3438</literal></expr> :</case> <comment type="block">/* convert text to timestamp with out time zone */</comment>
        <case>case <expr><literal type="number">3449</literal></expr> :</case> <comment type="block">/* convert text to date compatible with oracle */</comment>
        <case>case <expr><literal type="number">3437</literal></expr> :</case> <comment type="block">/* convert text to timestamp with time zone */</comment>
        <case>case <expr><literal type="number">3434</literal></expr> :</case> <comment type="block">/* convert text to timestamp with time zone */</comment>

        <comment type="block">/* timestamp compare function */</comment>        
        <case>case <expr><literal type="number">2338</literal></expr> :</case> <comment type="block">/* date_lt_timestamp    */</comment>
        <case>case <expr><literal type="number">2339</literal></expr> :</case> <comment type="block">/* date_le_timestamp    */</comment>
        <case>case <expr><literal type="number">2340</literal></expr> :</case> <comment type="block">/* date_eq_timestamp    */</comment>
        <case>case <expr><literal type="number">2341</literal></expr> :</case> <comment type="block">/* date_gt_timestamp    */</comment>
        <case>case <expr><literal type="number">2342</literal></expr> :</case> <comment type="block">/* date_ge_timestamp    */</comment>
        <case>case <expr><literal type="number">2343</literal></expr> :</case> <comment type="block">/* date_ne_timestamp    */</comment>
        <case>case <expr><literal type="number">2344</literal></expr> :</case> <comment type="block">/* date_cmp_timestamp   */</comment>
        <case>case <expr><literal type="number">2351</literal></expr> :</case> <comment type="block">/* date_lt_timestamptz  */</comment>
        <case>case <expr><literal type="number">2352</literal></expr> :</case> <comment type="block">/* date_le_timestamptz  */</comment>
        <case>case <expr><literal type="number">2353</literal></expr> :</case> <comment type="block">/* date_eq_timestamptz  */</comment>
        <case>case <expr><literal type="number">2354</literal></expr> :</case> <comment type="block">/* date_gt_timestamptz  */</comment>
        <case>case <expr><literal type="number">2355</literal></expr> :</case> <comment type="block">/* date_ge_timestamptz  */</comment>
        <case>case <expr><literal type="number">2356</literal></expr> :</case> <comment type="block">/* date_ne_timestamptz  */</comment>
        <case>case <expr><literal type="number">2357</literal></expr> :</case> <comment type="block">/* date_cmp_timestamptz */</comment>
        <case>case <expr><literal type="number">1189</literal></expr> :</case> <comment type="block">/* timestamptz_pl_interval   */</comment>
        <case>case <expr><literal type="number">1190</literal></expr> :</case> <comment type="block">/* timestamptz_mi_interval   */</comment>
        <case>case <expr><literal type="number">2377</literal></expr> :</case> <comment type="block">/* timestamptz_lt_date       */</comment>
        <case>case <expr><literal type="number">2378</literal></expr> :</case> <comment type="block">/* timestamptz_le_date       */</comment>
        <case>case <expr><literal type="number">2379</literal></expr> :</case> <comment type="block">/* timestamptz_eq_date       */</comment>
        <case>case <expr><literal type="number">2380</literal></expr> :</case> <comment type="block">/* timestamptz_gt_date       */</comment>
        <case>case <expr><literal type="number">2381</literal></expr> :</case> <comment type="block">/* timestamptz_ge_date       */</comment>
        <case>case <expr><literal type="number">2382</literal></expr> :</case> <comment type="block">/* timestamptz_ne_date       */</comment>
        <case>case <expr><literal type="number">2383</literal></expr> :</case> <comment type="block">/* timestamptz_cmp_date      */</comment>
        <case>case <expr><literal type="number">2520</literal></expr> :</case> <comment type="block">/* timestamp_lt_timestamptz  */</comment>
        <case>case <expr><literal type="number">2521</literal></expr> :</case> <comment type="block">/* timestamp_le_timestamptz  */</comment>
        <case>case <expr><literal type="number">2522</literal></expr> :</case> <comment type="block">/* timestamp_eq_timestamptz  */</comment>
        <case>case <expr><literal type="number">2523</literal></expr> :</case> <comment type="block">/* timestamp_gt_timestamptz  */</comment>
        <case>case <expr><literal type="number">2524</literal></expr> :</case> <comment type="block">/* timestamp_ge_timestamptz  */</comment>
        <case>case <expr><literal type="number">2525</literal></expr> :</case> <comment type="block">/* timestamp_ne_timestamptz  */</comment>
        <case>case <expr><literal type="number">2526</literal></expr> :</case> <comment type="block">/* timestamp_cmp_timestamptz */</comment>
        <case>case <expr><literal type="number">2527</literal></expr> :</case> <comment type="block">/* timestamptz_lt_timestamp  */</comment>
        <case>case <expr><literal type="number">2528</literal></expr> :</case> <comment type="block">/* timestamptz_le_timestamp  */</comment>
        <case>case <expr><literal type="number">2529</literal></expr> :</case> <comment type="block">/* timestamptz_eq_timestamp  */</comment>
        <case>case <expr><literal type="number">2530</literal></expr> :</case> <comment type="block">/* timestamptz_gt_timestamp  */</comment>
        <case>case <expr><literal type="number">2531</literal></expr> :</case> <comment type="block">/* timestamptz_ge_timestamp  */</comment>
        <case>case <expr><literal type="number">2532</literal></expr> :</case> <comment type="block">/* timestamptz_ne_timestamp  */</comment>
        <case>case <expr><literal type="number">2533</literal></expr> :</case> <comment type="block">/* timestamptz_cmp_timestamp */</comment>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
            
        <default>default:</default>
        <block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>func_volatile</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PROVOLATILE_VOLATILE</name><operator>)</operator></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
    </block_content>}</block></switch>
    <return>return <expr><name>result</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/*
     * For the time being a function is thought as shippable
     * only if it is immutable.
     */</comment>
    <return>return <expr><operator>(</operator><call><name>func_volatile</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PROVOLATILE_IMMUTABLE</name><operator>)</operator></expr>;</return>    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    
</block_content>}</block></function>


<comment type="block">/*
 * pgxc_find_dist_equijoin_qual
 * Check equijoin conditions on given relations
 */</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>pgxc_find_dist_equijoin_qual</name><parameter_list>(<parameter><decl><type><name>Relids</name></type> <name>varnos_1</name></decl></parameter>,
        <parameter><decl><type><name>Relids</name></type> <name>varnos_2</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>distcol_type</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>        <modifier>*</modifier></type><name>lquals</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>qcell</name></decl>;</decl_stmt>

    <comment type="block">/* If no quals, no equijoin */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>quals</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/*
     * Make a copy of the argument bitmaps, it will be modified by
     * bms_first_member().
     */</comment>
    <expr_stmt><expr><name>varnos_1</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>varnos_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>varnos_2</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>varnos_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>lquals</name> <operator>=</operator> <call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>lquals</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator><name>quals</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <macro><name>foreach</name><argument_list>(<argument>qcell</argument>, <argument>lquals</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>qual_expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>qcell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>lvar</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>rvar</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>qual_expr</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>op</name> <operator>=</operator> <operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator><name>qual_expr</name></expr>;</expr_stmt>
        <comment type="block">/* If not a binary operator, it can not be '='. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Check if both operands are Vars, if not check next expression */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>lvar</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rvar</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifndef>
        <comment type="block">/*
         * handle IMPLICIT_CAST case here
         */</comment>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>left_arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>right_arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            
            <expr_stmt><expr><name>lvar</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><call><name>get_var_from_arg</name><argument_list>(<argument><expr><name>left_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rvar</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><call><name>get_var_from_arg</name><argument_list>(<argument><expr><name>right_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lvar</name> <operator>||</operator> <operator>!</operator><name>rvar</name></expr>)</condition>
            <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <continue>continue;</continue>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * If the data types of both the columns are not same, continue. Hash
         * and Modulo of a the same bytes will be same if the data types are
         * same. So, only when the data types of the columns are same, we can
         * ship a distributed JOIN to the Datanodes
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>lvar</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>rvar</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* if the vars do not correspond to the required varnos, continue. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>lvar</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name>varnos_1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>rvar</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name>varnos_2</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
            <operator>(</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>lvar</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name>varnos_2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>rvar</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name>varnos_1</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgxc_is_var_distrib_column</name><argument_list>(<argument><expr><name>lvar</name></expr></argument>, <argument><expr><name>rtable</name></expr></argument>)</argument_list></call> <operator>||</operator>
                <operator>!</operator><call><name>pgxc_is_var_distrib_column</name><argument_list>(<argument><expr><name>rvar</name></expr></argument>, <argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <comment type="block">/* join shard tables should in same group */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgxc_is_shard_in_same_group</name><argument_list>(<argument><expr><name>lvar</name></expr></argument>, <argument><expr><name>rvar</name></expr></argument>, <argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></else></if_stmt>
        <comment type="block">/*
         * If the operator is not an assignment operator, check next
         * constraint. An operator is an assignment operator if it's
         * mergejoinable or hashjoinable. Beware that not every assignment
         * operator is mergejoinable or hashjoinable, so we might leave some
         * oportunity. But then we have to rely on the opname which may not
         * be something we know to be equality operator as well.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_mergejoinable</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>lvar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name>op_hashjoinable</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>lvar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <comment type="block">/* Found equi-join condition on distribution columns */</comment>
        <return>return <expr><name>qual_expr</name></expr>;</return>
    </block_content>}</block>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>List</name><modifier>*</modifier></type>
<name>pgxc_find_dist_equi_nodes</name><parameter_list>(<parameter><decl><type><name>Relids</name></type> <name>varnos_1</name></decl></parameter>,
        <parameter><decl><type><name>Relids</name></type> <name>varnos_2</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>distcol_type</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>        <modifier>*</modifier></type><name>lquals</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>qcell</name></decl>;</decl_stmt>

    <comment type="block">/* If no quals, no equijoin */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>quals</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/*
     * Make a copy of the argument bitmaps, it will be modified by
     * bms_first_member().
     */</comment>
    <expr_stmt><expr><name>varnos_1</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>varnos_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>varnos_2</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>varnos_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>lquals</name> <operator>=</operator> <call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>lquals</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator><name>quals</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <macro><name>foreach</name><argument_list>(<argument>qcell</argument>, <argument>lquals</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>qual_expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>qcell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>const_expr</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>qual_expr</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>op</name> <operator>=</operator> <operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator><name>qual_expr</name></expr>;</expr_stmt>
        <comment type="block">/* If not a binary operator, it can not be '='. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <block>{<block_content>
            <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>left_arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>right_arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>left_arg</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>rt</name> <init>= <expr><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator><name>left_arg</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>rt</name><operator>-&gt;</operator><name>relabelformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>left_arg</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>rt</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>right_arg</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>rt</name> <init>= <expr><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator><name>right_arg</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>rt</name><operator>-&gt;</operator><name>relabelformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>right_arg</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>rt</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>left_arg</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>right_arg</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name>left_arg</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>const_expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>right_arg</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>left_arg</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>right_arg</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name>right_arg</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>const_expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>left_arg</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block>

        <comment type="block">/* if the vars do not correspond to the required varnos, continue. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name>varnos_1</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name>varnos_2</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgxc_is_var_distrib_column</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></else></if_stmt>
        <comment type="block">/*
         * If the operator is not an assignment operator, check next
         * constraint. An operator is an assignment operator if it's
         * mergejoinable or hashjoinable. Beware that not every assignment
         * operator is mergejoinable or hashjoinable, so we might leave some
         * oportunity. But then we have to rely on the opname which may not
         * be something we know to be equality operator as well.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_mergejoinable</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name>op_hashjoinable</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <comment type="block">/* Found equi-qual condition on distribution columns, get executed nodelist */</comment>
        <if_stmt><if>if <condition>(<expr><name>const_expr</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RangeTblEntry</name>   <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RelationLocInfo</name>    <modifier>*</modifier></type><name>rel_loc_info</name> <init>= <expr><call><name>GetRelationLocInfo</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>        <name>disttype</name> <init>= <expr><call><name>get_atttype</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>partAttrNum</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name></type>    <name>disttypmod</name> <init>= <expr><call><name>get_atttypmod</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>partAttrNum</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>const_expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
                                                    <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>const_expr</name></expr></argument>,
                                                    <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>const_expr</name></expr></argument>)</argument_list></call></expr></argument>,
                                                    <argument><expr><name>disttype</name></expr></argument>, <argument><expr><name>disttypmod</name></expr></argument>,
                                                    <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
                                                    <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>const_expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>const_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>const_expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>const_expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator><name>const_expr</name></expr></init></decl>;</decl_stmt>
                
                <decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>exec_nodes</name> <init>= <expr><call><name>GetRelationNodes</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>,
                                            <argument><expr><name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name></expr></argument>,
                                            <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                            <argument><expr><name>RELATION_ACCESS_READ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <return>return <expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * pgxc_merge_exec_nodes
 * The routine combines the two exec_nodes passed such that the resultant
 * exec_node corresponds to the JOIN of respective relations.
 * If both exec_nodes can not be merged, it returns NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>ExecNodes</name> <modifier>*</modifier></type>
<name>pgxc_merge_exec_nodes</name><parameter_list>(<parameter><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>en1</name></decl></parameter>, <parameter><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>en2</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ExecNodes</name>    <modifier>*</modifier></type><name>merged_en</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExecNodes</name>    <modifier>*</modifier></type><name>tmp_en</name></decl>;</decl_stmt>

    <comment type="block">/* If either of exec_nodes are NULL, return the copy of other one */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>en1</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>tmp_en</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>en2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>tmp_en</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>en2</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>tmp_en</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>en1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>tmp_en</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Following cases are not handled in this routine */</comment>
    <comment type="block">/* PGXC_FQS_TODO how should we handle table usage type? */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>en1</name><operator>-&gt;</operator><name>primarynodelist</name></name> <operator>||</operator> <name><name>en2</name><operator>-&gt;</operator><name>primarynodelist</name></name> <operator>||</operator>
        <name><name>en1</name><operator>-&gt;</operator><name>en_expr</name></name> <operator>||</operator> <name><name>en2</name><operator>-&gt;</operator><name>en_expr</name></name> <operator>||</operator>
        <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>en1</name><operator>-&gt;</operator><name>en_relid</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>en2</name><operator>-&gt;</operator><name>en_relid</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
        <operator>(</operator><name><name>en1</name><operator>-&gt;</operator><name>accesstype</name></name> <operator>!=</operator> <name>RELATION_ACCESS_READ</name> <operator>&amp;&amp;</operator> <name><name>en1</name><operator>-&gt;</operator><name>accesstype</name></name> <operator>!=</operator> <name>RELATION_ACCESS_READ_FQS</name><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name><name>en2</name><operator>-&gt;</operator><name>accesstype</name></name> <operator>!=</operator> <name>RELATION_ACCESS_READ</name> <operator>&amp;&amp;</operator> <name><name>en2</name><operator>-&gt;</operator><name>accesstype</name></name> <operator>!=</operator> <name>RELATION_ACCESS_READ_FQS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsExecNodesReplicated</name><argument_list>(<argument><expr><name>en1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <call><name>IsExecNodesReplicated</name><argument_list>(<argument><expr><name>en2</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Replicated/replicated join case
         * Check that replicated relation is not disjoint
         * with initial relation which is also replicated.
         * If there is a common portion of the node list between
         * the two relations, other rtables have to be checked on
         * this restricted list.
         */</comment>
        <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>list_intersection_int</name><argument_list>(<argument><expr><name><name>en1</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>,
                                                    <argument><expr><name><name>en2</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name>LOCATOR_TYPE_REPLICATED</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>merged_en</name><operator>-&gt;</operator><name>nodeList</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FreeExecNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merged_en</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>merged_en</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsExecNodesReplicated</name><argument_list>(<argument><expr><name>en1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <call><name>IsExecNodesColumnDistributed</name><argument_list>(<argument><expr><name>en2</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>    <modifier>*</modifier></type><name>diff_nodelist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <comment type="block">/*
         * Replicated/distributed join case.
         * Node list of distributed table has to be included
         * in node list of replicated table.
         */</comment>
        <expr_stmt><expr><name>diff_nodelist</name> <operator>=</operator> <call><name>list_difference_int</name><argument_list>(<argument><expr><name><name>en2</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><name><name>en1</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * If the difference list is not empty, this means that node list of
         * distributed table is not completely mapped by node list of replicated
         * table, so go through standard planner.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>diff_nodelist</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FreeExecNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merged_en</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>en2</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name>LOCATOR_TYPE_DISTRIBUTED</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>merged_en</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsExecNodesColumnDistributed</name><argument_list>(<argument><expr><name>en1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <call><name>IsExecNodesReplicated</name><argument_list>(<argument><expr><name>en2</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>diff_nodelist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <comment type="block">/*
         * Distributed/replicated join case.
         * Node list of distributed table has to be included
         * in node list of replicated table.
         */</comment>
        <expr_stmt><expr><name>diff_nodelist</name> <operator>=</operator> <call><name>list_difference_int</name><argument_list>(<argument><expr><name><name>en1</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><name><name>en2</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If the difference list is not empty, this means that node list of
         * distributed table is not completely mapped by node list of replicated
             * table, so go through standard planner.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>diff_nodelist</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FreeExecNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merged_en</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>en1</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name>LOCATOR_TYPE_DISTRIBUTED</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>merged_en</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsExecNodesColumnDistributed</name><argument_list>(<argument><expr><name>en1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <call><name>IsExecNodesColumnDistributed</name><argument_list>(<argument><expr><name>en2</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Distributed/distributed case
         * If the caller has suggested that this is an equi-join between two
         * distributed results, check that they have the same nodes in the distribution
         * node list. The caller is expected to fully decide whether to merge
         * the nodes or not.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_difference_int</name><argument_list>(<argument><expr><name><name>en1</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><name><name>en2</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name>list_difference_int</name><argument_list>(<argument><expr><name><name>en2</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><name><name>en1</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>en1</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>en1</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>==</operator> <name><name>en2</name><operator>-&gt;</operator><name>baselocatortype</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name><name>en1</name><operator>-&gt;</operator><name>baselocatortype</name></name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name>LOCATOR_TYPE_DISTRIBUTED</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>FreeExecNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>merged_en</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <return>return <expr><name>merged_en</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Postgres-XC does not support this distribution type yet"</literal></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The feature is not currently supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Keep compiler happy */</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * pgxc_is_join_reducible
 * The shippability of JOIN is decided in following steps
 * 1. Are the JOIN conditions shippable?
 *     For INNER JOIN it's possible to apply some of the conditions at the
 *     Datanodes and others at coordinator. But for other JOINs, JOIN conditions
 *     decide which tuples on the OUTER side are appended with NULL columns from
 *     INNER side, we need all the join conditions to be shippable for the join to
 *     be shippable.
 * 2. Do the JOIN conditions have quals that will make it shippable?
 *     When both sides of JOIN are replicated, irrespective of the quals the JOIN
 *     is shippable.
 *     INNER joins between replicated and distributed relation are shippable
 *     irrespective of the quals. OUTER join between replicated and distributed
 *     relation is shippable if distributed relation is the outer relation.
 *     All joins between hash/modulo distributed relations are shippable if they
 *     have equi-join on the distributed column, such that distribution columns
 *     have same datatype and same distribution strategy.
 * 3. Are datanodes where the joining relations exist, compatible?
 *     Joins between replicated relations are shippable if both relations share a
 *     datanode. Joins between distributed relations are shippable if both
 *     relations are distributed on same set of Datanodes. Join between replicated
 *     and distributed relations is shippable is replicated relation is replicated
 *     on all nodes where distributed relation is distributed.
 *
 * The first step is to be applied by the caller of this function.
 */</comment>
<function><type><specifier>static</specifier> <name>ExecNodes</name> <modifier>*</modifier></type>
<name>pgxc_is_join_shippable</name><parameter_list>(<parameter><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>inner_en</name></decl></parameter>, <parameter><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>outer_en</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>in_relids</name></decl></parameter>,
                        <parameter><decl><type><name>Relids</name></type> <name>out_relids</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>join_quals</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                        <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>	<name>merge_nodes</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If either of inner_en or outer_en is NULL, return NULL. We can't ship the
	 * join when either of the sides do not have datanodes to ship to.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>outer_en</name> <operator>||</operator> <operator>!</operator><name>inner_en</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/*
	 * We only support reduction of INNER, LEFT [OUTER] and FULL [OUTER] joins.
	 * RIGHT [OUTER] join is converted to LEFT [OUTER] join during join tree
	 * deconstruction.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>!=</operator> <name>JOIN_INNER</name> <operator>&amp;&amp;</operator> <name>jointype</name> <operator>!=</operator> <name>JOIN_LEFT</name> <operator>&amp;&amp;</operator> <name>jointype</name> <operator>!=</operator> <name>JOIN_FULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If both sides are replicated or have single node each, we ship any kind
	 * of JOIN
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>IsExecNodesReplicated</name><argument_list>(<argument><expr><name>inner_en</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsExecNodesReplicated</name><argument_list>(<argument><expr><name>outer_en</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		 <operator>!</operator><name><name>inner_en</name><operator>-&gt;</operator><name>const_subquery</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>outer_en</name><operator>-&gt;</operator><name>const_subquery</name></name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>inner_en</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
		 <call><name>list_length</name><argument_list>(<argument><expr><name><name>outer_en</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>merge_nodes</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>

	<comment type="block">/* If both sides are distributed, ... */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>IsExecNodesColumnDistributed</name><argument_list>(<argument><expr><name>inner_en</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <call><name>IsExecNodesColumnDistributed</name><argument_list>(<argument><expr><name>outer_en</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If two sides are distributed in the same manner by a value, with an
		 * equi-join on the distribution column and that condition
		 * is shippable, ship the join if node lists from both sides can be
		 * merged.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>inner_en</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>==</operator> <name><name>outer_en</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>&amp;&amp;</operator>
			<call><name>IsExecNodesDistributedByValue</name><argument_list>(<argument><expr><name>inner_en</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>equi_join_expr</name> <init>= <expr><call><name>pgxc_find_dist_equijoin_qual</name><argument_list>(<argument><expr><name>in_relids</name></expr></argument>,
													<argument><expr><name>out_relids</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
													<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>join_quals</name></expr></argument>, <argument><expr><name>rtables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>equi_join_expr</name> <operator>&amp;&amp;</operator> <call><name>pgxc_is_expr_shippable</name><argument_list>(<argument><expr><name>equi_join_expr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>merge_nodes</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>merge_nodes</name> <operator>&amp;&amp;</operator> <name>restrict_query</name> <operator>&amp;&amp;</operator> <name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>outer_en</name><operator>-&gt;</operator><name>restrict_shippable</name></name> <operator>||</operator> <name><name>inner_en</name><operator>-&gt;</operator><name>restrict_shippable</name></name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>merged_en</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <switch>switch <condition>(<expr><name>jointype</name></expr>)</condition>
                    <block>{<block_content>
                        <case>case <expr><name>JOIN_INNER</name></expr>:</case>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name><name>outer_en</name><operator>-&gt;</operator><name>restrict_shippable</name></name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>outer_en</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            <if_stmt><if>if <condition>(<expr><name><name>inner_en</name><operator>-&gt;</operator><name>restrict_shippable</name></name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>inner_en</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>restrict_shippable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block>
                        <case>case <expr><name>JOIN_LEFT</name></expr>:</case>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>outer_en</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name><name>outer_en</name><operator>-&gt;</operator><name>restrict_shippable</name></name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>restrict_shippable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                            <break>break;</break>
                        </block_content>}</block>
                        <case>case <expr><name>JOIN_FULL</name></expr>:</case>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>list_union_int</name><argument_list>(<argument><expr><name><name>outer_en</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><name><name>inner_en</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block>
                        <default>default:</default>
                            <break>break;</break>
                    </block_content>}</block></switch>
                    <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name><name>inner_en</name><operator>-&gt;</operator><name>baselocatortype</name></name></expr>;</expr_stmt>
                    <return>return <expr><name>merged_en</name></expr>;</return>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_INNER</name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodelist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                        
                        <expr_stmt><expr><name>nodelist</name> <operator>=</operator> <call><name>pgxc_find_dist_equi_nodes</name><argument_list>(<argument><expr><name>in_relids</name></expr></argument>,
                                                    <argument><expr><name>out_relids</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                                                    <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>join_quals</name></expr></argument>, <argument><expr><name>rtables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>nodelist</name></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>merged_en</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name>nodelist</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name><name>inner_en</name><operator>-&gt;</operator><name>baselocatortype</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>restrict_shippable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            <return>return <expr><name>merged_en</name></expr>;</return>
                        </block_content>}</block></if></if_stmt>

                        <expr_stmt><expr><name>nodelist</name> <operator>=</operator> <call><name>pgxc_find_dist_equi_nodes</name><argument_list>(<argument><expr><name>in_relids</name></expr></argument>,
                                                    <argument><expr><name>out_relids</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                                                    <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rtables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>nodelist</name></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>merged_en</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name>nodelist</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name><name>inner_en</name><operator>-&gt;</operator><name>baselocatortype</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>restrict_shippable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            <return>return <expr><name>merged_en</name></expr>;</return>
                        </block_content>}</block></if></if_stmt>

                        <return>return <expr><call><name>pgxc_merge_exec_nodes</name><argument_list>(<argument><expr><name>inner_en</name></expr></argument>, <argument><expr><name>outer_en</name></expr></argument>)</argument_list></call></expr>;</return>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_LEFT</name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodelist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><name>nodelist</name> <operator>=</operator> <call><name>pgxc_find_dist_equi_nodes</name><argument_list>(<argument><expr><name>in_relids</name></expr></argument>,
                                                    <argument><expr><name>out_relids</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                                                    <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rtables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>nodelist</name></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>merged_en</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name>nodelist</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name><name>inner_en</name><operator>-&gt;</operator><name>baselocatortype</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>restrict_shippable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            <return>return <expr><name>merged_en</name></expr>;</return>
                        </block_content>}</block></if></if_stmt>

                        <return>return <expr><call><name>pgxc_merge_exec_nodes</name><argument_list>(<argument><expr><name>inner_en</name></expr></argument>, <argument><expr><name>outer_en</name></expr></argument>)</argument_list></call></expr>;</return>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <return>return <expr><call><name>pgxc_merge_exec_nodes</name><argument_list>(<argument><expr><name>inner_en</name></expr></argument>, <argument><expr><name>outer_en</name></expr></argument>)</argument_list></call></expr>;</return>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<comment type="block">/*
	 * If outer side is distributed and inner side is replicated, we can ship
	 * LEFT OUTER and INNER join.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>IsExecNodesColumnDistributed</name><argument_list>(<argument><expr><name>outer_en</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <call><name>IsExecNodesReplicated</name><argument_list>(<argument><expr><name>inner_en</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <operator>(</operator><name>jointype</name> <operator>==</operator> <name>JOIN_INNER</name> <operator>||</operator> <name>jointype</name> <operator>==</operator> <name>JOIN_LEFT</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>merge_nodes</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<comment type="block">/*
		 * Push down to restrict datanodes based if join is on distributed
		 * column or related qual
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>restrict_query</name> <operator>&amp;&amp;</operator>
			<name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>outer_en</name><operator>-&gt;</operator><name>restrict_shippable</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodelist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_INNER</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>nodelist</name> <operator>=</operator> <call><name>pgxc_find_dist_equi_nodes</name><argument_list>(<argument><expr><name>in_relids</name></expr></argument>,
											<argument><expr><name>out_relids</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
											<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>join_quals</name></expr></argument>, <argument><expr><name>rtables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>nodelist</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>list_difference_int</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>, <argument><expr><name><name>inner_en</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>merged_en</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name>nodelist</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name><name>outer_en</name><operator>-&gt;</operator><name>baselocatortype</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>restrict_shippable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<return>return <expr><name>merged_en</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_INNER</name> <operator>||</operator> <name>jointype</name> <operator>==</operator> <name>JOIN_LEFT</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>nodelist</name> <operator>=</operator> <call><name>pgxc_find_dist_equi_nodes</name><argument_list>(<argument><expr><name>in_relids</name></expr></argument>,
											<argument><expr><name>out_relids</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
											<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rtables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>nodelist</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>list_difference_int</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>, <argument><expr><name><name>inner_en</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>merged_en</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name>nodelist</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name><name>outer_en</name><operator>-&gt;</operator><name>baselocatortype</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>restrict_shippable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<return>return <expr><name>merged_en</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Inner side is constant subquery */</comment>
		<if_stmt><if>if <condition>(<expr><name>enable_subquery_shipping</name> <operator>&amp;&amp;</operator> <name><name>inner_en</name><operator>-&gt;</operator><name>const_subquery</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>merged_en</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>outer_en</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name><name>outer_en</name><operator>-&gt;</operator><name>baselocatortype</name></name></expr>;</expr_stmt>
			<return>return <expr><name>merged_en</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<comment type="block">/*
	 * If outer side is replicated and inner side is distributed, we can ship
	 * only for INNER join.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>IsExecNodesReplicated</name><argument_list>(<argument><expr><name>outer_en</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <call><name>IsExecNodesColumnDistributed</name><argument_list>(<argument><expr><name>inner_en</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <name>jointype</name> <operator>==</operator> <name>JOIN_INNER</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>merge_nodes</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<comment type="block">/*
		 * Push down to restrict datanodes based if join is on distributed
		 * column or related qual
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>restrict_query</name> <operator>&amp;&amp;</operator>
			<name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>inner_en</name><operator>-&gt;</operator><name>restrict_shippable</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodelist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>nodelist</name> <operator>=</operator> <call><name>pgxc_find_dist_equi_nodes</name><argument_list>(<argument><expr><name>in_relids</name></expr></argument>,
										<argument><expr><name>out_relids</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
										<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>join_quals</name></expr></argument>, <argument><expr><name>rtables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>nodelist</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>list_difference_int</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>, <argument><expr><name><name>outer_en</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>merged_en</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name>nodelist</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name><name>inner_en</name><operator>-&gt;</operator><name>baselocatortype</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>restrict_shippable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<return>return <expr><name>merged_en</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>nodelist</name> <operator>=</operator> <call><name>pgxc_find_dist_equi_nodes</name><argument_list>(<argument><expr><name>in_relids</name></expr></argument>,
										<argument><expr><name>out_relids</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
										<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rtables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>nodelist</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>list_difference_int</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>, <argument><expr><name><name>outer_en</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>merged_en</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name>nodelist</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name><name>inner_en</name><operator>-&gt;</operator><name>baselocatortype</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>restrict_shippable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<return>return <expr><name>merged_en</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Outer side is constant subquery */</comment>
		<if_stmt><if>if <condition>(<expr><name>enable_subquery_shipping</name> <operator>&amp;&amp;</operator> <name><name>outer_en</name><operator>-&gt;</operator><name>const_subquery</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>merged_en</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>inner_en</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>merged_en</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name><name>inner_en</name><operator>-&gt;</operator><name>baselocatortype</name></name></expr>;</expr_stmt>
			<return>return <expr><name>merged_en</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/*
     * If the ExecNodes of inner and outer nodes can be merged, the JOIN is
     * shippable
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>merge_nodes</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>pgxc_merge_exec_nodes</name><argument_list>(<argument><expr><name>inner_en</name></expr></argument>, <argument><expr><name>outer_en</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier>
<name>bool</name></type> <name>pgxc_targetlist_has_distcol</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RangeTblEntry</name>   <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelationLocInfo</name>    <modifier>*</modifier></type><name>rel_loc_info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>distcol</name></decl>;</decl_stmt>

    <comment type="block">/* distribution column only applies to the relations */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name> <operator>||</operator>
        <name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>rel_loc_info</name> <operator>=</operator> <call><name>GetRelationLocInfo</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>rel_loc_info</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>distcol</name> <operator>=</operator> <call><name>GetRelationDistribColumn</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>distcol</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>query-&gt;targetList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>, <argument><expr><name>distcol</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
 * pgxc_check_triggers_shippability:
 * Return true if none of the triggers prevents the query from being FQSed.
 */</comment>
<function><type><name>bool</name></type>
<name>pgxc_check_triggers_shippability</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>commandType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>  <name>has_unshippable_trigger</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type> <name>trigevent</name> <init>= <expr><call><name>pgxc_get_trigevent</name><argument_list>(<argument><expr><name>commandType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rd_locator_info</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* only process hash and shard table */</comment>
    <if_stmt><if>if <condition>(<expr><name>rd_locator_info</name> <operator>&amp;&amp;</operator> 
       <operator>(</operator><name><name>rd_locator_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>!=</operator> <name>LOCATOR_TYPE_SHARD</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/*
     * If we don't find unshippable row trigger, then the statement is
     * shippable as far as triggers are concerned. For FQSed query, statement
     * triggers are separately invoked on coordinator.
     */</comment>
    <expr_stmt><expr><name>has_unshippable_trigger</name> <operator>=</operator> <call><name>pgxc_find_unshippable_triggers</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name></name></expr></argument>, <argument><expr><name>trigevent</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>!</operator><name>has_unshippable_trigger</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
  * find unshippable triggers if any 
  *
  * If ignore_timing is true, just the trig_event is used to find a match, so
  * once the event matches, the search returns true regardless of whether it is a
  * before or after row trigger.
  *
  * If ignore_timing is false, return true if we find one or more unshippable
  * triggers that match the exact combination of event and timing.
  */</comment>
<function><type><name>bool</name></type>
<name>pgxc_find_unshippable_triggers</name><parameter_list>(<parameter><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigdesc</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>trig_event</name></decl></parameter>, 
                                       <parameter><decl><type><name>int16</name></type> <name>trig_timing</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ignore_timing</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* no triggers */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>trigdesc</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Quick check by just scanning the trigger descriptor, before
     * actually peeking into each of the individual triggers.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgxc_has_trigger_for_event</name><argument_list>(<argument><expr><name>trig_event</name></expr></argument>, <argument><expr><name>trigdesc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Trigger</name>    <modifier>*</modifier></type><name>trigger</name> <init>= <expr><operator>&amp;</operator><name><name>trigdesc</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int16</name></type>        <name>tgtype</name> <init>= <expr><name><name>trigger</name><operator>-&gt;</operator><name>tgtype</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * If we are asked to find triggers of *any* level or timing, just match
         * the event type to determine whether we should ignore this trigger.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>ignore_timing</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>TRIGGER_FOR_INSERT</name><argument_list>(<argument><expr><name>trig_event</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TRIGGER_FOR_INSERT</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
                <operator>(</operator><call><name>TRIGGER_FOR_UPDATE</name><argument_list>(<argument><expr><name>trig_event</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TRIGGER_FOR_UPDATE</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
                <operator>(</operator><call><name>TRIGGER_FOR_DELETE</name><argument_list>(<argument><expr><name>trig_event</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TRIGGER_FOR_DELETE</name><argument_list>(<argument><expr><name>tgtype</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * Otherwise, do an exact match with the given combination of event
             * and timing.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>tgtype</name> <operator>&amp;</operator> <name>TRIGGER_TYPE_TIMING_MASK</name><operator>)</operator> <operator>==</operator> <name>trig_timing</name> <operator>&amp;&amp;</operator>
                <operator>(</operator><name>tgtype</name> <operator>&amp;</operator> <name>trig_event</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * We now know that we cannot ignore this trigger, so check its
         * shippability.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgxc_is_trigger_shippable</name><argument_list>(<argument><expr><name>trigger</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>constraint_is_foreign_key</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>constroid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>constrRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>constrTup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>constrForm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>constrRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>constrTup</name> <operator>=</operator> <call><name>get_catalog_object_by_oid</name><argument_list>(<argument><expr><name>constrRel</name></expr></argument>, <argument><expr><name>constroid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>constrTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>, <argument><expr><name>constroid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>constrForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>constrTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>constrForm</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_FOREIGN</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>constrRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgxc_is_shard_table</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_shard_table</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>is_shard_table</name> <operator>=</operator> <call><name>RelationIsSharded</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>is_shard_table</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * pgxc_is_trigger_shippable:
 * Check if trigger is shippable to a remote node. This function would be
 * called both on coordinator as well as datanode. We want this function
 * to be workable on datanode because we want to skip non-shippable triggers
 * on datanode.
 */</comment>
<function><type><name>bool</name></type>
<name>pgxc_is_trigger_shippable</name><parameter_list>(<parameter><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>trigger</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>res</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * If trigger is based on a constraint or is internal, enforce its launch
     * whatever the node type where we are for the time being.
     * PGXCTODO: we need to remove this condition once constraints are better
     * implemented within Postgres-XC as a constraint can be locally
     * evaluated on remote nodes depending on the distribution type of the table
     * on which it is defined or on its parent/child distribution types.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>trigger</name><operator>-&gt;</operator><name>tgisinternal</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgconstraint</name></name></expr></argument>)</argument_list></call> <operator>||</operator> 
            <operator>!</operator><call><name>constraint_is_foreign_key</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgconstraint</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
            <operator>!</operator><call><name>pgxc_is_shard_table</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgconstrrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * INSTEAD OF triggers can only be defined on views, which are defined
     * only on Coordinators, so they cannot be shipped.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FOR_INSTEAD</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgtype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Finally check if function called is shippable */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgxc_is_func_shippable</name><argument_list>(<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgfoid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
      * For now, we regard a function as shippable only if it is immutable, but
      * do not look inside the function. 
      *  In TBase, we need more than this. We have to know what exactly the function do, 
      *  and if function called will involve more than one datanodes.
      * TODO: check the function called
      */</comment>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* treat all triggers as unshippable now.... */</comment>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ExecNodes</name><modifier>*</modifier></type>
<name>pgxc_is_group_subquery_shippable</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>Shippability_context</name> <modifier>*</modifier></type><name>sc_context</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>lcell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExecNodes</name>   <modifier>*</modifier></type><name>exec_nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>      
    
    <macro><name>foreach</name> <argument_list>(<argument>lcell</argument>, <argument>query-&gt;groupClause</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name>     <modifier>*</modifier></type><name>sgc</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name>                <modifier>*</modifier></type><name>sgc_expr</name></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>sgc</name></expr></argument>, <argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name>sgc_expr</name> <operator>=</operator> <call><name>get_sortgroupclause_expr</name><argument_list>(<argument><expr><name>sgc</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>sgc_expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Var</name>             <modifier>*</modifier></type><name>var</name>       <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RangeTblEntry</name>   <modifier>*</modifier></type><name>rte</name>       <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>            
            <expr_stmt><expr><name>var</name>             <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name>sgc_expr</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
            <if_stmt><if>if <condition>(<expr><name>RTE_SUBQUERY</name> <operator>==</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Shippability_context</name></type> <name>local_sc</name></decl>;</decl_stmt>  
                <decl_stmt><decl><type><name>ExecNodes</name>   <modifier>*</modifier></type><name>local_exec_nodes_0</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>  
                <decl_stmt><decl><type><name>ExecNodes</name>   <modifier>*</modifier></type><name>local_exec_nodes_1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>  

                <comment type="block">/* just assume we are a standalone query. */</comment>
                <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>local_sc</name></expr></argument>, <argument><expr><literal type="number">0X00</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Shippability_context</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>local_sc</name><operator>.</operator><name>sc_query</name></name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>local_sc</name><operator>.</operator><name>sc_query_level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>local_sc</name><operator>.</operator><name>sc_for_expr</name></name>  <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                
                <expr_stmt><expr><call><name>pgxc_shippability_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>local_sc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>local_sc</name><operator>.</operator><name>sc_exec_nodes</name></name> <operator>&amp;&amp;</operator> <literal type="number">1</literal> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>local_sc</name><operator>.</operator><name>sc_exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>                    
                    <comment type="block">/* try to merge the exec node to check whether the subquery has the same exec node as the local one. */</comment>
                    <expr_stmt><expr><name>local_exec_nodes_0</name> <operator>=</operator> <call><name>pgxc_merge_exec_nodes</name><argument_list>(<argument><expr><name><name>local_sc</name><operator>.</operator><name>sc_exec_nodes</name></name></expr></argument>, <argument><expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_exec_nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>local_exec_nodes_1</name> <operator>=</operator> <name>exec_nodes</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>exec_nodes</name> <operator>=</operator> <call><name>pgxc_merge_exec_nodes</name><argument_list>(<argument><expr><name>local_exec_nodes_0</name></expr></argument>, <argument><expr><name>local_exec_nodes_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>local_exec_nodes_0</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>FreeExecNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>local_exec_nodes_0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name>local_exec_nodes_1</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>FreeExecNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>local_exec_nodes_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>exec_nodes</name></expr>)</condition>
                    <block>{<block_content>    
                        <comment type="block">/* Can't be push down. */</comment>
                        <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_NEED_SINGLENODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/* Free the structs if needed. */</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>local_sc</name><operator>.</operator><name>sc_exec_nodes</name></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>FreeExecNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_sc</name><operator>.</operator><name>sc_exec_nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>

                        <if_stmt><if>if <condition>(<expr><name><name>local_sc</name><operator>.</operator><name>sc_subquery_en</name></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>FreeExecNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_sc</name><operator>.</operator><name>sc_subquery_en</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <return>return <expr><name>NULL</name></expr>;</return>
                    </block_content>}</block></if></if_stmt>    

                    <comment type="block">/* Free the structs if needed. */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>local_sc</name><operator>.</operator><name>sc_exec_nodes</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>FreeExecNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_sc</name><operator>.</operator><name>sc_exec_nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>local_sc</name><operator>.</operator><name>sc_subquery_en</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>FreeExecNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_sc</name><operator>.</operator><name>sc_subquery_en</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>        
                    <if_stmt><if>if <condition>(<expr><name>exec_nodes</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>FreeExecNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>exec_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <return>return <expr><name>NULL</name></expr>;</return>
                </block_content>}</block></else></if_stmt>
                
            </block_content>}</block></if></if_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
    <return>return <expr><name>exec_nodes</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgxc_is_rte_subquery_shippable</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Shippability_context</name> <modifier>*</modifier></type><name>sc_context</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ExecNodes</name>   <modifier>*</modifier></type><name>exec_nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>     
    
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeTblRef</name>     <modifier>*</modifier></type><name>ref</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RangeTblEntry</name>   <modifier>*</modifier></type><name>rte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        
        <expr_stmt><expr><name>ref</name> <operator>=</operator> <operator>(</operator><name>RangeTblRef</name><operator>*</operator><operator>)</operator><name>node</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <if_stmt><if>if <condition>(<expr><name>RTE_SUBQUERY</name> <operator>==</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Shippability_context</name></type> <name>local_sc</name></decl>;</decl_stmt>  

            <comment type="block">/* just assume we are a standalone query. */</comment>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>local_sc</name></expr></argument>, <argument><expr><literal type="number">0X00</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Shippability_context</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>local_sc</name><operator>.</operator><name>sc_query</name></name>       <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>local_sc</name><operator>.</operator><name>sc_query_level</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>local_sc</name><operator>.</operator><name>sc_for_expr</name></name>    <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pgxc_shippability_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>local_sc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>local_sc</name><operator>.</operator><name>sc_exec_nodes</name></name> <operator>&amp;&amp;</operator> <literal type="number">1</literal> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>local_sc</name><operator>.</operator><name>sc_exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>                    
                <comment type="block">/* try to merge the exec node to check whether the subquery has the same exec node as the local one. */</comment>
                <expr_stmt><expr><name>exec_nodes</name> <operator>=</operator> <call><name>pgxc_merge_exec_nodes</name><argument_list>(<argument><expr><name><name>local_sc</name><operator>.</operator><name>sc_exec_nodes</name></name></expr></argument>, <argument><expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_exec_nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>exec_nodes</name></expr>)</condition>
                <block>{<block_content>    
                    <comment type="block">/* Can't be push down. */</comment>
                    <expr_stmt><expr><call><name>pgxc_set_shippability_reason</name><argument_list>(<argument><expr><name>sc_context</name></expr></argument>, <argument><expr><name>SS_NEED_SINGLENODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* Free all exec node to tell the caller we are not shippable. */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_exec_nodes</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>FreeExecNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sc_context</name><operator>-&gt;</operator><name>sc_exec_nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_exec_nodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* shippable , just set the exec nodes */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_exec_nodes</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>FreeExecNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sc_context</name><operator>-&gt;</operator><name>sc_exec_nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name><name>sc_context</name><operator>-&gt;</operator><name>sc_exec_nodes</name></name> <operator>=</operator> <name>exec_nodes</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <comment type="block">/* Free the structs if needed. */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>local_sc</name><operator>.</operator><name>sc_exec_nodes</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>FreeExecNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_sc</name><operator>.</operator><name>sc_exec_nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>local_sc</name><operator>.</operator><name>sc_subquery_en</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>FreeExecNodes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_sc</name><operator>.</operator><name>sc_subquery_en</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>            
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>Node</name> <modifier>*</modifier></type>
<name>get_var_from_arg</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <switch>switch<condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_Var</name></expr>:</case>
            <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name>arg</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_RelabelType</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>rt</name> <init>= <expr><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>rt</name><operator>-&gt;</operator><name>relabelformat</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name> <operator>&amp;&amp;</operator> 
                    <call><name>IsA</name><argument_list>(<argument><expr><name><name>rt</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name><name>rt</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>
        <default>default:</default>
            <expr_stmt><expr><name>var</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>var</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>is_var_distribute_column</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>rtable</name> <operator>||</operator> <operator>!</operator><name>var</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&gt;</operator> <name><name>rtable</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><call><name>pgxc_is_var_distrib_column</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
