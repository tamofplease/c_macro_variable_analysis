<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/optimizer/util/pathnode.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pathnode.c
 *      Routines to manipulate pathlists and create path nodes
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/optimizer/util/pathnode.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/extensible.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/restrictinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/selfuncs.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/locator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/nodemgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_key_values.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAgg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/distribution.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pgxcship.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/groupmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxcnode.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_class.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*GUC parameter */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>prefer_olap</name></decl>;</decl_stmt>
<comment type="block">/* Max replication level on join to make Query more efficient */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>replication_level</name></decl>;</decl_stmt>
<comment type="block">/* Restrict query to involved node as possible */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>restrict_query</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* Support fast query shipping for subquery */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>enable_subquery_shipping</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>REPLICATION_FACTOR</name></cpp:macro> <cpp:value>0.8</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><enum>enum
<block>{
    <decl><name>COSTS_EQUAL</name></decl>,                <comment type="block">/* path costs are fuzzily equal */</comment>
    <decl><name>COSTS_BETTER1</name></decl>,                <comment type="block">/* first path is cheaper than second */</comment>
    <decl><name>COSTS_BETTER2</name></decl>,                <comment type="block">/* second path is cheaper than first */</comment>
    <decl><name>COSTS_DIFFERENT</name></decl>                <comment type="block">/* neither path dominates the other on cost */</comment>
}</block></enum></type> <name>PathCostComparison</name>;</typedef>

<comment type="block">/*
 * STD_FUZZ_FACTOR is the normal fuzz factor for compare_path_costs_fuzzily.
 * XXX is it worth making this user-controllable?  It provides a tradeoff
 * between planner runtime and the accuracy of path cost comparisons.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STD_FUZZ_FACTOR</name></cpp:macro> <cpp:value>1.01</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>translate_sub_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>reparameterize_pathlist_by_child</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                                                                <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathlist</name></decl></parameter>,
                                                                <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>child_rel</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>restrict_distribution</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>ri</name></decl></parameter>,
                                  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>pathnode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Path</name> <modifier>*</modifier></type><name>redistribute_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
                  <parameter><decl><type><name>char</name></type> <name>distributionType</name></decl></parameter>, <parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>distributionExpr</name></decl></parameter>,
                  <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nodes</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>restrictNodes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_scanpath_distribution</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>pathnode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>set_joinpath_distribution</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>JoinPath</name> <modifier>*</modifier></type><name>pathnode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>PoolPingNodes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>get_num_connections</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numnodes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nRemotePlans</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/*****************************************************************************
 *        MISC. PATH UTILITIES
 *****************************************************************************/</comment>

<comment type="block">/*
 * compare_path_costs
 *      Return -1, 0, or +1 according as path1 is cheaper, the same cost,
 *      or more expensive than path2 for the specified criterion.
 */</comment>
<function><type><name>int</name></type>
<name>compare_path_costs</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path1</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path2</name></decl></parameter>, <parameter><decl><type><name>CostSelector</name></type> <name>criterion</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name>criterion</name> <operator>==</operator> <name>STARTUP_COST</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>path1</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>&lt;</operator> <name><name>path2</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>path1</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>&gt;</operator> <name><name>path2</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/*
         * If paths have the same startup cost (not at all unlikely), order
         * them by total cost.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>path1</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&lt;</operator> <name><name>path2</name><operator>-&gt;</operator><name>total_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>path1</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&gt;</operator> <name><name>path2</name><operator>-&gt;</operator><name>total_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>path1</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&lt;</operator> <name><name>path2</name><operator>-&gt;</operator><name>total_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>path1</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&gt;</operator> <name><name>path2</name><operator>-&gt;</operator><name>total_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/*
         * If paths have the same total cost, order them by startup cost.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>path1</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>&lt;</operator> <name><name>path2</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>path1</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>&gt;</operator> <name><name>path2</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * compare_path_fractional_costs
 *      Return -1, 0, or +1 according as path1 is cheaper, the same cost,
 *      or more expensive than path2 for fetching the specified fraction
 *      of the total tuples.
 *
 * If fraction is &lt;= 0 or &gt; 1, we interpret it as 1, ie, we select the
 * path with the cheaper total_cost.
 */</comment>
<function><type><name>int</name></type>
<name>compare_fractional_path_costs</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path1</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path2</name></decl></parameter>,
                              <parameter><decl><type><name>double</name></type> <name>fraction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Cost</name></type>        <name>cost1</name></decl>,
                <decl><type ref="prev"/><name>cost2</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>fraction</name> <operator>&lt;=</operator> <literal type="number">0.0</literal> <operator>||</operator> <name>fraction</name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>compare_path_costs</name><argument_list>(<argument><expr><name>path1</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>, <argument><expr><name>TOTAL_COST</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>cost1</name> <operator>=</operator> <name><name>path1</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+</operator>
        <name>fraction</name> <operator>*</operator> <operator>(</operator><name><name>path1</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>-</operator> <name><name>path1</name><operator>-&gt;</operator><name>startup_cost</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>cost2</name> <operator>=</operator> <name><name>path2</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+</operator>
        <name>fraction</name> <operator>*</operator> <operator>(</operator><name><name>path2</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>-</operator> <name><name>path2</name><operator>-&gt;</operator><name>startup_cost</name></name><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>cost1</name> <operator>&lt;</operator> <name>cost2</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>cost1</name> <operator>&gt;</operator> <name>cost2</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>+</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * compare_path_costs_fuzzily
 *      Compare the costs of two paths to see if either can be said to
 *      dominate the other.
 *
 * We use fuzzy comparisons so that add_path() can avoid keeping both of
 * a pair of paths that really have insignificantly different cost.
 *
 * The fuzz_factor argument must be 1.0 plus delta, where delta is the
 * fraction of the smaller cost that is considered to be a significant
 * difference.  For example, fuzz_factor = 1.01 makes the fuzziness limit
 * be 1% of the smaller cost.
 *
 * The two paths are said to have "equal" costs if both startup and total
 * costs are fuzzily the same.  Path1 is said to be better than path2 if
 * it has fuzzily better startup cost and fuzzily no worse total cost,
 * or if it has fuzzily better total cost and fuzzily no worse startup cost.
 * Path2 is better than path1 if the reverse holds.  Finally, if one path
 * is fuzzily better than the other on startup cost and fuzzily worse on
 * total cost, we just say that their costs are "different", since neither
 * dominates the other across the whole performance spectrum.
 *
 * This function also enforces a policy rule that paths for which the relevant
 * one of parent-&gt;consider_startup and parent-&gt;consider_param_startup is false
 * cannot survive comparisons solely on the grounds of good startup cost, so
 * we never return COSTS_DIFFERENT when that is true for the total-cost loser.
 * (But if total costs are fuzzily equal, we compare startup costs anyway,
 * in hopes of eliminating one path or the other.)
 */</comment>
<function><type><specifier>static</specifier> <name>PathCostComparison</name></type>
<name>compare_path_costs_fuzzily</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path1</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path2</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>fuzz_factor</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSIDER_PATH_STARTUP_COST</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro>  \
    <cpp:value>((p)-&gt;param_info == NULL ? (p)-&gt;parent-&gt;consider_startup : (p)-&gt;parent-&gt;consider_param_startup)</cpp:value></cpp:define>

    <comment type="block">/*
     * Check total cost first since it's more likely to be different; many
     * paths have zero startup cost.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>path1</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&gt;</operator> <name><name>path2</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>*</operator> <name>fuzz_factor</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* path1 fuzzily worse on total cost */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>CONSIDER_PATH_STARTUP_COST</name><argument_list>(<argument><expr><name>path1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <name><name>path2</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>&gt;</operator> <name><name>path1</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>*</operator> <name>fuzz_factor</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* ... but path2 fuzzily worse on startup, so DIFFERENT */</comment>
            <return>return <expr><name>COSTS_DIFFERENT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* else path2 dominates */</comment>
        <return>return <expr><name>COSTS_BETTER2</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>path2</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&gt;</operator> <name><name>path1</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>*</operator> <name>fuzz_factor</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* path2 fuzzily worse on total cost */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>CONSIDER_PATH_STARTUP_COST</name><argument_list>(<argument><expr><name>path2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <name><name>path1</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>&gt;</operator> <name><name>path2</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>*</operator> <name>fuzz_factor</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* ... but path1 fuzzily worse on startup, so DIFFERENT */</comment>
            <return>return <expr><name>COSTS_DIFFERENT</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* else path1 dominates */</comment>
        <return>return <expr><name>COSTS_BETTER1</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* fuzzily the same on total cost ... */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>path1</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>&gt;</operator> <name><name>path2</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>*</operator> <name>fuzz_factor</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* ... but path1 fuzzily worse on startup, so path2 wins */</comment>
        <return>return <expr><name>COSTS_BETTER2</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>path2</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>&gt;</operator> <name><name>path1</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>*</operator> <name>fuzz_factor</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* ... but path2 fuzzily worse on startup, so path1 wins */</comment>
        <return>return <expr><name>COSTS_BETTER1</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* fuzzily the same on both costs */</comment>
    <return>return <expr><name>COSTS_EQUAL</name></expr>;</return>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CONSIDER_PATH_STARTUP_COST</name></cpp:undef>
</block_content>}</block></function>

<comment type="block">/*
 * set_cheapest
 *      Find the minimum-cost paths from among a relation's paths,
 *      and save them in the rel's cheapest-path fields.
 *
 * cheapest_total_path is normally the cheapest-total-cost unparameterized
 * path; but if there are no unparameterized paths, we assign it to be the
 * best (cheapest least-parameterized) parameterized path.  However, only
 * unparameterized paths are considered candidates for cheapest_startup_path,
 * so that will be NULL if there are no unparameterized paths.
 *
 * The cheapest_parameterized_paths list collects all parameterized paths
 * that have survived the add_path() tournament for this relation.  (Since
 * add_path ignores pathkeys for a parameterized path, these will be paths
 * that have best cost or best row count for their parameterization.  We
 * may also have both a parallel-safe and a non-parallel-safe path in some
 * cases for the same parameterization in some cases, but this should be
 * relatively rare since, most typically, all paths for the same relation
 * will be parallel-safe or none of them will.)
 *
 * cheapest_parameterized_paths always includes the cheapest-total
 * unparameterized path, too, if there is one; the users of that list find
 * it more convenient if that's included.
 *
 * This is normally called only after we've finished constructing the path
 * list for the rel node.
 */</comment>
<function><type><name>void</name></type>
<name>set_cheapest</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parent_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>cheapest_startup_path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>cheapest_total_path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>best_param_path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>parameterized_paths</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>, <argument><expr><name>RelOptInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<comment type="block">/*
	 * When set_joinpath_distribution() adjusted the strategy for complex
	 * UPDATE/DELETE, the original paths could be give up caused by no proper
	 * distribution found. Which lead to an early error pop up here, thus
	 * we need to provide more accurate error message here. (Before the
	 * complex delete enhancement, this will pop up in group_planner at
	 * final stage.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
		<name><name>parent_rel</name><operator>-&gt;</operator><name>resultRelLoc</name></name> <operator>!=</operator> <name>RESULT_REL_NONE</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STATEMENT_TOO_COMPLEX</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not plan this distributed UPDATE/DELETE"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"correlated or complex UPDATE/DELETE is currently not supported in Postgres-XL."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STATEMENT_TOO_COMPLEX</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not plan this distributed UPDATE/DELETE"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"correlated or complex UPDATE/DELETE is currently not supported in TBase."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not devise a query plan for the given query"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>cheapest_startup_path</name> <operator>=</operator> <name>cheapest_total_path</name> <operator>=</operator> <name>best_param_path</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>parameterized_paths</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>p</argument>, <argument>parent_rel-&gt;pathlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>cmp</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Parameterized path, so add it to parameterized_paths */</comment>
            <expr_stmt><expr><name>parameterized_paths</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>parameterized_paths</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * If we have an unparameterized cheapest-total, we no longer care
             * about finding the best parameterized path, so move on.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>cheapest_total_path</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Otherwise, track the best parameterized path, which is the one
             * with least total cost among those of the minimum
             * parameterization.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>best_param_path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>best_param_path</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <switch>switch <condition>(<expr><call><name>bms_subset_compare</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>best_param_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>BMS_EQUAL</name></expr>:</case>
                        <comment type="block">/* keep the cheaper one */</comment>
                        <if_stmt><if>if <condition>(<expr><call><name>compare_path_costs</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>best_param_path</name></expr></argument>,
                                               <argument><expr><name>TOTAL_COST</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>best_param_path</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <break>break;</break>
                    <case>case <expr><name>BMS_SUBSET1</name></expr>:</case>
                        <comment type="block">/* new path is less-parameterized */</comment>
                        <expr_stmt><expr><name>best_param_path</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>BMS_SUBSET2</name></expr>:</case>
                        <comment type="block">/* old path is less-parameterized, keep it */</comment>
                        <break>break;</break>
                    <case>case <expr><name>BMS_DIFFERENT</name></expr>:</case>

                        <comment type="block">/*
                         * This means that neither path has the least possible
                         * parameterization for the rel.  We'll sit on the old
                         * path until something better comes along.
                         */</comment>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Unparameterized path, so consider it for cheapest slots */</comment>
            <if_stmt><if>if <condition>(<expr><name>cheapest_total_path</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>cheapest_startup_path</name> <operator>=</operator> <name>cheapest_total_path</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * If we find two paths of identical costs, try to keep the
             * better-sorted one.  The paths might have unrelated sort
             * orderings, in which case we can only guess which might be
             * better to keep, but if one is superior then we definitely
             * should keep that one.
             */</comment>
            <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>compare_path_costs</name><argument_list>(<argument><expr><name>cheapest_startup_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>STARTUP_COST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
                <operator>(</operator><name>cmp</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                 <call><name>compare_pathkeys</name><argument_list>(<argument><expr><name><name>cheapest_startup_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>,
                                  <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PATHKEYS_BETTER2</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>cheapest_startup_path</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>compare_path_costs</name><argument_list>(<argument><expr><name>cheapest_total_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>TOTAL_COST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
                <operator>(</operator><name>cmp</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                 <call><name>compare_pathkeys</name><argument_list>(<argument><expr><name><name>cheapest_total_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>,
                                  <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PATHKEYS_BETTER2</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>cheapest_total_path</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>

    <comment type="block">/* Add cheapest unparameterized path, if any, to parameterized_paths */</comment>
    <if_stmt><if>if <condition>(<expr><name>cheapest_total_path</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>parameterized_paths</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>cheapest_total_path</name></expr></argument>, <argument><expr><name>parameterized_paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If there is no unparameterized path, use the best parameterized path as
     * cheapest_total_path (but not as cheapest_startup_path).
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>cheapest_total_path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>cheapest_total_path</name> <operator>=</operator> <name>best_param_path</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cheapest_total_path</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>cheapest_startup_path</name></name> <operator>=</operator> <name>cheapest_startup_path</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name> <operator>=</operator> <name>cheapest_total_path</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>cheapest_unique_path</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>    <comment type="block">/* computed only if needed */</comment>
    <expr_stmt><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>cheapest_parameterized_paths</name></name> <operator>=</operator> <name>parameterized_paths</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * add_path
 *      Consider a potential implementation path for the specified parent rel,
 *      and add it to the rel's pathlist if it is worthy of consideration.
 *      A path is worthy if it has a better sort order (better pathkeys) or
 *      cheaper cost (on either dimension), or generates fewer rows, than any
 *      existing path that has the same or superset parameterization rels.
 *      We also consider parallel-safe paths more worthy than others.
 *
 *      We also remove from the rel's pathlist any old paths that are dominated
 *      by new_path --- that is, new_path is cheaper, at least as well ordered,
 *      generates no more rows, requires no outer rels not required by the old
 *      path, and is no less parallel-safe.
 *
 *      In most cases, a path with a superset parameterization will generate
 *      fewer rows (since it has more join clauses to apply), so that those two
 *      figures of merit move in opposite directions; this means that a path of
 *      one parameterization can seldom dominate a path of another.  But such
 *      cases do arise, so we make the full set of checks anyway.
 *
 *      There are two policy decisions embedded in this function, along with
 *      its sibling add_path_precheck.  First, we treat all parameterized paths
 *      as having NIL pathkeys, so that they cannot win comparisons on the
 *      basis of sort order.  This is to reduce the number of parameterized
 *      paths that are kept; see discussion in src/backend/optimizer/README.
 *
 *      Second, we only consider cheap startup cost to be interesting if
 *      parent_rel-&gt;consider_startup is true for an unparameterized path, or
 *      parent_rel-&gt;consider_param_startup is true for a parameterized one.
 *      Again, this allows discarding useless paths sooner.
 *
 *      The pathlist is kept sorted by total_cost, with cheaper paths
 *      at the front.  Within this routine, that's simply a speed hack:
 *      doing it that way makes it more likely that we will reject an inferior
 *      path after a few comparisons, rather than many comparisons.
 *      However, add_path_precheck relies on this ordering to exit early
 *      when possible.
 *
 *      NOTE: discarded Path objects are immediately pfree'd to reduce planner
 *      memory consumption.  We dare not try to free the substructure of a Path,
 *      since much of it may be shared with other Paths or the query tree itself;
 *      but just recycling discarded Path nodes is a very useful savings in
 *      a large join tree.  We can recycle the List nodes of pathlist, too.
 *
 *      As noted in optimizer/README, deleting a previously-accepted Path is
 *      safe because we know that Paths of this rel cannot yet be referenced
 *      from any other rel, such as a higher-level join.  However, in some cases
 *      it is possible that a Path is referenced by another Path for its own
 *      rel; we must not delete such a Path, even if it is dominated by the new
 *      Path.  Currently this occurs only for IndexPath objects, which may be
 *      referenced as children of BitmapHeapPaths as well as being paths in
 *      their own right.  Hence, we don't pfree IndexPaths when rejecting them.
 *
 * 'parent_rel' is the relation entry to which the path corresponds.
 * 'new_path' is a potential path for parent_rel.
 *
 * Returns nothing, but modifies parent_rel-&gt;pathlist.
 */</comment>
<function><type><name>void</name></type>
<name>add_path</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parent_rel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>new_path</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>accept_new</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* unless we find a superior old path */</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>insert_after</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* where to insert new item */</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>new_path_pathkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>p1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>p1_prev</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>p1_next</name></decl>;</decl_stmt>

    <comment type="block">/*
     * This is a convenient place to check for query cancel --- no part of the
     * planner goes very long without calling add_path().
     */</comment>
    <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<comment type="block">/*
	 * In case we skipped the join paths caused by invalid result rel
	 * distribution.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_path</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Pretend parameterized paths have no pathkeys, per comment above */</comment>
    <expr_stmt><expr><name>new_path_pathkeys</name> <operator>=</operator> <ternary><condition><expr><name><name>new_path</name><operator>-&gt;</operator><name>param_info</name></name></expr> ?</condition><then> <expr><name>NIL</name></expr> </then><else>: <expr><name><name>new_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/*
     * Loop to check proposed new path against old paths.  Note it is possible
     * for more than one old path to be tossed out because new_path dominates
     * it.
     *
     * We can't use foreach here because the loop body may delete the current
     * list cell.
     */</comment>
    <expr_stmt><expr><name>p1_prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>p1</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>pathlist</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p1</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>p1</name> <operator>=</operator> <name>p1_next</name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>old_path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>remove_old</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> <comment type="block">/* unless new proves superior */</comment>
        <decl_stmt><decl><type><name>PathCostComparison</name></type> <name>costcmp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PathKeysComparison</name></type> <name>keyscmp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BMS_Comparison</name></type> <name>outercmp</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>p1_next</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Do a fuzzy cost comparison with standard fuzziness limit.
         */</comment>
        <expr_stmt><expr><name>costcmp</name> <operator>=</operator> <call><name>compare_path_costs_fuzzily</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr><name>old_path</name></expr></argument>,
                                             <argument><expr><name>STD_FUZZ_FACTOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If the two paths compare differently for startup and total cost,
         * then we want to keep both, and we can skip comparing pathkeys and
         * required_outer rels.  If they compare the same, proceed with the
         * other comparisons.  Row count is checked last.  (We make the tests
         * in this order because the cost comparison is most likely to turn
         * out "different", and the pathkeys comparison next most likely.  As
         * explained above, row count very seldom makes a difference, so even
         * though it's cheap to compare there's not much point in checking it
         * earlier.)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>costcmp</name> <operator>!=</operator> <name>COSTS_DIFFERENT</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Similarly check to see if either dominates on pathkeys */</comment>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>old_path_pathkeys</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>old_path_pathkeys</name> <operator>=</operator> <ternary><condition><expr><name><name>old_path</name><operator>-&gt;</operator><name>param_info</name></name></expr> ?</condition><then> <expr><name>NIL</name></expr> </then><else>: <expr><name><name>old_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name>keyscmp</name> <operator>=</operator> <call><name>compare_pathkeys</name><argument_list>(<argument><expr><name>new_path_pathkeys</name></expr></argument>,
                                       <argument><expr><name>old_path_pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>keyscmp</name> <operator>!=</operator> <name>PATHKEYS_DIFFERENT</name></expr>)</condition>
            <block>{<block_content>
                <switch>switch <condition>(<expr><name>costcmp</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>COSTS_EQUAL</name></expr>:</case>
                        <expr_stmt><expr><name>outercmp</name> <operator>=</operator> <call><name>bms_subset_compare</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>old_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>keyscmp</name> <operator>==</operator> <name>PATHKEYS_BETTER1</name></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>outercmp</name> <operator>==</operator> <name>BMS_EQUAL</name> <operator>||</operator>
                                 <name>outercmp</name> <operator>==</operator> <name>BMS_SUBSET1</name><operator>)</operator> <operator>&amp;&amp;</operator>
                                <name><name>new_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&lt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&amp;&amp;</operator>
                                <name><name>new_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&gt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>remove_old</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* new dominates old */</comment>
                        </block_content>}</block></if>
                        <if type="elseif">else if <condition>(<expr><name>keyscmp</name> <operator>==</operator> <name>PATHKEYS_BETTER2</name></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>outercmp</name> <operator>==</operator> <name>BMS_EQUAL</name> <operator>||</operator>
                                 <name>outercmp</name> <operator>==</operator> <name>BMS_SUBSET2</name><operator>)</operator> <operator>&amp;&amp;</operator>
                                <name><name>new_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&gt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&amp;&amp;</operator>
                                <name><name>new_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&lt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>accept_new</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* old dominates new */</comment>
                        </block_content>}</block></if>
                        <else>else    <comment type="block">/* keyscmp == PATHKEYS_EQUAL */</comment>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name>outercmp</name> <operator>==</operator> <name>BMS_EQUAL</name></expr>)</condition>
                            <block>{<block_content>
                                <comment type="block">/*
                                 * Same pathkeys and outer rels, and fuzzily
                                 * the same cost, so keep just one; to decide
                                 * which, first check parallel-safety, then
                                 * rows, then do a fuzzy cost comparison with
                                 * very small fuzz limit.  (We used to do an
                                 * exact cost comparison, but that results in
                                 * annoying platform-specific plan variations
                                 * due to roundoff in the cost estimates.)    If
                                 * things are still tied, arbitrarily keep
                                 * only the old path.  Notice that we will
                                 * keep only the old path even if the
                                 * less-fuzzy comparison decides the startup
                                 * and total costs compare differently.
                                 */</comment>
                                <if_stmt><if>if <condition>(<expr><name><name>new_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&gt;</operator>
                                    <name><name>old_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><name>remove_old</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* new dominates old */</comment>
                                <if type="elseif">else if <condition>(<expr><name><name>new_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&lt;</operator>
                                         <name><name>old_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><name>accept_new</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* old dominates new */</comment>
                                <if type="elseif">else if <condition>(<expr><name><name>new_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&lt;</operator> <name><name>old_path</name><operator>-&gt;</operator><name>rows</name></name></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><name>remove_old</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* new dominates old */</comment>
                                <if type="elseif">else if <condition>(<expr><name><name>new_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&gt;</operator> <name><name>old_path</name><operator>-&gt;</operator><name>rows</name></name></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><name>accept_new</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* old dominates new */</comment>
                                <if type="elseif">else if <condition>(<expr><call><name>compare_path_costs_fuzzily</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>,
                                                                    <argument><expr><name>old_path</name></expr></argument>,
                                                                    <argument><expr><literal type="number">1.0000000001</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>COSTS_BETTER1</name></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><name>remove_old</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* new dominates old */</comment>
                                <else>else<block type="pseudo"><block_content>
                                    <expr_stmt><expr><name>accept_new</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* old equals or
                                                         * dominates new */</comment>
                            </block_content>}</block></if>
                            <if type="elseif">else if <condition>(<expr><name>outercmp</name> <operator>==</operator> <name>BMS_SUBSET1</name> <operator>&amp;&amp;</operator>
                                     <name><name>new_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&lt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&amp;&amp;</operator>
                                     <name><name>new_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&gt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>remove_old</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* new dominates old */</comment>
                            <if type="elseif">else if <condition>(<expr><name>outercmp</name> <operator>==</operator> <name>BMS_SUBSET2</name> <operator>&amp;&amp;</operator>
                                     <name><name>new_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&gt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&amp;&amp;</operator>
                                     <name><name>new_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&lt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>accept_new</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* old dominates new */</comment>
                            <comment type="block">/* else different parameterizations, keep both */</comment>
                        </block_content>}</block></else></if_stmt>
                        <break>break;</break>
                    <case>case <expr><name>COSTS_BETTER1</name></expr>:</case>
                        <if_stmt><if>if <condition>(<expr><name>keyscmp</name> <operator>!=</operator> <name>PATHKEYS_BETTER2</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>outercmp</name> <operator>=</operator> <call><name>bms_subset_compare</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr></argument>,
                                                          <argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>old_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>outercmp</name> <operator>==</operator> <name>BMS_EQUAL</name> <operator>||</operator>
                                 <name>outercmp</name> <operator>==</operator> <name>BMS_SUBSET1</name><operator>)</operator> <operator>&amp;&amp;</operator>
                                <name><name>new_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&lt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&amp;&amp;</operator>
                                <name><name>new_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&gt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>remove_old</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* new dominates old */</comment>
                        </block_content>}</block></if></if_stmt>
                        <break>break;</break>
                    <case>case <expr><name>COSTS_BETTER2</name></expr>:</case>
                        <if_stmt><if>if <condition>(<expr><name>keyscmp</name> <operator>!=</operator> <name>PATHKEYS_BETTER1</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>outercmp</name> <operator>=</operator> <call><name>bms_subset_compare</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr></argument>,
                                                          <argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>old_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>outercmp</name> <operator>==</operator> <name>BMS_EQUAL</name> <operator>||</operator>
                                 <name>outercmp</name> <operator>==</operator> <name>BMS_SUBSET2</name><operator>)</operator> <operator>&amp;&amp;</operator>
                                <name><name>new_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&gt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>rows</name></name> <operator>&amp;&amp;</operator>
                                <name><name>new_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&lt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>accept_new</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* old dominates new */</comment>
                        </block_content>}</block></if></if_stmt>
                        <break>break;</break>
                    <case>case <expr><name>COSTS_DIFFERENT</name></expr>:</case>

                        <comment type="block">/*
                         * can't get here, but keep this case to keep compiler
                         * quiet
                         */</comment>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Remove current element from pathlist if dominated by new.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>remove_old</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>pathlist</name></name></expr></argument>,
                                                    <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p1_prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Delete the data pointed-to by the deleted cell, if possible
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>old_path</name></expr></argument>, <argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>old_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* p1_prev does not advance */</comment>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* new belongs after this old path if it has cost &gt;= old's */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>new_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&gt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>total_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>insert_after</name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* p1_prev advances */</comment>
            <expr_stmt><expr><name>p1_prev</name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * If we found an old path that dominates new_path, we can quit
         * scanning the pathlist; we will not add new_path, and we assume
         * new_path cannot dominate any other elements of the pathlist.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>accept_new</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>accept_new</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Accept the new path: insert it at proper place in pathlist */</comment>
        <if_stmt><if>if <condition>(<expr><name>insert_after</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>lappend_cell</name><argument_list>(<argument><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>pathlist</name></name></expr></argument>, <argument><expr><name>insert_after</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>pathlist</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>pathlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Reject and recycle the new path */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * add_path_precheck
 *      Check whether a proposed new path could possibly get accepted.
 *      We assume we know the path's pathkeys and parameterization accurately,
 *      and have lower bounds for its costs.
 *
 * Note that we do not know the path's rowcount, since getting an estimate for
 * that is too expensive to do before prechecking.  We assume here that paths
 * of a superset parameterization will generate fewer rows; if that holds,
 * then paths with different parameterizations cannot dominate each other
 * and so we can simply ignore existing paths of another parameterization.
 * (In the infrequent cases where that rule of thumb fails, add_path will
 * get rid of the inferior path.)
 *
 * At the time this is called, we haven't actually built a Path structure,
 * so the required information has to be passed piecemeal.
 */</comment>
<function><type><name>bool</name></type>
<name>add_path_precheck</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parent_rel</name></decl></parameter>,
                  <parameter><decl><type><name>Cost</name></type> <name>startup_cost</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>total_cost</name></decl></parameter>,
                  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>new_path_pathkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>consider_startup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>p1</name></decl>;</decl_stmt>

    <comment type="block">/* Pretend parameterized paths have no pathkeys, per add_path policy */</comment>
    <expr_stmt><expr><name>new_path_pathkeys</name> <operator>=</operator> <ternary><condition><expr><name>required_outer</name></expr> ?</condition><then> <expr><name>NIL</name></expr> </then><else>: <expr><name>pathkeys</name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/* Decide whether new path's startup cost is interesting */</comment>
    <expr_stmt><expr><name>consider_startup</name> <operator>=</operator> <ternary><condition><expr><name>required_outer</name></expr> ?</condition><then> <expr><name><name>parent_rel</name><operator>-&gt;</operator><name>consider_param_startup</name></name></expr> </then><else>: <expr><name><name>parent_rel</name><operator>-&gt;</operator><name>consider_startup</name></name></expr></else></ternary></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>p1</argument>, <argument>parent_rel-&gt;pathlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>old_path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PathKeysComparison</name></type> <name>keyscmp</name></decl>;</decl_stmt>

        <comment type="block">/*
         * We are looking for an old_path with the same parameterization (and
         * by assumption the same rowcount) that dominates the new path on
         * pathkeys as well as both cost metrics.  If we find one, we can
         * reject the new path.
         *
         * Cost comparisons here should match compare_path_costs_fuzzily.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>total_cost</name> <operator>&gt;</operator> <name><name>old_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>*</operator> <name>STD_FUZZ_FACTOR</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* new path can win on startup cost only if consider_startup */</comment>
            <if_stmt><if>if <condition>(<expr><name>startup_cost</name> <operator>&gt;</operator> <name><name>old_path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>*</operator> <name>STD_FUZZ_FACTOR</name> <operator>||</operator>
                <operator>!</operator><name>consider_startup</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* new path loses on cost, so check pathkeys... */</comment>
                <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>old_path_pathkeys</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>old_path_pathkeys</name> <operator>=</operator> <ternary><condition><expr><name><name>old_path</name><operator>-&gt;</operator><name>param_info</name></name></expr> ?</condition><then> <expr><name>NIL</name></expr> </then><else>: <expr><name><name>old_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></else></ternary></expr>;</expr_stmt>
                <expr_stmt><expr><name>keyscmp</name> <operator>=</operator> <call><name>compare_pathkeys</name><argument_list>(<argument><expr><name>new_path_pathkeys</name></expr></argument>,
                                           <argument><expr><name>old_path_pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>keyscmp</name> <operator>==</operator> <name>PATHKEYS_EQUAL</name> <operator>||</operator>
                    <name>keyscmp</name> <operator>==</operator> <name>PATHKEYS_BETTER2</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* new path does not win on pathkeys... */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>bms_equal</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>, <argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>old_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* Found an old path that dominates the new one */</comment>
                        <return>return <expr><name>false</name></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * Since the pathlist is sorted by total_cost, we can stop looking
             * once we reach a path with a total_cost larger than the new
             * path's.
             */</comment>
            <break>break;</break>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * add_partial_path
 *      Like add_path, our goal here is to consider whether a path is worthy
 *      of being kept around, but the considerations here are a bit different.
 *      A partial path is one which can be executed in any number of workers in
 *      parallel such that each worker will generate a subset of the path's
 *      overall result.
 *
 *      As in add_path, the partial_pathlist is kept sorted with the cheapest
 *      total path in front.  This is depended on by multiple places, which
 *      just take the front entry as the cheapest path without searching.
 *
 *      We don't generate parameterized partial paths for several reasons.  Most
 *      importantly, they're not safe to execute, because there's nothing to
 *      make sure that a parallel scan within the parameterized portion of the
 *      plan is running with the same value in every worker at the same time.
 *      Fortunately, it seems unlikely to be worthwhile anyway, because having
 *      each worker scan the entire outer relation and a subset of the inner
 *      relation will generally be a terrible plan.  The inner (parameterized)
 *      side of the plan will be small anyway.  There could be rare cases where
 *      this wins big - e.g. if join order constraints put a 1-row relation on
 *      the outer side of the topmost join with a parameterized plan on the inner
 *      side - but we'll have to be content not to handle such cases until
 *      somebody builds an executor infrastructure that can cope with them.
 *
 *      Because we don't consider parameterized paths here, we also don't
 *      need to consider the row counts as a measure of quality: every path will
 *      produce the same number of rows.  Neither do we need to consider startup
 *      costs: parallelism is only used for plans that will be run to completion.
 *      Therefore, this routine is much simpler than add_path: it needs to
 *      consider only pathkeys and total cost.
 *
 *      As with add_path, we pfree paths that are found to be dominated by
 *      another partial path; this requires that there be no other references to
 *      such paths yet.  Hence, GatherPaths must not be created for a rel until
 *      we're done creating all partial paths for it.  Unlike add_path, we don't
 *      take an exception for IndexPaths as partial index paths won't be
 *      referenced by partial BitmapHeapPaths.
 */</comment>
<function><type><name>void</name></type>
<name>add_partial_path</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parent_rel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>new_path</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>accept_new</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* unless we find a superior old path */</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>insert_after</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* where to insert new item */</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>p1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>p1_prev</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>p1_next</name></decl>;</decl_stmt>

    <comment type="block">/* Check for query cancel. */</comment>
    <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * As in add_path, throw out any paths which are dominated by the new
     * path, but throw out the new path if some existing path dominates it.
     */</comment>
    <expr_stmt><expr><name>p1_prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>p1</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>p1</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
         <incr><expr><name>p1</name> <operator>=</operator> <name>p1_next</name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>old_path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>remove_old</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> <comment type="block">/* unless new proves superior */</comment>
        <decl_stmt><decl><type><name>PathKeysComparison</name></type> <name>keyscmp</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>p1_next</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Compare pathkeys. */</comment>
        <expr_stmt><expr><name>keyscmp</name> <operator>=</operator> <call><name>compare_pathkeys</name><argument_list>(<argument><expr><name><name>new_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>, <argument><expr><name><name>old_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Unless pathkeys are incompable, keep just one of the two paths. */</comment>
        <if_stmt><if>if <condition>(<expr><name>keyscmp</name> <operator>!=</operator> <name>PATHKEYS_DIFFERENT</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>new_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&gt;</operator> <name><name>old_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>*</operator> <name>STD_FUZZ_FACTOR</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* New path costs more; keep it only if pathkeys are better. */</comment>
                <if_stmt><if>if <condition>(<expr><name>keyscmp</name> <operator>!=</operator> <name>PATHKEYS_BETTER1</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>accept_new</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>old_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&gt;</operator> <name><name>new_path</name><operator>-&gt;</operator><name>total_cost</name></name>
                     <operator>*</operator> <name>STD_FUZZ_FACTOR</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Old path costs more; keep it only if pathkeys are better. */</comment>
                <if_stmt><if>if <condition>(<expr><name>keyscmp</name> <operator>!=</operator> <name>PATHKEYS_BETTER2</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>remove_old</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>keyscmp</name> <operator>==</operator> <name>PATHKEYS_BETTER1</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Costs are about the same, new path has better pathkeys. */</comment>
                <expr_stmt><expr><name>remove_old</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>keyscmp</name> <operator>==</operator> <name>PATHKEYS_BETTER2</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Costs are about the same, old path has better pathkeys. */</comment>
                <expr_stmt><expr><name>accept_new</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>old_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&gt;</operator> <name><name>new_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>*</operator> <literal type="number">1.0000000001</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Pathkeys are the same, and the old path costs more. */</comment>
                <expr_stmt><expr><name>remove_old</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * Pathkeys are the same, and new path isn't materially
                 * cheaper.
                 */</comment>
                <expr_stmt><expr><name>accept_new</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Remove current element from partial_pathlist if dominated by new.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>remove_old</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>=</operator>
                <call><name>list_delete_cell</name><argument_list>(<argument><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p1_prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>old_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* p1_prev does not advance */</comment>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* new belongs after this old path if it has cost &gt;= old's */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>new_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&gt;=</operator> <name><name>old_path</name><operator>-&gt;</operator><name>total_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>insert_after</name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/* p1_prev advances */</comment>
            <expr_stmt><expr><name>p1_prev</name> <operator>=</operator> <name>p1</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * If we found an old path that dominates new_path, we can quit
         * scanning the partial_pathlist; we will not add new_path, and we
         * assume new_path cannot dominate any later path.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>accept_new</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>accept_new</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Accept the new path: insert it at proper place */</comment>
        <if_stmt><if>if <condition>(<expr><name>insert_after</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>lappend_cell</name><argument_list>(<argument><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>, <argument><expr><name>insert_after</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name> <operator>=</operator>
                <call><name>lcons</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>partial_pathlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Reject and recycle the new path */</comment>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * add_partial_path_precheck
 *      Check whether a proposed new partial path could possibly get accepted.
 *
 * Unlike add_path_precheck, we can ignore startup cost and parameterization,
 * since they don't matter for partial paths (see add_partial_path).  But
 * we do want to make sure we don't add a partial path if there's already
 * a complete path that dominates it, since in that case the proposed path
 * is surely a loser.
 */</comment>
<function><type><name>bool</name></type>
<name>add_partial_path_precheck</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parent_rel</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>total_cost</name></decl></parameter>,
                          <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>p1</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Our goal here is twofold.  First, we want to find out whether this path
     * is clearly inferior to some existing partial path.  If so, we want to
     * reject it immediately.  Second, we want to find out whether this path
     * is clearly superior to some existing partial path -- at least, modulo
     * final cost computations.  If so, we definitely want to consider it.
     *
     * Unlike add_path(), we always compare pathkeys here.  This is because we
     * expect partial_pathlist to be very short, and getting a definitive
     * answer at this stage avoids the need to call add_path_precheck.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>p1</argument>, <argument>parent_rel-&gt;partial_pathlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>old_path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PathKeysComparison</name></type> <name>keyscmp</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>keyscmp</name> <operator>=</operator> <call><name>compare_pathkeys</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name><name>old_path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>keyscmp</name> <operator>!=</operator> <name>PATHKEYS_DIFFERENT</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>total_cost</name> <operator>&gt;</operator> <name><name>old_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>*</operator> <name>STD_FUZZ_FACTOR</name> <operator>&amp;&amp;</operator>
                <name>keyscmp</name> <operator>!=</operator> <name>PATHKEYS_BETTER1</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>old_path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>&gt;</operator> <name>total_cost</name> <operator>*</operator> <name>STD_FUZZ_FACTOR</name> <operator>&amp;&amp;</operator>
                <name>keyscmp</name> <operator>!=</operator> <name>PATHKEYS_BETTER2</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * This path is neither clearly inferior to an existing partial path nor
     * clearly good enough that it might replace one.  Compare it to
     * non-parallel plans.  If it loses even before accounting for the cost of
     * the Gather node, we should definitely reject it.
     *
     * Note that we pass the total_cost to add_path_precheck twice.  This is
     * because it's never advantageous to consider the startup cost of a
     * partial path; the resulting plans, if run in parallel, will be run to
     * completion.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>add_path_precheck</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>, <argument><expr><name>total_cost</name></expr></argument>, <argument><expr><name>total_cost</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>,
                           <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *        PATH NODE CREATION ROUTINES
 *****************************************************************************/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<comment type="block">/*
 * restrict_distribution
 *    Analyze the RestrictInfo and decide if it is possible to restrict
 *    distribution nodes
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>restrict_distribution</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>ri</name></decl></parameter>,
                                  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>pathnode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Distribution</name>   <modifier>*</modifier></type><name>distribution</name> <init>= <expr><name><name>pathnode</name><operator>-&gt;</operator><name>distribution</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>                <name>keytype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Const</name>           <modifier>*</modifier></type><name>constExpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name>found_key</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Oid</name></type>             <name>reloid</name>  <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>             <name>groupid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Can not restrict - not distributed or key is not defined
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>distribution</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
            <name><name>distribution</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We do not support OR'ed conditions yet
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>ri</name><operator>-&gt;</operator><name>orclause</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Check if the operator is hash joinable. Currently we only support hash
     * joinable operator for arriving at restricted nodes. This allows us
     * correctly deduce clauses which include a mix of int2/int4/int8 or
     * float4/float8 or clauses which have same type arguments and have a hash
     * joinable operator.
     *
     * Note: This stuff is mostly copied from check_hashjoinable
     */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>clause</name> <init>= <expr><name><name>ri</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>opno</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>leftarg</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>ri</name><operator>-&gt;</operator><name>pseudoconstant</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_opclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>opno</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>opno</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>leftarg</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_hashjoinable</name><argument_list>(<argument><expr><name>opno</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>leftarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
                <call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>
    </block_content>}</block>


    <expr_stmt><expr><name>keytype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name><name>distribution</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ri</name><operator>-&gt;</operator><name>left_ec</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><name><name>ri</name><operator>-&gt;</operator><name>left_ec</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>, <argument><expr><name><name>distribution</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>found_key</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>cexpr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                       <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>cexpr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>constExpr</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>cexpr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>ri</name><operator>-&gt;</operator><name>right_ec</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><name><name>ri</name><operator>-&gt;</operator><name>right_ec</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>, <argument><expr><name><name>distribution</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>found_key</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>cexpr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                       <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>cexpr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>constExpr</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>cexpr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>opexpr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name><name>ri</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
                <call><name>op_mergejoinable</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>arg1</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>arg2</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>other</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifndef>
            <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var1</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><call><name>get_var_from_arg</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>arg1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var2</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><call><name>get_var_from_arg</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>arg2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>var1</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>arg1</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>var1</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>var2</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>arg2</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>var2</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name><name>distribution</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>other</name> <operator>=</operator> <name>arg2</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><name><name>distribution</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>other</name> <operator>=</operator> <name>arg1</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>other</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>found_key</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>other</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>constExpr</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>other</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>found_key</name> <operator>&amp;&amp;</operator> <name>constExpr</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name>        <modifier>*</modifier></type><name>nodeList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>tmpset</name> <init>= <expr><call><name>bms_copy</name><argument_list>(<argument><expr><name><name>distribution</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>restrictinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Locator</name>    <modifier>*</modifier></type><name>locator</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name>           <modifier>*</modifier></type><name>nodenums</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>         <name>i</name></decl>, <decl><type ref="prev"/><name>count</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
        <decl_stmt><decl><type><name>AttrNumber</name></type>  <name>secAttrNum</name> <init>= <expr><name>InvalidAttrNumber</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <while>while<condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_first_member</name><argument_list>(<argument><expr><name>tmpset</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>nodeList</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>nodeList</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>tmpset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>nodeList</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"[restrict_distribution]nodeList is empty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return ;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//for (i = 1; i &lt; root-&gt;simple_rel_array_size; i++)</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array_size</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>rtekind</name> <operator>==</operator> <name>RTE_RELATION</name>
                <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>relkind</name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>reloid</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>relid</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"[restrict_distribution]reloid=%d"</literal></expr></argument>, <argument><expr><name>reloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>groupid</name> <operator>=</operator> <call><name>GetRelGroup</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"[restrict_distribution]groupid=%d"</literal></expr></argument>, <argument><expr><name>groupid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>groupid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>distribution</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not get group info for shard table %u"</literal></expr></argument>, <argument><expr><name>reloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name></name> <operator>&amp;&amp;</operator> <call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>secAttrNum</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><name>locator</name> <operator>=</operator> <call><name>createLocator</name><argument_list>(<argument><expr><name><name>distribution</name><operator>-&gt;</operator><name>distributionType</name></name></expr></argument>,
                                <argument><expr><name>RELATION_ACCESS_READ</name></expr></argument>,
                                <argument><expr><name>keytype</name></expr></argument>,
                                <argument><expr><name>LOCATOR_LIST_LIST</name></expr></argument>,
                                <argument><expr><literal type="number">0</literal></expr></argument>,
                                <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>nodeList</name></expr></argument>,
                                <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>nodenums</name></expr></argument>,
                                <argument><expr><name>false</name></expr></argument>,
                                <argument><expr><name>groupid</name></expr></argument>, <argument><expr><call><name>GetRelColdGroup</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>secAttrNum</name></expr></argument>,
                                <argument><expr><name>reloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>locator</name> <operator>=</operator> <call><name>createLocator</name><argument_list>(<argument><expr><name><name>distribution</name><operator>-&gt;</operator><name>distributionType</name></name></expr></argument>,
                                <argument><expr><name>RELATION_ACCESS_READ</name></expr></argument>,
                                <argument><expr><name>keytype</name></expr></argument>,
                                <argument><expr><name>LOCATOR_LIST_LIST</name></expr></argument>,
                                <argument><expr><literal type="number">0</literal></expr></argument>,
                                <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>nodeList</name></expr></argument>,
                                <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>nodenums</name></expr></argument>,
                                <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>GET_NODES</name><argument_list>(<argument><expr><name>locator</name></expr></argument>, <argument><expr><name><name>constExpr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>,
                          <argument><expr><name><name>constExpr</name><operator>-&gt;</operator><name>constisnull</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>GET_NODES</name><argument_list>(<argument><expr><name>locator</name></expr></argument>, <argument><expr><name><name>constExpr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>,
                          <argument><expr><name><name>constExpr</name><operator>-&gt;</operator><name>constisnull</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name>restrictinfo</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>restrictinfo</name></expr></argument>, <argument><expr><name><name>nodenums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        <if_stmt><if>if <condition>(<expr><name><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <call><name>bms_intersect</name><argument_list>(<argument><expr><name><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>,
                                                        <argument><expr><name>restrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <name>restrictinfo</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>nodeList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>freeLocator</name><argument_list>(<argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * set_scanpath_distribution
 *      Assign distribution to the path which is a base relation scan.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_scanpath_distribution</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>pathnode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>RangeTblEntry</name>   <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rel_loc_info</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rel_loc_info</name> <operator>=</operator> <call><name>GetRelationLocInfo</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* 
     * get group oid which base rel belongs to, and used later at end of planner.
     * local tables not included.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>rel_loc_info</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type> <name>group</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name> <operator>||</operator>
                <name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_REPLICATED</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>GetRelGroup</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>group</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call> 
                <operator>||</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>has_cold_hot_table</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_REPLICATED</name>
                    <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* do nothing */</comment>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>groupOids</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name>groupOids</name></expr></argument>, <argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <name>rel_loc_info</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>retry</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Distribution</name> <modifier>*</modifier></type><name>distribution</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Distribution</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>distribution</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>=</operator> <name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name></expr>;</expr_stmt>
        <comment type="block">/*
         * for LOCATOR_TYPE_REPLICATED distribution, check if
         * all of the mentioned nodes are hale and hearty. Remove
         * those which are not. Do this only for SELECT queries!
         */</comment>
<label><name>retry_pools</name>:</label>
        <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator>
                <name><name>distribution</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_REPLICATED</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>healthmap</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>healthmap</name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>TBASE_MAX_DATANODE_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>healthmap</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory for healthmap"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>PgxcNodeDnListHealth</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr></argument>, <argument><expr><name>healthmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel_loc_info-&gt;rl_nodeList</argument>)</argument_list></macro>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>healthmap</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>==</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>distribution</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>distribution</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>,
                                                         <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block>

            <if_stmt><if>if <condition>(<expr><name>healthmap</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>healthmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>healthmap</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>distribution</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Try an on-demand pool maintenance just to see if some nodes
                 * have come back.
                 *
                 * Try once and error out if datanodes are still down
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>retry</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>PoolPingNodes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>retry</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <goto>goto <name>retry_pools</name>;</goto>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                         <argument><expr><literal type="string">"Could not find healthy nodes for replicated table. Exiting!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel_loc_info-&gt;rl_nodeList</argument>)</argument_list></macro>
                <expr_stmt><expr><name><name>distribution</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>distribution</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>,
                                                     <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <comment type="block">/*
         * Distribution expression of the base relation is Var representing
         * respective attribute.
         */</comment>
        <expr_stmt><expr><name><name>distribution</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>partAttrNum</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Var</name>        <modifier>*</modifier></type><name>var</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

            <comment type="block">/* Look if the Var is already in the target list */</comment>
            <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>rel-&gt;reltarget-&gt;exprs</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>&amp;&amp;</operator>
                        <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>rel_loc_info</name><operator>-&gt;</operator><name>partAttrNum</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block>
            <comment type="block">/* If not found we should look up the attribute and make the Var */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lc</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Relation</name></type>     <name>relation</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tdesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>att_tup</name> <operator>=</operator> <name><name>tdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>partAttrNum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>partAttrNum</name></name></expr></argument>,
                              <argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
                              <argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


                <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name><name>distribution</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>distribution</name></name> <operator>=</operator> <name>distribution</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * create_remotesubplan_path
 *    Redistribute the data to match the distribution.
 *
 * Creates a RemoteSubPath on top of the path, redistributing the data
 * according to the specified distribution.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_remotesubplan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
                          <parameter><decl><type><name>Distribution</name> <modifier>*</modifier></type><name>distribution</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RelOptInfo</name>       <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteSubPath</name>  <modifier>*</modifier></type><name>pathnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Distribution</name>   <modifier>*</modifier></type><name>subDist</name> <init>= <expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>pathnode</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteSubPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_RemoteSubplan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <operator>(</operator><name>Distribution</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>distribution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We don't want to run subplains in parallel workers */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>cost_remote_subplan</name><argument_list>(<argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>,
                        <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
						<argument><expr><ternary><condition><expr><name>subDist</name></expr> ?</condition><then> <expr><call><name>calcDistReplications</name><argument_list>(<argument><expr><name><name>subDist</name><operator>-&gt;</operator><name>distributionType</name></name></expr></argument>, <argument><expr><name><name>subDist</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * redistribute_path
 *     Redistributes the path to match desired distribution parameters.
 *
 * It's also possible to specify desired sort order using pathkeys. If the
 * subpath does not match the order, a Sort node will be added automatically.
 * This is similar to how create_merge_append_path() injects Sort nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>Path</name> <modifier>*</modifier></type>
<name>redistribute_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
                  <parameter><decl><type><name>char</name></type> <name>distributionType</name></decl></parameter>, <parameter><decl><type><name>Node</name><modifier>*</modifier></type> <name>distributionExpr</name></decl></parameter>,
                  <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nodes</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>restrictNodes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Distribution</name>   <modifier>*</modifier></type><name>distribution</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelOptInfo</name>       <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteSubPath</name>  <modifier>*</modifier></type><name>pathnode</name></decl>;</decl_stmt>

     <if_stmt><if>if <condition>(<expr><name>distributionType</name> <operator>!=</operator> <name>LOCATOR_TYPE_NONE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>distribution</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Distribution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>distribution</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>=</operator> <name>distributionType</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>distribution</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <name>nodes</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <name>restrictNodes</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>distribution</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>=</operator> <name>distributionExpr</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If inner path node is a MaterialPath pull it up to store tuples on
     * the destination nodes and avoid sending them over the network.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>MaterialPath</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MaterialPath</name> <modifier>*</modifier></type><name>mpath</name> <init>= <expr><operator>(</operator><name>MaterialPath</name> <operator>*</operator><operator>)</operator> <name>subpath</name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* If subpath is already a RemoteSubPath, just replace distribution */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>mpath</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>RemoteSubPath</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>pathnode</name> <operator>=</operator> <operator>(</operator><name>RemoteSubPath</name> <operator>*</operator><operator>)</operator> <name><name>mpath</name><operator>-&gt;</operator><name>subpath</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>pathnode</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteSubPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_RemoteSubplan</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name><name>mpath</name><operator>-&gt;</operator><name>subpath</name></name></expr>;</expr_stmt>

            <comment type="block">/* We don't want to run subplains in parallel workers */</comment>
            <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>mpath</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>subpath</name> <operator>=</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <name>distribution</name></expr>;</expr_stmt>
        <comment type="block">/* (re)calculate costs */</comment>
		<expr_stmt><expr><call><name>cost_remote_subplan</name><argument_list>(<argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr></argument>,
							<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>,
							<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
							<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
							<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
							<argument><expr><call><name>calcDistReplications</name><argument_list>(<argument><expr><name>distributionType</name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>mpath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <operator>(</operator><name>Distribution</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>distribution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mpath</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>cost_material</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mpath</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
                      <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name></expr></argument>,
                      <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name></expr></argument>,
                      <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr></argument>,
                      <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>mpath</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>Cost</name></type>    <name>input_startup_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Cost</name></type>    <name>input_total_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>pathnode</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteSubPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_RemoteSubplan</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <ternary><condition><expr><name>pathkeys</name></expr> ?</condition><then> <expr><name>pathkeys</name></expr> </then><else>: <expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <name>distribution</name></expr>;</expr_stmt>

        <comment type="block">/*
         * If we need to insert a Sort node, add it here, so that it gets
         * pushed down to the remote node.
         *
         * This works just like create_merge_append_path, i.e. we only do the
         * costing here and only actually construct the Sort node later in
         * create_remotescan_plan.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Subpath is adequately ordered, we won't need to sort it */</comment>
            <expr_stmt><expr><name>input_startup_cost</name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>input_total_cost</name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* We'll need to insert a Sort node, so include cost for that */</comment>
            <decl_stmt><decl><type><name>Path</name></type>        <name>sort_path</name></decl>;</decl_stmt>        <comment type="block">/* dummy for result of cost_sort */</comment>

            <expr_stmt><expr><call><name>cost_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sort_path</name></expr></argument>,
                      <argument><expr><name>root</name></expr></argument>,
                      <argument><expr><name>pathkeys</name></expr></argument>,
                      <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
                      <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>,
                      <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
                      <argument><expr><literal type="number">0.0</literal></expr></argument>,
                      <argument><expr><name>work_mem</name></expr></argument>,
                      <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>input_startup_cost</name> <operator>+=</operator> <name><name>sort_path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>input_total_cost</name> <operator>+=</operator> <name><name>sort_path</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>

        <comment type="block">/* We don't want to run subplains in parallel workers */</comment>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>cost_remote_subplan</name><argument_list>(<argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr></argument>,
							<argument><expr><name>input_startup_cost</name></expr></argument>,
							<argument><expr><name>input_total_cost</name></expr></argument>,
							<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
							<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
							<argument><expr><call><name>calcDistReplications</name><argument_list>(<argument><expr><name>distributionType</name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Analyze join parameters and set distribution of the join node.
 * If there are possible alternate distributions the respective pathes are
 * returned as a list so caller can cost all of them and choose cheapest to
 * continue.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>set_joinpath_distribution</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>JoinPath</name> <modifier>*</modifier></type><name>pathnode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Distribution</name>   <modifier>*</modifier></type><name>innerd</name> <init>= <expr><name><name>pathnode</name><operator>-&gt;</operator><name>innerjoinpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Distribution</name>   <modifier>*</modifier></type><name>outerd</name> <init>= <expr><name><name>pathnode</name><operator>-&gt;</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Distribution</name>   <modifier>*</modifier></type><name>targetd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>           <modifier>*</modifier></type><name>alternate</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>           <modifier>*</modifier></type><name>restrictClauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>List</name>           <modifier>*</modifier></type><name>innerpathkeys</name> <init>= <expr><name><name>pathnode</name><operator>-&gt;</operator><name>innerjoinpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>           <modifier>*</modifier></type><name>outerpathkeys</name> <init>= <expr><name><name>pathnode</name><operator>-&gt;</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<decl_stmt><decl><type><name>bool</name></type>           <name>dml</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		   <name>keepResultRelLoc</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannerInfo</name>    <modifier>*</modifier></type><name>top_root</name> <init>= <expr><name>root</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResultRelLocation</name></type> <name>resultRelLoc</name> <init>= <expr><name>RESULT_REL_NONE</name></expr></init></decl>;</decl_stmt>

	<while>while<condition>(<expr><name><name>top_root</name><operator>-&gt;</operator><name>parent_root</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>top_root</name> <operator>=</operator> <name><name>top_root</name><operator>-&gt;</operator><name>parent_root</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name><name>top_root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator>
		<name><name>top_root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dml</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Only top root will consider more restrict rules to make sure
	 * UPDATE/DELETE result relation does not redistributed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>top_root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator>
		<name><name>top_root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Set the result relation location */</comment>
		<expr_stmt><expr><name>resultRelLoc</name> <operator>=</operator> <call><name>getResultRelLocation</name><argument_list>(<argument><expr><name><name>top_root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>,
											<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>innerjoinpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
											<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>resultRelLoc</name></name> <operator>=</operator> <name>resultRelLoc</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>resultRelLoc</name> <operator>!=</operator> <name>RESULT_REL_NONE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>keepResultRelLoc</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


    <comment type="block">/* for mergejoins, override with outersortkeys, if needed */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>MergePath</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MergePath</name> <modifier>*</modifier></type><name>mpath</name> <init>= <expr><operator>(</operator><name>MergePath</name><operator>*</operator><operator>)</operator><name>pathnode</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>mpath</name><operator>-&gt;</operator><name>innersortkeys</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>innerpathkeys</name> <operator>=</operator> <name><name>mpath</name><operator>-&gt;</operator><name>innersortkeys</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>mpath</name><operator>-&gt;</operator><name>outersortkeys</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>outerpathkeys</name> <operator>=</operator> <name><name>mpath</name><operator>-&gt;</operator><name>outersortkeys</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Catalog join */</comment>
    <if_stmt><if>if <condition>(<expr><name>innerd</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>outerd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>

	<comment type="block">/*
	 * If outer or inner subpaths are distributed by shard and they do not exist
	 * in same node set, which means we may need to redistribute tuples to data
	 * nodes which use different router map to producer.
	 * We don't support that, so pull it up to CN to accomplish the join.
	 * 
	 * TODO:
	 *      1. if the join is "REPLICATION join SHARD", and node set of SHARD table
	 *      is subset of REPLICATION table, no need to pull up.
	 *      2. find out which side of this join needs to dispatch, and only decide
	 *      whether to pull up by the distributionType of another side subpath.
	 *      3. pass target router map to another group maybe ? thus nothing need to
	 *      pull up to CN.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>innerd</name> <operator>&amp;&amp;</operator> <name>outerd</name> <operator>&amp;&amp;</operator> 
		<operator>(</operator><name><name>outerd</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name> <operator>||</operator>
		<operator>(</operator><name><name>innerd</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>, <argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<goto>goto <name>pull_up</name>;</goto>
	</block_content>}</block></if></if_stmt>
	
	<comment type="block">/*
	 * the join of cold-hot tables must be pulled up to CN until we find a way 
	 * to determine whether this join occurs in a specific group.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>has_cold_hot_table</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>groupOids</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <goto>goto <name>pull_up</name>;</goto>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>groupOids</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>has_cold_hot_table</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cold-hot table joins without groups"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * If both subpaths are distributed by replication, the resulting
     * distribution will be replicated on smallest common set of nodes.
     * Catalog tables are the same on all nodes, so treat them as replicated
     * on all nodes.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>innerd</name> <operator>&amp;&amp;</operator> <call><name>IsLocatorReplicated</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>distributionType</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>outerd</name> <operator>&amp;&amp;</operator> <call><name>IsLocatorReplicated</name><argument_list>(<argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>distributionType</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Determine common nodes */</comment>
        <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>common</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>common</name> <operator>=</operator> <call><name>bms_intersect</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>, <argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>not_allowed_join</name>;</goto></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Join result is replicated on common nodes. Running query on any
         * of them produce correct result.
         */</comment>
        <expr_stmt><expr><name>targetd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Distribution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>=</operator> <name>LOCATOR_TYPE_REPLICATED</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <name>common</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <name>targetd</name></expr>;</expr_stmt>
        <return>return <expr><name>alternate</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check if we have inner replicated
	 * The "both replicated" case is already checked, so if innerd
	 * is replicated, then outerd is not replicated and it is not NULL.
	 * This case is not acceptable for some join types. If outer relation is
	 * nullable data nodes will produce joined rows with NULLs for cases when
	 * matching row exists, but on other data node.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>innerd</name> <operator>&amp;&amp;</operator> <call><name>IsLocatorReplicated</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>distributionType</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_INNER</name> <operator>||</operator>
			 <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_LEFT</name> <operator>||</operator>
			 <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_SEMI</name> <operator>||</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
             <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_LEFT_SCALAR</name> <operator>||</operator>
			 <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_LEFT_SEMI</name> <operator>||</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			 <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_ANTI</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We need inner relation is defined on all nodes where outer is */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>outerd</name> <operator>||</operator> <operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>, <argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>not_allowed_join</name>;</goto></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>targetd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Distribution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>=</operator> <name><name>outerd</name><operator>-&gt;</operator><name>distributionType</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>=</operator> <name><name>outerd</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <name>targetd</name></expr>;</expr_stmt>
		<return>return <expr><name>alternate</name></expr>;</return>
	</block_content>}</block></if></if_stmt>


    <comment type="block">/*
     * Check if we have outer replicated
     * The "both replicated" case is already checked, so if outerd
     * is replicated, then innerd is not replicated and it is not NULL.
     * This case is not acceptable for some join types. If inner relation is
     * nullable data nodes will produce joined rows with NULLs for cases when
     * matching row exists, but on other data node.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>outerd</name> <operator>&amp;&amp;</operator> <call><name>IsLocatorReplicated</name><argument_list>(<argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>distributionType</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_INNER</name> <operator>||</operator>
             <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_RIGHT</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* We need outer relation is defined on all nodes where inner is */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>innerd</name> <operator>||</operator> <operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>, <argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>not_allowed_join</name>;</goto></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>targetd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Distribution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>=</operator> <name><name>innerd</name><operator>-&gt;</operator><name>distributionType</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>=</operator> <name><name>innerd</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <name>targetd</name></expr>;</expr_stmt>
        <return>return <expr><name>alternate</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * DML may need to push down to datanodes, for example:
	 *   DELETE FROM
	 *   	geocode_settings as gc
	 *   USING geocode_settings_default AS gf
	 *   WHERE
	 *   	gf.name = gc.name and gf.setting = gc.setting;
	 * prefer_olap means pulling query up to coordinator node, in case data
	 * re-distribute in TPC-C test case.
	 *
	 * TODO: We need to automatically determine whether we need to pull it up,
		* but not using GUC.
		*/</comment>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>prefer_olap</name> <operator>&amp;&amp;</operator> <name>false</name> <operator>==</operator> <name>dml</name></expr>)</condition>
	<block>{<block_content>
		<goto>goto <name>pull_up</name>;</goto>
	</block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>restrictClauses</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>joinrestrictinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>restrictClauses</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>restrictClauses</name></expr></argument>,
            <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>movedrestrictinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This join is still allowed if inner and outer paths have equivalent
	 * distribution and joined along the distribution keys. Make sure
	 * distribution functions are the same, for now they depend on data type.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>innerd</name> <operator>&amp;&amp;</operator> <name>outerd</name> <operator>&amp;&amp;</operator>
		<name><name>innerd</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>==</operator> <name><name>outerd</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>&amp;&amp;</operator>
		<name><name>innerd</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>&amp;&amp;</operator>
		<name><name>outerd</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>&amp;&amp;</operator>
		<call><name>bms_equal</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>, <argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Planner already did necessary work and if there is a join
         * condition like left.key=right.key the key expressions
         * will be members of the same equivalence class, and both
         * sides of the corresponding RestrictInfo will refer that
         * Equivalence Class.
         * Try to figure out if such restriction exists.
         */</comment>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>restrictClauses</argument>)</argument_list></macro>
        <block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>	 <modifier>*</modifier></type><name>emc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		  <name>found_outer</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		  <name>found_inner</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * Restriction operator is not equality operator ?
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>ri</name><operator>-&gt;</operator><name>left_ec</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ri</name><operator>-&gt;</operator><name>right_ec</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/*
             * A restriction with OR may be compatible if all OR'ed
             * conditions are compatible. For the moment we do not
             * check this and skip restriction. The case if multiple
             * OR'ed conditions are compatible is rare and probably
             * do not worth doing at all.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>ri</name><operator>-&gt;</operator><name>orclause</name></name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>hashjoinoperator</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <comment type="block">/*
             * If parts belong to the same equivalence member check
             * if both distribution keys are members of the class.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>ri</name><operator>-&gt;</operator><name>left_ec</name></name> <operator>==</operator> <name><name>ri</name><operator>-&gt;</operator><name>right_ec</name></name></expr>)</condition>
            <block>{<block_content>
                <macro><name>foreach</name><argument_list>(<argument>emc</argument>, <argument>ri-&gt;left_ec-&gt;ec_members</argument>)</argument_list></macro>
                <block>{<block_content>
					<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> 	<init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>emc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Expr</name>			  <modifier>*</modifier></type><name>var</name> 	<init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>var</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_outer</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>found_outer</name> <operator>=</operator> <call><name>equal</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_inner</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>found_inner</name> <operator>=</operator> <call><name>equal</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block>
                <if_stmt><if>if <condition>(<expr><name>found_outer</name> <operator>&amp;&amp;</operator> <name>found_inner</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>tlc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>emc</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>targetd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Distribution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>=</operator> <name><name>innerd</name><operator>-&gt;</operator><name>distributionType</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <name>targetd</name></expr>;</expr_stmt>
                    <comment type="block">/*
                     * Each member of the equivalence class may be a
                     * distribution expression, but we prefer some from the
                     * target list.
                     */</comment>
                    <macro><name>foreach</name><argument_list>(<argument>tlc</argument>, <argument>pathnode-&gt;path.parent-&gt;reltarget-&gt;exprs</argument>)</argument_list></macro>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tlc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <macro><name>foreach</name><argument_list>(<argument>emc</argument>, <argument>ri-&gt;left_ec-&gt;ec_members</argument>)</argument_list></macro>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>emvar</name></decl>;</decl_stmt>

                            <expr_stmt><expr><name>em</name> <operator>=</operator> <operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>emc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>emvar</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>emvar</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>emvar</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>emvar</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            <if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>emvar</name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
								<comment type="block">/*
								 * For UPDATE/DELETE, make sure we are distributing by
								 * the result relation.
								 */</comment>
								<if_stmt><if>if <condition>(<expr><name>keepResultRelLoc</name> <operator>&amp;&amp;</operator>
									<operator>!</operator><call><name>equal_distributions</name><argument_list>(<argument><expr><name>top_root</name></expr></argument>,
														 <argument><expr><name><name>top_root</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>,
														 <argument><expr><name>targetd</name></expr></argument>)</argument_list></call></expr>)</condition>
								<block>{<block_content>
									<continue>continue;</continue>
								</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                <return>return <expr><name>alternate</name></expr>;</return>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block>
                    </block_content>}</block>
                    <comment type="block">/* Not found, take any */</comment>
                    <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>=</operator> <name><name>innerd</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<comment type="block">/*
					 * For UPDATE/DELETE, make sure we are distributing by
					 * the result relation.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>keepResultRelLoc</name> <operator>&amp;&amp;</operator>
						<operator>!</operator><call><name>equal_distributions</name><argument_list>(<argument><expr><name>top_root</name></expr></argument>,
											 <argument><expr><name><name>top_root</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>,
											 <argument><expr><name>targetd</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>targetd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>targetd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <return>return <expr><name>alternate</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <comment type="block">/*
             * Check clause, if both arguments are distribution keys and
             * operator is an equality operator
             */</comment>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op_exp</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Expr</name>   <modifier>*</modifier></type><name>arg1</name></decl>,
                       <decl><type ref="prev"><modifier>*</modifier></type><name>arg2</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>op_exp</name> <operator>=</operator> <operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name><name>ri</name><operator>-&gt;</operator><name>clause</name></name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>op_exp</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>op_exp</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>arg1</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>op_exp</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>arg2</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>op_exp</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifndef>
                <block>{<block_content>        
                    <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var1</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><call><name>get_var_from_arg</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>arg1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var2</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><call><name>get_var_from_arg</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>arg2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        
                    <if_stmt><if>if <condition>(<expr><name>var1</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>arg1</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>var1</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
        
                    <if_stmt><if>if <condition>(<expr><name>var2</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>arg2</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>var2</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><name>found_outer</name> <operator>=</operator> <call><name>equal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>equal</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>found_inner</name> <operator>=</operator> <call><name>equal</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>equal</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>found_outer</name> <operator>&amp;&amp;</operator> <name>found_inner</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>targetd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Distribution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>=</operator> <name><name>innerd</name><operator>-&gt;</operator><name>distributionType</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <name>targetd</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifndef>
                    <if_stmt><if>if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_LEFT</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_FULL</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>, <argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<comment type="block">/*
					 * In case of outer join distribution key should not refer
					 * distribution key of nullable part.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_FULL</name></expr>)</condition><block type="pseudo"><block_content>
						<comment type="block">/* both parts are nullable */</comment>
						<expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_RIGHT</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>=</operator> <name><name>innerd</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>=</operator> <name><name>outerd</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					<comment type="block">/*
					 * For UPDATE/DELETE, make sure we are distributing by
					 * the result relation.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>keepResultRelLoc</name> <operator>&amp;&amp;</operator>
						<operator>!</operator><call><name>equal_distributions</name><argument_list>(<argument><expr><name>top_root</name></expr></argument>,
											 <argument><expr><name><name>top_root</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>,
											 <argument><expr><name>targetd</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>targetd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>targetd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<return>return <expr><name>alternate</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifndef>
		<if_stmt><if>if <condition>(<expr><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>, <argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>restrict_query</name> <operator>&amp;&amp;</operator>
			<name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_FULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>targetd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Distribution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>=</operator> <name><name>innerd</name><operator>-&gt;</operator><name>distributionType</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <name>targetd</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * In case of outer join distribution key should not refer
			 * distribution key of nullable part.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_FULL</name></expr>)</condition><block type="pseudo"><block_content>
				<comment type="block">/* both parts are nullable */</comment>
				<expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_RIGHT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>=</operator> <name><name>innerd</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>=</operator> <name><name>outerd</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<comment type="block">/*
			 * For UPDATE/DELETE, make sure we are distributing by
			 * the result relation.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>keepResultRelLoc</name> <operator>||</operator> <call><name>equal_distributions</name><argument_list>(<argument><expr><name>top_root</name></expr></argument>,
														 <argument><expr><name><name>top_root</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>,
														 <argument><expr><name>targetd</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>alternate</name></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>targetd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>targetd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<return>return <expr><name>alternate</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If we could not determine the distribution redistribute the subpathes.
     */</comment>
<label><name>not_allowed_join</name>:</label>
	<comment type="block">/*
	 * If redistribution is required, sometimes the cheapest path would be if
	 * one of the subplan is replicated. If replication of any or all subplans
	 * is possible, return resulting plans as alternates. Try to distribute all
	 * by has as main variant.
	 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>	
	<comment type="block">/* These join types allow replicated inner */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>outerd</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_INNER</name> <operator>||</operator>
			 <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_LEFT</name> <operator>||</operator>
			 <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_SEMI</name> <operator>||</operator>
			 <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_LEFT_SCALAR</name> <operator>||</operator>
			 <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_ANTI</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><name>outerd</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_INNER</name> <operator>||</operator>
			 <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_LEFT</name> <operator>||</operator>
			 <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_SEMI</name> <operator>||</operator>
			 <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_ANTI</name><operator>)</operator></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<comment type="block">/*
		 * Since we discard all alternate pathes except one it is OK if all they
		 * reference the same objects
		 */</comment>
		<decl_stmt><decl><type><name>JoinPath</name> <modifier>*</modifier></type><name>altpath</name> <init>= <expr><call><name>flatCopyJoinPath</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Redistribute inner subquery */</comment>
		<expr_stmt><expr><name><name>altpath</name><operator>-&gt;</operator><name>innerjoinpath</name></name> <operator>=</operator> <call><name>redistribute_path</name><argument_list>(
				<argument><expr><name>root</name></expr></argument>,
				<argument><expr><name><name>altpath</name><operator>-&gt;</operator><name>innerjoinpath</name></name></expr></argument>,
				<argument><expr><name>innerpathkeys</name></expr></argument>,
				<argument><expr><name>LOCATOR_TYPE_REPLICATED</name></expr></argument>,
				<argument><expr><name>NULL</name></expr></argument>,
				<argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>targetd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Distribution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>=</operator> <name><name>outerd</name><operator>-&gt;</operator><name>distributionType</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>=</operator> <name><name>outerd</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>altpath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <name>targetd</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>alternate</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>alternate</name></expr></argument>, <argument><expr><name>altpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* These join types allow replicated outer */</comment>
    <if_stmt><if>if <condition>(<expr><name>innerd</name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_INNER</name> <operator>||</operator>
             <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_RIGHT</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Since we discard all alternate pathes except one it is OK if all they
         * reference the same objects
         */</comment>
        <decl_stmt><decl><type><name>JoinPath</name> <modifier>*</modifier></type><name>altpath</name> <init>= <expr><call><name>flatCopyJoinPath</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="block">/* Redistribute inner subquery */</comment>
        <expr_stmt><expr><name><name>altpath</name><operator>-&gt;</operator><name>outerjoinpath</name></name> <operator>=</operator> <call><name>redistribute_path</name><argument_list>(
                <argument><expr><name>root</name></expr></argument>,
                <argument><expr><name><name>altpath</name><operator>-&gt;</operator><name>outerjoinpath</name></name></expr></argument>,
                <argument><expr><name>outerpathkeys</name></expr></argument>,
                <argument><expr><name>LOCATOR_TYPE_REPLICATED</name></expr></argument>,
                <argument><expr><name>NULL</name></expr></argument>,
                <argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>bms_copy</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>targetd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Distribution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>=</operator> <name><name>innerd</name><operator>-&gt;</operator><name>distributionType</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>=</operator> <name><name>innerd</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>altpath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <name>targetd</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>alternate</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>alternate</name></expr></argument>, <argument><expr><name>altpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Redistribute subplans to make them compatible.
     * If any of the subplans is a coordinator subplan skip this stuff and do
     * coordinator join.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>innerd</name> <operator>&amp;&amp;</operator> <name>outerd</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RestrictInfo</name>   <modifier>*</modifier></type><name>preferred</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Expr</name>           <modifier>*</modifier></type><name>new_inner_key</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Expr</name>           <modifier>*</modifier></type><name>new_outer_key</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>            <name>distType</name> <init>= <expr><name>LOCATOR_TYPE_NONE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>        <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<decl_stmt><decl><type><name>Oid</name></type>				<name>group</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> 			<name>nRemotePlans_outer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> 			<name>nRemotePlans_inner</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> 			<name>redistribute_outer</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> 			<name>redistribute_inner</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * Look through the join restrictions to find one that is a hashable
         * operator on two arguments. Choose best restriction acoording to
         * following criteria:
         * 1. one argument is already a partitioning key of one subplan.
         * 2. restriction is cheaper to calculate
         */</comment>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>restrictClauses</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RestrictInfo</name>   <modifier>*</modifier></type><name>ri</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* can not handle ORed conditions */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>ri</name><operator>-&gt;</operator><name>orclause</name></name></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name><name>ri</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
                        <call><name>op_hashjoinable</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>left</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>right</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>left_expr</name> <init>= <expr><name>left</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>right_expr</name> <init>= <expr><name>right</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<decl_stmt><decl><type><name>Oid</name> <name>leftType</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>left</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__TBASE__</name></cpp:ifndef>
					<decl_stmt><decl><type><name>Oid</name> <name>rightType</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<decl_stmt><decl><type><name>Relids</name></type> <name>inner_rels</name> <init>= <expr><name><name>pathnode</name><operator>-&gt;</operator><name>innerjoinpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Relids</name></type> <name>outer_rels</name> <init>= <expr><name><name>pathnode</name><operator>-&gt;</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>QualCost</name></type> <name>cost</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive>	<name>__TBASE__</name></cpp:ifndef>
					<comment type="block">/*
					 * Check if both parts are of the same data type and choose
					 * distribution type to redistribute.
					 * XXX We may want more sophisticated algorithm to choose
					 * the best condition to redistribute parts along.
					 * For now use simple but reliable approach.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>leftType</name> <operator>!=</operator> <name>rightType</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifndef>
                    <block>{<block_content>        
                        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr1</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>get_var_from_arg</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>left</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr2</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>get_var_from_arg</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            
                        <if_stmt><if>if <condition>(<expr><name>expr1</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>left_expr</name> <operator>=</operator> <name>expr1</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
            
                        <if_stmt><if>if <condition>(<expr><name>expr2</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>right_expr</name> <operator>=</operator> <name>expr2</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>

                        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>left_expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>right_expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <continue>continue;</continue>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<comment type="block">/*
					 * Evaluation cost will be needed to choose preferred
					 * distribution
					 */</comment>
					<expr_stmt><expr><call><name>cost_qual_eval_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cost</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>ri</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>outerd</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr>)</condition>
					<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
						<comment type="block">/*
						 * For UPDATE/DELETE, make sure outer rel does not need
						 * to distribute
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>keepResultRelLoc</name> <operator>&amp;&amp;</operator> <name>resultRelLoc</name> <operator>==</operator> <name>RESULT_REL_INNER</name></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
						<comment type="block">/*
						 * If left side is distribution key of outer subquery
						 * and right expression refers only inner subquery
						 */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr></argument>, <argument><expr><name>left_expr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
								<call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>, <argument><expr><name>inner_rels</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><name>preferred</name> <operator>||</operator> <comment type="block">/* no preferred restriction yet found */</comment>
								<operator>(</operator><name>new_inner_key</name> <operator>&amp;&amp;</operator> <name>new_outer_key</name><operator>)</operator> <operator>||</operator> <comment type="block">/* preferred restriction require redistribution of both parts */</comment>
								<operator>(</operator><name><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>&lt;</operator> <name><name>preferred</name><operator>-&gt;</operator><name>eval_cost</name><operator>.</operator><name>per_tuple</name></name><operator>)</operator></expr>)</condition> <comment type="block">/* current restriction is cheaper */</comment>
							<block>{<block_content>
								<comment type="block">/* set new preferred restriction */</comment>
								<expr_stmt><expr><name>preferred</name> <operator>=</operator> <name>ri</name></expr>;</expr_stmt>
								<expr_stmt><expr><name>new_inner_key</name> <operator>=</operator> <name>right</name></expr>;</expr_stmt>
								<expr_stmt><expr><name>new_outer_key</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* no need to change */</comment>
								<expr_stmt><expr><name>distType</name> <operator>=</operator> <name><name>outerd</name><operator>-&gt;</operator><name>distributionType</name></name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<continue>continue;</continue>
						</block_content>}</block></if></if_stmt>
						<comment type="block">/*
						 * If right side is distribution key of outer subquery
						 * and left expression refers only inner subquery
						 */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr></argument>, <argument><expr><name>right_expr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
								<call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>, <argument><expr><name>inner_rels</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><name>preferred</name> <operator>||</operator> <comment type="block">/* no preferred restriction yet found */</comment>
								<operator>(</operator><name>new_inner_key</name> <operator>&amp;&amp;</operator> <name>new_outer_key</name><operator>)</operator> <operator>||</operator> <comment type="block">/* preferred restriction require redistribution of both parts */</comment>
								<operator>(</operator><name><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>&lt;</operator> <name><name>preferred</name><operator>-&gt;</operator><name>eval_cost</name><operator>.</operator><name>per_tuple</name></name><operator>)</operator></expr>)</condition> <comment type="block">/* current restriction is cheaper */</comment>
							<block>{<block_content>
								<comment type="block">/* set new preferred restriction */</comment>
								<expr_stmt><expr><name>preferred</name> <operator>=</operator> <name>ri</name></expr>;</expr_stmt>
								<expr_stmt><expr><name>new_inner_key</name> <operator>=</operator> <name>left</name></expr>;</expr_stmt>
								<expr_stmt><expr><name>new_outer_key</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* no need to change */</comment>
								<expr_stmt><expr><name>distType</name> <operator>=</operator> <name><name>outerd</name><operator>-&gt;</operator><name>distributionType</name></name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<continue>continue;</continue>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>innerd</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr>)</condition>
					<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
						<comment type="block">/* For UPDATE/DELETE, make sure inner rel does not need to distribute */</comment>
						<if_stmt><if>if <condition>(<expr><name>keepResultRelLoc</name> <operator>&amp;&amp;</operator> <name>resultRelLoc</name> <operator>==</operator> <name>RESULT_REL_OUTER</name></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
						<comment type="block">/*
						 * If left side is distribution key of inner subquery
						 * and right expression refers only outer subquery
						 */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr></argument>, <argument><expr><name>left_expr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
								<call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>, <argument><expr><name>outer_rels</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><name>preferred</name> <operator>||</operator> <comment type="block">/* no preferred restriction yet found */</comment>
									<operator>(</operator><name>new_inner_key</name> <operator>&amp;&amp;</operator> <name>new_outer_key</name><operator>)</operator> <operator>||</operator> <comment type="block">/* preferred restriction require redistribution of both parts */</comment>
									<operator>(</operator><name><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>&lt;</operator> <name><name>preferred</name><operator>-&gt;</operator><name>eval_cost</name><operator>.</operator><name>per_tuple</name></name><operator>)</operator></expr>)</condition> <comment type="block">/* current restriction is cheaper */</comment>
							<block>{<block_content>
								<comment type="block">/* set new preferred restriction */</comment>
								<expr_stmt><expr><name>preferred</name> <operator>=</operator> <name>ri</name></expr>;</expr_stmt>
								<expr_stmt><expr><name>new_inner_key</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* no need to change */</comment>
								<expr_stmt><expr><name>new_outer_key</name> <operator>=</operator> <name>right</name></expr>;</expr_stmt>
								<expr_stmt><expr><name>distType</name> <operator>=</operator> <name><name>innerd</name><operator>-&gt;</operator><name>distributionType</name></name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<continue>continue;</continue>
						</block_content>}</block></if></if_stmt>
						<comment type="block">/*
						 * If right side is distribution key of inner subquery
						 * and left expression refers only outer subquery
						 */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr></argument>, <argument><expr><name>right_expr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
								<call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>, <argument><expr><name>outer_rels</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><operator>!</operator><name>preferred</name> <operator>||</operator> <comment type="block">/* no preferred restriction yet found */</comment>
									<operator>(</operator><name>new_inner_key</name> <operator>&amp;&amp;</operator> <name>new_outer_key</name><operator>)</operator> <operator>||</operator> <comment type="block">/* preferred restriction require redistribution of both parts */</comment>
									<operator>(</operator><name><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>&lt;</operator> <name><name>preferred</name><operator>-&gt;</operator><name>eval_cost</name><operator>.</operator><name>per_tuple</name></name><operator>)</operator></expr>)</condition> <comment type="block">/* current restriction is cheaper */</comment>
							<block>{<block_content>
								<comment type="block">/* set new preferred restriction */</comment>
								<expr_stmt><expr><name>preferred</name> <operator>=</operator> <name>ri</name></expr>;</expr_stmt>
								<expr_stmt><expr><name>new_inner_key</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* no need to change */</comment>
								<expr_stmt><expr><name>new_outer_key</name> <operator>=</operator> <name>left</name></expr>;</expr_stmt>
								<expr_stmt><expr><name>distType</name> <operator>=</operator> <name><name>innerd</name><operator>-&gt;</operator><name>distributionType</name></name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<continue>continue;</continue>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/*
					 * Current restriction recuire redistribution of both parts.
					 * If preferred restriction require redistribution of one,
					 * keep it.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>preferred</name> <operator>&amp;&amp;</operator>
							<operator>(</operator><name>new_inner_key</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>new_outer_key</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * Skip this condition if the data type of the expressions
					 * does not allow either HASH or MODULO distribution.
					 * HASH distribution is preferrable.
					 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <if_stmt><if>if <condition>(<expr><name>groupOids</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>linitial_oid</name><argument_list>(<argument><expr><name>groupOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>group</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>distType</name> <operator>=</operator> <name>LOCATOR_TYPE_SHARD</name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <if_stmt><if>if <condition>(<expr><call><name>IsTypeHashDistributable</name><argument_list>(<argument><expr><name>leftType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>distType</name> <operator>=</operator> <name>LOCATOR_TYPE_HASH</name></expr>;</expr_stmt></block_content></block></if>
                    <if type="elseif">else if <condition>(<expr><call><name>IsTypeModuloDistributable</name><argument_list>(<argument><expr><name>leftType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>distType</name> <operator>=</operator> <name>LOCATOR_TYPE_MODULO</name></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <continue>continue;</continue></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
					</block_content>}</block></else></if_stmt>

					<comment type="block">/*
					 * Skip redistribute both side, which will redistribute the
					 * result relation
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>keepResultRelLoc</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<comment type="block">/*
					 * If this restriction the first or easier to calculate
					 * then preferred, try to store it as new preferred
					 * restriction to redistribute along it.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>preferred</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
						<operator>(</operator><name><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>&lt;</operator> <name><name>preferred</name><operator>-&gt;</operator><name>eval_cost</name><operator>.</operator><name>per_tuple</name></name><operator>)</operator></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Left expression depends only on outer subpath and
						 * right expression depends only on inner subpath, so
						 * we can redistribute both and make left expression the
						 * distribution key of outer subplan and right
						 * expression the distribution key of inner subplan
						 */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>, <argument><expr><name>outer_rels</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
								<call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>, <argument><expr><name>inner_rels</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>preferred</name> <operator>=</operator> <name>ri</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>new_outer_key</name> <operator>=</operator> <name>left</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>new_inner_key</name> <operator>=</operator> <name>right</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<comment type="block">/*
						 * Left expression depends only on inner subpath and
						 * right expression depends only on outer subpath, so
						 * we can redistribute both and make left expression the
						 * distribution key of inner subplan and right
						 * expression the distribution key of outer subplan
						 */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>, <argument><expr><name>inner_rels</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
								<call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>ri</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>, <argument><expr><name>outer_rels</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>preferred</name> <operator>=</operator> <name>ri</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>new_inner_key</name> <operator>=</operator> <name>left</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>new_outer_key</name> <operator>=</operator> <name>right</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<expr_stmt><expr><call><name>contains_remotesubplan</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>outerjoinpath</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nRemotePlans_outer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>redistribute_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>contains_remotesubplan</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>innerjoinpath</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nRemotePlans_inner</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>redistribute_inner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* If we have suitable restriction we can repartition accordingly */</comment>
		<if_stmt><if>if <condition>(<expr><name>preferred</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>restrictNodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<comment type="block">/* consider the outer/inner size when make the redistribute plan */</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name>replicate_inner</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>replicate_outer</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>outer_rel</name> <init>= <expr><name><name>pathnode</name><operator>-&gt;</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name> <init>= <expr><name><name>pathnode</name><operator>-&gt;</operator><name>innerjoinpath</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type> <name>outer_size</name> <init>= <expr><name><name>outer_rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name><name>outer_rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type> <name>inner_size</name> <init>= <expr><name><name>inner_rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name><name>inner_rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>width</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>outer_nodes</name> <init>= <expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>inner_nodes</name> <init>= <expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="block">/* If we redistribute both parts do join on all nodes ... */</comment>
            <if_stmt><if>if <condition>(<expr><name>new_inner_key</name> <operator>&amp;&amp;</operator> <name>new_outer_key</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<comment type="block">/*
				 * We end up here that we don't have replication table and whether
				 * 1. we have no shard table at both sides OR
				 * 2. we have shard table but spread in same node set
				 * so check distribution type and decide what's next.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>innerd</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name> <operator>||</operator>
					<name><name>outerd</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* must be same node set, just copy */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>, <argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<comment type="block">/* check if we can distribute by shard */</comment>
				<if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>      <name>node_index</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int32</name></type>	 <name>dn_num</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int32</name>   <modifier>*</modifier></type><name>datanodes</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>GetShardNodes</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datanodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dn_num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>nodes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					
					<for>for<control>(<init><expr><name>node_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>node_index</name> <operator>&lt;</operator> <name>dn_num</name></expr>;</condition> <incr><expr><name>node_index</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>						
						<expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>, <argument><expr><name><name>datanodes</name><index>[<expr><name>node_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * We should not get both new_inner_key &amp; new_outer_key for
				 * UPDATE/DELETE
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>keepResultRelLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * if any side is smaller enough, replicate the smaller one
				 * instead of redistribute both of them.
                 */</comment>
                <if_stmt><if>if<condition>(<expr><name>inner_size</name> <operator>*</operator> <name>outer_nodes</name> <operator>&lt;</operator> <name>inner_size</name> <operator>+</operator> <name>outer_size</name> <operator>&amp;&amp;</operator>
                    <operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_RIGHT</name> <operator>&amp;&amp;</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_FULL</name><operator>)</operator> <operator>&amp;&amp;</operator>
                    <name><name>outerd</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>!=</operator> <name>LOCATOR_TYPE_REPLICATED</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>redistribute_inner</name> <operator>&amp;&amp;</operator>
                    <call><name>get_num_connections</name><argument_list>(<argument><expr><name>outer_nodes</name></expr></argument>, <argument><expr><name>nRemotePlans_inner</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MaxConnections</name> <operator>*</operator> <name>REPLICATION_FACTOR</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><name>dml</name> <operator>&amp;&amp;</operator> <name>nRemotePlans_inner</name> <operator>&lt;</operator> <name>replication_level</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pathnode</name><operator>-&gt;</operator><name>inner_unique</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>replicate_inner</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                    <expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

				<if_stmt><if>if<condition>(<expr><name>outer_size</name> <operator>*</operator> <name>inner_nodes</name> <operator>&lt;</operator> <name>inner_size</name> <operator>+</operator> <name>outer_size</name> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_LEFT</name> <operator>&amp;&amp;</operator>
					 <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_FULL</name> <operator>&amp;&amp;</operator>
					 <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_SEMI</name> <operator>&amp;&amp;</operator>
					 <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_LEFT_SCALAR</name> <operator>&amp;&amp;</operator>
					 <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_LEFT_SEMI</name> <operator>&amp;&amp;</operator>
					 <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_ANTI</name><operator>)</operator> <operator>&amp;&amp;</operator>
					 <name><name>innerd</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>!=</operator> <name>LOCATOR_TYPE_REPLICATED</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>redistribute_outer</name> <operator>&amp;&amp;</operator>
					 <call><name>get_num_connections</name><argument_list>(<argument><expr><name>inner_nodes</name></expr></argument>, <argument><expr><name>nRemotePlans_outer</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MaxConnections</name> <operator>*</operator> <name>REPLICATION_FACTOR</name> <operator>&amp;&amp;</operator>
					 <operator>!</operator><name>replicate_inner</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>dml</name> <operator>&amp;&amp;</operator> <name>nRemotePlans_outer</name> <operator>&lt;</operator> <name>replication_level</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pathnode</name><operator>-&gt;</operator><name>inner_unique</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>replicate_outer</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

					<expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if>
            <comment type="block">/*
             * ... if we do only one of them redistribute it on the same nodes
             * as other.
             */</comment>
            <if type="elseif">else if <condition>(<expr><name>new_inner_key</name></expr>)</condition>
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<comment type="block">/*
				 * If inner is smaller than outer, redistribute inner as the
				 * preferred key we picked.
				 * If inner is bigger than outer (inner &gt; inner-&gt;nodes * outer),
				 * replicate outer as an optimization to save network costs.
                 */</comment>
				<if_stmt><if>if<condition>(<expr><name>inner_size</name> <operator>&gt;</operator> <name>outer_size</name> <operator>*</operator> <name>inner_nodes</name> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_LEFT</name> <operator>&amp;&amp;</operator>
					 <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_FULL</name> <operator>&amp;&amp;</operator>
					 <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_SEMI</name> <operator>&amp;&amp;</operator>
					 <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_LEFT_SCALAR</name> <operator>&amp;&amp;</operator>
					 <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_LEFT_SEMI</name> <operator>&amp;&amp;</operator>
					 <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_ANTI</name><operator>)</operator> <operator>&amp;&amp;</operator>
					 <name><name>innerd</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>!=</operator> <name>LOCATOR_TYPE_REPLICATED</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>redistribute_outer</name> <operator>&amp;&amp;</operator>
					 <call><name>get_num_connections</name><argument_list>(<argument><expr><name>inner_nodes</name></expr></argument>, <argument><expr><name>nRemotePlans_outer</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MaxConnections</name> <operator>*</operator> <name>REPLICATION_FACTOR</name> <operator>&amp;&amp;</operator>
					 <operator>!</operator><name>dml</name> <operator>&amp;&amp;</operator> <name>nRemotePlans_outer</name> <operator>&lt;</operator> <name>replication_level</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pathnode</name><operator>-&gt;</operator><name>inner_unique</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>replicate_outer</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

					<comment type="block">/* replicate outer to all inner nodes */</comment>
					<expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>restrictNodes</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>keepResultRelLoc</name> <operator>||</operator> <name>resultRelLoc</name> <operator>!=</operator> <name>RESULT_REL_INNER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>restrictNodes</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if>
            <else>else <comment type="block">/*if (new_outer_key)*/</comment>
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<comment type="block">/*
				 * If outer is smaller than inner, redistribute outer as the
				 * preferred key we picked.
				 * If outer is bigger than inner (outer &gt; outer-&gt;nodes * inner),
				 * replicate inner as an optimization to save network costs.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>outer_size</name> <operator>&gt;</operator> <name>inner_size</name> <operator>*</operator> <name>outer_nodes</name> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_RIGHT</name> <operator>&amp;&amp;</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_FULL</name><operator>)</operator> <operator>&amp;&amp;</operator>
					<name><name>outerd</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>!=</operator> <name>LOCATOR_TYPE_REPLICATED</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>redistribute_inner</name> <operator>&amp;&amp;</operator>
					<call><name>get_num_connections</name><argument_list>(<argument><expr><name>outer_nodes</name></expr></argument>, <argument><expr><name>nRemotePlans_inner</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MaxConnections</name> <operator>*</operator> <name>REPLICATION_FACTOR</name> <operator>&amp;&amp;</operator>
					<operator>!</operator><name>dml</name> <operator>&amp;&amp;</operator> <name>nRemotePlans_inner</name> <operator>&lt;</operator> <name>replication_level</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pathnode</name><operator>-&gt;</operator><name>inner_unique</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>replicate_inner</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

					<comment type="block">/* replicate inner to all outer nodes */</comment>
					<expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>restrictNodes</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>keepResultRelLoc</name> <operator>||</operator> <name>resultRelLoc</name> <operator>!=</operator> <name>RESULT_REL_OUTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>restrictNodes</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/*
             * Redistribute join by hash, and, if jointype allows, create
             * alternate path where inner subplan is distributed by replication
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>new_inner_key</name></expr>)</condition>
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<comment type="block">/*
				 * replicate outer rel, just set LOCATOR_TYPE_NONE to remove
				 * the path distribution.
				 */</comment>
                <if_stmt><if>if<condition>(<expr><name>replicate_outer</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>outerjoinpath</name></name> <operator>=</operator> <call><name>redistribute_path</name><argument_list>(
                                                <argument><expr><name>root</name></expr></argument>,
                                                <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>outerjoinpath</name></name></expr></argument>,
                                                <argument><expr><name>outerpathkeys</name></expr></argument>,
                                                <argument><expr><name>LOCATOR_TYPE_NONE</name></expr></argument>,
                                                <argument><expr><name>NULL</name></expr></argument>,
                                                <argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>,
                                                <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>MergePath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>MergePath</name><operator>*</operator><operator>)</operator><name>pathnode</name><operator>)</operator><operator>-&gt;</operator><name>outersortkeys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if<condition>(<expr><operator>!</operator><name>replicate_inner</name></expr>)</condition>
                <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/* Redistribute inner subquery */</comment>
                <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>innerjoinpath</name></name> <operator>=</operator> <call><name>redistribute_path</name><argument_list>(
                        <argument><expr><name>root</name></expr></argument>,
                        <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>innerjoinpath</name></name></expr></argument>,
                        <argument><expr><name>innerpathkeys</name></expr></argument>,
                        <argument><expr><name>distType</name></expr></argument>,
                        <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>new_inner_key</name></expr></argument>,
                        <argument><expr><name>nodes</name></expr></argument>,
                        <argument><expr><name>restrictNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>MergePath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>MergePath</name><operator>*</operator><operator>)</operator><name>pathnode</name><operator>)</operator><operator>-&gt;</operator><name>innersortkeys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/*
             * Redistribute join by hash, and, if jointype allows, create
             * alternate path where outer subplan is distributed by replication
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>new_outer_key</name></expr>)</condition>
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <comment type="block">/*
				 * replicate inner rel, just set LOCATOR_TYPE_NONE to remove
				 * the path distribution.
				 */</comment>
                <if_stmt><if>if<condition>(<expr><name>replicate_inner</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>innerjoinpath</name></name> <operator>=</operator> <call><name>redistribute_path</name><argument_list>(
                                                <argument><expr><name>root</name></expr></argument>,
                                                <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>innerjoinpath</name></name></expr></argument>,
                                                <argument><expr><name>innerpathkeys</name></expr></argument>,
                                                <argument><expr><name>LOCATOR_TYPE_NONE</name></expr></argument>,
                                                <argument><expr><name>NULL</name></expr></argument>,
                                                <argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>,
                                                <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>MergePath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>MergePath</name><operator>*</operator><operator>)</operator><name>pathnode</name><operator>)</operator><operator>-&gt;</operator><name>innersortkeys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if<condition>(<expr><operator>!</operator><name>replicate_outer</name></expr>)</condition>
                <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/* Redistribute outer subquery */</comment>
                <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>outerjoinpath</name></name> <operator>=</operator> <call><name>redistribute_path</name><argument_list>(
                        <argument><expr><name>root</name></expr></argument>,
                        <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>outerjoinpath</name></name></expr></argument>,
                        <argument><expr><name>outerpathkeys</name></expr></argument>,
                        <argument><expr><name>distType</name></expr></argument>,
                        <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>new_outer_key</name></expr></argument>,
                        <argument><expr><name>nodes</name></expr></argument>,
                        <argument><expr><name>restrictNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>MergePath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>MergePath</name><operator>*</operator><operator>)</operator><name>pathnode</name><operator>)</operator><operator>-&gt;</operator><name>outersortkeys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>targetd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Distribution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>=</operator> <name>distType</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <name>nodes</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <name>targetd</name></expr>;</expr_stmt>

            <comment type="block">/*
             * For mergejoins we can also reset the sortkeys, because
             * redistribute_path will take care of that by creating a nested
             * Sort if needed. Otherwise create_mergejoin_plan would add
             * another sort node, but we want to push it down.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>MergePath</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// ((MergePath*)pathnode)-&gt;innersortkeys = NIL;</comment>
                <comment type="line">// ((MergePath*)pathnode)-&gt;outersortkeys = NIL;</comment>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * In case of outer join distribution key should not refer
             * distribution key of nullable part.
             * NB: we should not refer innerd and outerd here, subpathes are
             * redistributed already
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_FULL</name></expr>)</condition><block type="pseudo"><block_content>
                <comment type="block">/* both parts are nullable */</comment>
                <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_RIGHT</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>=</operator>
                        <name><name>pathnode</name><operator>-&gt;</operator><name>innerjoinpath</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                if<condition>(<expr><name>replicate_outer</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>=</operator>
                            <name><name>pathnode</name><operator>-&gt;</operator><name>innerjoinpath</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><name><name>targetd</name><operator>-&gt;</operator><name>distributionExpr</name></name> <operator>=</operator>
                        <name><name>pathnode</name><operator>-&gt;</operator><name>outerjoinpath</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>distributionExpr</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<return>return <expr><name>alternate</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>keepResultRelLoc</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We didn't got the preferred redistribution plan for UPDATE/DELETE.
			 * Thus, to keeping result relation not redistributed, we replicate
			 * the other subpath.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>resultRelLoc</name> <operator>==</operator> <name>RESULT_REL_INNER</name> <operator>&amp;&amp;</operator>
				<name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_LEFT</name> <operator>&amp;&amp;</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_FULL</name> <operator>&amp;&amp;</operator>
				<name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_SEMI</name> <operator>&amp;&amp;</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_ANTI</name> <operator>&amp;&amp;</operator>
				<name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_LEFT_SCALAR</name> <operator>&amp;&amp;</operator>
				<name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_LEFT_SEMI</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pathnode</name><operator>-&gt;</operator><name>inner_unique</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Replicate outer */</comment>
				<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>outerjoinpath</name></name> <operator>=</operator> <call><name>redistribute_path</name><argument_list>(
											<argument><expr><name>root</name></expr></argument>,
											<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>outerjoinpath</name></name></expr></argument>,
											<argument><expr><name>outerpathkeys</name></expr></argument>,
											<argument><expr><name>LOCATOR_TYPE_NONE</name></expr></argument>,
											<argument><expr><name>NULL</name></expr></argument>,
											<argument><expr><name><name>innerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>,
											<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <name>innerd</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>MergePath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>(</operator><operator>(</operator><name>MergePath</name><operator>*</operator><operator>)</operator><name>pathnode</name><operator>)</operator><operator>-&gt;</operator><name>outersortkeys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>resultRelLoc</name> <operator>==</operator> <name>RESULT_REL_OUTER</name> <operator>&amp;&amp;</operator>
					 <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_RIGHT</name> <operator>&amp;&amp;</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_FULL</name> <operator>&amp;&amp;</operator>
					 <operator>!</operator><name><name>pathnode</name><operator>-&gt;</operator><name>inner_unique</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Replicate inner */</comment>
				<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>innerjoinpath</name></name> <operator>=</operator> <call><name>redistribute_path</name><argument_list>(
											<argument><expr><name>root</name></expr></argument>,
											<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>innerjoinpath</name></name></expr></argument>,
											<argument><expr><name>innerpathkeys</name></expr></argument>,
											<argument><expr><name>LOCATOR_TYPE_NONE</name></expr></argument>,
											<argument><expr><name>NULL</name></expr></argument>,
											<argument><expr><name><name>outerd</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>,
											<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <name>outerd</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>MergePath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>(</operator><operator>(</operator><name>MergePath</name><operator>*</operator><operator>)</operator><name>pathnode</name><operator>)</operator><operator>-&gt;</operator><name>innersortkeys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><name>alternate</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* 
	 * For DELETE/UPDATE, If the other side already been replicated, we directly
	 * inherit the resultRelLoc side distribution.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>keepResultRelLoc</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>innerd</name> <operator>&amp;&amp;</operator><name>resultRelLoc</name> <operator>==</operator> <name>RESULT_REL_INNER</name> <operator>&amp;&amp;</operator>
			<name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_LEFT</name> <operator>&amp;&amp;</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_FULL</name> <operator>&amp;&amp;</operator>
			<name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_SEMI</name> <operator>&amp;&amp;</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_ANTI</name> <operator>&amp;&amp;</operator>
			<name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_LEFT_SCALAR</name> <operator>&amp;&amp;</operator>
			<name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_LEFT_SEMI</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pathnode</name><operator>-&gt;</operator><name>inner_unique</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <name>innerd</name></expr>;</expr_stmt>
			<return>return <expr><name>alternate</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>outerd</name> <operator>&amp;&amp;</operator> <name>resultRelLoc</name> <operator>==</operator> <name>RESULT_REL_OUTER</name> <operator>&amp;&amp;</operator>
				 <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_RIGHT</name> <operator>&amp;&amp;</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_FULL</name> <operator>&amp;&amp;</operator>
				 <operator>!</operator><name><name>pathnode</name><operator>-&gt;</operator><name>inner_unique</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <name>outerd</name></expr>;</expr_stmt>
			<return>return <expr><name>alternate</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Build cartesian product, if no hasheable restrictions is found.
     * Perform coordinator join in such cases. If this join would be a part of
     * larger join, it will be handled as replicated.
     * To do that leave join distribution NULL and place a RemoteSubPath node on
     * top of each subpath to provide access to joined result sets.
     * Do not redistribute pathes that already have NULL distribution, this is
     * possible if performing outer join on a coordinator and a datanode
     * relations.
     */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    if (innerd &amp;&amp; !outerd)
    {
        if (IsLocatorDistributedByValue(innerd-&gt;distributionType) &amp;&amp;
            !pathnode-&gt;innerjoinpath-&gt;param_info &amp;&amp;
            !pathnode-&gt;outerjoinpath-&gt;param_info &amp;&amp;
            pathnode-&gt;jointype == JOIN_INNER)
        {
            pathnode-&gt;path.distribution = copyObject(pathnode-&gt;innerjoinpath-&gt;distribution);

            return alternate;
        }
    }
    
    if (!innerd &amp;&amp; outerd)
    {
        if (IsLocatorDistributedByValue(outerd-&gt;distributionType) &amp;&amp;
            !pathnode-&gt;innerjoinpath-&gt;param_info &amp;&amp;
            !pathnode-&gt;outerjoinpath-&gt;param_info &amp;&amp;
            pathnode-&gt;jointype == JOIN_INNER)
        {
            pathnode-&gt;path.distribution = copyObject(pathnode-&gt;outerjoinpath-&gt;distribution);

            return alternate;
        }
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<label><name>pull_up</name>:</label>
    <if_stmt><if>if <condition>(<expr><name>innerd</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>innerjoinpath</name></name> <operator>=</operator> <call><name>redistribute_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                    <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>innerjoinpath</name></name></expr></argument>,
                                                    <argument><expr><name>innerpathkeys</name></expr></argument>,
                                                    <argument><expr><name>LOCATOR_TYPE_NONE</name></expr></argument>,
                                                    <argument><expr><name>NULL</name></expr></argument>,
                                                    <argument><expr><name>NULL</name></expr></argument>,
                                                    <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>MergePath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>MergePath</name><operator>*</operator><operator>)</operator><name>pathnode</name><operator>)</operator><operator>-&gt;</operator><name>innersortkeys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>outerd</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>outerjoinpath</name></name> <operator>=</operator> <call><name>redistribute_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                    <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>outerjoinpath</name></name></expr></argument>,
                                                    <argument><expr><name>outerpathkeys</name></expr></argument>,
                                                    <argument><expr><name>LOCATOR_TYPE_NONE</name></expr></argument>,
                                                    <argument><expr><name>NULL</name></expr></argument>,
                                                    <argument><expr><name>NULL</name></expr></argument>,
                                                    <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                                    

        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>MergePath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>MergePath</name><operator>*</operator><operator>)</operator><name>pathnode</name><operator>)</operator><operator>-&gt;</operator><name>outersortkeys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>alternate</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/* count remotesubplans in path */</comment>
<function><type><name>void</name></type>
<name>contains_remotesubplan</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>number</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>redistribute</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>number</name></expr>)</condition><block type="pseudo"><block_content>    
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>path</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <switch>switch<condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>pathtype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_RemoteSubplan</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>RemoteSubPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><operator>(</operator><name>RemoteSubPath</name> <operator>*</operator><operator>)</operator><name>path</name></expr></init></decl>;</decl_stmt>
                
                <decl_stmt><decl><type><name>Distribution</name>   <modifier>*</modifier></type><name>subdistribution</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>distribution</name></name></expr></init></decl>;</decl_stmt>
                
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>subdistribution</name> <operator>||</operator> <name><name>subdistribution</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_NONE</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><operator>(</operator><operator>*</operator><name>number</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>subdistribution</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>subdistribution</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_HASH</name> <operator>||</operator>
                    <name><name>subdistribution</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>redistribute</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><call><name>contains_remotesubplan</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_Gather</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>GatherPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><operator>(</operator><name>GatherPath</name> <operator>*</operator><operator>)</operator><name>path</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>contains_remotesubplan</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
		<case>case <expr><name>T_GatherMerge</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GatherMergePath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><operator>(</operator><name>GatherMergePath</name> <operator>*</operator><operator>)</operator><name>path</name></expr></init></decl>;</decl_stmt>
				
				<expr_stmt><expr><call><name>contains_remotesubplan</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
        <case>case <expr><name>T_Agg</name></expr>:</case>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>AggPath</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>AggPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><operator>(</operator><name>AggPath</name> <operator>*</operator><operator>)</operator><name>path</name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>contains_remotesubplan</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name>GroupingSetsPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><operator>(</operator><name>GroupingSetsPath</name> <operator>*</operator><operator>)</operator><name>path</name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>contains_remotesubplan</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_HashJoin</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>HashPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><operator>(</operator><name>HashPath</name> <operator>*</operator><operator>)</operator><name>path</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>contains_remotesubplan</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name></name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>contains_remotesubplan</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name></name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_MergeJoin</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>MergePath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><operator>(</operator><name>MergePath</name> <operator>*</operator><operator>)</operator><name>path</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>contains_remotesubplan</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name></name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>contains_remotesubplan</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name></name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_NestLoop</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>NestPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><operator>(</operator><name>NestPath</name> <operator>*</operator><operator>)</operator><name>path</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>contains_remotesubplan</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>innerjoinpath</name></name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>contains_remotesubplan</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>outerjoinpath</name></name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_Material</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>MaterialPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><operator>(</operator><name>MaterialPath</name> <operator>*</operator><operator>)</operator><name>path</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>contains_remotesubplan</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_Unique</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>UniquePath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><operator>(</operator><name>UniquePath</name> <operator>*</operator><operator>)</operator><name>path</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>contains_remotesubplan</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_SubqueryScan</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>SubqueryScanPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><operator>(</operator><name>SubqueryScanPath</name> <operator>*</operator><operator>)</operator><name>path</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>contains_remotesubplan</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_Result</name></expr>:</case>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>ProjectionPath</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ProjectionPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><operator>(</operator><name>ProjectionPath</name> <operator>*</operator><operator>)</operator><name>path</name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>contains_remotesubplan</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_ProjectSet</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ProjectSetPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><operator>(</operator><name>ProjectSetPath</name> <operator>*</operator><operator>)</operator><name>path</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>contains_remotesubplan</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_Sort</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>SortPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><operator>(</operator><name>SortPath</name> <operator>*</operator><operator>)</operator><name>path</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>contains_remotesubplan</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_Group</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>GroupPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><operator>(</operator><name>GroupPath</name> <operator>*</operator><operator>)</operator><name>path</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>contains_remotesubplan</name><argument_list>(<argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_Append</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>AppendPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><operator>(</operator><name>AppendPath</name> <operator>*</operator><operator>)</operator><name>path</name></expr></init></decl>;</decl_stmt>

                <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>pathnode-&gt;subpaths</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>contains_remotesubplan</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>T_MergeAppend</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>MergeAppendPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><operator>(</operator><name>MergeAppendPath</name> <operator>*</operator><operator>)</operator><name>path</name></expr></init></decl>;</decl_stmt>

                <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>pathnode-&gt;subpaths</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>contains_remotesubplan</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>number</name></expr></argument>, <argument><expr><name>redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
            </block_content>}</block>
            <break>break;</break>
        <default>default:</default>
            <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_num_connections</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numnodes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nRemotePlans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>num_connections</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nRemotePlans</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>num_connections</name> <operator>=</operator> <name>num_connections</name> <operator>*</operator> <name>numnodes</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>num_connections</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * redistribute local grouping results among datanodes for 
 * distinct aggs like count(distinct a) or avg(distinct a)...
 *
 * Tips: we do not check the agg column's type, directly use that
 * as hash column, but some data types are not supported as hash column now,
 * maybe some errors.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_redistribute_distinct_agg_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>pathtarget</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name>    <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>   <modifier>*</modifier></type><name>nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>group</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name><name>agg</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name><name>agg</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if<condition>(<expr><name>te</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Distinct aggref not found in pathtarget."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>groupOids</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>groupOids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Tables from different groups should not be invloved in one Query."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>groupOids</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>linitial_oid</name><argument_list>(<argument><expr><name>groupOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>group</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>group</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<comment type="block">/*
		 * FIXING ME! check hash column's data type to satisfity hash locator func
		 */</comment>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>redistribute_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								 <argument><expr><name>path</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>LOCATOR_TYPE_HASH</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
								 <argument><expr><name>nodes</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodelist</name> <init>= <expr><call><name>GetGroupNodeList</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>nodelist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>nodeid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<comment type="block">/*
		 * FIXING ME! check hash column's data type to satisfity hash locator func
		 */</comment>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>redistribute_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								 <argument><expr><name>path</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name>LOCATOR_TYPE_SHARD</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
								 <argument><expr><name>nodes</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name>pathtarget</name></expr>;</expr_stmt>

	<return>return <expr><name>path</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
  * redistribute local grouping results among datanodes, then
  * get the final grouping results. seems more efficient...
  *
  * Tips: we do not check the grouping column's type, directly use that
  * as hash column, but some data types are not supported as hash column now,
  * maybe some errors.
  */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_redistribute_grouping_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if<condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* not implement now */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"grouping sets not supported now!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
          * current implemention is quite rough, need more work.
          */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type> <name>group</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type>    <name>rows</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type>    <name>num_groups</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>       <name>colIdx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                        
        <decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>groupColIdx</name> <init>= <expr><call><name>extract_grouping_cols</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
                                                        <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupExprs</name> <init>= <expr><call><name>get_sortgrouplist_exprs</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
                                                 <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>AggPath</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>AggPath</name> <modifier>*</modifier></type><name>agg</name> <init>= <expr><operator>(</operator><name>AggPath</name> <operator>*</operator><operator>)</operator><name>path</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>rows</name> <operator>=</operator> <name><name>agg</name><operator>-&gt;</operator><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>rows</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* choose group key which get max group numbers as distributed key */</comment>
        <for>for <control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type> <name>dNumGroups</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>groupExpr</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name>groupExprs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>groupExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <call><name>estimate_num_groups</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>dNumGroups</name> <operator>&gt;</operator> <name>num_groups</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>num_groups</name> <operator>=</operator> <name>dNumGroups</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>colIdx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>groupExprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>colIdx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Could not get group-by redistributed column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>te</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator><call><name>list_nth</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                     <argument><expr><name><name>groupColIdx</name><index>[<expr><name>colIdx</name></expr>]</index></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>groupOids</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>linitial_oid</name><argument_list>(<argument><expr><name>groupOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>group</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>group</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

            <comment type="block">/*
              * FIXING ME! check hash column's data type to satisfity hash locator func
              */</comment>
            <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>redistribute_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                     <argument><expr><name>path</name></expr></argument>,
                                     <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><name>LOCATOR_TYPE_HASH</name></expr></argument>,
                                     <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
                                     <argument><expr><name>nodes</name></expr></argument>,
                                     <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodelist</name> <init>= <expr><call><name>GetGroupNodeList</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>nodelist</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>nodeid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <comment type="block">/*
              * FIXING ME! check hash column's data type to satisfity hash locator func
              */</comment>
            <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>redistribute_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                     <argument><expr><name>path</name></expr></argument>,
                                     <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><name>LOCATOR_TYPE_SHARD</name></expr></argument>,
                                     <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
                                     <argument><expr><name>nodes</name></expr></argument>,
                                     <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <return>return <expr><name>path</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
          * FIXING ME! check hash column's data type to satisfity hash locator func
          */</comment>
        <expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>redistribute_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                 <argument><expr><name>path</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>LOCATOR_TYPE_NONE</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>path</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>NULL</name></expr>;</return> <comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>add_groups_to_list</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>has_baserestrictinfo</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type>          <name>relid</name></decl></parameter>, <parameter><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rel_loc_info</name></decl></parameter>, 
                          <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>dis_qual</name></decl></parameter>, <parameter><decl><type><name>List</name>    <modifier>*</modifier></type><name>nodeList</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>sec_quals</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int32</name></type>     <name>nGroup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>     <modifier>*</modifier></type><name>groups</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>      <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>    <modifier>*</modifier></type><name>newnodelist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_CHILD</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RELATION_GET_PARENT</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* has base AND-quals with relations */</comment>
    <if_stmt><if>if <condition>(<expr><name>has_baserestrictinfo</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* meet distributed column quals */</comment>
        <if_stmt><if>if <condition>(<expr><name>dis_qual</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int16</name></type>         <name>typlen</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>         <name>typbyval</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type>         <name>typalign</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type>         <name>typdelim</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>          <name>typioparam</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>          <name>typiofunc</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>          <name>keyValueGroup</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>          <name>keyValueColdGroup</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>const_expr</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator><name>dis_qual</name></expr></init></decl>;</decl_stmt>
            
            <comment type="block">/* check whether the value is key value */</comment>
            <expr_stmt><expr><call><name>get_type_io_data</name><argument_list>(<argument><expr><name><name>const_expr</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>, <argument><expr><name>IOFunc_output</name></expr></argument>,
                             <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>,
                             <argument><expr><operator>&amp;</operator><name>typalign</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typdelim</name></expr></argument>,
                             <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typiofunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typiofunc</name></expr></argument>, <argument><expr><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
            
            <expr_stmt><expr><name>keyValueGroup</name> <operator>=</operator> <call><name>GetKeyValuesGroup</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keyValueColdGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

            <comment type="block">/* relation in key-value */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>keyValueGroup</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>groupOids</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name>groupOids</name></expr></argument>, <argument><expr><name>keyValueGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>groupOids</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name>groupOids</name></expr></argument>, <argument><expr><name>keyValueColdGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

                <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>nodeList</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type> <name>nodeidx</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <decl_stmt><decl><type><name>Oid</name></type> <name>nodeoid</name> <init>= <expr><call><name>PGXCNodeGetNodeOid</name><argument_list>(<argument><expr><name>nodeidx</name></expr></argument>, <argument><expr><name>PGXC_NODE_DATANODE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <decl_stmt><decl><type><name>Oid</name></type> <name>groupoid</name> <init>= <expr><call><name>GetGroupOidByNode</name><argument_list>(<argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name>groupOids</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name>groupOids</name></expr></argument>, <argument><expr><name>groupoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>GetRelationSecondGroup</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>groups</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* relation in key-value */</comment>
            <if_stmt><if>if <condition>(<expr><name>nGroup</name></expr>)</condition>
            <block>{<block_content>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nGroup</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><name>groupOids</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name>groupOids</name></expr></argument>, <argument><expr><name><name>groups</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>

                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>groupOids</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name>groupOids</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>groupOids</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name>groupOids</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* has second distributed column qual */</comment>
                <if_stmt><if>if <condition>(<expr><name>sec_quals</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
                    
                    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>oids</name> <init>= <expr><call><name>GetRelationGroupsByQuals</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><name>sec_quals</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name>groupOids</name> <operator>=</operator> <call><name>list_union_oid</name><argument_list>(<argument><expr><name>groupOids</name></expr></argument>, <argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>oids</argument>)</argument_list></macro>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>int32</name></type>     <name>dn_num</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>int32</name>  <modifier>*</modifier></type><name>datanodes</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>Oid</name></type> <name>groupoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><call><name>GetShardNodes</name><argument_list>(<argument><expr><name>groupoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datanodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dn_num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <for>for<control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>dn_num</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>                            
                            <expr_stmt><expr><name>newnodelist</name> <operator>=</operator> <call><name>list_append_unique_int</name><argument_list>(<argument><expr><name>newnodelist</name></expr></argument>, <argument><expr><name><name>datanodes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></for>
                        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>datanodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>groupOids</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name>groupOids</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>groupOids</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name>groupOids</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>groupOids</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name>groupOids</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>groupOids</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name>groupOids</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* secondary group */</comment>
        <expr_stmt><expr><call><name>GetRelationSecondGroup</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>groups</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nGroup</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>groupOids</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name>groupOids</name></expr></argument>, <argument><expr><name><name>groups</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        
        <if_stmt><if>if <condition>(<expr><name>nGroup</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>newnodelist</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>adjust_distribution_nodes</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, 
                                    <parameter><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rel_loc_info</name></decl></parameter>, <parameter><decl><type><name>Distribution</name> <modifier>*</modifier></type><name>distribution</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name>rel_loc_info</name> <operator>&amp;&amp;</operator> <call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nodeidx</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>cold_hot_group</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CmdType</name></type> <name>cmd</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nodelist</name> <init>= <expr><ternary><condition><expr><name><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr> ?</condition><then> <expr><name><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr> </then><else>: <expr><name><name>distribution</name><operator>-&gt;</operator><name>nodes</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>nodeidx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>nodeidx</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>, <argument><expr><name>nodeidx</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type> <name>nodeoid</name> <init>= <expr><call><name>PGXCNodeGetNodeOid</name><argument_list>(<argument><expr><name>nodeidx</name></expr></argument>, <argument><expr><name>PGXC_NODE_DATANODE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>Oid</name></type> <name>groupoid</name> <init>= <expr><call><name>GetGroupOidByNode</name><argument_list>(<argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>groupOids</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name>groupOids</name></expr></argument>, <argument><expr><name>groupoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>cold_hot_group</name> <operator>=</operator> <call><name>list_append_unique_oid</name><argument_list>(<argument><expr><name>cold_hot_group</name></expr></argument>, <argument><expr><name>groupoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <if_stmt><if>if <condition>(<expr><name><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>cold_hot_group</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>==</operator> <name>CMD_SELECT</name> <operator>||</operator> 
                <operator>(</operator><operator>(</operator><name>cmd</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator> <name>cmd</name> <operator>==</operator> <name>CMD_DELETE</name> <operator>||</operator> <name>cmd</name> <operator>==</operator> <name>CMD_INSERT</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>!=</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int32</name></type> <name>dn_num</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int32</name> <modifier>*</modifier></type><name>datanodes</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>newnodelist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type> <name>groupoid</name> <init>= <expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name>cold_hot_group</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>GetShardNodes</name><argument_list>(<argument><expr><name>groupoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datanodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dn_num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for<control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>dn_num</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>                            
                    <expr_stmt><expr><name>newnodelist</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>newnodelist</name></expr></argument>, <argument><expr><name><name>datanodes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>

                <if_stmt><if>if <condition>(<expr><name>newnodelist</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>distribution</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <name>newnodelist</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * create_seqscan_path
 *      Creates a path corresponding to a sequential scan, returning the
 *      pathnode.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_seqscan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                    <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>parallel_workers</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>RangeTblEntry</name>    <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rel_loc_info</name> <init>= <expr><call><name>GetRelationLocInfo</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>=</operator> <name>T_SeqScan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
                                                     <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <ternary><condition><expr><name>parallel_workers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_workers</name></name> <operator>=</operator> <name>parallel_workers</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>    <comment type="block">/* seqscan has unordered result */</comment>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <expr_stmt><expr><call><name>set_scanpath_distribution</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pathnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
        <decl_stmt><decl><type><name>bool</name></type> <name>or_clause</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>rel-&gt;baserestrictinfo</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>restrict_distribution</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ri</name></expr></argument>, <argument><expr><name>pathnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ri</name><operator>-&gt;</operator><name>orclause</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name><name>ri</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>or_clause</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>or_clause</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Distribution</name>   <modifier>*</modifier></type><name>distribution</name> <init>= <expr><name><name>pathnode</name><operator>-&gt;</operator><name>distribution</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RelationAccessType</name></type> <name>rel_access</name> <init>= <expr><name>RELATION_ACCESS_READ</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>for_update</name> <init>= <expr><ternary><condition><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

            <switch>switch <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>CMD_SELECT</name></expr>:</case>
                    <if_stmt><if>if <condition>(<expr><name>for_update</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_READ_FOR_UPDATE</name></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_READ_FQS</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    <break>break;</break>

                <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
                <case>case <expr><name>CMD_DELETE</name></expr>:</case>
                    <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_UPDATE</name></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>CMD_INSERT</name></expr>:</case>
                    <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_INSERT</name></expr>;</expr_stmt>
                    <break>break;</break>

                <default>default:</default>
                    <comment type="block">/* should not happen, but */</comment>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unrecognised command type %d"</literal></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></switch>

            <if_stmt><if>if <condition>(<expr><name>rel_loc_info</name> <operator>&amp;&amp;</operator> <call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>dis_qual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>sec_quals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator> 
                    <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name> <operator>||</operator>
                    <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>!=</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_READ</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>GetRelationNodesByQuals</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, 
                                                    <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>quals</name></expr></argument>, <argument><expr><name>rel_access</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dis_qual</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newnodelist</name> <init>= <expr><call><name>add_groups_to_list</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>rel_loc_info</name></expr></argument>, 
                                                           <argument><expr><name>dis_qual</name></expr></argument>, <argument><expr><name><name>nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><name>sec_quals</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>newnodelist</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name>newnodelist</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>count</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>restrictinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                    
                    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>nodes-&gt;nodeList</argument>)</argument_list></macro>
                    <block>{<block_content>
                        <expr_stmt><expr><name>restrictinfo</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>restrictinfo</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block>

                    <expr_stmt><expr><name><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <name>restrictinfo</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <name>or_clause</name> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>rel_loc_info</name> <operator>&amp;&amp;</operator> <call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>add_groups_to_list</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>rel_loc_info</name> <operator>&amp;&amp;</operator> <call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>add_groups_to_list</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Distribution</name>   <modifier>*</modifier></type><name>distribution</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator><name>pathnode</name><operator>)</operator><operator>-&gt;</operator><name>distribution</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>adjust_distribution_nodes</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><name>distribution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>cost_seqscan</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_samplescan_path
 *      Creates a path node for a sampled table scan.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_samplescan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>RangeTblEntry</name>    <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rel_loc_info</name> <init>= <expr><call><name>GetRelationLocInfo</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>=</operator> <name>T_SampleScan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
                                                     <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>    <comment type="block">/* samplescan has unordered result */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <expr_stmt><expr><call><name>set_scanpath_distribution</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>pathnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
        <decl_stmt><decl><type><name>bool</name></type> <name>or_clause</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>rel-&gt;baserestrictinfo</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>restrict_distribution</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ri</name></expr></argument>, <argument><expr><name>pathnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ri</name><operator>-&gt;</operator><name>orclause</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name><name>ri</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>or_clause</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>or_clause</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Distribution</name>   <modifier>*</modifier></type><name>distribution</name> <init>= <expr><name><name>pathnode</name><operator>-&gt;</operator><name>distribution</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RelationAccessType</name></type> <name>rel_access</name> <init>= <expr><name>RELATION_ACCESS_READ</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>for_update</name> <init>= <expr><ternary><condition><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

            <switch>switch <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>CMD_SELECT</name></expr>:</case>
                    <if_stmt><if>if <condition>(<expr><name>for_update</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_READ_FOR_UPDATE</name></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_READ_FQS</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    <break>break;</break>

                <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
                <case>case <expr><name>CMD_DELETE</name></expr>:</case>
                    <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_UPDATE</name></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>CMD_INSERT</name></expr>:</case>
                    <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_INSERT</name></expr>;</expr_stmt>
                    <break>break;</break>

                <default>default:</default>
                    <comment type="block">/* should not happen, but */</comment>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unrecognised command type %d"</literal></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></switch>

            <if_stmt><if>if <condition>(<expr><name>rel_loc_info</name> <operator>&amp;&amp;</operator> <call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>dis_qual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>sec_quals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                
                <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator> 
                    <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name> <operator>||</operator>
                    <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>!=</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_READ</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>GetRelationNodesByQuals</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, 
                                                    <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>quals</name></expr></argument>, <argument><expr><name>rel_access</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dis_qual</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newnodelist</name> <init>= <expr><call><name>add_groups_to_list</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>rel_loc_info</name></expr></argument>, 
                                                           <argument><expr><name>dis_qual</name></expr></argument>, <argument><expr><name><name>nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><name>sec_quals</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>newnodelist</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name>newnodelist</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>count</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>restrictinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                    
                    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>nodes-&gt;nodeList</argument>)</argument_list></macro>
                    <block>{<block_content>
                        <expr_stmt><expr><name>restrictinfo</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>restrictinfo</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block>

                    <expr_stmt><expr><name><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <name>restrictinfo</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <name>or_clause</name> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>rel_loc_info</name> <operator>&amp;&amp;</operator> <call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>add_groups_to_list</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>rel_loc_info</name> <operator>&amp;&amp;</operator> <call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>add_groups_to_list</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Distribution</name>   <modifier>*</modifier></type><name>distribution</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator><name>pathnode</name><operator>)</operator><operator>-&gt;</operator><name>distribution</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>adjust_distribution_nodes</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><name>distribution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>cost_samplescan</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_index_path
 *      Creates a path node for an index scan.
 *
 * 'index' is a usable index.
 * 'indexclauses' is a list of RestrictInfo nodes representing clauses
 *            to be used as index qual conditions in the scan.
 * 'indexclausecols' is an integer list of index column numbers (zero based)
 *            the indexclauses can be used with.
 * 'indexorderbys' is a list of bare expressions (no RestrictInfos)
 *            to be used as index ordering operators in the scan.
 * 'indexorderbycols' is an integer list of index column numbers (zero based)
 *            the ordering operators can be used with.
 * 'pathkeys' describes the ordering of the path.
 * 'indexscandir' is ForwardScanDirection or BackwardScanDirection
 *            for an ordered index, or NoMovementScanDirection for
 *            an unordered index.
 * 'indexonly' is true if an index-only scan is wanted.
 * 'required_outer' is the set of outer relids for a parameterized path.
 * 'loop_count' is the number of repetitions of the indexscan to factor into
 *        estimates of caching behavior.
 * 'partial_path' is true if constructing a parallel index scan path.
 *
 * Returns the new path node.
 */</comment>
<function><type><name>IndexPath</name> <modifier>*</modifier></type>
<name>create_index_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                  <parameter><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name></decl></parameter>,
                  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexclauses</name></decl></parameter>,
                  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexclausecols</name></decl></parameter>,
                  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexorderbys</name></decl></parameter>,
                  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexorderbycols</name></decl></parameter>,
                  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
                  <parameter><decl><type><name>ScanDirection</name></type> <name>indexscandir</name></decl></parameter>,
                  <parameter><decl><type><name>bool</name></type> <name>indexonly</name></decl></parameter>,
                  <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>,
                  <parameter><decl><type><name>double</name></type> <name>loop_count</name></decl></parameter>,
                  <parameter><decl><type><name>bool</name></type> <name>partial_path</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>IndexPath</name>  <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>index</name><operator>-&gt;</operator><name>rel</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>indexquals</name></decl>,
               <decl><type ref="prev"><modifier>*</modifier></type><name>indexqualcols</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name>    <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rel_loc_info</name> <init>= <expr><call><name>GetRelationLocInfo</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <ternary><condition><expr><name>indexonly</name></expr> ?</condition><then> <expr><name>T_IndexOnlyScan</name></expr> </then><else>: <expr><name>T_IndexScan</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
                                                          <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>

    <comment type="block">/* Convert clauses to indexquals the executor can handle */</comment>
    <expr_stmt><expr><call><name>expand_indexqual_conditions</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>indexclauses</name></expr></argument>, <argument><expr><name>indexclausecols</name></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name>indexquals</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>indexqualcols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Fill in the pathnode */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>indexinfo</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>indexclauses</name></name> <operator>=</operator> <name>indexclauses</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>indexquals</name></name> <operator>=</operator> <name>indexquals</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>indexqualcols</name></name> <operator>=</operator> <name>indexqualcols</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>indexorderbys</name></name> <operator>=</operator> <name>indexorderbys</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>indexorderbycols</name></name> <operator>=</operator> <name>indexorderbycols</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>indexscandir</name></name> <operator>=</operator> <name>indexscandir</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <expr_stmt><expr><call><name>set_scanpath_distribution</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>indexclauses</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>indexclauses</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>restrict_distribution</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ri</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name> <operator>&amp;&amp;</operator> <name>restrict_query</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>rel-&gt;baserestrictinfo</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>restrict_distribution</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ri</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>rel-&gt;baserestrictinfo</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ri</name><operator>-&gt;</operator><name>orclause</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name><name>ri</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>quals</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>
    
	<if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Distribution</name>   <modifier>*</modifier></type><name>distribution</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator><name>pathnode</name><operator>)</operator><operator>-&gt;</operator><name>distribution</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RelationAccessType</name></type> <name>rel_access</name> <init>= <expr><name>RELATION_ACCESS_READ</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>for_update</name> <init>= <expr><ternary><condition><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>CMD_SELECT</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>for_update</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_READ_FOR_UPDATE</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_READ_FQS</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                <break>break;</break>

            <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
            <case>case <expr><name>CMD_DELETE</name></expr>:</case>
                <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_UPDATE</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>CMD_INSERT</name></expr>:</case>
                <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_INSERT</name></expr>;</expr_stmt>
                <break>break;</break>

            <default>default:</default>
                <comment type="block">/* should not happen, but */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unrecognised command type %d"</literal></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>

        <if_stmt><if>if <condition>(<expr><name>rel_loc_info</name> <operator>&amp;&amp;</operator> <call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>dis_qual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>sec_quals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator> 
                <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name> <operator>||</operator>
                <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>!=</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_READ</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>GetRelationNodesByQuals</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, 
                                                <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>quals</name></expr></argument>, <argument><expr><name>rel_access</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dis_qual</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newnodelist</name> <init>= <expr><call><name>add_groups_to_list</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>rel_loc_info</name></expr></argument>, 
                                                       <argument><expr><name>dis_qual</name></expr></argument>, <argument><expr><name><name>nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><name>sec_quals</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>newnodelist</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name>newnodelist</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>count</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>restrictinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                
                <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>nodes-&gt;nodeList</argument>)</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name>restrictinfo</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>restrictinfo</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>

                <expr_stmt><expr><name><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <name>restrictinfo</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Distribution</name>   <modifier>*</modifier></type><name>distribution</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator><name>pathnode</name><operator>)</operator><operator>-&gt;</operator><name>distribution</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>adjust_distribution_nodes</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><name>distribution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>cost_index</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>loop_count</name></expr></argument>, <argument><expr><name>partial_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_bitmap_heap_path
 *      Creates a path node for a bitmap scan.
 *
 * 'bitmapqual' is a tree of IndexPath, BitmapAndPath, and BitmapOrPath nodes.
 * 'required_outer' is the set of outer relids for a parameterized path.
 * 'loop_count' is the number of repetitions of the indexscan to factor into
 *        estimates of caching behavior.
 *
 * loop_count should match the value used when creating the component
 * IndexPaths.
 */</comment>
<function><type><name>BitmapHeapPath</name> <modifier>*</modifier></type>
<name>create_bitmap_heap_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                        <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                        <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>bitmapqual</name></decl></parameter>,
                        <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>,
                        <parameter><decl><type><name>double</name></type> <name>loop_count</name></decl></parameter>,
                        <parameter><decl><type><name>int</name></type> <name>parallel_degree</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>BitmapHeapPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>BitmapHeapPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>RangeTblEntry</name>    <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rel_loc_info</name> <init>= <expr><call><name>GetRelationLocInfo</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_BitmapHeapScan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
                                                          <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <ternary><condition><expr><name>parallel_degree</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name>parallel_degree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>    <comment type="block">/* always unordered */</comment>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>bitmapqual</name></name> <operator>=</operator> <name>bitmapqual</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <expr_stmt><expr><call><name>set_scanpath_distribution</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>baserestrictinfo</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
        <decl_stmt><decl><type><name>bool</name></type> <name>or_clause</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>rel-&gt;baserestrictinfo</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>restrict_distribution</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ri</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ri</name><operator>-&gt;</operator><name>orclause</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name><name>ri</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>or_clause</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>or_clause</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Distribution</name>   <modifier>*</modifier></type><name>distribution</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator><name>pathnode</name><operator>)</operator><operator>-&gt;</operator><name>distribution</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RelationAccessType</name></type> <name>rel_access</name> <init>= <expr><name>RELATION_ACCESS_READ</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>for_update</name> <init>= <expr><ternary><condition><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rowMarks</name></name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

            <switch>switch <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>CMD_SELECT</name></expr>:</case>
                    <if_stmt><if>if <condition>(<expr><name>for_update</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_READ_FOR_UPDATE</name></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_READ_FQS</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    <break>break;</break>

                <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
                <case>case <expr><name>CMD_DELETE</name></expr>:</case>
                    <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_UPDATE</name></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>CMD_INSERT</name></expr>:</case>
                    <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_INSERT</name></expr>;</expr_stmt>
                    <break>break;</break>

                <default>default:</default>
                    <comment type="block">/* should not happen, but */</comment>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unrecognised command type %d"</literal></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></switch>

            <if_stmt><if>if <condition>(<expr><name>rel_loc_info</name> <operator>&amp;&amp;</operator> <call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>dis_qual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>sec_quals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator> 
                    <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name> <operator>||</operator>
                    <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>!=</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>rel_access</name> <operator>=</operator> <name>RELATION_ACCESS_READ</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>GetRelationNodesByQuals</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, 
                                                    <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>quals</name></expr></argument>, <argument><expr><name>rel_access</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dis_qual</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sec_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newnodelist</name> <init>= <expr><call><name>add_groups_to_list</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>rel_loc_info</name></expr></argument>, 
                                                           <argument><expr><name>dis_qual</name></expr></argument>, <argument><expr><name><name>nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><name>sec_quals</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>newnodelist</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name>newnodelist</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>count</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>restrictinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                    
                    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>nodes-&gt;nodeList</argument>)</argument_list></macro>
                    <block>{<block_content>
                        <expr_stmt><expr><name>restrictinfo</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>restrictinfo</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block>

                    <expr_stmt><expr><name><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <name>restrictinfo</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <name>or_clause</name> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>rel_loc_info</name> <operator>&amp;&amp;</operator> <call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>add_groups_to_list</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>rel_loc_info</name> <operator>&amp;&amp;</operator> <call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>add_groups_to_list</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Distribution</name>   <modifier>*</modifier></type><name>distribution</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator><name>pathnode</name><operator>)</operator><operator>-&gt;</operator><name>distribution</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>adjust_distribution_nodes</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><name>distribution</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>cost_bitmap_heap_scan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
                          <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr></argument>,
                          <argument><expr><name>bitmapqual</name></expr></argument>, <argument><expr><name>loop_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_bitmap_and_path
 *      Creates a path node representing a BitmapAnd.
 */</comment>
<function><type><name>BitmapAndPath</name> <modifier>*</modifier></type>
<name>create_bitmap_and_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                       <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                       <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>bitmapquals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BitmapAndPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>BitmapAndPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_BitmapAnd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>    <comment type="block">/* not used in bitmap trees */</comment>

    <comment type="block">/*
     * Currently, a BitmapHeapPath, BitmapAndPath, or BitmapOrPath will be
     * parallel-safe if and only if rel-&gt;consider_parallel is set.  So, we can
     * set the flag for this path based only on the relation-level flag,
     * without actually iterating over the list of children.
     */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>    <comment type="block">/* always unordered */</comment>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>bitmapquals</name></name> <operator>=</operator> <name>bitmapquals</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <expr_stmt><expr><call><name>set_scanpath_distribution</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* this sets bitmapselectivity as well as the regular cost fields: */</comment>
    <expr_stmt><expr><call><name>cost_bitmap_and_node</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_bitmap_or_path
 *      Creates a path node representing a BitmapOr.
 */</comment>
<function><type><name>BitmapOrPath</name> <modifier>*</modifier></type>
<name>create_bitmap_or_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                      <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>bitmapquals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>BitmapOrPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>BitmapOrPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_BitmapOr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>    <comment type="block">/* not used in bitmap trees */</comment>

    <comment type="block">/*
     * Currently, a BitmapHeapPath, BitmapAndPath, or BitmapOrPath will be
     * parallel-safe if and only if rel-&gt;consider_parallel is set.  So, we can
     * set the flag for this path based only on the relation-level flag,
     * without actually iterating over the list of children.
     */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>    <comment type="block">/* always unordered */</comment>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>bitmapquals</name></name> <operator>=</operator> <name>bitmapquals</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <expr_stmt><expr><call><name>set_scanpath_distribution</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* this sets bitmapselectivity as well as the regular cost fields: */</comment>
    <expr_stmt><expr><call><name>cost_bitmap_or_node</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_tidscan_path
 *      Creates a path corresponding to a scan by TID, returning the pathnode.
 */</comment>
<function><type><name>TidPath</name> <modifier>*</modifier></type>
<name>create_tidscan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tidquals</name></decl></parameter>,
                    <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TidPath</name>    <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TidPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_TidScan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
                                                          <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>    <comment type="block">/* always unordered */</comment>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>tidquals</name></name> <operator>=</operator> <name>tidquals</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <expr_stmt><expr><call><name>set_scanpath_distribution</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* We may need to pass info about target node to support */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not perform TID scan on remote relation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>cost_tidscan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tidquals</name></expr></argument>,
                 <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_append_path
 *      Creates a path corresponding to an Append plan, returning the
 *      pathnode.
 *
 * Note that we must handle subpaths = NIL, representing a dummy access path.
 */</comment>
<function><type><name>AppendPath</name> <modifier>*</modifier></type>
<name>create_append_path</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subpaths</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>,
                   <parameter><decl><type><name>int</name></type> <name>parallel_workers</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitioned_rels</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>AppendPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AppendPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Distribution</name> <modifier>*</modifier></type><name>distribution</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>subpath</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Append</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_appendrel_parampathinfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
                                                            <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name>parallel_workers</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>    <comment type="block">/* result is always considered unsorted */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <comment type="block">/*
     * Append path is used to implement scans of partitioned tables, inherited
     * tables and some "set" operations, like UNION ALL. While all partitioned
     * and inherited tables should have the same distribution, UNION'ed queries
     * may have different.  When paths being appended have the same
     * distribution it is OK to push Append down to the data nodes. If not,
     * perform "coordinator" Append.
     *
     * Since we ensure that all partitions of a partitioned table are always
     * distributed by the same strategy on the same set of nodes, we can push
     * down MergeAppend of partitions of the table.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>partitioned_rels</name> <operator>&amp;&amp;</operator> <name>subpaths</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Take distribution of the first node */</comment>
        <expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>distribution</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <name>distribution</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* Special case of the dummy relation, if the subpaths list is empty */</comment>
    <if type="elseif">else if <condition>(<expr><name>subpaths</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Take distribution of the first node */</comment>
        <expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>distribution</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * Check remaining subpaths, if all distributions equal to the first set
         * it as a distribution of the Append path; otherwise make up coordinator
         * Append
         */</comment>
        <while>while <condition>(<expr><operator>(</operator><name>l</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * For Append and MergeAppend paths, we are most often dealing with
             * different relations, appended together. So its very likely that
             * the distribution for each relation will have a different varno.
             * But we should be able to push down Append and MergeAppend as
             * long as rest of the distribution information matches.
             *
             * equalDistribution() compares everything except the varnos
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>equalDistribution</name><argument_list>(<argument><expr><name>distribution</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Both distribution and subpath-&gt;distribution may be NULL at
                 * this point, or they both are not null.
                 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<if_stmt><if>if <condition>(<expr><name>distribution</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>&amp;&amp;</operator> <name><name>subpath</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <call><name>bms_union</name><argument_list>(
							<argument><expr><name><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>,
							<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <if_stmt><if>if <condition>(<expr><name>distribution</name> <operator>&amp;&amp;</operator> <name><name>subpath</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <call><name>bms_union</name><argument_list>(
                            <argument><expr><name><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>,
                            <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
        <if_stmt><if>if <condition>(<expr><name>l</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newsubpaths</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
            <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>subpaths</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>redistribute_path</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
                                                <argument><expr><name>LOCATOR_TYPE_NONE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                                <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>newsubpaths</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newsubpaths</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><name>subpaths</name> <operator>=</operator> <name>newsubpaths</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <name>distribution</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>partitioned_rels</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>partitioned_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpaths</name></name> <operator>=</operator> <name>subpaths</name></expr>;</expr_stmt>

    <comment type="block">/*
     * We don't bother with inventing a cost_append(), but just do it here.
     *
     * Compute rows and costs as sums of subplan rows and costs.  We charge
     * nothing extra for the Append itself, which perhaps is too optimistic,
     * but since it doesn't do any selection or projection, it is a pretty
     * cheap node.
     */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>subpaths</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* first node? */</comment>
            <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>&amp;&amp;</operator>
            <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>

        <comment type="block">/* All child paths must have same parameterization */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_equal</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_merge_append_path
 *      Creates a path corresponding to a MergeAppend plan, returning the
 *      pathnode.
 */</comment>
<function><type><name>MergeAppendPath</name> <modifier>*</modifier></type>
<name>create_merge_append_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                         <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                         <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subpaths</name></decl></parameter>,
                         <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
                         <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>,
                         <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitioned_rels</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>MergeAppendPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>MergeAppendPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Cost</name></type>        <name>input_startup_cost</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Cost</name></type>        <name>input_total_cost</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Distribution</name> <modifier>*</modifier></type><name>distribution</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>subpath</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_MergeAppend</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <comment type="block">/*
     * Since we ensure that all partitions of a partitioned table are always
     * distributed by the same strategy on the same set of nodes, we can push
     * down MergeAppend of partitions of the table.
     *
     * For MergeAppend of non-partitions, it is safe to push down MergeAppend
     * if all subpath distributions are the same and these distributions are
     * Replicated or distribution key is the expression of the first pathkey.
     */</comment>
    <expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>distribution</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>partitioned_rels</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <name>distribution</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * Verify if it is safe to push down MergeAppend with this distribution.
         * TODO implement check of the second condition (distribution key is the
         * first pathkey)
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>distribution</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>IsLocatorReplicated</name><argument_list>(<argument><expr><name><name>distribution</name><operator>-&gt;</operator><name>distributionType</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Check remaining subpaths, if all distributions equal to the first set
             * it as a distribution of the Append path; otherwise make up coordinator
             * Append
             */</comment>
            <while>while <condition>(<expr><operator>(</operator><name>l</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * See comments in Append path
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>distribution</name> <operator>&amp;&amp;</operator> <call><name>equalDistribution</name><argument_list>(<argument><expr><name>distribution</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name> <operator>=</operator> <call><name>bms_union</name><argument_list>(
                                <argument><expr><name><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>,
                                <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>restrictNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <break>break;</break>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>l</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newsubpaths</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
            <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>subpaths</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * If an explicit sort is necessary, make sure it's pushed
                     * down to the remote node (i.e. add it before the remote
                     * subplan).
                     */</comment>
                    <expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>redistribute_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>,
                                                <argument><expr><name>LOCATOR_TYPE_NONE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                                <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>newsubpaths</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newsubpaths</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <expr_stmt><expr><name>subpaths</name> <operator>=</operator> <name>newsubpaths</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <name>distribution</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_appendrel_parampathinfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
                                                            <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>partitioned_rels</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>partitioned_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpaths</name></name> <operator>=</operator> <name>subpaths</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Apply query-wide LIMIT if known and path is for sole base relation.
     * (Handling this at this low level is a bit klugy.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>all_baserels</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>limit_tuples</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>limit_tuples</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>limit_tuples</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Add up the sizes and costs of the input paths.
     */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>input_startup_cost</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>input_total_cost</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>subpaths</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>&amp;&amp;</operator>
            <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Subpath is adequately ordered, we won't need to sort it */</comment>
            <expr_stmt><expr><name>input_startup_cost</name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>input_total_cost</name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* We'll need to insert a Sort node, so include cost for that */</comment>
            <decl_stmt><decl><type><name>Path</name></type>        <name>sort_path</name></decl>;</decl_stmt>    <comment type="block">/* dummy for result of cost_sort */</comment>

            <expr_stmt><expr><call><name>cost_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sort_path</name></expr></argument>,
                      <argument><expr><name>root</name></expr></argument>,
                      <argument><expr><name>pathkeys</name></expr></argument>,
                      <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
                      <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>,
                      <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
                      <argument><expr><literal type="number">0.0</literal></expr></argument>,
                      <argument><expr><name>work_mem</name></expr></argument>,
                      <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>limit_tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>input_startup_cost</name> <operator>+=</operator> <name><name>sort_path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>input_total_cost</name> <operator>+=</operator> <name><name>sort_path</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* All child paths must have same parameterization */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_equal</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Now we can compute total costs of the MergeAppend */</comment>
    <expr_stmt><expr><call><name>cost_merge_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
                      <argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>input_startup_cost</name></expr></argument>, <argument><expr><name>input_total_cost</name></expr></argument>,
                      <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_result_path
 *      Creates a path representing a Result-and-nothing-else plan.
 *
 * This is only used for degenerate cases, such as a query with an empty
 * jointree.
 */</comment>
<function><type><name>ResultPath</name> <modifier>*</modifier></type>
<name>create_result_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                   <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>resconstantqual</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ResultPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ResultPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Result</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>    <comment type="block">/* there are no other rels... */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>resconstantqual</name></expr>;</expr_stmt>

    <comment type="block">/* Hardly worth defining a cost_result() function ... just do it */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator>
        <name>cpu_tuple_cost</name> <operator>+</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>resconstantqual</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>QualCost</name></type>    <name>qual_cost</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>cost_qual_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qual_cost</name></expr></argument>, <argument><expr><name>resconstantqual</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* resconstantqual is evaluated once at startup */</comment>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>+=</operator> <name><name>qual_cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator> <name><name>qual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name><name>qual_cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator> <name><name>qual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_material_path
 *      Creates a path corresponding to a Material plan, returning the
 *      pathnode.
 */</comment>
<function><type><name>MaterialPath</name> <modifier>*</modifier></type>
<name>create_material_path</name><parameter_list>(<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MaterialPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>MaterialPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Material</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
        <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <operator>(</operator><name>Distribution</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>cost_material</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
                  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>,
                  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
                  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
                  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_unique_path
 *      Creates a path representing elimination of distinct rows from the
 *      input data.  Distinct-ness is defined according to the needs of the
 *      semijoin represented by sjinfo.  If it is not possible to identify
 *      how to make the data unique, NULL is returned.
 *
 * If used at all, this is likely to be called repeatedly on the same rel;
 * and the input subpath should always be the same (the cheapest_total path
 * for the rel).  So we cache the result.
 */</comment>
<function><type><name>UniquePath</name> <modifier>*</modifier></type>
<name>create_unique_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
                   <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>UniquePath</name> <modifier>*</modifier></type><name>pathnode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Path</name></type>        <name>sort_path</name></decl>;</decl_stmt>        <comment type="block">/* dummy for result of cost_sort */</comment>
    <decl_stmt><decl><type><name>Path</name></type>        <name>agg_path</name></decl>;</decl_stmt>        <comment type="block">/* dummy for result of cost_agg */</comment>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>numCols</name></decl>;</decl_stmt>

    <comment type="block">/* Caller made a mistake if subpath isn't cheapest_total ... */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>subpath</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name> <operator>==</operator> <name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* ... or if SpecialJoinInfo is the wrong one */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name> <operator>==</operator> <name>JOIN_SEMI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_equal</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If result already cached, return it */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_unique_path</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>(</operator><name>UniquePath</name> <operator>*</operator><operator>)</operator> <name><name>rel</name><operator>-&gt;</operator><name>cheapest_unique_path</name></name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* If it's not possible to unique-ify, return NULL */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_btree</name></name> <operator>||</operator> <name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_hash</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We must ensure path struct and subsidiary data are allocated in main
     * planning context; otherwise GEQO memory management causes trouble.
     */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>planner_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pathnode</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>UniquePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Unique</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
        <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Assume the output is unsorted, since we don't necessarily have pathkeys
     * to represent it.  (This might get overridden below.)
     */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>in_operators</name></name> <operator>=</operator> <name><name>sjinfo</name><operator>-&gt;</operator><name>semi_operators</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>uniq_exprs</name></name> <operator>=</operator> <name><name>sjinfo</name><operator>-&gt;</operator><name>semi_rhs_exprs</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <comment type="block">/* distribution is the same as in the subpath */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <operator>(</operator><name>Distribution</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If the input is a relation and it has a unique index that proves the
     * semi_rhs_exprs are unique, then we don't need to do anything.  Note
     * that relation_has_unique_index_for automatically considers restriction
     * clauses for the rel, as well.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name> <operator>&amp;&amp;</operator> <name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_btree</name></name> <operator>&amp;&amp;</operator>
        <call><name>relation_has_unique_index_for</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
                                      <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_rhs_exprs</name></name></expr></argument>,
                                      <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_operators</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>umethod</name></name> <operator>=</operator> <name>UNIQUE_PATH_NOOP</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_unique_path</name></name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>pathnode</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If the input is a subquery whose output must be unique already, then we
     * don't need to do anything.  The test for uniqueness has to consider
     * exactly which columns we are extracting; for example "SELECT DISTINCT
     * x,y" doesn't guarantee that x alone is distinct. So we cannot check for
     * this optimization unless semi_rhs_exprs consists only of simple Vars
     * referencing subquery outputs.  (Possibly we could do something with
     * expressions in the subquery outputs, too, but for now keep it simple.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>query_supports_distinctness</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>sub_tlist_colnos</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>sub_tlist_colnos</name> <operator>=</operator> <call><name>translate_sub_tlist</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_rhs_exprs</name></name></expr></argument>,
                                                   <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>sub_tlist_colnos</name> <operator>&amp;&amp;</operator>
                <call><name>query_is_distinct_for</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>,
                                      <argument><expr><name>sub_tlist_colnos</name></expr></argument>,
                                      <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_operators</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>umethod</name></name> <operator>=</operator> <name>UNIQUE_PATH_NOOP</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_unique_path</name></name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <return>return <expr><name>pathnode</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Estimate number of output rows */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <call><name>estimate_num_groups</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                              <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_rhs_exprs</name></name></expr></argument>,
                                              <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
                                              <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>numCols</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_rhs_exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_btree</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Estimate cost for sort+unique implementation
         */</comment>
        <expr_stmt><expr><call><name>cost_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sort_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
                  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
                  <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
                  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
                  <argument><expr><literal type="number">0.0</literal></expr></argument>,
                  <argument><expr><name>work_mem</name></expr></argument>,
                  <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Charge one cpu_operator_cost per comparison per input tuple. We
         * assume all columns get compared at most of the tuples. (XXX
         * probably this is an overestimate.)  This should agree with
         * create_upper_unique_path.
         */</comment>
        <expr_stmt><expr><name><name>sort_path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name>cpu_operator_cost</name> <operator>*</operator> <name><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name>numCols</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_hash</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Estimate the overhead per hashtable entry at 64 bytes (same as in
         * planner.c).
         */</comment>
        <decl_stmt><decl><type><name>int</name></type>            <name>hashentrysize</name> <init>= <expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name> <operator>+</operator> <literal type="number">64</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>hashentrysize</name> <operator>*</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>&gt;</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We should not try to hash.  Hack the SpecialJoinInfo to
             * remember this, in case we come through here again.
             */</comment>
            <expr_stmt><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_hash</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>cost_agg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agg_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
                     <argument><expr><name>AGG_HASHED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                     <argument><expr><name>numCols</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr></argument>,
                     <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>,
                     <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
                     <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_btree</name></name> <operator>&amp;&amp;</operator> <name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_hash</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>agg_path</name><operator>.</operator><name>total_cost</name></name> <operator>&lt;</operator> <name><name>sort_path</name><operator>.</operator><name>total_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>umethod</name></name> <operator>=</operator> <name>UNIQUE_PATH_HASH</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>umethod</name></name> <operator>=</operator> <name>UNIQUE_PATH_SORT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_btree</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>umethod</name></name> <operator>=</operator> <name>UNIQUE_PATH_SORT</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>semi_can_hash</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>umethod</name></name> <operator>=</operator> <name>UNIQUE_PATH_HASH</name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* we can get here only if we abandoned hashing above */</comment>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>umethod</name></name> <operator>==</operator> <name>UNIQUE_PATH_HASH</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>agg_path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>agg_path</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>sort_path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>sort_path</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>cheapest_unique_path</name></name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_gather_merge_path
 *
 *      Creates a path corresponding to a gather merge scan, returning
 *      the pathnode.
 */</comment>
<function><type><name>GatherMergePath</name> <modifier>*</modifier></type>
<name>create_gather_merge_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
                         <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
                         <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GatherMergePath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>GatherMergePath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Cost</name></type>        <name>input_startup_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Cost</name></type>        <name>input_total_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_GatherMerge</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
                                                          <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/* distribution is the same as in the subpath */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <operator>(</operator><name>Distribution</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <ternary><condition><expr><name>target</name></expr> ?</condition><then> <expr><name>target</name></expr> </then><else>: <expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Subpath is adequately ordered, we won't need to sort it */</comment>
        <expr_stmt><expr><name>input_startup_cost</name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>input_total_cost</name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* We'll need to insert a Sort node, so include cost for that */</comment>
        <decl_stmt><decl><type><name>Path</name></type>        <name>sort_path</name></decl>;</decl_stmt>    <comment type="block">/* dummy for result of cost_sort */</comment>

        <expr_stmt><expr><call><name>cost_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sort_path</name></expr></argument>,
                  <argument><expr><name>root</name></expr></argument>,
                  <argument><expr><name>pathkeys</name></expr></argument>,
                  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
                  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
                  <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
                  <argument><expr><literal type="number">0.0</literal></expr></argument>,
                  <argument><expr><name>work_mem</name></expr></argument>,
                  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>input_startup_cost</name> <operator>+=</operator> <name><name>sort_path</name><operator>.</operator><name>startup_cost</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>input_total_cost</name> <operator>+=</operator> <name><name>sort_path</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>cost_gather_merge</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr></argument>,
                      <argument><expr><name>input_startup_cost</name></expr></argument>, <argument><expr><name>input_total_cost</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * translate_sub_tlist - get subquery column numbers represented by tlist
 *
 * The given targetlist usually contains only Vars referencing the given relid.
 * Extract their varattnos (ie, the column numbers of the subquery) and return
 * as an integer List.
 *
 * If any of the tlist items is not a simple Var, we cannot determine whether
 * the subquery's uniqueness condition (if any) matches ours, so punt and
 * return NIL.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>translate_sub_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>tlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Var</name>           <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>var</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>!=</operator> <name>relid</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* punt */</comment>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_gather_path
 *      Creates a path corresponding to a gather scan, returning the
 *      pathnode.
 *
 * 'rows' may optionally be set to override row estimates from other sources.
 */</comment>
<function><type><name>GatherPath</name> <modifier>*</modifier></type>
<name>create_gather_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
                   <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>rows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GatherPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>GatherPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Gather</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
                                                          <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>    <comment type="block">/* Gather has unordered result */</comment>

    <comment type="block">/* distribution is the same as in the subpath */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <operator>(</operator><name>Distribution</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>single_copy</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>num_workers</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>single_copy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>cost_gather</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr></argument>, <argument><expr><name>rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_subqueryscan_path
 *      Creates a path corresponding to a scan of a subquery,
 *      returning the pathnode.
 */</comment>
<function><type><name>SubqueryScanPath</name> <modifier>*</modifier></type>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<name>create_subqueryscan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
                         <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>,
                         <parameter><decl><type><name>Distribution</name> <modifier>*</modifier></type><name>distribution</name></decl></parameter>)</parameter_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
create_subqueryscan_path<parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
                         <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
    <decl_stmt><decl><type><name>SubqueryScanPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SubqueryScanPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <name>distribution</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_SubqueryScan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
                                                          <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
        <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>cost_subqueryscan</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_functionscan_path
 *      Creates a path corresponding to a sequential scan of a function,
 *      returning the pathnode.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_functionscan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                         <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>=</operator> <name>T_FunctionScan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
                                                     <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>cost_functionscan</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_tablefuncscan_path
 *      Creates a path corresponding to a sequential scan of a table function,
 *      returning the pathnode.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_tablefuncscan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                          <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>=</operator> <name>T_TableFuncScan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
                                                     <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>    <comment type="block">/* result is always unordered */</comment>

    <expr_stmt><expr><call><name>cost_tablefuncscan</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_valuesscan_path
 *      Creates a path corresponding to a scan of a VALUES list,
 *      returning the pathnode.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_valuesscan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                       <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>=</operator> <name>T_ValuesScan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
                                                     <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>    <comment type="block">/* result is always unordered */</comment>

    <expr_stmt><expr><call><name>cost_valuesscan</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_ctescan_path
 *      Creates a path corresponding to a scan of a non-self-reference CTE,
 *      returning the pathnode.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_ctescan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>=</operator> <name>T_CteScan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
                                                     <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>    <comment type="block">/* XXX for now, result is always unordered */</comment>

    <expr_stmt><expr><call><name>cost_ctescan</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_namedtuplestorescan_path
 *      Creates a path corresponding to a scan of a named tuplestore, returning
 *      the pathnode.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_namedtuplestorescan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                                <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>=</operator> <name>T_NamedTuplestoreScan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
                                                     <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>    <comment type="block">/* result is always unordered */</comment>

    <expr_stmt><expr><call><name>cost_namedtuplestorescan</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_worktablescan_path
 *      Creates a path corresponding to a scan of a self-reference CTE,
 *      returning the pathnode.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_worktablescan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                          <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>=</operator> <name>T_WorkTableScan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
                                                     <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>    <comment type="block">/* result is always unordered */</comment>

    <comment type="block">/* Cost is the same as for a regular CTE scan */</comment>
    <expr_stmt><expr><call><name>cost_ctescan</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>param_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_foreignscan_path
 *      Creates a path corresponding to a scan of a foreign table, foreign join,
 *      or foreign upper-relation processing, returning the pathnode.
 *
 * This function is never called from core Postgres; rather, it's expected
 * to be called by the GetForeignPaths, GetForeignJoinPaths, or
 * GetForeignUpperPaths function of a foreign data wrapper.  We make the FDW
 * supply all fields of the path, since we do not have any way to calculate
 * them in core.  However, there is a usually-sane default for the pathtarget
 * (rel-&gt;reltarget), so we let a NULL for "target" select that.
 */</comment>
<function><type><name>ForeignPath</name> <modifier>*</modifier></type>
<name>create_foreignscan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                        <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
                        <parameter><decl><type><name>double</name></type> <name>rows</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>startup_cost</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name>total_cost</name></decl></parameter>,
                        <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
                        <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>,
                        <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>fdw_outerpath</name></decl></parameter>,
                        <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>fdw_private</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ForeignPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ForeignPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_ForeignScan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <ternary><condition><expr><name>target</name></expr> ?</condition><then> <expr><name>target</name></expr> </then><else>: <expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
                                                          <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name>rows</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name>startup_cost</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name>total_cost</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>fdw_outerpath</name></name> <operator>=</operator> <name>fdw_outerpath</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>fdw_private</name></name> <operator>=</operator> <name>fdw_private</name></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * calc_nestloop_required_outer
 *      Compute the required_outer set for a nestloop join path
 *
 * Note: result must not share storage with either input
 */</comment>
<function><type><name>Relids</name></type>
<name>calc_nestloop_required_outer</name><parameter_list>(<parameter><decl><type><name>Relids</name></type> <name>outerrelids</name></decl></parameter>,
							 <parameter><decl><type><name>Relids</name></type> <name>outer_paramrels</name></decl></parameter>,
							 <parameter><decl><type><name>Relids</name></type> <name>innerrelids</name></decl></parameter>,
							 <parameter><decl><type><name>Relids</name></type> <name>inner_paramrels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relids</name></type>        <name>required_outer</name></decl>;</decl_stmt>

    <comment type="block">/* inner_path can require rels from outer path, but not vice versa */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>outer_paramrels</name></expr></argument>, <argument><expr><name>innerrelids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* easy case if inner path is not parameterized */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>inner_paramrels</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>bms_copy</name><argument_list>(<argument><expr><name>outer_paramrels</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* else, form the union ... */</comment>
    <expr_stmt><expr><name>required_outer</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>outer_paramrels</name></expr></argument>, <argument><expr><name>inner_paramrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* ... and remove any mention of now-satisfied outer rels */</comment>
    <expr_stmt><expr><name>required_outer</name> <operator>=</operator> <call><name>bms_del_members</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>,
									 <argument><expr><name>outerrelids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* maintain invariant that required_outer is exactly NULL if empty */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>required_outer</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>required_outer</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * calc_non_nestloop_required_outer
 *      Compute the required_outer set for a merge or hash join path
 *
 * Note: result must not share storage with either input
 */</comment>
<function><type><name>Relids</name></type>
<name>calc_non_nestloop_required_outer</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>outer_path</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relids</name></type>        <name>outer_paramrels</name> <init>= <expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>outer_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relids</name></type>        <name>inner_paramrels</name> <init>= <expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>inner_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relids</name></type>        <name>required_outer</name></decl>;</decl_stmt>

    <comment type="block">/* neither path can require rels from the other */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>outer_paramrels</name></expr></argument>, <argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><name>inner_paramrels</name></expr></argument>, <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* form the union ... */</comment>
    <expr_stmt><expr><name>required_outer</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>outer_paramrels</name></expr></argument>, <argument><expr><name>inner_paramrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* we do not need an explicit test for empty; bms_union gets it right */</comment>
    <return>return <expr><name>required_outer</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_nestloop_path
 *      Creates a pathnode corresponding to a nestloop join between two
 *      relations.
 *
 * 'joinrel' is the join relation.
 * 'jointype' is the type of join required
 * 'workspace' is the result from initial_cost_nestloop
 * 'extra' contains various information about the join
 * 'outer_path' is the outer path
 * 'inner_path' is the inner path
 * 'restrict_clauses' are the RestrictInfo nodes to apply at the join
 * 'pathkeys' are the path keys of the new join path
 * 'required_outer' is the set of required outer rels
 *
 * Returns the resulting path node.
 */</comment>
<function><type><name>NestPath</name> <modifier>*</modifier></type>
<name>create_nestloop_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                     <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
                     <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
                     <parameter><decl><type><name>JoinCostWorkspace</name> <modifier>*</modifier></type><name>workspace</name></decl></parameter>,
                     <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>,
                     <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>outer_path</name></decl></parameter>,
                     <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_path</name></decl></parameter>,
                     <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrict_clauses</name></decl></parameter>,
                     <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
                     <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>NestPath</name>   <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>NestPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>alternate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>mclauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>Relids</name></type>        <name>inner_req_outer</name> <init>= <expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>inner_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * If the inner path is parameterized by the outer, we must drop any
     * restrict_clauses that are due to be moved into the inner path.  We have
     * to do this now, rather than postpone the work till createplan time,
     * because the restrict_clauses list can affect the size and cost
     * estimates for this path.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>inner_req_outer</name></expr></argument>, <argument><expr><name><name>outer_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Relids</name></type>        <name>inner_and_outer</name> <init>= <expr><call><name>bms_union</name><argument_list>(<argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
                                                <argument><expr><name>inner_req_outer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>jclauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>restrict_clauses</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>join_clause_is_movable_into</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>,
                                             <argument><expr><name><name>inner_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
                                             <argument><expr><name>inner_and_outer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>jclauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>jclauses</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>mclauses</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>mclauses</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block>
        <expr_stmt><expr><name>restrict_clauses</name> <operator>=</operator> <name>jclauses</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_NestLoop</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>joinrel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>joinrel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator>
        <call><name>get_joinrel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                  <argument><expr><name>joinrel</name></expr></argument>,
                                  <argument><expr><name>outer_path</name></expr></argument>,
                                  <argument><expr><name>inner_path</name></expr></argument>,
                                  <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>sjinfo</name></name></expr></argument>,
                                  <argument><expr><name>required_outer</name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>restrict_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>joinrel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
        <name><name>outer_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&amp;&amp;</operator> <name><name>inner_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
    <comment type="block">/* This is a foolish way to estimate parallel_workers, but for now... */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>jointype</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>inner_unique</name></name> <operator>=</operator> <name><name>extra</name><operator>-&gt;</operator><name>inner_unique</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>outerjoinpath</name></name> <operator>=</operator> <name>outer_path</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>innerjoinpath</name></name> <operator>=</operator> <name>inner_path</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>joinrestrictinfo</name></name> <operator>=</operator> <name>restrict_clauses</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <ternary><condition><expr><name><name>outer_path</name><operator>-&gt;</operator><name>parallel_workers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>movedrestrictinfo</name></name> <operator>=</operator> <name>mclauses</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>alternate</name> <operator>=</operator> <call><name>set_joinpath_distribution</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>pathnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<comment type="block">/*
	 * Since set_joinpath_distribution() could add additional pathnode such as
	 * RemoteSubplan, the result of initial_cost_nestloop() needs to be
	 * recalculated.
	 */</comment>
	<expr_stmt><expr><call><name>initial_cost_nestloop</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>,
						  <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>outerjoinpath</name></name></expr></argument>,
						  <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>innerjoinpath</name></name></expr></argument>,
						  <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>final_cost_nestloop</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <comment type="block">/*
     * Also calculate costs of all alternates and return cheapest path
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>alternate</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>NestPath</name> <modifier>*</modifier></type><name>altpath</name> <init>= <expr><operator>(</operator><name>NestPath</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<comment type="block">/*
		 * Recalculate the initial cost of alternate path
		 */</comment>
		<expr_stmt><expr><call><name>initial_cost_nestloop</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>,
							  <argument><expr><name><name>altpath</name><operator>-&gt;</operator><name>outerjoinpath</name></name></expr></argument>,
							  <argument><expr><name><name>altpath</name><operator>-&gt;</operator><name>innerjoinpath</name></name></expr></argument>,
							  <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>final_cost_nestloop</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>altpath</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>altpath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>&lt;</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>pathnode</name> <operator>=</operator> <name>altpath</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* For DELETE, check if the path distribution satisfy resultRel distribution */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SatisfyResultRelDist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_mergejoin_path
 *      Creates a pathnode corresponding to a mergejoin join between
 *      two relations
 *
 * 'joinrel' is the join relation
 * 'jointype' is the type of join required
 * 'workspace' is the result from initial_cost_mergejoin
 * 'extra' contains various information about the join
 * 'outer_path' is the outer path
 * 'inner_path' is the inner path
 * 'restrict_clauses' are the RestrictInfo nodes to apply at the join
 * 'pathkeys' are the path keys of the new join path
 * 'required_outer' is the set of required outer rels
 * 'mergeclauses' are the RestrictInfo nodes to use as merge clauses
 *        (this should be a subset of the restrict_clauses list)
 * 'outersortkeys' are the sort varkeys for the outer relation
 * 'innersortkeys' are the sort varkeys for the inner relation
 */</comment>
<function><type><name>MergePath</name> <modifier>*</modifier></type>
<name>create_mergejoin_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                      <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
                      <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
                      <parameter><decl><type><name>JoinCostWorkspace</name> <modifier>*</modifier></type><name>workspace</name></decl></parameter>,
                      <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>,
                      <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>outer_path</name></decl></parameter>,
                      <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_path</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrict_clauses</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
                      <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeclauses</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>outersortkeys</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>innersortkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MergePath</name>  <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>MergePath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>alternate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_MergeJoin</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>joinrel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>joinrel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator>
        <call><name>get_joinrel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                  <argument><expr><name>joinrel</name></expr></argument>,
                                  <argument><expr><name>outer_path</name></expr></argument>,
                                  <argument><expr><name>inner_path</name></expr></argument>,
                                  <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>sjinfo</name></name></expr></argument>,
                                  <argument><expr><name>required_outer</name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>restrict_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>joinrel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
        <name><name>outer_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&amp;&amp;</operator> <name><name>inner_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
    <comment type="block">/* This is a foolish way to estimate parallel_workers, but for now... */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>jointype</name></name> <operator>=</operator> <name>jointype</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>inner_unique</name></name> <operator>=</operator> <name><name>extra</name><operator>-&gt;</operator><name>inner_unique</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name></name> <operator>=</operator> <name>outer_path</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name></name> <operator>=</operator> <name>inner_path</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>joinrestrictinfo</name></name> <operator>=</operator> <name>restrict_clauses</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path_mergeclauses</name></name> <operator>=</operator> <name>mergeclauses</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>outersortkeys</name></name> <operator>=</operator> <name>outersortkeys</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>innersortkeys</name></name> <operator>=</operator> <name>innersortkeys</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <ternary><condition><expr><name><name>outer_path</name><operator>-&gt;</operator><name>parallel_workers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <expr_stmt><expr><name>alternate</name> <operator>=</operator> <call><name>set_joinpath_distribution</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>JoinPath</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* pathnode-&gt;skip_mark_restore will be set by final_cost_mergejoin */</comment>
    <comment type="block">/* pathnode-&gt;materialize_inner will be set by final_cost_mergejoin */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<comment type="block">/*
	 * Since set_joinpath_distribution() could add additional pathnode such as
	 * RemoteSubplan, the result of initial_cost_mergejoin() needs to be
	 * recalculated.
	 */</comment>
	<expr_stmt><expr><call><name>initial_cost_mergejoin</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>mergeclauses</name></expr></argument>,
						   <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name></name></expr></argument>,
						   <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name></name></expr></argument>,
						   <argument><expr><name>outersortkeys</name></expr></argument>, <argument><expr><name>innersortkeys</name></expr></argument>,
						   <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>final_cost_mergejoin</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <comment type="block">/*
     * Also calculate costs of all alternates and return cheapest path
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>alternate</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MergePath</name> <modifier>*</modifier></type><name>altpath</name> <init>= <expr><operator>(</operator><name>MergePath</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<comment type="block">/*
		 * Recalculate the initial cost of alternate path
		 */</comment>
		<expr_stmt><expr><call><name>initial_cost_mergejoin</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>mergeclauses</name></expr></argument>,
							   <argument><expr><name><name>altpath</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name></name></expr></argument>,
							   <argument><expr><name><name>altpath</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name></name></expr></argument>,
							   <argument><expr><name>outersortkeys</name></expr></argument>, <argument><expr><name>innersortkeys</name></expr></argument>,
							   <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>final_cost_mergejoin</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>altpath</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>altpath</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>&lt;</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>total_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>pathnode</name> <operator>=</operator> <name>altpath</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* For DELETE, check if the path distribution satisfy resultRel distribution */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SatisfyResultRelDist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_hashjoin_path
 *      Creates a pathnode corresponding to a hash join between two relations.
 *
 * 'joinrel' is the join relation
 * 'jointype' is the type of join required
 * 'workspace' is the result from initial_cost_hashjoin
 * 'extra' contains various information about the join
 * 'outer_path' is the cheapest outer path
 * 'inner_path' is the cheapest inner path
 * 'restrict_clauses' are the RestrictInfo nodes to apply at the join
 * 'required_outer' is the set of required outer rels
 * 'hashclauses' are the RestrictInfo nodes to use as hash clauses
 *        (this should be a subset of the restrict_clauses list)
 */</comment>
<function><type><name>HashPath</name> <modifier>*</modifier></type>
<name>create_hashjoin_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                     <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>joinrel</name></decl></parameter>,
                     <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
                     <parameter><decl><type><name>JoinCostWorkspace</name> <modifier>*</modifier></type><name>workspace</name></decl></parameter>,
                     <parameter><decl><type><name>JoinPathExtraData</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>,
                     <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>outer_path</name></decl></parameter>,
                     <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>inner_path</name></decl></parameter>,
                     <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrict_clauses</name></decl></parameter>,
                     <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>,
                     <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashclauses</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>HashPath</name>   <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>HashPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>alternate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_HashJoin</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>joinrel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>joinrel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator>
        <call><name>get_joinrel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                  <argument><expr><name>joinrel</name></expr></argument>,
                                  <argument><expr><name>outer_path</name></expr></argument>,
                                  <argument><expr><name>inner_path</name></expr></argument>,
                                  <argument><expr><name><name>extra</name><operator>-&gt;</operator><name>sjinfo</name></name></expr></argument>,
                                  <argument><expr><name>required_outer</name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>restrict_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>olap_optimizer</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>joinrel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
        <name><name>outer_path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&amp;&amp;</operator> <name><name>inner_path</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
    <comment type="block">/* This is a foolish way to estimate parallel_workers, but for now... */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>outer_path</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * A hashjoin never has pathkeys, since its output ordering is
     * unpredictable due to possible batching.  XXX If the inner relation is
     * small enough, we could instruct the executor that it must not batch,
     * and then we could assume that the output inherits the outer relation's
     * ordering, which might save a sort step.  However there is considerable
     * downside if our estimate of the inner relation size is badly off. For
     * the moment we don't risk it.  (Note also that if we wanted to take this
     * seriously, joinpath.c would have to consider many more paths for the
     * outer rel than it does now.)
     */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>jointype</name></name> <operator>=</operator> <name>jointype</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>inner_unique</name></name> <operator>=</operator> <name><name>extra</name><operator>-&gt;</operator><name>inner_unique</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name></name> <operator>=</operator> <name>outer_path</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name></name> <operator>=</operator> <name>inner_path</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>joinrestrictinfo</name></name> <operator>=</operator> <name>restrict_clauses</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path_hashclauses</name></name> <operator>=</operator> <name>hashclauses</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <expr_stmt><expr><name>alternate</name> <operator>=</operator> <call><name>set_joinpath_distribution</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>JoinPath</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<comment type="block">/*
	 * Since set_joinpath_distribution() could add additional pathnode such as
	 * RemoteSubplan, the result of initial_cost_hashjoin() needs to be
	 * recalculated.
	 */</comment>
	<expr_stmt><expr><call><name>initial_cost_hashjoin</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
						  <argument><expr><name>workspace</name></expr></argument>,
						  <argument><expr><name>jointype</name></expr></argument>,
						  <argument><expr><name>hashclauses</name></expr></argument>,
						  <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name></name></expr></argument>,
						  <argument><expr><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name></name></expr></argument>,
						  <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* final_cost_hashjoin will fill in pathnode-&gt;num_batches */</comment>
    <expr_stmt><expr><call><name>final_cost_hashjoin</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <comment type="block">/*
     * Calculate costs of all alternates and return cheapest path
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>alternate</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HashPath</name> <modifier>*</modifier></type><name>altpath</name> <init>= <expr><operator>(</operator><name>HashPath</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<comment type="block">/*
		 * Recalculate the initial cost of alternate path
		 */</comment>
		<expr_stmt><expr><call><name>initial_cost_hashjoin</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
							  <argument><expr><name>workspace</name></expr></argument>,
							  <argument><expr><name>jointype</name></expr></argument>,
							  <argument><expr><name>hashclauses</name></expr></argument>,
							  <argument><expr><name><name>altpath</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>outerjoinpath</name></name></expr></argument>,
							  <argument><expr><name><name>altpath</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>innerjoinpath</name></name></expr></argument>,
							  <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>final_cost_hashjoin</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>altpath</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>altpath</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>&lt;</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name><operator>.</operator><name>total_cost</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>pathnode</name> <operator>=</operator> <name>altpath</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* For DELETE, check if the path distribution satisfy resultRel distribution */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SatisfyResultRelDist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>jpath</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_projection_path
 *      Creates a pathnode that represents performing a projection.
 *
 * 'rel' is the parent relation associated with the result
 * 'subpath' is the path representing the source of data
 * 'target' is the PathTarget to be computed
 */</comment>
<function><type><name>ProjectionPath</name> <modifier>*</modifier></type>
<name>create_projection_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                       <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                       <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
                       <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ProjectionPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ProjectionPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>oldtarget</name> <init>= <expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Result</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
    <comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
        <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&amp;&amp;</operator>
        <call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
    <comment type="block">/* Projection does not change the sort order */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <operator>(</operator><name>Distribution</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>

    <comment type="block">/*
     * We might not need a separate Result node.  If the input plan node type
     * can project, we can just tell it to project something else.  Or, if it
     * can't project but the desired target has the same expression list as
     * what the input will produce anyway, we can still give it the desired
     * tlist (possibly changing its ressortgroupref labels, but nothing else).
     * Note: in the latter case, create_projection_plan has to recheck our
     * conclusion; see comments therein.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>is_projection_capable_path</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>equal</name><argument_list>(<argument><expr><name><name>oldtarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* No separate Result node needed */</comment>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>dummypp</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Set cost of plan as subpath's cost, adjusted for tlist replacement.
         */</comment>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+</operator>
            <operator>(</operator><name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>-</operator> <name><name>oldtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+</operator>
            <operator>(</operator><name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>-</operator> <name><name>oldtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name><operator>)</operator> <operator>+</operator>
            <operator>(</operator><name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>-</operator> <name><name>oldtarget</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name><operator>)</operator> <operator>*</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* We really do need the Result node */</comment>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>dummypp</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <comment type="block">/*
         * The Result node's cost is cpu_tuple_cost per row, plus the cost of
         * evaluating the tlist.  There is no qual to worry about.
         */</comment>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+</operator>
            <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+</operator>
            <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator>
            <operator>(</operator><name>cpu_tuple_cost</name> <operator>+</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name><operator>)</operator> <operator>*</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * apply_projection_to_path
 *      Add a projection step, or just apply the target directly to given path.
 *
 * This has the same net effect as create_projection_path(), except that if
 * a separate Result plan node isn't needed, we just replace the given path's
 * pathtarget with the desired one.  This must be used only when the caller
 * knows that the given path isn't referenced elsewhere and so can be modified
 * in-place.
 *
 * If the input path is a GatherPath, we try to push the new target down to
 * its input as well; this is a yet more invasive modification of the input
 * path, which create_projection_path() can't do.
 *
 * Note that we mustn't change the source path's parent link; so when it is
 * add_path'd to "rel" things will be a bit inconsistent.  So far that has
 * not caused any trouble.
 *
 * 'rel' is the parent relation associated with the result
 * 'path' is the path representing the source of data
 * 'target' is the PathTarget to be computed
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>apply_projection_to_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                         <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                         <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
                         <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>QualCost</name></type>    <name>oldcost</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If given path can't project, we might need a Result node, so make a
     * separate ProjectionPath.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_projection_capable_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_projection_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We can just jam the desired tlist into the existing path, being sure to
     * update its cost estimates appropriately.
     */</comment>
    <expr_stmt><expr><name>oldcost</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>cost</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>-</operator> <name><name>oldcost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>-</operator> <name><name>oldcost</name><operator>.</operator><name>startup</name></name> <operator>+</operator>
        <operator>(</operator><name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>-</operator> <name><name>oldcost</name><operator>.</operator><name>per_tuple</name></name><operator>)</operator> <operator>*</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * If the path happens to be a Gather path, we'd like to arrange for the
     * subpath to return the required target list so that workers can help
     * project.  But if there is something that is not parallel-safe in the
     * target expressions, then we can't.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>GatherPath</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GatherPath</name> <modifier>*</modifier></type><name>gpath</name> <init>= <expr><operator>(</operator><name>GatherPath</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * We always use create_projection_path here, even if the subpath is
         * projection-capable, so as to avoid modifying the subpath in place.
         * It seems unlikely at present that there could be any other
         * references to the subpath, but better safe than sorry.
         *
         * Note that we don't change the GatherPath's cost estimates; it might
         * be appropriate to do so, to reflect the fact that the bulk of the
         * target evaluation will happen in workers.
         */</comment>
        <expr_stmt><expr><name><name>gpath</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator>
            <call><name>create_projection_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                   <argument><expr><name><name>gpath</name><operator>-&gt;</operator><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>,
                                   <argument><expr><name><name>gpath</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>,
                                   <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&amp;&amp;</operator>
             <operator>!</operator><call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We're inserting a parallel-restricted target list into a path
         * currently marked parallel-safe, so we have to mark it as no longer
         * safe.
         */</comment>
        <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>path</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_set_projection_path
 *      Creates a pathnode that represents performing a projection that
 *      includes set-returning functions.
 *
 * 'rel' is the parent relation associated with the result
 * 'subpath' is the path representing the source of data
 * 'target' is the PathTarget to be computed
 */</comment>
<function><type><name>ProjectSetPath</name> <modifier>*</modifier></type>
<name>create_set_projection_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                           <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                           <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
                           <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ProjectSetPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ProjectSetPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>tlist_rows</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_ProjectSet</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
    <comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
        <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&amp;&amp;</operator>
        <call><name>is_parallel_safe</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
    <comment type="block">/* Projection does not change the sort order XXX? */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>

    <comment type="block">/* distribution is the same as in the subpath */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Estimate number of rows produced by SRFs for each row of input; if
     * there's more than one in this node, use the maximum.
     */</comment>
    <expr_stmt><expr><name>tlist_rows</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>target-&gt;exprs</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type>        <name>itemrows</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>itemrows</name> <operator>=</operator> <call><name>expression_returns_set_rows</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>tlist_rows</name> <operator>&lt;</operator> <name>itemrows</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>tlist_rows</name> <operator>=</operator> <name>itemrows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * In addition to the cost of evaluating the tlist, charge cpu_tuple_cost
     * per input row, and half of cpu_tuple_cost for each added output row.
     * This is slightly bizarre maybe, but it's what 9.6 did; we may revisit
     * this estimate later.
     */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name>tlist_rows</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name> <operator>+</operator>
        <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+</operator>
        <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator>
        <operator>(</operator><name>cpu_tuple_cost</name> <operator>+</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name><operator>)</operator> <operator>*</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name> <operator>+</operator>
        <operator>(</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>-</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name><operator>)</operator> <operator>*</operator> <name>cpu_tuple_cost</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_sort_path
 *      Creates a pathnode that represents performing an explicit sort.
 *
 * 'rel' is the parent relation associated with the result
 * 'subpath' is the path representing the source of data
 * 'pathkeys' represents the desired sort order
 * 'limit_tuples' is the estimated bound on the number of output tuples,
 *        or -1 if no LIMIT or couldn't estimate
 */</comment>
<function><type><name>SortPath</name> <modifier>*</modifier></type>
<name>create_sort_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                 <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
                 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
                 <parameter><decl><type><name>double</name></type> <name>limit_tuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SortPath</name>   <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SortPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Sort</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <comment type="block">/* Sort doesn't project, so use source path's pathtarget */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr>;</expr_stmt>
    <comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
        <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>

    <comment type="block">/* distribution is the same as in the subpath */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>cost_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>pathkeys</name></expr></argument>,
              <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
              <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
              <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
              <argument><expr><literal type="number">0.0</literal></expr></argument>,                <comment type="block">/* XXX comparison_cost shouldn't be 0? */</comment>
              <argument><expr><name>work_mem</name></expr></argument>, <argument><expr><name>limit_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_group_path
 *      Creates a pathnode that represents performing grouping of presorted input
 *
 * 'rel' is the parent relation associated with the result
 * 'subpath' is the path representing the source of data
 * 'target' is the PathTarget to be computed
 * 'groupClause' is a list of SortGroupClause's representing the grouping
 * 'qual' is the HAVING quals if any
 * 'numGroups' is the estimated number of groups
 */</comment>
<function><type><name>GroupPath</name> <modifier>*</modifier></type>
<name>create_group_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
                  <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
                  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>,
                  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>,
                  <parameter><decl><type><name>double</name></type> <name>numGroups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GroupPath</name>  <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>GroupPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Group</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
    <comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
        <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
    <comment type="block">/* Group doesn't change sort ordering */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>

    <comment type="block">/* distribution is the same as in the subpath */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <operator>(</operator><name>Distribution</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <name>groupClause</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qual</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>cost_group</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
               <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><name>numGroups</name></expr></argument>,
               <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
               <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* add tlist eval cost for each output row */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>+=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator>
        <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_upper_unique_path
 *      Creates a pathnode that represents performing an explicit Unique step
 *      on presorted input.
 *
 * This produces a Unique plan node, but the use-case is so different from
 * create_unique_path that it doesn't seem worth trying to merge the two.
 *
 * 'rel' is the parent relation associated with the result
 * 'subpath' is the path representing the source of data
 * 'numCols' is the number of grouping columns
 * 'numGroups' is the estimated number of groups
 *
 * The input path must be sorted on the grouping columns, plus possibly
 * additional columns; so the first numCols pathkeys are the grouping columns
 */</comment>
<function><type><name>UpperUniquePath</name> <modifier>*</modifier></type>
<name>create_upper_unique_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                         <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                         <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
                         <parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>,
                         <parameter><decl><type><name>double</name></type> <name>numGroups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>UpperUniquePath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>UpperUniquePath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Unique</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <comment type="block">/* Unique doesn't project, so use source path's pathtarget */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr>;</expr_stmt>
    <comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
        <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
    <comment type="block">/* Unique doesn't change the input ordering */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <operator>(</operator><name>Distribution</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>numkeys</name></name> <operator>=</operator> <name>numCols</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Charge one cpu_operator_cost per comparison per input tuple. We assume
     * all columns get compared at most of the tuples.  (XXX probably this is
     * an overestimate.)
     */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+</operator>
        <name>cpu_operator_cost</name> <operator>*</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name>numCols</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name>numGroups</name></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_agg_path
 *      Creates a pathnode that represents performing aggregation/grouping
 *
 * 'rel' is the parent relation associated with the result
 * 'subpath' is the path representing the source of data
 * 'target' is the PathTarget to be computed
 * 'aggstrategy' is the Agg node's basic implementation strategy
 * 'aggsplit' is the Agg node's aggregate-splitting mode
 * 'groupClause' is a list of SortGroupClause's representing the grouping
 * 'qual' is the HAVING quals if any
 * 'aggcosts' contains cost info about the aggregate functions to be computed
 * 'numGroups' is the estimated number of groups (1 if not grouping)
 */</comment>
<function><type><name>AggPath</name> <modifier>*</modifier></type>
<name>create_agg_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
                <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
                <parameter><decl><type><name>AggStrategy</name></type> <name>aggstrategy</name></decl></parameter>,
                <parameter><decl><type><name>AggSplit</name></type> <name>aggsplit</name></decl></parameter>,
                <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>,
                <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>,
                <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>aggcosts</name></decl></parameter>,
                <parameter><decl><type><name>double</name></type> <name>numGroups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>AggPath</name>    <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AggPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Agg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
    <comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
        <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>aggstrategy</name> <operator>==</operator> <name>AGG_SORTED</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* preserves order */</comment>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>    <comment type="block">/* output is unordered */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>

    <comment type="block">/* distribution is the same as in the subpath */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <operator>(</operator><name>Distribution</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>=</operator> <name>aggstrategy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>aggsplit</name></name> <operator>=</operator> <name>aggsplit</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <name>numGroups</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <name>groupClause</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>qual</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>hybrid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>entrySize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>cost_agg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
             <argument><expr><name>aggstrategy</name></expr></argument>, <argument><expr><name>aggcosts</name></expr></argument>,
             <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>numGroups</name></expr></argument>,
             <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
             <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* add tlist eval cost for each output row */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>+=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator>
        <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<comment type="block">/* estimate entry size for hashtable used by hashagg */</comment>
	<if_stmt><if>if <condition>(<expr><name>g_hybrid_hash_agg</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>aggstrategy</name> <operator>==</operator> <name>AGG_HASHED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>entrySize</name></name> <operator>=</operator> <call><name>estimate_hashagg_entrysize</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>aggcosts</name></expr></argument>, <argument><expr><name>numGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_groupingsets_path
 *      Creates a pathnode that represents performing GROUPING SETS aggregation
 *
 * GroupingSetsPath represents sorted grouping with one or more grouping sets.
 * The input path's result must be sorted to match the last entry in
 * rollup_groupclauses.
 *
 * 'rel' is the parent relation associated with the result
 * 'subpath' is the path representing the source of data
 * 'target' is the PathTarget to be computed
 * 'having_qual' is the HAVING quals if any
 * 'rollups' is a list of RollupData nodes
 * 'agg_costs' contains cost info about the aggregate functions to be computed
 * 'numGroups' is the estimated total number of groups
 */</comment>
<function><type><name>GroupingSetsPath</name> <modifier>*</modifier></type>
<name>create_groupingsets_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                         <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                         <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
                         <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
                         <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>having_qual</name></decl></parameter>,
                         <parameter><decl><type><name>AggStrategy</name></type> <name>aggstrategy</name></decl></parameter>,
                         <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rollups</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
                         <parameter><decl><type><name>double</name></type> <name>numGroups</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>GroupingSetsPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>GroupingSetsPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_first_sort</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* The topmost generated Plan node will be an Agg */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Agg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>param_info</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
        <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>

    <comment type="block">/* distribution is the same as in the subpath */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <operator>(</operator><name>Distribution</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Simplify callers by downgrading AGG_SORTED to AGG_PLAIN, and AGG_MIXED
     * to AGG_HASHED, here if possible.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>aggstrategy</name> <operator>==</operator> <name>AGG_SORTED</name> <operator>&amp;&amp;</operator>
        <call><name>list_length</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
        <operator>(</operator><operator>(</operator><name>RollupData</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>groupClause</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>aggstrategy</name> <operator>=</operator> <name>AGG_PLAIN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>aggstrategy</name> <operator>==</operator> <name>AGG_MIXED</name> <operator>&amp;&amp;</operator>
        <call><name>list_length</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>aggstrategy</name> <operator>=</operator> <name>AGG_HASHED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Output will be in sorted order by group_pathkeys if, and only if, there
     * is a single rollup operation on a non-empty list of grouping
     * expressions.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>aggstrategy</name> <operator>==</operator> <name>AGG_SORTED</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>=</operator> <name>aggstrategy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>rollups</name></name> <operator>=</operator> <name>rollups</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>having_qual</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rollups</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>aggstrategy</name> <operator>!=</operator> <name>AGG_PLAIN</name> <operator>||</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>aggstrategy</name> <operator>!=</operator> <name>AGG_MIXED</name> <operator>||</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rollups</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>gsets</name> <init>= <expr><name><name>rollup</name><operator>-&gt;</operator><name>gsets</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>numGroupCols</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>gsets</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * In AGG_SORTED or AGG_PLAIN mode, the first rollup takes the
         * (already-sorted) input, and following ones do their own sort.
         *
         * In AGG_HASHED mode, there is one rollup for each grouping set.
         *
         * In AGG_MIXED mode, the first rollups are hashed, the first
         * non-hashed one takes the (already-sorted) input, and following ones
         * do their own sort.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>is_first</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>cost_agg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
                     <argument><expr><name>aggstrategy</name></expr></argument>,
                     <argument><expr><name>agg_costs</name></expr></argument>,
                     <argument><expr><name>numGroupCols</name></expr></argument>,
                     <argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name></expr></argument>,
                     <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>,
                     <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
                     <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>is_first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rollup</name><operator>-&gt;</operator><name>is_hashed</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>is_first_sort</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>Path</name></type>        <name>sort_path</name></decl>;</decl_stmt>    <comment type="block">/* dummy for result of cost_sort */</comment>
            <decl_stmt><decl><type><name>Path</name></type>        <name>agg_path</name></decl>;</decl_stmt>    <comment type="block">/* dummy for result of cost_agg */</comment>

            <if_stmt><if>if <condition>(<expr><name><name>rollup</name><operator>-&gt;</operator><name>is_hashed</name></name> <operator>||</operator> <name>is_first_sort</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Account for cost of aggregation, but don't charge input
                 * cost again
                 */</comment>
                <expr_stmt><expr><call><name>cost_agg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agg_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
                         <argument><expr><ternary><condition><expr><name><name>rollup</name><operator>-&gt;</operator><name>is_hashed</name></name></expr> ?</condition><then> <expr><name>AGG_HASHED</name></expr> </then><else>: <expr><name>AGG_SORTED</name></expr></else></ternary></expr></argument>,
                         <argument><expr><name>agg_costs</name></expr></argument>,
                         <argument><expr><name>numGroupCols</name></expr></argument>,
                         <argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name></expr></argument>,
                         <argument><expr><literal type="number">0.0</literal></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>,
                         <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rollup</name><operator>-&gt;</operator><name>is_hashed</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>is_first_sort</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* Account for cost of sort, but don't charge input cost again */</comment>
                <expr_stmt><expr><call><name>cost_sort</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sort_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
                          <argument><expr><literal type="number">0.0</literal></expr></argument>,
                          <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>,
                          <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>,
                          <argument><expr><literal type="number">0.0</literal></expr></argument>,
                          <argument><expr><name>work_mem</name></expr></argument>,
                          <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Account for cost of aggregation */</comment>

                <expr_stmt><expr><call><name>cost_agg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agg_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
                         <argument><expr><name>AGG_SORTED</name></expr></argument>,
                         <argument><expr><name>agg_costs</name></expr></argument>,
                         <argument><expr><name>numGroupCols</name></expr></argument>,
                         <argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>numGroups</name></name></expr></argument>,
                         <argument><expr><name><name>sort_path</name><operator>.</operator><name>startup_cost</name></name></expr></argument>,
                         <argument><expr><name><name>sort_path</name><operator>.</operator><name>total_cost</name></name></expr></argument>,
                         <argument><expr><name><name>sort_path</name><operator>.</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name><name>agg_path</name><operator>.</operator><name>total_cost</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>+=</operator> <name><name>agg_path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>g_hybrid_hash_agg</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>rollup</name><operator>-&gt;</operator><name>is_hashed</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>rollup</name><operator>-&gt;</operator><name>entrySize</name></name> <operator>=</operator> <call><name>estimate_hashagg_entrysize</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>agg_costs</name></expr></argument>, <argument><expr><name>numGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block>

    <comment type="block">/* add tlist eval cost for each output row */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>+=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator>
        <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_minmaxagg_path
 *      Creates a pathnode that represents computation of MIN/MAX aggregates
 *
 * 'rel' is the parent relation associated with the result
 * 'target' is the PathTarget to be computed
 * 'mmaggregates' is a list of MinMaxAggInfo structs
 * 'quals' is the HAVING quals if any
 */</comment>
<function><type><name>MinMaxAggPath</name> <modifier>*</modifier></type>
<name>create_minmaxagg_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                      <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                      <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>mmaggregates</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MinMaxAggPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>MinMaxAggPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Cost</name></type>        <name>initplan_cost</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* The topmost generated Plan node will be a Result */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Result</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
    <comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <comment type="block">/* A MinMaxAggPath implies use of subplans, so cannot be parallel-safe */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <comment type="block">/* Result is one unordered row */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>mmaggregates</name></name> <operator>=</operator> <name>mmaggregates</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>quals</name></expr>;</expr_stmt>

    <comment type="block">/* Calculate cost of all the initplans ... */</comment>
    <expr_stmt><expr><name>initplan_cost</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>mmaggregates</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MinMaxAggInfo</name> <modifier>*</modifier></type><name>mminfo</name> <init>= <expr><operator>(</operator><name>MinMaxAggInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>initplan_cost</name> <operator>+=</operator> <name><name>mminfo</name><operator>-&gt;</operator><name>pathcost</name></name></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* add tlist eval cost for each output row, plus cpu_tuple_cost */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name>initplan_cost</name> <operator>+</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name>initplan_cost</name> <operator>+</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator>
        <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>+</operator> <name>cpu_tuple_cost</name></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_windowagg_path
 *      Creates a pathnode that represents computation of window functions
 *
 * 'rel' is the parent relation associated with the result
 * 'subpath' is the path representing the source of data
 * 'target' is the PathTarget to be computed
 * 'windowFuncs' is a list of WindowFunc structs
 * 'winclause' is a WindowClause that is common to all the WindowFuncs
 * 'winpathkeys' is the pathkeys for the PARTITION keys + ORDER keys
 *
 * The actual sort order of the input must match winpathkeys, but might
 * have additional keys after those.
 */</comment>
<function><type><name>WindowAggPath</name> <modifier>*</modifier></type>
<name>create_windowagg_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                      <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                      <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
                      <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>windowFuncs</name></decl></parameter>,
                      <parameter><decl><type><name>WindowClause</name> <modifier>*</modifier></type><name>winclause</name></decl></parameter>,
                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>winpathkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>WindowAggPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>WindowAggPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_WindowAgg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
    <comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
        <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
    <comment type="block">/* WindowAgg preserves the input sort order */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>winclause</name></name> <operator>=</operator> <name>winclause</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>winpathkeys</name></name> <operator>=</operator> <name>winpathkeys</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * For costing purposes, assume that there are no redundant partitioning
     * or ordering columns; it's not worth the trouble to deal with that
     * corner case here.  So we just pass the unmodified list lengths to
     * cost_windowagg.
     */</comment>
    <expr_stmt><expr><call><name>cost_windowagg</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
                   <argument><expr><name>windowFuncs</name></expr></argument>,
                   <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>winclause</name><operator>-&gt;</operator><name>partitionClause</name></name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>winclause</name><operator>-&gt;</operator><name>orderClause</name></name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr></argument>,
                   <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>,
                   <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* add tlist eval cost for each output row */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>+=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator>
        <name><name>target</name><operator>-&gt;</operator><name>cost</name><operator>.</operator><name>per_tuple</name></name> <operator>*</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_setop_path
 *      Creates a pathnode that represents computation of INTERSECT or EXCEPT
 *
 * 'rel' is the parent relation associated with the result
 * 'subpath' is the path representing the source of data
 * 'cmd' is the specific semantics (INTERSECT or EXCEPT, with/without ALL)
 * 'strategy' is the implementation strategy (sorted or hashed)
 * 'distinctList' is a list of SortGroupClause's representing the grouping
 * 'flagColIdx' is the column number where the flag column will be, if any
 * 'firstFlag' is the flag value for the first input relation when hashing;
 *        or -1 when sorting
 * 'numGroups' is the estimated number of distinct groups
 * 'outputRows' is the estimated number of output rows
 */</comment>
<function><type><name>SetOpPath</name> <modifier>*</modifier></type>
<name>create_setop_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                  <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
                  <parameter><decl><type><name>SetOpCmd</name></type> <name>cmd</name></decl></parameter>,
                  <parameter><decl><type><name>SetOpStrategy</name></type> <name>strategy</name></decl></parameter>,
                  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctList</name></decl></parameter>,
                  <parameter><decl><type><name>AttrNumber</name></type> <name>flagColIdx</name></decl></parameter>,
                  <parameter><decl><type><name>int</name></type> <name>firstFlag</name></decl></parameter>,
                  <parameter><decl><type><name>double</name></type> <name>numGroups</name></decl></parameter>,
                  <parameter><decl><type><name>double</name></type> <name>outputRows</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SetOpPath</name>  <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SetOpPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_SetOp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <comment type="block">/* SetOp doesn't project, so use source path's pathtarget */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr>;</expr_stmt>
    <comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
        <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
    <comment type="block">/* SetOp preserves the input sort order if in sort mode */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator>
        <ternary><condition><expr><operator>(</operator><name>strategy</name> <operator>==</operator> <name>SETOP_SORTED</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr> </then><else>: <expr><name>NIL</name></expr></else></ternary></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>cmd</name></name> <operator>=</operator> <name>cmd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>strategy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>distinctList</name></name> <operator>=</operator> <name>distinctList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>flagColIdx</name></name> <operator>=</operator> <name>flagColIdx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>firstFlag</name></name> <operator>=</operator> <name>firstFlag</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <name>numGroups</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Charge one cpu_operator_cost per comparison per input tuple. We assume
     * all columns get compared at most of the tuples.
     */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+</operator>
        <name>cpu_operator_cost</name> <operator>*</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>distinctList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name>outputRows</name></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_recursiveunion_path
 *      Creates a pathnode that represents a recursive UNION node
 *
 * 'rel' is the parent relation associated with the result
 * 'leftpath' is the source of data for the non-recursive term
 * 'rightpath' is the source of data for the recursive term
 * 'target' is the PathTarget to be computed
 * 'distinctList' is a list of SortGroupClause's representing the grouping
 * 'wtParam' is the ID of Param representing work table
 * 'numGroups' is the estimated number of groups
 *
 * For recursive UNION ALL, distinctList is empty and numGroups is zero
 */</comment>
<function><type><name>RecursiveUnionPath</name> <modifier>*</modifier></type>
<name>create_recursiveunion_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                           <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                           <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>leftpath</name></decl></parameter>,
                           <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>rightpath</name></decl></parameter>,
                           <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
                           <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>distinctList</name></decl></parameter>,
                           <parameter><decl><type><name>int</name></type> <name>wtParam</name></decl></parameter>,
                           <parameter><decl><type><name>double</name></type> <name>numGroups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RecursiveUnionPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RecursiveUnionPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_RecursiveUnion</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
    <comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
        <name><name>leftpath</name><operator>-&gt;</operator><name>parallel_safe</name></name> <operator>&amp;&amp;</operator> <name><name>rightpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
    <comment type="block">/* Foolish, but we'll do it like joins for now: */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>leftpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
    <comment type="block">/* RecursiveUnion result is always unsorted */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * FIXME This assumes left/right path have the same distribution, or one
     * of them is NULL. This is related to the subquery_planner() assuming all
     * tables are replicated on the same group of nodes, which may or may not
     * be the case, and we need to be more careful about it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>leftpath</name><operator>-&gt;</operator><name>distribution</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>leftpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>rightpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>leftpath</name></name> <operator>=</operator> <name>leftpath</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>rightpath</name></name> <operator>=</operator> <name>rightpath</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>distinctList</name></name> <operator>=</operator> <name>distinctList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>wtParam</name></name> <operator>=</operator> <name>wtParam</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>numGroups</name></name> <operator>=</operator> <name>numGroups</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>cost_recursive_union</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>leftpath</name></expr></argument>, <argument><expr><name>rightpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_lockrows_path
 *      Creates a pathnode that represents acquiring row locks
 *
 * 'rel' is the parent relation associated with the result
 * 'subpath' is the path representing the source of data
 * 'rowMarks' is a list of PlanRowMark's
 * 'epqParam' is the ID of Param for EvalPlanQual re-eval
 */</comment>
<function><type><name>LockRowsPath</name> <modifier>*</modifier></type>
<name>create_lockrows_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                     <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rowMarks</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>epqParam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LockRowsPath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>LockRowsPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_LockRows</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <comment type="block">/* LockRows doesn't project, so use source path's pathtarget */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr>;</expr_stmt>
    <comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The result cannot be assumed sorted, since locking might cause the sort
     * key columns to be replaced with new values.
     */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <name>rowMarks</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>epqParam</name></name> <operator>=</operator> <name>epqParam</name></expr>;</expr_stmt>

    <comment type="block">/*
     * We should charge something extra for the costs of row locking and
     * possible refetches, but it's hard to say how much.  For now, use
     * cpu_tuple_cost per row.
     */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>+</operator>
        <name>cpu_tuple_cost</name> <operator>*</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_modifytable_path
 *      Creates a pathnode that represents performing INSERT/UPDATE/DELETE mods
 *
 * 'rel' is the parent relation associated with the result
 * 'operation' is the operation type
 * 'canSetTag' is true if we set the command tag/es_processed
 * 'nominalRelation' is the parent RT index for use of EXPLAIN
 * 'partitioned_rels' is an integer list of RT indexes of non-leaf tables in
 *        the partition tree, if this is an UPDATE/DELETE to a partitioned table.
 *        Otherwise NIL.
 * 'partColsUpdated' is true if any partitioning columns are being updated,
 *		either from the target relation or a descendent partitioned table.
 * 'resultRelations' is an integer list of actual RT indexes of target rel(s)
 * 'subpaths' is a list of Path(s) producing source data (one per rel)
 * 'subroots' is a list of PlannerInfo structs (one per rel)
 * 'withCheckOptionLists' is a list of WCO lists (one per rel)
 * 'returningLists' is a list of RETURNING tlists (one per rel)
 * 'rowMarks' is a list of PlanRowMarks (non-locking only)
 * 'onconflict' is the ON CONFLICT clause, or NULL
 * 'epqParam' is the ID of Param for EvalPlanQual re-eval
 */</comment>
<function><type><name>ModifyTablePath</name> <modifier>*</modifier></type>
<name>create_modifytable_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                        <parameter><decl><type><name>CmdType</name></type> <name>operation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>,
                        <parameter><decl><type><name>Index</name></type> <name>nominalRelation</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partitioned_rels</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>partColsUpdated</name></decl></parameter>,
                        <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>resultRelations</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subpaths</name></decl></parameter>,
                        <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>subroots</name></decl></parameter>,
                        <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>withCheckOptionLists</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>returningLists</name></decl></parameter>,
                        <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rowMarks</name></decl></parameter>, <parameter><decl><type><name>OnConflictExpr</name> <modifier>*</modifier></type><name>onconflict</name></decl></parameter>,
                        <parameter><decl><type><name>int</name></type> <name>epqParam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ModifyTablePath</name> <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ModifyTablePath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type>        <name>total_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>subroots</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>withCheckOptionLists</name> <operator>==</operator> <name>NIL</name> <operator>||</operator>
           <call><name>list_length</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>withCheckOptionLists</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>returningLists</name> <operator>==</operator> <name>NIL</name> <operator>||</operator>
           <call><name>list_length</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>returningLists</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_ModifyTable</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <comment type="block">/* pathtarget is not interesting, just make it minimally valid */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>reltarget</name></name></expr>;</expr_stmt>
    <comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Compute cost &amp; rowcount as sum of subpath costs &amp; rowcounts.
     *
     * Currently, we don't charge anything extra for the actual table
     * modification work, nor for the WITH CHECK OPTIONS or RETURNING
     * expressions if any.  It would only be window dressing, since
     * ModifyTable is always a top-level node and there is no way for the
     * costs to change any higher-level planning choices.  But we might want
     * to make it look better sometime.
     */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>total_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>subpaths</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>subpath</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>lc</name> <operator>==</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* first node? */</comment>
            <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>total_size</name> <operator>+=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name> <operator>*</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Set width to the average width of the subpath outputs.  XXX this is
     * totally wrong: we should report zero if no RETURNING, else an average
     * of the RETURNING tlist widths.  But it's what happened historically,
     * and improving it is a task for another day.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>total_size</name> <operator>/=</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>total_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>operation</name></name> <operator>=</operator> <name>operation</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>canSetTag</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>nominalRelation</name></name> <operator>=</operator> <name>nominalRelation</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>partitioned_rels</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>partitioned_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>partColsUpdated</name></name> <operator>=</operator> <name>partColsUpdated</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>resultRelations</name></name> <operator>=</operator> <name>resultRelations</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpaths</name></name> <operator>=</operator> <name>subpaths</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subroots</name></name> <operator>=</operator> <name>subroots</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>withCheckOptionLists</name></name> <operator>=</operator> <name>withCheckOptionLists</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>returningLists</name></name> <operator>=</operator> <name>returningLists</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <name>rowMarks</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>onconflict</name></name> <operator>=</operator> <name>onconflict</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>epqParam</name></name> <operator>=</operator> <name>epqParam</name></expr>;</expr_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * create_limit_path
 *      Creates a pathnode that represents performing LIMIT/OFFSET
 *
 * In addition to providing the actual OFFSET and LIMIT expressions,
 * the caller must provide estimates of their values for costing purposes.
 * The estimates are as computed by preprocess_limit(), ie, 0 represents
 * the clause not being present, and -1 means it's present but we could
 * not estimate its value.
 *
 * 'rel' is the parent relation associated with the result
 * 'subpath' is the path representing the source of data
 * 'limitOffset' is the actual OFFSET expression, or NULL
 * 'limitCount' is the actual LIMIT expression, or NULL
 * 'offset_est' is the estimated value of the OFFSET expression
 * 'count_est' is the estimated value of the LIMIT expression
 */</comment>
<function><type><name>LimitPath</name> <modifier>*</modifier></type>
<name>create_limit_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
                  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>limitOffset</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>limitCount</name></decl></parameter>,
                  <parameter><decl><type><name>int64</name></type> <name>offset_est</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>count_est</name></decl></parameter>,
                  <parameter><decl><type><name>bool</name></type> <name>skipEarlyFinish</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>LimitPath</name>  <modifier>*</modifier></type><name>pathnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>LimitPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Limit</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
    <comment type="block">/* Limit doesn't project, so use source path's pathtarget */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr>;</expr_stmt>
    <comment type="block">/* For now, assume we are above any joins, so no parameterization */</comment>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>consider_parallel</name></name> <operator>&amp;&amp;</operator>
        <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <name>limitOffset</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <name>limitCount</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>skipEarlyFinish</name></name> <operator>=</operator> <name>skipEarlyFinish</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>distribution</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Adjust the output rows count and costs according to the offset/limit.
     * This is only a cosmetic issue if we are at top level, but if we are
     * building a subquery then it's important to report correct info to the
     * outer planner.
     *
     * When the offset or count couldn't be estimated, use 10% of the
     * estimated number of rows emitted from the subpath.
     *
     * XXX we don't bother to add eval costs of the offset/limit expressions
     * themselves to the path costs.  In theory we should, but in most cases
     * those expressions are trivial and it's just not worth the trouble.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>offset_est</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>double</name></type>        <name>offset_rows</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>offset_est</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>offset_rows</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>offset_est</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>offset_rows</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <literal type="number">0.10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>offset_rows</name> <operator>&gt;</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>offset_rows</name> <operator>=</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>+=</operator>
                <operator>(</operator><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>-</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name><operator>)</operator>
                <operator>*</operator> <name>offset_rows</name> <operator>/</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>-=</operator> <name>offset_rows</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>count_est</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>double</name></type>        <name>count_rows</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>count_est</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>count_rows</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>count_est</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>count_rows</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <literal type="number">0.10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>count_rows</name> <operator>&gt;</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>count_rows</name> <operator>=</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>+</operator>
                <operator>(</operator><name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name> <operator>-</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name><operator>)</operator>
                <operator>*</operator> <name>count_rows</name> <operator>/</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name>count_rows</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * reparameterize_path
 *        Attempt to modify a Path to have greater parameterization
 *
 * We use this to attempt to bring all child paths of an appendrel to the
 * same parameterization level, ensuring that they all enforce the same set
 * of join quals (and thus that that parameterization can be attributed to
 * an append path built from such paths).  Currently, only a few path types
 * are supported here, though more could be added at need.  We return NULL
 * if we can't reparameterize the given path.
 *
 * Note: we intentionally do not pass created paths to add_path(); it would
 * possibly try to delete them on the grounds of being cost-inferior to the
 * paths they were made from, and we don't want that.  Paths made here are
 * not necessarily of general-purpose usefulness, but they can be useful
 * as members of an append path.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>reparameterize_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
                    <parameter><decl><type><name>Relids</name></type> <name>required_outer</name></decl></parameter>,
                    <parameter><decl><type><name>double</name></type> <name>loop_count</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Can only increase, not decrease, path's parameterization */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    <switch>switch <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>pathtype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_SeqScan</name></expr>:</case>
            <return>return <expr><call><name>create_seqscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>T_SampleScan</name></expr>:</case>
            <return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_samplescan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>T_IndexScan</name></expr>:</case>
        <case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>IndexPath</name>  <modifier>*</modifier></type><name>ipath</name> <init>= <expr><operator>(</operator><name>IndexPath</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>IndexPath</name>  <modifier>*</modifier></type><name>newpath</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="block">/*
                 * We can't use create_index_path directly, and would not want
                 * to because it would re-compute the indexqual conditions
                 * which is wasted effort.  Instead we hack things a bit:
                 * flat-copy the path node, revise its param_info, and redo
                 * the cost estimate.
                 */</comment>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newpath</name></expr></argument>, <argument><expr><name>ipath</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexPath</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>newpath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator>
                    <call><name>get_baserel_parampathinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>cost_index</name><argument_list>(<argument><expr><name>newpath</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>loop_count</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>newpath</name></expr>;</return>
            </block_content>}</block>
        <case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>BitmapHeapPath</name> <modifier>*</modifier></type><name>bpath</name> <init>= <expr><operator>(</operator><name>BitmapHeapPath</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></init></decl>;</decl_stmt>

                <return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_bitmap_heap_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                        <argument><expr><name>rel</name></expr></argument>,
                                                        <argument><expr><name><name>bpath</name><operator>-&gt;</operator><name>bitmapqual</name></name></expr></argument>,
                                                        <argument><expr><name>required_outer</name></expr></argument>,
                                                        <argument><expr><name>loop_count</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block>
        <case>case <expr><name>T_SubqueryScan</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
            <block>{<block_content>
                <decl_stmt><decl><type><name>SubqueryScanPath</name> <modifier>*</modifier></type><name>spath</name> <init>= <expr><operator>(</operator><name>SubqueryScanPath</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></init></decl>;</decl_stmt>

                <return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_subqueryscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                         <argument><expr><name>rel</name></expr></argument>,
                                                         <argument><expr><name><name>spath</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>,
                                                         <argument><expr><name><name>spath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></argument>,
                                                         <argument><expr><name>required_outer</name></expr></argument>,
                                                         <argument><expr><name><name>path</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <block>{<block_content>
                <decl_stmt><decl><type><name>SubqueryScanPath</name> <modifier>*</modifier></type><name>spath</name> <init>= <expr><operator>(</operator><name>SubqueryScanPath</name> <operator>*</operator><operator>)</operator> <name>path</name></expr></init></decl>;</decl_stmt>

                <return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_subqueryscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                         <argument><expr><name>rel</name></expr></argument>,
                                                         <argument><expr><name><name>spath</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>,
                                                         <argument><expr><name><name>spath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></argument>,
                                                         <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <default>default:</default>
            <break>break;</break>
    </block_content>}</block></switch>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * reparameterize_path_by_child
 * 		Given a path parameterized by the parent of the given child relation,
 * 		translate the path to be parameterized by the given child relation.
 *
 * The function creates a new path of the same type as the given path, but
 * parameterized by the given child relation.  Most fields from the original
 * path can simply be flat-copied, but any expressions must be adjusted to
 * refer to the correct varnos, and any paths must be recursively
 * reparameterized.  Other fields that refer to specific relids also need
 * adjustment.
 *
 * The cost, number of rows, width and parallel path properties depend upon
 * path-&gt;parent, which does not change during the translation. Hence those
 * members are copied as they are.
 *
 * If the given path can not be reparameterized, the function returns NULL.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>reparameterize_path_by_child</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
							 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>child_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAT_COPY_PATH</name><parameter_list>(<parameter><type><name>newnode</name></type></parameter>, <parameter><type><name>node</name></type></parameter>, <parameter><type><name>nodetype</name></type></parameter>)</parameter_list></cpp:macro>  \
	<cpp:value>( (newnode) = makeNode(nodetype), \
	  memcpy((newnode), (node), sizeof(nodetype)) )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADJUST_CHILD_ATTRS</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((node) = \
	 (List *) adjust_appendrel_attrs_multilevel(root, (Node *) (node), \
												child_rel-&gt;relids, \
												child_rel-&gt;top_parent_relids))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPARAMETERIZE_CHILD_PATH</name><parameter_list>(<parameter><type><name>path</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	(path) = reparameterize_path_by_child(root, (path), child_rel); \
	if ((path) == NULL) \
		return NULL; \
} while(0);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPARAMETERIZE_CHILD_PATH_LIST</name><parameter_list>(<parameter><type><name>pathlist</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	if ((pathlist) != NIL) \
	{ \
		(pathlist) = reparameterize_pathlist_by_child(root, (pathlist), \
													  child_rel); \
		if ((pathlist) == NIL) \
			return NULL; \
	} \
} while(0);</cpp:value></cpp:define>

	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>new_path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>new_ppi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamPathInfo</name> <modifier>*</modifier></type><name>old_ppi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>required_outer</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the path is not parameterized by parent of the given relation, it
	 * doesn't need reparameterization.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>path</name><operator>-&gt;</operator><name>param_info</name></name> <operator>||</operator>
		<operator>!</operator><call><name>bms_overlap</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>child_rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>path</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Reparameterize a copy of given path. */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Path</name></expr>:</case>
			<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>Path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndexPath</name>  <modifier>*</modifier></type><name>ipath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>ipath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>IndexPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ADJUST_CHILD_ATTRS</name><argument_list>(<argument><expr><name><name>ipath</name><operator>-&gt;</operator><name>indexclauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ADJUST_CHILD_ATTRS</name><argument_list>(<argument><expr><name><name>ipath</name><operator>-&gt;</operator><name>indexquals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>ipath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_BitmapHeapPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapHeapPath</name> <modifier>*</modifier></type><name>bhpath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>bhpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>BitmapHeapPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>bhpath</name><operator>-&gt;</operator><name>bitmapqual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>bhpath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_BitmapAndPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapAndPath</name> <modifier>*</modifier></type><name>bapath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>bapath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>BitmapAndPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH_LIST</name><argument_list>(<argument><expr><name><name>bapath</name><operator>-&gt;</operator><name>bitmapquals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>bapath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_BitmapOrPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapOrPath</name> <modifier>*</modifier></type><name>bopath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>bopath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>BitmapOrPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH_LIST</name><argument_list>(<argument><expr><name><name>bopath</name><operator>-&gt;</operator><name>bitmapquals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>bopath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_TidPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TidPath</name>    <modifier>*</modifier></type><name>tpath</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * TidPath contains tidquals, which do not contain any
				 * external parameters per create_tidscan_path(). So don't
				 * bother to translate those.
				 */</comment>
				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>tpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>TidPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>tpath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_ForeignPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ForeignPath</name> <modifier>*</modifier></type><name>fpath</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ReparameterizeForeignPathByChild_function</name></type> <name>rfpc_func</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>ForeignPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>fpath</name><operator>-&gt;</operator><name>fdw_outerpath</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>fpath</name><operator>-&gt;</operator><name>fdw_outerpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Hand over to FDW if needed. */</comment>
				<expr_stmt><expr><name>rfpc_func</name> <operator>=</operator>
					<name><name>path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>fdwroutine</name><operator>-&gt;</operator><name>ReparameterizeForeignPathByChild</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>rfpc_func</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>fpath</name><operator>-&gt;</operator><name>fdw_private</name></name> <operator>=</operator> <call><name>rfpc_func</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>fpath</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></argument>,
												   <argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>fpath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CustomPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CustomPath</name> <modifier>*</modifier></type><name>cpath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>cpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>CustomPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH_LIST</name><argument_list>(<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>custom_paths</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>cpath</name><operator>-&gt;</operator><name>methods</name></name> <operator>&amp;&amp;</operator>
					<name><name>cpath</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>ReparameterizeCustomPathByChild</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>cpath</name><operator>-&gt;</operator><name>custom_private</name></name> <operator>=</operator>
						<call><name><name>cpath</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>ReparameterizeCustomPathByChild</name></name><argument_list>(<argument><expr><name>root</name></expr></argument>,
																		<argument><expr><name><name>cpath</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>,
																		<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>cpath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_NestPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>JoinPath</name>   <modifier>*</modifier></type><name>jpath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>jpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NestPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>jpath</name><operator>-&gt;</operator><name>outerjoinpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>jpath</name><operator>-&gt;</operator><name>innerjoinpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ADJUST_CHILD_ATTRS</name><argument_list>(<argument><expr><name><name>jpath</name><operator>-&gt;</operator><name>joinrestrictinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>jpath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_MergePath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>JoinPath</name>   <modifier>*</modifier></type><name>jpath</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>MergePath</name>  <modifier>*</modifier></type><name>mpath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>mpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>MergePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>jpath</name> <operator>=</operator> <operator>(</operator><name>JoinPath</name> <operator>*</operator><operator>)</operator> <name>mpath</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>jpath</name><operator>-&gt;</operator><name>outerjoinpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>jpath</name><operator>-&gt;</operator><name>innerjoinpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ADJUST_CHILD_ATTRS</name><argument_list>(<argument><expr><name><name>jpath</name><operator>-&gt;</operator><name>joinrestrictinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ADJUST_CHILD_ATTRS</name><argument_list>(<argument><expr><name><name>mpath</name><operator>-&gt;</operator><name>path_mergeclauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>mpath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_HashPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>JoinPath</name>   <modifier>*</modifier></type><name>jpath</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>HashPath</name>   <modifier>*</modifier></type><name>hpath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>hpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>HashPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>jpath</name> <operator>=</operator> <operator>(</operator><name>JoinPath</name> <operator>*</operator><operator>)</operator> <name>hpath</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>jpath</name><operator>-&gt;</operator><name>outerjoinpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>jpath</name><operator>-&gt;</operator><name>innerjoinpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ADJUST_CHILD_ATTRS</name><argument_list>(<argument><expr><name><name>jpath</name><operator>-&gt;</operator><name>joinrestrictinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ADJUST_CHILD_ATTRS</name><argument_list>(<argument><expr><name><name>hpath</name><operator>-&gt;</operator><name>path_hashclauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>hpath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_AppendPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AppendPath</name> <modifier>*</modifier></type><name>apath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>apath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>AppendPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH_LIST</name><argument_list>(<argument><expr><name><name>apath</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>apath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_MergeAppendPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MergeAppendPath</name> <modifier>*</modifier></type><name>mapath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>mapath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>MergeAppendPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH_LIST</name><argument_list>(<argument><expr><name><name>mapath</name><operator>-&gt;</operator><name>subpaths</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>mapath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_MaterialPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MaterialPath</name> <modifier>*</modifier></type><name>mpath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>mpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>MaterialPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>mpath</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>mpath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_UniquePath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>UniquePath</name> <modifier>*</modifier></type><name>upath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>upath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>UniquePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>upath</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ADJUST_CHILD_ATTRS</name><argument_list>(<argument><expr><name><name>upath</name><operator>-&gt;</operator><name>uniq_exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>upath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_GatherPath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GatherPath</name> <modifier>*</modifier></type><name>gpath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>gpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>GatherPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>gpath</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>gpath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_GatherMergePath</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>GatherMergePath</name> <modifier>*</modifier></type><name>gmpath</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLAT_COPY_PATH</name><argument_list>(<argument><expr><name>gmpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>GatherMergePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>REPARAMETERIZE_CHILD_PATH</name><argument_list>(<argument><expr><name><name>gmpath</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>new_path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>gmpath</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<default>default:</default>

			<comment type="block">/* We don't know how to reparameterize this path. */</comment>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Adjust the parameterization information, which refers to the topmost
	 * parent. The topmost parent can be multiple levels away from the given
	 * child, hence use multi-level expression adjustment routines.
	 */</comment>
	<expr_stmt><expr><name>old_ppi</name> <operator>=</operator> <name><name>new_path</name><operator>-&gt;</operator><name>param_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>required_outer</name> <operator>=</operator>
		<call><name>adjust_child_relids_multilevel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>old_ppi</name><operator>-&gt;</operator><name>ppi_req_outer</name></name></expr></argument>,
									   <argument><expr><name><name>child_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
									   <argument><expr><name><name>child_rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If we already have a PPI for this parameterization, just return it */</comment>
	<expr_stmt><expr><name>new_ppi</name> <operator>=</operator> <call><name>find_param_path_info</name><argument_list>(<argument><expr><name><name>new_path</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>, <argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If not, build a new one and link it to the list of PPIs. For the same
	 * reason as explained in mark_dummy_rel(), allocate new PPI in the same
	 * context the given RelOptInfo is in.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>new_ppi</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>new_ppi</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ParamPathInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_ppi</name><operator>-&gt;</operator><name>ppi_req_outer</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_ppi</name><operator>-&gt;</operator><name>ppi_rows</name></name> <operator>=</operator> <name><name>old_ppi</name><operator>-&gt;</operator><name>ppi_rows</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_ppi</name><operator>-&gt;</operator><name>ppi_clauses</name></name> <operator>=</operator> <name><name>old_ppi</name><operator>-&gt;</operator><name>ppi_clauses</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADJUST_CHILD_ATTRS</name><argument_list>(<argument><expr><name><name>new_ppi</name><operator>-&gt;</operator><name>ppi_clauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>ppilist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>ppilist</name></name></expr></argument>, <argument><expr><name>new_ppi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>required_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>new_path</name><operator>-&gt;</operator><name>param_info</name></name> <operator>=</operator> <name>new_ppi</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Adjust the path target if the parent of the outer relation is
	 * referenced in the targetlist. This can happen when only the parent of
	 * outer relation is laterally referenced in this relation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>lateral_relids</name></name></expr></argument>,
					<argument><expr><name><name>child_rel</name><operator>-&gt;</operator><name>top_parent_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>new_path</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>=</operator> <call><name>copy_pathtarget</name><argument_list>(<argument><expr><name><name>new_path</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ADJUST_CHILD_ATTRS</name><argument_list>(<argument><expr><name><name>new_path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>new_path</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * reparameterize_pathlist_by_child
 * 		Helper function to reparameterize a list of paths by given child rel.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>reparameterize_pathlist_by_child</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathlist</name></decl></parameter>,
								 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>child_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pathlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>reparameterize_path_by_child</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><name>child_rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NIL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
 * Count datanode number for given path, consider replication table as 1
 * because we use this function to figure out how many parts that data
 * had been separated into, when we estimating costs of a plan. Therefore
 * to get more accurate estimating result as in a distributed system.
 */</comment>
<function><type><name>double</name></type>
<name>path_count_datanodes</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>distribution</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>distribution</name></name></expr></argument>, <argument><expr><name>Distribution</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	    <operator>(</operator><name><name>path</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name> <operator>||</operator>
	     <name><name>path</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_HASH</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type> <name>nodes</name> <init>= <expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>distribution</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>nodes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>nodes</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
