<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/pgxc/pool/poolutils.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * poolutils.c
 *
 * Utilities for Postgres-XC pooler
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 *
 * IDENTIFICATION
 *    $$
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/poolmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/locator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/nodemgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/poolutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxcnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/prepare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner.h"</cpp:file></cpp:include>

<comment type="block">/*
 * pgxc_pool_check
 *
 * Check if Pooler information in catalog is consistent
 * with information cached.
 */</comment>
<function><type><name>Datum</name></type>
<name>pgxc_pool_check</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to manage pooler"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* A Datanode has no pooler active, so do not bother about that */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Simply check with pooler */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>PoolManagerCheckConnectionInfo</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pgxc_pool_reload
 *
 * This function checks if a refresh should be carried out first. A refresh
 * is carried out if NODEs have only been ALTERed in the catalog. Otherwise
 * reload is performed as below.
 *
 * Reload data cached in pooler and reload node connection
 * information in all the server sessions. This aborts all
 * the existing transactions on this node and reinitializes pooler.
 * First a lock is taken on Pooler to keep consistency of node information
 * being updated. If connection information cached is already consistent
 * in pooler, reload is not executed.
 * Reload itself is made in 2 phases:
 * 1) Update database pools with new connection information based on catalog
 *    pgxc_node. Remote node pools are changed as follows:
 *      - cluster nodes dropped in new cluster configuration are deleted and all
 *      their remote connections are dropped.
 *    - cluster nodes whose port or host value is modified are dropped the same
 *      way, as connection information has changed.
 *    - cluster nodes whose port or host has not changed are kept as is, but
 *      reorganized respecting the new cluster configuration.
 *    - new cluster nodes are added.
 * 2) Reload information in all the sessions of the local node.
 *    All the sessions in server are signaled to reconnect to pooler to get
 *    newest connection information and update connection information related
 *    to remote nodes. This results in losing prepared and temporary objects
 *    in all the sessions of server. All the existing transactions are aborted
 *    and a WARNING message is sent back to client.
 *    Session that invoked the reload does the same process, but no WARNING
 *    message is sent back to client.
 */</comment>
<function><type><name>Datum</name></type>
<name>pgxc_pool_reload</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pgxc_pool_reload cannot run inside a transaction block"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Always check if we can get away with a LESS destructive refresh
     * operation.
     */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>     
    if (PgxcNodeRefresh())
        PG_RETURN_BOOL(true);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    <comment type="block">/* TODO: disable node refresh now, consider the handle fd state and enable refresh later */</comment>
    <comment type="block">/* Always send reload msg to pooler */</comment>
    PgxcNodeRefresh();
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Session is being reloaded, drop prepared and temporary objects */</comment>
    <expr_stmt><expr><call><name>DropAllPreparedStatements</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reinitialize session, it updates the shared memory table */</comment>
    <expr_stmt><expr><call><name>InitMultinodeExecutor</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* Take a lock on pooler to forbid any action during reload */</comment>
    <expr_stmt><expr><call><name>PoolManagerLock</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Be sure it is done consistently */</comment>
    <do>do
    <block>{<block_content>
        <comment type="block">/* Reload connection information in pooler */</comment>
        <expr_stmt><expr><call><name>PoolManagerReloadConnectionInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>while <condition>(<expr><operator>!</operator><call><name>PoolManagerCheckConnectionInfo</name><argument_list>()</argument_list></call></expr>)</condition>;</do>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>PoolManagerLock</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Signal other sessions to reconnect to pooler if have privileges */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ReloadConnInfoOnBackends</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>PgxcNodeRefresh</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodes_alter</name> <init>= <expr><name>NIL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nodes_delete</name> <init>= <expr><name>NIL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nodes_add</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Check if NODE metadata has been ALTERed only. If there are DELETIONs
     * or ADDITIONs of NODEs, then we tell the caller to use reload
     * instead
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PgxcNodeDiffBackendHandles</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nodes_alter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodes_delete</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodes_add</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Self node altered. Performing reload"</literal>
             <literal type="string">" to re-create connections!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>nodes_delete</name> <operator>!=</operator> <name>NIL</name> <operator>||</operator> <name>nodes_add</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Nodes added/deleted. Performing reload"</literal>
             <literal type="string">" to re-create connections!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>nodes_alter</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"No nodes altered. Returning"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Be sure it is done consistently */</comment>
    <while>while <condition>(<expr><operator>!</operator><call><name>PoolManagerCheckConnectionInfo</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Refresh connection information in pooler */</comment>
        <expr_stmt><expr><call><name>PoolManagerRefreshConnectionInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>PgxcNodeRefreshBackendHandlesShmem</name><argument_list>(<argument><expr><name>nodes_alter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Signal other sessions to reconnect to pooler if have privileges */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ReloadConnInfoOnBackends</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>nodes_alter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>nodes_add</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>nodes_delete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CleanConnection()
 *
 * Utility to clean up Postgres-XC Pooler connections.
 * This utility is launched to all the Coordinators of the cluster
 *
 * Use of CLEAN CONNECTION is limited to a super user.
 * It is advised to clean connections before shutting down a Node or drop a Database.
 *
 * SQL query synopsis is as follows:
 * CLEAN CONNECTION TO
 *        (COORDINATOR num | DATANODE num | ALL {FORCE})
 *        [ FOR DATABASE dbname ]
 *        [ TO USER username ]
 *
 * Connection cleaning can be made on a chosen database called dbname
 * or/and a chosen user.
 * Cleaning is done for all the users of a given database
 * if no user name is specified.
 * Cleaning is done for all the databases for one user
 * if no database name is specified.
 *
 * It is also possible to clean connections of several Coordinators or Datanodes
 * Ex:    CLEAN CONNECTION TO DATANODE dn1,dn2,dn3 FOR DATABASE template1
 *        CLEAN CONNECTION TO COORDINATOR co2,co4,co3 FOR DATABASE template1
 *        CLEAN CONNECTION TO DATANODE dn2,dn5 TO USER postgres
 *        CLEAN CONNECTION TO COORDINATOR co6,co1 FOR DATABASE template1 TO USER postgres
 *
 * Or even to all Coordinators/Datanodes at the same time
 * Ex:    CLEAN CONNECTION TO DATANODE * FOR DATABASE template1
 *        CLEAN CONNECTION TO COORDINATOR * FOR DATABASE template1
 *        CLEAN CONNECTION TO COORDINATOR * TO USER postgres
 *        CLEAN CONNECTION TO COORDINATOR * FOR DATABASE template1 TO USER postgres
 *
 * When FORCE is used, all the transactions using pooler connections are aborted,
 * and pooler connections are cleaned up.
 * Ex:    CLEAN CONNECTION TO ALL FORCE FOR DATABASE template1;
 *        CLEAN CONNECTION TO ALL FORCE TO USER postgres;
 *        CLEAN CONNECTION TO ALL FORCE FOR DATABASE template1 TO USER postgres;
 *
 * FORCE can only be used with TO ALL, as it takes a lock on pooler to stop requests
 * asking for connections, aborts all the connections in the cluster, and cleans up
 * pool connections associated to the given user and/or database.
 */</comment>
<function><type><name>void</name></type>
<name>CleanConnection</name><parameter_list>(<parameter><decl><type><name>CleanConnStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>nodelist_item</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>co_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>dn_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>stmt_nodes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>dbname</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>dbname</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>username</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>username</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_coord</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>is_coord</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_force</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>is_force</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Database name or user name is mandatory */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dbname</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>username</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must define Database name or user name"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check if the Database exists by getting its Oid */</comment>
    <if_stmt><if>if <condition>(<expr><name>dbname</name> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_database_oid</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_DATABASE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check if role exists */</comment>
    <if_stmt><if>if <condition>(<expr><name>username</name> <operator>&amp;&amp;</operator>
        <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_role_oid</name><argument_list>(<argument><expr><name>username</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"role \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>username</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Permission checks
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_database_ownercheck</name><argument_list>(<argument><expr><call><name>get_database_oid</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_DATABASE</name></expr></argument>,
                       <argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * FORCE is activated,
     * Send a SIGTERM signal to all the processes and take a lock on Pooler
     * to avoid backends to take new connections when cleaning.
     * Only Disconnect is allowed.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_force</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>loop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>proc_pids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>num_proc_pids</name></decl>, <decl><type ref="prev"/><name>count</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>num_proc_pids</name> <operator>=</operator> <call><name>PoolManagerAbortTransactions</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>username</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>proc_pids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Watch the processes that received a SIGTERM.
         * At the end of the timestamp loop, processes are considered as not finished
         * and force the connection cleaning has failed
         */</comment>

        <while>while <condition>(<expr><name>num_proc_pids</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>loop</name> <operator>&lt;</operator> <name>TIMEOUT_CLEAN_LOOP</name></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><expr><name>count</name> <operator>=</operator> <name>num_proc_pids</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>count</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>count</name><operator>--</operator></expr></incr>)</control>
            <block>{<block_content>
                <switch>switch<condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><name><name>proc_pids</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><literal type="number">0</literal></expr>:</case> <comment type="block">/* Termination not done yet */</comment>
                        <break>break;</break>

                    <default>default:</default>
                        <comment type="block">/* Move tail pid in free space */</comment>
                        <expr_stmt><expr><name><name>proc_pids</name><index>[<expr><name>count</name></expr>]</index></name> <operator>=</operator> <name><name>proc_pids</name><index>[<expr><name>num_proc_pids</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>num_proc_pids</name><operator>--</operator></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>loop</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>

        <if_stmt><if>if <condition>(<expr><name>proc_pids</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>proc_pids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>loop</name> <operator>&gt;=</operator> <name>TIMEOUT_CLEAN_LOOP</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"All Transactions have not been aborted"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <macro><name>foreach</name><argument_list>(<argument>nodelist_item</argument>, <argument>stmt-&gt;nodes</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>node_name</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>nodelist_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name>node_type</name> <init>= <expr><name>PGXC_NODE_NONE</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>stmt_nodes</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>stmt_nodes</name></expr></argument>,
                                 <argument><expr><call><name>PGXCNodeGetNodeIdFromName</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>,
                                                           <argument><expr><operator>&amp;</operator><name>node_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>node_type</name> <operator>==</operator> <name>PGXC_NODE_NONE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC Node %s: object not defined"</literal></expr></argument>,
                                    <argument><expr><name>node_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/* Build lists to be sent to Pooler Manager */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>nodes</name></name> <operator>&amp;&amp;</operator> <name>is_coord</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>co_list</name> <operator>=</operator> <name>stmt_nodes</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>nodes</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_coord</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>dn_list</name> <operator>=</operator> <name>stmt_nodes</name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
		<expr_stmt><expr><name>co_list</name> <operator>=</operator> <call><name>GetEntireCoordNodes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dn_list</name> <operator>=</operator> <call><name>GetAllDataNodes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * If force is launched, send a signal to all the processes
     * that are in transaction and take a lock.
     * Get back their process number and watch them locally here.
     * Process are checked as alive or not with pg_usleep and when all processes are down
     * go out of the control loop.
     * If at the end of the loop processes are not down send an error to client.
     * Then Make a clean with normal pool cleaner.
     * Always release the lock when calling CLEAN CONNECTION.
     */</comment>

    <comment type="block">/* Finish by contacting Pooler Manager */</comment>
    <expr_stmt><expr><call><name>PoolManagerCleanConnection</name><argument_list>(<argument><expr><name>dn_list</name></expr></argument>, <argument><expr><name>co_list</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>username</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Clean up memory */</comment>
    <if_stmt><if>if <condition>(<expr><name>co_list</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>co_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>dn_list</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>dn_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * DropDBCleanConnection
 *
 * Clean Connection for given database before dropping it
 * FORCE is not used here
 */</comment>
<function><type><name>void</name></type>
<name>DropDBCleanConnection</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	<modifier>*</modifier></type><name>co_list</name> <init>= <expr><call><name>GetEntireCoordNodes</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>    <modifier>*</modifier></type><name>dn_list</name> <init>= <expr><call><name>GetAllDataNodes</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Check permissions for this database */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_database_ownercheck</name><argument_list>(<argument><expr><call><name>get_database_oid</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><name>ACL_KIND_DATABASE</name></expr></argument>,
                       <argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PoolManagerCleanConnection</name><argument_list>(<argument><expr><name>dn_list</name></expr></argument>, <argument><expr><name>co_list</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Clean up memory */</comment>
    <if_stmt><if>if <condition>(<expr><name>co_list</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>co_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>dn_list</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>dn_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * HandlePoolerReload
 *
 * This is called when PROCSIG_PGXCPOOL_RELOAD is activated.
 * Abort the current transaction if any, then reconnect to pooler.
 * and reinitialize session connection information.
 */</comment>
<function><type><name>void</name></type>
<name>HandlePoolerReload</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>proc_exit_inprogress</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Prevent using of cached connections to remote nodes */</comment>
    <expr_stmt><expr><call><name>RequestInvalidateRemoteHandles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * HandlePoolerRefresh
 *
 * This is called when PROCSIG_PGXCPOOL_REFRESH is activated.
 * Reconcile local backend connection info with the one in
 * shared memory
 */</comment>
<function><type><name>void</name></type>
<name>HandlePoolerRefresh</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>proc_exit_inprogress</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>RequestRefreshRemoteHandles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* make sure the event is processed in due course */</comment>
    <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<function><type><name>Datum</name></type>
<name>pgxc_pool_disconnect</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Name</name></type>   <name>database_arg</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Name</name></type>   <name>username_arg</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>database</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>username</name></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>database_arg</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>database</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>database</name> <operator>=</operator> <name><name>database_arg</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>username_arg</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>username</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>username</name> <operator>=</operator> <name><name>username_arg</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>PoolManagerClosePooledConnections</name><argument_list>(<argument><expr><name>database</name></expr></argument>, <argument><expr><name>username</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</unit>
