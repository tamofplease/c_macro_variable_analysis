<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/pgxc/pool/pgxcnode.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pgxcnode.c
 *
 *      Functions for the Coordinator communicating with the PGXC nodes:
 *      Datanodes and Coordinators
 *
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 *
 * IDENTIFICATION
 *      $$
 *
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;poll.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__sun</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/filio.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ioctl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/prepare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_c.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxcnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/locator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/nodemgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/poolmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/dest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/elog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/formatting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../interfaces/libpq/libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../interfaces/libpq/libpq-fe.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMD_ID_MSG_LEN</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGXC_CANCEL_DELAY</name></cpp:macro>    <cpp:value>100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGXC_RESULT_TIME_OUT</name></cpp:macro> <cpp:value>PoolDNSetTimeout</cpp:value></cpp:define> <comment type="block">/* in seconds */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/* Number of connections held */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>datanode_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>coord_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>  <name>slavedatanode_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Datanode handles saved in Transaction memory context
 * when PostgresMain is launched.
 * Those handles are used inside a transaction by Coordinator to Datanodes.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>dn_handles</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>sdn_handles</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Coordinator handles saved in Transaction memory context
 * when PostgresMain is launched.
 * Those handles are used inside a transaction by Coordinator to Coordinators
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>co_handles</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>current_transaction_handles</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/* Hash key: nodeoid value: index in  dn_handles or co_handles */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>node_handles_hash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 

<typedef>typedef <type><struct>struct <name>PGXCNodeHandlesLookupEnt</name>
<block>{
    <decl_stmt><decl><type><name>Oid</name></type>            <name>nodeoid</name></decl>;</decl_stmt>    <comment type="block">/* Node Oid */</comment>
    <decl_stmt><decl><type><name>int32</name></type>       <name>nodeidx</name></decl>;</decl_stmt>    <comment type="block">/* Node index*/</comment>
}</block></struct></type> <name>PGXCNodeHandlesLookupEnt</name>;</typedef>
<function_decl><type><specifier>static</specifier> <name>int</name></type>
<name>pgxc_check_socket_health</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sock</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forRead</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forWrite</name></decl></parameter>, <parameter><decl><type><name>time_t</name></type> <name>end_time</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>pgxc_coordinator_proc_pid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name>pgxc_coordinator_proc_vxid</name> <init>= <expr><name>InvalidTransactionId</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Current size of dn_handles and co_handles */</comment>
<decl_stmt><decl><type><name>int</name></type>            <name>NumDataNodes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>         <name>NumCoords</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>            <name>NumSlaveDataNodes</name></decl>;</decl_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name></type> <name>HandlesInvalidatePending</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name></type> <name>HandlesRefreshPending</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Session and transaction parameters need to to be set on newly connected
 * remote nodes.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>session_param_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>List</name>    <modifier>*</modifier></type><name>local_param_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>StringInfo</name></type>     <name>session_params</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>StringInfo</name></type>    <name>local_params</name></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>NameData</name></type> <name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NameData</name></type> <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>flags</name></decl>;</decl_stmt>
}</block></struct></type> <name>ParamEntry</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>DoInvalidateRemoteHandles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>DoRefreshRemoteHandles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgxc_node_init</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sock</name></decl></parameter>,
		<parameter><decl><type><name>bool</name></type> <name>global_session</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgxc_node_init</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sock</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgxc_node_free</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgxc_node_all_free</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>get_int</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type> <name>conn</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>get_char</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type> <name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>ParamEntry</name> <modifier>*</modifier></type> <name>paramlist_get_paramentry</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>param_list</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ParamEntry</name> <modifier>*</modifier></type> <name>paramentry_copy</name><parameter_list>(<parameter><decl><type><name>ParamEntry</name> <modifier>*</modifier></type> <name>src_entry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PGXCNodeHandleError</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>msg_body</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PGXCNodeAllHandles</name> <modifier>*</modifier></type> <name>get_empty_handles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_current_dn_handles_internal</name><parameter_list>(<parameter><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_current_cn_handles_internal</name><parameter_list>(<parameter><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_current_txn_dn_handles_internal</name><parameter_list>(<parameter><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_current_txn_cn_handles_internal</name><parameter_list>(<parameter><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Initialize PGXCNodeHandle struct
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_pgxc_handle</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>pgxc_handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * Socket descriptor is small non-negative integer,
     * Indicate the handle is not initialized yet
     */</comment>
    <expr_stmt><expr><name><name>pgxc_handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>=</operator> <name>NO_SOCKET</name></expr>;</expr_stmt>

    <comment type="block">/* Initialise buffers */</comment>
    <expr_stmt><expr><name><name>pgxc_handle</name><operator>-&gt;</operator><name>error</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgxc_handle</name><operator>-&gt;</operator><name>outSize</name></name> <operator>=</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgxc_handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>pgxc_handle</name><operator>-&gt;</operator><name>outSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgxc_handle</name><operator>-&gt;</operator><name>inSize</name></name> <operator>=</operator> <literal type="number">16</literal> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pgxc_handle</name><operator>-&gt;</operator><name>inBuffer</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>pgxc_handle</name><operator>-&gt;</operator><name>inSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgxc_handle</name><operator>-&gt;</operator><name>combiner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgxc_handle</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgxc_handle</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgxc_handle</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgxc_handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgxc_handle</name><operator>-&gt;</operator><name>needSync</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>    
	<expr_stmt><expr><name><name>pgxc_handle</name><operator>-&gt;</operator><name>sock_fatal_occurred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgxc_handle</name><operator>-&gt;</operator><name>plpgsql_need_begin_sub_txn</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgxc_handle</name><operator>-&gt;</operator><name>plpgsql_need_begin_txn</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifndef>
    <expr_stmt><expr><name><name>pgxc_handle</name><operator>-&gt;</operator><name>sendGxidVersion</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name><name>pgxc_handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>pgxc_handle</name><operator>-&gt;</operator><name>inBuffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Allocate and initialize memory to store Datanode and Coordinator handles.
 */</comment>
<function><type><name>void</name></type>
<name>InitMultinodeExecutor</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_force</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>                <name>count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>                <modifier>*</modifier></type><name>coOids</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dnOids</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sdnOids</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <decl_stmt><decl><type><name>MemoryContext</name></type>    <name>oldcontext</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* Init node handles hashtable */</comment>
    <decl_stmt><decl><type><name>HASHCTL</name></type>         <name>hinfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>             <name>hflags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeHandlesLookupEnt</name> <modifier>*</modifier></type><name>node_handle_ent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Free all the existing information first */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_force</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pgxc_node_all_free</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* This function could get called multiple times because of sigjmp */</comment>
    <if_stmt><if>if <condition>(<expr><name>dn_handles</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
        <name>co_handles</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Update node table in the shared memory */</comment>
	<expr_stmt><expr><call><name>PgxcNodeListAndCountWrapTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get classified list of node Oids */</comment>
    <expr_stmt><expr><call><name>PgxcNodeGetOidsExtend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>coOids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dnOids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sdnOids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>NumCoords</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>NumDataNodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>NumSlaveDataNodes</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Process node number related memory */</comment>
	<expr_stmt><expr><call><name>RebuildDatanodeQueryHashTable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>clean_stat_transaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <comment type="block">/*
     * Coordinator and datanode handles should be available during all the
     * session lifetime
     */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Do proper initialization of handles */</comment>
    <if_stmt><if>if <condition>(<expr><name>NumDataNodes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>dn_handles</name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>)</operator>
            <call><name>palloc</name><argument_list>(<argument><expr><name>NumDataNodes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>NumCoords</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>co_handles</name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>)</operator>
            <call><name>palloc</name><argument_list>(<argument><expr><name>NumCoords</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>NumSlaveDataNodes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>sdn_handles</name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>)</operator>
            <call><name>palloc</name><argument_list>(<argument><expr><name>NumSlaveDataNodes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>dn_handles</name> <operator>&amp;&amp;</operator> <name>NumDataNodes</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
        <operator>(</operator><operator>!</operator><name>co_handles</name> <operator>&amp;&amp;</operator> <name>NumCoords</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
        <operator>(</operator><operator>!</operator><name>sdn_handles</name> <operator>&amp;&amp;</operator> <name>NumSlaveDataNodes</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory for node handles"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>    
    <comment type="block">/* destory hash table */</comment>
    <if_stmt><if>if <condition>(<expr><name>node_handles_hash</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>node_handles_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>node_handles_hash</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hflags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hinfo</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>hinfo</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandlesLookupEnt</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>hflags</name> <operator>|=</operator> <name>HASH_ELEM</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>hinfo</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>oid_hash</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>hflags</name> <operator>|=</operator> <name>HASH_FUNCTION</name></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>node_handles_hash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Node Handles Hash"</literal></expr></argument>, <argument><expr><name>NumCoords</name> <operator>+</operator> <name>NumDataNodes</name> <operator>+</operator> <name>NumSlaveDataNodes</name></expr></argument>,
                                              <argument><expr><operator>&amp;</operator><name>hinfo</name></expr></argument>, <argument><expr><name>hflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Initialize new empty slots */</comment>
    <for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>count</name> <operator>&lt;</operator> <name>NumDataNodes</name></expr>;</condition> <incr><expr><name>count</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        
        <expr_stmt><expr><call><name>init_pgxc_handle</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dn_handles</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodeoid</name> <operator>=</operator> <name><name>dnOids</name><index>[<expr><name>count</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodeid</name> <operator>=</operator> <call><name>get_pgxc_node_id</name><argument_list>(<argument><expr><name><name>dnOids</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>dn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodename</name></expr></argument>, <argument><expr><call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name><name>dnOids</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>dn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodehost</name></expr></argument>, <argument><expr><call><name>get_pgxc_nodehost</name><argument_list>(<argument><expr><name><name>dnOids</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodeport</name> <operator>=</operator> <call><name>get_pgxc_nodeport</name><argument_list>(<argument><expr><name><name>dnOids</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>enable_multi_cluster_print</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"dn handle %d nodename %s nodehost %s nodeport %d Oid %d NumDataNodes %d"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name><name>dn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodename</name></expr></argument>,
                <argument><expr><name><name>dn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodehost</name></expr></argument>, <argument><expr><name><name>dn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodeport</name></expr></argument>, <argument><expr><name><name>dnOids</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>, <argument><expr><name>NumDataNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><name>node_handle_ent</name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandlesLookupEnt</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>node_handles_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>dn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodeoid</name><operator>)</operator></expr></argument>,
                                            <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <if_stmt><if>if <condition>(<expr><name>node_handle_ent</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>node_handle_ent</name><operator>-&gt;</operator><name>nodeoid</name></name> <operator>=</operator> <name><name>dn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodeoid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>node_handle_ent</name><operator>-&gt;</operator><name>nodeidx</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>,
				<argument><expr><literal type="string">"node_handles_hash enter primary datanode nodeoid: %d"</literal></expr></argument>,
				<argument><expr><name><name>node_handle_ent</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>dn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>node_type</name> <operator>=</operator> <name>PGXC_NODE_DATANODE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>        
        
    </block_content>}</block></for>

    <for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>count</name> <operator>&lt;</operator> <name>NumSlaveDataNodes</name></expr>;</condition> <incr><expr><name>count</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>init_pgxc_handle</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sdn_handles</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sdn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodeoid</name> <operator>=</operator> <name><name>sdnOids</name><index>[<expr><name>count</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sdn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodeid</name> <operator>=</operator> <call><name>get_pgxc_node_id</name><argument_list>(<argument><expr><name><name>sdnOids</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>sdn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodename</name></expr></argument>, <argument><expr><call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name><name>sdnOids</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>sdn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodehost</name></expr></argument>, <argument><expr><call><name>get_pgxc_nodehost</name><argument_list>(<argument><expr><name><name>sdnOids</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sdn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodeport</name> <operator>=</operator> <call><name>get_pgxc_nodeport</name><argument_list>(<argument><expr><name><name>sdnOids</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"sdn handle %d nodename %s nodehost %s nodeport %d Oid %d"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name><name>dn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodename</name></expr></argument>,
            <argument><expr><name><name>sdn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodehost</name></expr></argument>, <argument><expr><name><name>sdn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodeport</name></expr></argument>, <argument><expr><name><name>sdnOids</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><name>node_handle_ent</name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandlesLookupEnt</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>node_handles_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>sdn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodeoid</name><operator>)</operator></expr></argument>,
                                            <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <if_stmt><if>if <condition>(<expr><name>node_handle_ent</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>node_handle_ent</name><operator>-&gt;</operator><name>nodeoid</name></name> <operator>=</operator> <name><name>sdn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodeoid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>node_handle_ent</name><operator>-&gt;</operator><name>nodeidx</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>,
				<argument><expr><literal type="string">"node_handles_hash enter slave datanode nodeoid: %d"</literal></expr></argument>,
				<argument><expr><name><name>node_handle_ent</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>sdn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>node_type</name> <operator>=</operator> <name>PGXC_NODE_SLAVEDATANODE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>        
        
    </block_content>}</block></for>
        
    <for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>count</name> <operator>&lt;</operator> <name>NumCoords</name></expr>;</condition> <incr><expr><name>count</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>init_pgxc_handle</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>co_handles</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>co_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodeoid</name> <operator>=</operator> <name><name>coOids</name><index>[<expr><name>count</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>co_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodeid</name> <operator>=</operator> <call><name>get_pgxc_node_id</name><argument_list>(<argument><expr><name><name>coOids</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>co_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodename</name></expr></argument>, <argument><expr><call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name><name>coOids</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>co_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodehost</name></expr></argument>, <argument><expr><call><name>get_pgxc_nodehost</name><argument_list>(<argument><expr><name><name>coOids</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>co_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodeport</name> <operator>=</operator> <call><name>get_pgxc_nodeport</name><argument_list>(<argument><expr><name><name>coOids</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>enable_multi_cluster_print</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"cn handle %d nodename %s nodehost %s nodeport %d Oid %d"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name><name>co_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodename</name></expr></argument>,
                <argument><expr><name><name>co_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodehost</name></expr></argument>, <argument><expr><name><name>co_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodeport</name></expr></argument>, <argument><expr><name><name>coOids</name><index>[<expr><name>count</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><name>node_handle_ent</name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandlesLookupEnt</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>node_handles_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>co_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodeoid</name><operator>)</operator></expr></argument>,
                                            <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <if_stmt><if>if <condition>(<expr><name>node_handle_ent</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>node_handle_ent</name><operator>-&gt;</operator><name>nodeoid</name></name> <operator>=</operator> <name><name>co_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodeoid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>node_handle_ent</name><operator>-&gt;</operator><name>nodeidx</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>,
				<argument><expr><literal type="string">"node_handles_hash enter coordinator nodeoid: %d"</literal></expr></argument>,
				<argument><expr><name><name>node_handle_ent</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>co_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>node_type</name> <operator>=</operator> <name>PGXC_NODE_COORDINATOR</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    
    </block_content>}</block></for>

    <expr_stmt><expr><name>datanode_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>coord_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>slavedatanode_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>PGXCNodeId</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>PGXCSessionId</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsConnFromApp</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>PGXCSessionId</name></expr></argument>, <argument><expr><literal type="string">"%s_%d_%ld"</literal></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>count</name> <operator>&lt;</operator> <name>NumCoords</name></expr>;</condition> <incr><expr><name>count</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>PGXCNodeName</name></expr></argument>,
                       <argument><expr><call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name><name>co_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodeoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>PGXCNodeId</name> <operator>=</operator> <name>count</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <else>else <comment type="block">/* DataNode */</comment>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>count</name> <operator>&lt;</operator> <name>NumDataNodes</name></expr>;</condition> <incr><expr><name>count</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>PGXCNodeName</name></expr></argument>,
                       <argument><expr><call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name><name>dn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodeoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>PGXCNodeId</name> <operator>=</operator> <name>count</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>

        <for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>count</name> <operator>&lt;</operator> <name>NumSlaveDataNodes</name></expr>;</condition> <incr><expr><name>count</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>PGXCNodeName</name></expr></argument>,
                       <argument><expr><call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name><name>sdn_handles</name><index>[<expr><name>count</name></expr>]</index></name><operator>.</operator><name>nodeoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>PGXCNodeId</name> <operator>=</operator> <name>count</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>PGXCMainClusterName</name></expr></argument>, <argument><expr><name>PGXCClusterName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>IsPGXCMainCluster</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>init_transaction_handles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
</block_content>}</block></function>

<function><type><name>Oid</name></type>
<name>get_nodeoid_from_nodeid</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nodeid</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>node_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>PGXC_NODE_COORDINATOR</name> <operator>==</operator> <name>node_type</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>nodeid</name> <operator>&gt;=</operator> <name>NumCoords</name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>InvalidOid</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name><name>co_handles</name><index>[<expr><name>nodeid</name></expr>]</index></name><operator>.</operator><name>nodeoid</name></expr>;</return>
    </block_content>}</block></if> 
    <if type="elseif">else if <condition>(<expr><name>PGXC_NODE_DATANODE</name> <operator>==</operator> <name>node_type</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>nodeid</name> <operator>&gt;=</operator> <name>NumDataNodes</name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>InvalidOid</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name><name>dn_handles</name><index>[<expr><name>nodeid</name></expr>]</index></name><operator>.</operator><name>nodeoid</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Builds up a connection string
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>PGXCNodeConnStr</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>host</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>,
                <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pgoptions</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>remote_type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>parent_node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>out</name></decl>,
                <decl><type ref="prev"/><name><name>connstr</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>num</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type>       <name>same_host</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>host</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>PGXCNodeHost</name></expr></argument>, <argument><expr><name>host</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>same_host</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Build up connection string
     * remote type can be Coordinator, Datanode or application.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><name>MLS_USER</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><name>AUDIT_USER</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>same_host</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>connstr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>connstr</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                   <argument><expr><literal type="string">"port=%d dbname=%s user=%s application_name='pgxc:%s' sslmode=disable options='-c remotetype=%s -c parentnode=%s %s %s'"</literal></expr></argument>,
                   <argument><expr><name>port</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><name>parent_node</name></expr></argument>, <argument><expr><name>remote_type</name></expr></argument>, <argument><expr><name>parent_node</name></expr></argument>,
                   <argument><expr><name>pgoptions</name></expr></argument>, <argument><expr><name>MLS_CONN_OPTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>connstr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>connstr</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                       <argument><expr><literal type="string">"host=%s port=%d dbname=%s user=%s application_name='pgxc:%s' sslmode=disable options='-c remotetype=%s -c parentnode=%s %s %s'"</literal></expr></argument>,
                       <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><name>parent_node</name></expr></argument>, <argument><expr><name>remote_type</name></expr></argument>, <argument><expr><name>parent_node</name></expr></argument>,
                       <argument><expr><name>pgoptions</name></expr></argument>, <argument><expr><name>MLS_CONN_OPTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if <condition>(<expr><name>same_host</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>connstr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>connstr</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                   <argument><expr><literal type="string">"port=%d dbname=%s user=%s application_name='pgxc:%s' sslmode=disable options='-c remotetype=%s -c parentnode=%s %s'"</literal></expr></argument>,
                   <argument><expr><name>port</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><name>parent_node</name></expr></argument>, <argument><expr><name>remote_type</name></expr></argument>, <argument><expr><name>parent_node</name></expr></argument>,
                   <argument><expr><name>pgoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>connstr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>connstr</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                       <argument><expr><literal type="string">"host=%s port=%d dbname=%s user=%s application_name='pgxc:%s' sslmode=disable options='-c remotetype=%s -c parentnode=%s %s'"</literal></expr></argument>,
                       <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><name>parent_node</name></expr></argument>, <argument><expr><name>remote_type</name></expr></argument>, <argument><expr><name>parent_node</name></expr></argument>,
                       <argument><expr><name>pgoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    
	<if_stmt><if>if <condition>(<expr><name>tcp_keepalives_idle</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>num</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>connstr</name> <operator>+</operator> <name>num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>connstr</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>num</name></expr></argument>,
					   <argument><expr><literal type="string">" connect_timeout=%d"</literal></expr></argument>, <argument><expr><name>tcp_keepalives_idle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Check for overflow */</comment>
	<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>num</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>connstr</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Output result */</comment>
		<expr_stmt><expr><name>out</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>num</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>connstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>out</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/* return NULL if we have problem */</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Connect to a Datanode using a connection string
 */</comment>
<function><type><name>NODE_CONNECTION</name> <modifier>*</modifier></type>
<name>PGXCNodeConnect</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>connstr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGconn</name>       <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

    <comment type="block">/* Delegate call to the pglib */</comment>
    <expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>PQconnectdb</name><argument_list>(<argument><expr><name>connstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>NODE_CONNECTION</name> <operator>*</operator><operator>)</operator> <name>conn</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>PGXCNodePing</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>connstr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>connstr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGPing</name></type> <name>status</name> <init>= <expr><call><name>PQping</name><argument_list>(<argument><expr><name>connstr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>PQPING_OK</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Close specified connection
 */</comment>
<function><type><name>void</name></type>
<name>PGXCNodeClose</name><parameter_list>(<parameter><decl><type><name>NODE_CONNECTION</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Delegate call to the pglib */</comment>
    <expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><operator>(</operator><name>PGconn</name> <operator>*</operator><operator>)</operator> <name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Checks if connection active
 */</comment>
<function><type><name>int</name></type>
<name>PGXCNodeConnected</name><parameter_list>(<parameter><decl><type><name>NODE_CONNECTION</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Delegate call to the pglib */</comment>
    <decl_stmt><decl><type><name>PGconn</name>       <modifier>*</modifier></type><name>pgconn</name> <init>= <expr><operator>(</operator><name>PGconn</name> <operator>*</operator><operator>)</operator> <name>conn</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Simple check, want to do more comprehencive -
     * check if it is ready for guery
     */</comment>
    <return>return <expr><name>pgconn</name> <operator>&amp;&amp;</operator> <call><name>PQstatus</name><argument_list>(<argument><expr><name>pgconn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_OK</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/* Close the socket handle (this process' copy) and free occupied memory
 *
 * Note that we do not free the handle and its members. This will be
 * taken care of when the transaction ends, when TopTransactionContext
 * is destroyed in xact.c.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgxc_node_free</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>=</operator> <name>NO_SOCKET</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Free all the node handles cached
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgxc_node_all_free</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>num_nodes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>array_handles</name></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name>i</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="number">0</literal></expr>:</case>
                <expr_stmt><expr><name>num_nodes</name> <operator>=</operator> <name>NumCoords</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>array_handles</name> <operator>=</operator> <name>co_handles</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">1</literal></expr>:</case>
                <expr_stmt><expr><name>num_nodes</name> <operator>=</operator> <name>NumDataNodes</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>array_handles</name> <operator>=</operator> <name>dn_handles</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">2</literal></expr>:</case>
                <expr_stmt><expr><name>num_nodes</name> <operator>=</operator> <name>NumSlaveDataNodes</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>array_handles</name> <operator>=</operator> <name>sdn_handles</name></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>

        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>num_nodes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><operator>&amp;</operator><name><name>array_handles</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>pgxc_node_free</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>array_handles</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>array_handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>co_handles</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>dn_handles</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sdn_handles</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>HandlesInvalidatePending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>HandlesRefreshPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create and initialise internal structure to communicate to
 * Datanode via supplied socket descriptor.
 * Structure stores state info and I/O buffers
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgxc_node_init</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sock</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>global_session</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>init_str</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>=</operator> <name>sock</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name> <operator>=</operator> <name>pid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>=</operator> <literal type="char">'I'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>read_only</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>ck_resp_rollback</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>combiner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DN_CONNECTION_DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>have_row_desc</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>needSync</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>recv_datarows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>plpgsql_need_begin_sub_txn</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>plpgsql_need_begin_txn</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>sendGxidVersion</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>sock_fatal_occurred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * We got a new connection, set on the remote node the session parameters
     * if defined. The transaction parameter should be sent after BEGIN
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>global_session</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>init_str</name> <operator>=</operator> <call><name>PGXCNodeGetSessionParamStr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>init_str</name></expr>)</condition>
        <block>{<block_content>
			<expr_stmt><expr><call><name>pgxc_node_set_query</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>init_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    if (global_session)
    {
        int nbytes = 0;
        nbytes = pgxc_node_is_data_enqueued(handle);
        if (nbytes)
        {
            elog(LOG, "pgxc_node_init %d  LEFT_OVER data found, try to read it", nbytes);
            pgxc_print_pending_data(handle, true);    
            nbytes = pgxc_node_is_data_enqueued(handle);
            if (nbytes)
            {
                elog(LOG, "pgxc_node_init after read  LEFT_OVER data still %d bytes left", nbytes);
            }
        }
        
        init_str = PGXCNodeGetSessionParamStr();
        if (init_str)
        {
            elog(LOG, "pgxc_node_init send SET %s command", init_str);
            if (PoolManagerSetCommand(&amp;handle, 1, POOL_CMD_GLOBAL_SET, init_str) &lt; 0)
            {
                elog(ERROR, "TBase: ERROR pgxc_node_init SET query:%s", init_str);
            }
        }

        nbytes = pgxc_node_is_data_enqueued(handle);
        if (nbytes)
        {
            elog(LOG, "pgxc_node_init %d  LEFT_OVER data found, try to read it", nbytes);
            pgxc_print_pending_data(handle, true);    
            nbytes = pgxc_node_is_data_enqueued(handle);
            if (nbytes)
            {
                elog(LOG, "pgxc_node_init after read  LEFT_OVER data still %d bytes left", nbytes);
            }
        }
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    
</block_content>}</block></function>

<comment type="block">/*
 * Wait while at least one of specified connections has data available and read
 * the data into the buffer
 *
 * Returning state code
 * 		DNStatus_OK      = 0,
 *		DNStatus_ERR     = 1,
 *		DNStatus_EXPIRED = 2,
 *		DNStatus_BUTTY
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type>
<name>pgxc_node_receive</name><argument_list>(<argument><expr><specifier>const</specifier> <name>int</name> <name>conn_count</name></expr></argument>,
                  <argument><expr><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator> <name>connections</name></expr></argument>, <argument><expr>struct <name>timeval</name> <operator>*</operator> <name>timeout</name></expr></argument>)</argument_list>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<name>bool</name>
<name>pgxc_node_receive</name><argument_list>(<argument><expr><specifier>const</specifier> <name>int</name> <name>conn_count</name></expr></argument>,
                  <argument><expr><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator> <name>connections</name></expr></argument>, <argument><expr>struct <name>timeval</name> <operator>*</operator> <name>timeout</name></expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__TBASE__</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERROR_OCCURED</name></cpp:macro>        <cpp:value>true</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NO_ERROR_OCCURED</name></cpp:macro>    <cpp:value>false</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <decl_stmt><decl><type><name>int</name></type>        <name>i</name></decl>,
            <decl><type ref="prev"/><name>sockets_to_poll</name></decl>,
            <decl><type ref="prev"/><name>poll_val</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>    <name>is_msg_buffered</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>     <name>timeout_ms</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name>    <name>pollfd</name></name></type> <name><name>pool_fd</name><index>[<expr><name>conn_count</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* sockets to be polled index */</comment>
    <expr_stmt><expr><name>sockets_to_poll</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>is_msg_buffered</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>conn_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* If connection has a buffered message */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>HAS_MESSAGE_BUFFERED</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>is_msg_buffered</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>conn_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* If connection finished sending do not wait input from it */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>state</name> <operator>==</operator> <name>DN_CONNECTION_STATE_IDLE</name> <operator>||</operator> <call><name>HAS_MESSAGE_BUFFERED</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>pool_fd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pool_fd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_receive node:%s pid:%d in DN_CONNECTION_STATE_IDLE no need to receive. "</literal></expr></argument>, <argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nodename</name></expr></argument>, <argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>backend_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* prepare select params */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>sock</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>pool_fd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>sock</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pool_fd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <name>POLLIN</name> <operator>|</operator> <name>POLLPRI</name> <operator>|</operator> <name>POLLRDNORM</name> <operator>|</operator> <name>POLLRDBAND</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>sockets_to_poll</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* flag as bad, it will be removed from the list */</comment>
            <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pool_fd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pool_fd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Return if we do not have connections to receive input
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>sockets_to_poll</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>is_msg_buffered</name></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <return>return <expr><name>DNStatus_OK</name></expr>;</return>            
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <return>return <expr><name>NO_ERROR_OCCURED</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"no message in buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>DNStatus_ERR</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <return>return <expr><name>ERROR_OCCURED</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* do conversion from the select behaviour */</comment>
    <if_stmt><if>if <condition>( <expr><name>timeout</name> <operator>==</operator> <name>NULL</name></expr> )</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>timeout_ms</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>timeout_ms</name> <operator>=</operator> <operator>(</operator><name><name>timeout</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>*</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <literal type="number">1000</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>timeout</name><operator>-&gt;</operator><name>tv_usec</name></name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

<label><name>retry</name>:</label>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>poll_val</name>  <operator>=</operator> <call><name>poll</name><argument_list>(<argument><expr><name>pool_fd</name></expr></argument>, <argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>timeout_ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>poll_val</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* error - retry if EINTR */</comment>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name>  <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EAGAIN</name></expr>)</condition>
        <block>{<block_content>
            <goto>goto <name>retry</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EBADF</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"poll() bad file descriptor set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"poll() failed for error: %d, %s"</literal></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <if_stmt><if>if <condition>(<expr><name>errno</name></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <return>return <expr><name>DNStatus_ERR</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <return>return <expr><name>ERROR_OCCURED</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>
        
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <return>return <expr><name>DNStatus_OK</name></expr>;</return>            
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <return>return <expr><name>NO_ERROR_OCCURED</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>poll_val</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Handle timeout */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"timeout %ld while waiting for any response from %d connections"</literal></expr></argument>, <argument><expr><name>timeout_ms</name></expr></argument>,<argument><expr><name>conn_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>conn_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"timeout %ld while waiting for any response from node:%s pid:%d connections"</literal></expr></argument>, <argument><expr><name>timeout_ms</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">//PGXCNodeSetConnectionState(connections[i], DN_CONNECTION_STATE_ERROR_FATAL);</comment>
        </block_content>}</block></for>        
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <return>return <expr><name>DNStatus_EXPIRED</name></expr>;</return>            
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <return>return <expr><name>NO_ERROR_OCCURED</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* read data */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>conn_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if<condition>( <expr><name><name>pool_fd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>( <expr><name><name>pool_fd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>==</operator> <name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr> )</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>( <expr><name><name>pool_fd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>revents</name> <operator>&amp;</operator> <name>POLLIN</name></expr> )</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>    <name>read_status</name> <init>= <expr><call><name>pgxc_node_read_data</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>( <expr><name>read_status</name> <operator>==</operator> <name>EOF</name> <operator>||</operator> <name>read_status</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition>
                <block>{<block_content>
                    <comment type="block">/* Can not read - no more actions, just discard connection */</comment>
                    <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
                            <argument><expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"unexpected EOF on datanode connection."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"unexpected EOF on node:%s pid:%d, read_status:%d, EOF:%d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name>read_status</name></expr></argument>, <argument><expr><name>EOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
                    <comment type="block">/*
                     * before returning, also update the shared health
                     * status field to indicate that this node could be
                     * possibly unavailable.
                     *
                     * Note that this error could be due to a stale handle
                     * and it's possible that another backend might have
                     * already updated the health status OR the node
                     * might have already come back since the last disruption
                     */</comment>
                    PoolPingNodeRecheck(conn-&gt;nodeoid);
                    
                    <comment type="block">/* Should we read from the other connections before returning? */</comment>
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <return>return <expr><name>DNStatus_ERR</name></expr>;</return>            
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <return>return <expr><name>ERROR_OCCURED</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></if></if_stmt>

            </block_content>}</block></if>
            <if type="elseif">else if <condition>(
                    <expr><operator>(</operator><name><name>pool_fd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>revents</name> <operator>&amp;</operator> <name>POLLERR</name><operator>)</operator> <operator>||</operator>
                    <operator>(</operator><name><name>pool_fd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>revents</name> <operator>&amp;</operator> <name>POLLHUP</name><operator>)</operator> <operator>||</operator>
                    <operator>(</operator><name><name>pool_fd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>revents</name> <operator>&amp;</operator> <name>POLLNVAL</name><operator>)</operator></expr>
                    )</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                        <argument><expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"unexpected network error on datanode connection"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"unexpected EOF on datanode:%s pid:%d with event %d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>pool_fd</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>revents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Should we check/read from the other connections before returning? */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <return>return <expr><name>DNStatus_ERR</name></expr>;</return>            
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <return>return <expr><name>ERROR_OCCURED</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <return>return <expr><name>DNStatus_OK</name></expr>;</return>            
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><name>NO_ERROR_OCCURED</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></decl></decl_stmt>


<function><type><name>void</name></type>
<name>pgxc_print_pending_data</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>reset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>       <name>ret</name></decl>;</decl_stmt>
    <comment type="line">//DNConnectionState estate = 0;</comment>
    <decl_stmt><decl><type><name>int</name></type>         <name>msg_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>msg_type</name></decl>;</decl_stmt>
    <comment type="line">//char        txn_status = 'I';</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name>            <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name>           <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt>    

    <comment type="line">//estate     = handle-&gt;state;</comment>
    <comment type="line">//txn_status = handle-&gt;transaction_status;</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>        
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>DN_CONNECTION_STATE_QUERY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pgxc_node_receive</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>DNStatus_ERR</name> <operator>==</operator> <name>ret</name></expr>)</condition>
        <block>{<block_content>            
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_print_pending_data pgxc_node_receive LEFT_OVER data ERROR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>DNStatus_OK</name> <operator>==</operator> <name>ret</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_print_pending_data pgxc_node_receive LEFT_OVER data succeed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_print_pending_data pgxc_node_receive LEFT_OVER data timeout"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        
        
        <comment type="block">/* No data available, exit */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HAS_MESSAGE_BUFFERED</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_print_pending_data pgxc_node_receive LEFT_OVER data finished"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>                    

        <comment type="block">/* TODO handle other possible responses */</comment>
        <expr_stmt><expr><name>msg_type</name> <operator>=</operator> <call><name>get_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>msg_type</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">'\0'</literal></expr>:</case>            <comment type="block">/* Not enough data in the buffer */</comment>
                <goto>goto <name>DONE</name>;</goto>
            <case>case <expr><literal type="char">'c'</literal></expr>:</case>            <comment type="block">/* CopyToCommandComplete */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LEFT_OVER CopyToCommandComplete found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'C'</literal></expr>:</case>            <comment type="block">/* CommandComplete */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LEFT_OVER CommandComplete found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'T'</literal></expr>:</case>            <comment type="block">/* RowDescription */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LEFT_OVER RowDescription found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'D'</literal></expr>:</case>            <comment type="block">/* DataRow */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LEFT_OVER DataRow found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'s'</literal></expr>:</case>            <comment type="block">/* PortalSuspended */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LEFT_OVER PortalSuspended found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'1'</literal></expr>:</case> <comment type="block">/* ParseComplete */</comment>
            <case>case <expr><literal type="char">'2'</literal></expr>:</case> <comment type="block">/* BindComplete */</comment>
            <case>case <expr><literal type="char">'3'</literal></expr>:</case> <comment type="block">/* CloseComplete */</comment>
            <case>case <expr><literal type="char">'n'</literal></expr>:</case> <comment type="block">/* NoData */</comment>
                <comment type="block">/* simple notifications, continue reading */</comment>
                <break>break;</break>
            <case>case <expr><literal type="char">'G'</literal></expr>:</case> <comment type="block">/* CopyInResponse */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LEFT_OVER CopyInResponse found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'H'</literal></expr>:</case> <comment type="block">/* CopyOutResponse */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LEFT_OVER CopyOutResponse found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'d'</literal></expr>:</case> <comment type="block">/* CopyOutDataRow */</comment>                            
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LEFT_OVER CopyOutDataRow found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'E'</literal></expr>:</case>            <comment type="block">/* ErrorResponse */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LEFT_OVER ErrorResponse found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'A'</literal></expr>:</case>            <comment type="block">/* NotificationResponse */</comment>
            <case>case <expr><literal type="char">'N'</literal></expr>:</case>            <comment type="block">/* NoticeResponse */</comment>
            <case>case <expr><literal type="char">'S'</literal></expr>:</case>            <comment type="block">/* SetCommandComplete */</comment>
                <comment type="block">/*
                 * Ignore these to prevent multiple messages, one from each
                 * node. Coordinator will send one for DDL anyway
                 */</comment>
                <break>break;</break>
            <case>case <expr><literal type="char">'Z'</literal></expr>:</case>            <comment type="block">/* ReadyForQuery */</comment>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LEFT_OVER ReadyForQuery found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>                        

            <case>case <expr><literal type="char">'Y'</literal></expr>:</case>            <comment type="block">/* ReadyForQuery */</comment>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LEFT_OVER ReadyForQuery found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            </block_content>}</block>
            <case>case <expr><literal type="char">'M'</literal></expr>:</case>            <comment type="block">/* Command Id */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LEFT_OVER Command Id found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'b'</literal></expr>:</case>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LEFT_OVER DN_CONNECTION_STATE_IDLE found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
                
            <case>case <expr><literal type="char">'I'</literal></expr>:</case>            <comment type="block">/* EmptyQuery */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LEFT_OVER EmptyQuery found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'W'</literal></expr>:</case>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LEFT_OVER W found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'x'</literal></expr>:</case>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LEFT_OVER RESPONSE_ASSIGN_GXID found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"LEFT_OVER invalid status found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></for>
    
<label><name>DONE</name>:</label>    
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>=</operator> <literal type="char">'I'</literal></expr>;</expr_stmt>    
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    
    <comment type="block">/* reset the status */</comment>
    <if_stmt><if>if <condition>(<expr><name>reset</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>error</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_print_pending_data LEFT_OVER errmsg:%s"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>needSync</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Is there any data enqueued in the TCP input buffer waiting
 * to be read sent by the PGXC node connection
 */</comment>

<function><type><name>int</name></type>
<name>pgxc_node_is_data_enqueued</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>enqueued</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ioctl</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>FIONREAD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>enqueued</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>enqueued</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read up incoming messages from the PGXC node connection
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_read_data</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>close_if_error</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>someread</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nread</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>close_if_error</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"bad socket"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Left-justify any data in the buffer to make room */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr></argument>,
                    <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>-=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>-=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* buffer is logically empty, reset it */</comment>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * If the buffer is fairly full, enlarge it. We need to be able to enlarge
     * the buffer in case a single message exceeds the initial buffer size. We
     * enlarge before filling the buffer entirely so as to avoid asking the
     * kernel for a partial packet. The magic constant here should be large
     * enough for a TCP packet or Unix pipe bufferload.  8K is the usual pipe
     * buffer size, so...
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inSize</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>&lt;</operator> <literal type="number">8192</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>ensure_in_buffer_capacity</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <literal type="number">8192</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We don't insist that the enlarge worked, but we need some room
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inSize</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>&lt;</operator> <literal type="number">100</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>close_if_error</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"can not allocate buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

<label><name>retry</name>:</label>
    <expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>recv</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr></argument>,
                 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inSize</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>
        <comment type="block">/* Some systems return EAGAIN/EWOULDBLOCK for no data */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAGAIN</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EAGAIN</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>someread</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EWOULDBLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EAGAIN</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>EWOULDBLOCK</name> <operator>!=</operator> <name>EAGAIN</name><operator>)</operator><operator>)</operator></expr></cpp:if>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>someread</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* We might get ECONNRESET here if using TCP and backend died */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ECONNRESET</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ECONNRESET</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * OK, we are getting a zero read even though select() says ready. This
             * means the connection has been closed.  Cope.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>close_if_error</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
                                <argument><expr><literal type="string">"Datanode closed the connection unexpectedly\n"</literal>
                    <literal type="string">"\tThis probably means the Datanode terminated abnormally\n"</literal>
                                <literal type="string">"\tbefore or while processing the request.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
                        <argument><expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* No more connection to
                                                            * backend */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_read_data, fatal_conn=%p, fatal_conn-&gt;nodename=%s, fatal_conn-&gt;sock=%d, "</literal>
					<literal type="string">"fatal_conn-&gt;read_only=%d, fatal_conn-&gt;transaction_status=%c, "</literal>
					<literal type="string">"fatal_conn-&gt;sock_fatal_occurred=%d, conn-&gt;backend_pid=%d, fatal_conn-&gt;error=%s"</literal></expr></argument>, 
					<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>read_only</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name></expr></argument>,
					<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock_fatal_occurred</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>,  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>=</operator> <name>NO_SOCKET</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sock_fatal_occurred</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if <condition>(<expr><name>close_if_error</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"could not receive data from server"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>+=</operator> <name>nread</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Hack to deal with the fact that some kernels will only give us back
         * 1 packet per recv() call, even if we asked for more and there is
         * more available.    If it looks like we are reading a long message,
         * loop back to recv() again immediately, until we run out of data or
         * buffer space.  Without this, the block-and-restart behavior of
         * libpq's higher levels leads to O(N^2) performance on long messages.
         *
         * Since we left-justified the data above, conn-&gt;inEnd gives the
         * amount of data already read in the current message.    We consider
         * the message "long" once we have acquired 32k ...
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name> <operator>&gt;</operator> <literal type="number">32768</literal> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>inSize</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name><operator>)</operator> <operator>&gt;=</operator> <literal type="number">8192</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>someread</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <goto>goto <name>retry</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>nread</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>close_if_error</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"nread returned 0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Get one character from the connection buffer and advance cursor
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_char</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type> <name>conn</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>EOF</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read an integer from the connection buffer and advance cursor
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_int</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>tmp2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tmp4</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+</operator> <name>len</name> <operator>&gt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

    <switch>switch <condition>(<expr><name>len</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="number">2</literal></expr>:</case>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp2</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name>tmp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="number">4</literal></expr>:</case>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp4</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>tmp4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"not supported int size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></switch>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_message
 * If connection has enough data read entire message from the connection buffer
 * and returns message type. Message data and data length are returned as
 * var parameters.
 * If buffer does not have enough data leaves cursor unchanged, changes
 * connection status to DN_CONNECTION_STATE_QUERY indicating it needs to
 * receive more and returns \0
 * conn - connection to read from
 * len - returned length of the data where msg is pointing to
 * msg - returns pointer to memory in the incoming buffer. The buffer probably
 * will be overwritten upon next receive, so if caller wants to refer it later
 * it should make a copy.
 */</comment>
<function><type><name>char</name></type>
<name>get_message</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>         <name>msgtype</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>get_char</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msgtype</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>get_int</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Successful get_char would move cursor, restore position */</comment>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr>;</expr_stmt>
        <return>return <expr><literal type="char">'\0'</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>len</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+</operator> <operator>*</operator><name>len</name> <operator>&gt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Not enough data in the buffer, we should read more.
         * Reading function will discard already consumed data in the buffer
         * till conn-&gt;inBegin. Then we want the message that is partly in the
         * buffer now has been read completely, to avoid extra read/handle
         * cycles. The space needed is 1 byte for message type, 4 bytes for
         * message length and message itself which size is currently in *len.
         * The buffer may already be large enough, in this case the function
         * ensure_in_buffer_capacity() will immediately return
         */</comment>
        <expr_stmt><expr><call><name>ensure_in_buffer_capacity</name><argument_list>(<argument><expr><literal type="number">5</literal> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <operator>*</operator><name>len</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr>;</expr_stmt>
        <return>return <expr><literal type="char">'\0'</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>msg</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name> <operator>+=</operator> <operator>*</operator><name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr>;</expr_stmt>
    <return>return <expr><name>msgtype</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Release all Datanode and Coordinator connections
 * back to pool and release occupied memory.
 * Release handles when transaction aborts. 
 */</comment>
<function><type><name>void</name></type>
<name>release_handles</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>destroy</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		 	<name>nbytes</name>	<init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* don't free connection if holding a cluster lock */</comment>
		<if_stmt><if>if <condition>(<expr><name>cluster_ex_lock_held</name></expr>)</condition>
		<block>{<block_content>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>datanode_count</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>coord_count</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>slavedatanode_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Do not release connections if we have prepared statements on nodes */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>HaveActiveDatanodeStatements</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Free Datanodes handles */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><operator>&amp;</operator><name><name>dn_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Connections at this point should be completely inactive,
			 * otherwise abandon them. We can not allow not cleaned up
             * connection is returned to pool.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name> <operator>||</operator>
                    <name><name>handle</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>!=</operator> <literal type="char">'I'</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>destroy</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Connection to Datanode %d has unexpected state %d and will be dropped"</literal></expr></argument>,
                     <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"release_handles release a connection with datanode %s"</literal>
                      <literal type="string">"remote backend PID %d"</literal></expr></argument>,
                    <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>pgxc_node_free</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifndef>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>sendGxidVersion</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>pgxc_node_is_data_enqueued</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nbytes</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Connection to Datanode %s has data %d pending"</literal></expr></argument>,
					 <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumSlaveDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><operator>&amp;</operator><name><name>sdn_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		
		<if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Connections at this point should be completely inactive,
			 * otherwise abandon them. We can not allow not cleaned up
			 * connection is returned to pool.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name> <operator>||</operator>
					<name><name>handle</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>!=</operator> <literal type="char">'I'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>destroy</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Connection to Datanode %d has unexpected state %d and will be dropped"</literal></expr></argument>,
					 <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"release_handles release a connection with datanode %s"</literal>
                      <literal type="string">"remote backend PID %d"</literal></expr></argument>,
                    <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>pgxc_node_free</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifndef>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>sendGxidVersion</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>pgxc_node_is_data_enqueued</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nbytes</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Connection to Datanode %s has data %d pending"</literal></expr></argument>,
                     <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>        
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Collect Coordinator handles */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumCoords</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><operator>&amp;</operator><name><name>co_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Connections at this point should be completely inactive,
                 * otherwise abandon them. We can not allow not cleaned up
                 * connection is returned to pool.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name> <operator>||</operator>
                        <name><name>handle</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>!=</operator> <literal type="char">'I'</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>destroy</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Connection to Coordinator %d has unexpected state %d and will be dropped"</literal></expr></argument>,
                            <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"release_handles release a connection with coordinator %s"</literal>
                          <literal type="string">"remote backend PID %d"</literal></expr></argument>,
                        <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <expr_stmt><expr><call><name>pgxc_node_free</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifndef>
            <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>sendGxidVersion</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>pgxc_node_is_data_enqueued</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>nbytes</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Connection to Datanode %s has data %d pending"</literal></expr></argument>,
                         <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

	<comment type="block">/* And finally release all the connections on pooler */</comment>
	<expr_stmt><expr><call><name>PoolManagerReleaseConnections</name><argument_list>(<argument><expr><name>destroy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>datanode_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>coord_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>slavedatanode_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether there bad connections to remote nodes when abort transactions.
 */</comment>
<function><type><name>bool</name></type>
<name>validate_handles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>int</name></type>            <name>ret</name></decl>;</decl_stmt>
    
    <comment type="block">/* Free Datanodes handles */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><operator>&amp;</operator><name><name>dn_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Connections at this point should be completely inactive,
             * otherwise abaandon them. We can not allow not cleaned up
             * connection is returned to pool.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name> <operator>==</operator> <name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pgxc_check_socket_health</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Remote node \"%s\", running with pid %d state:%d is bad"</literal></expr></argument>,
                                <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>true</name></expr>;</return>
                </block_content>}</block></if></if_stmt>                
            </block_content>}</block></if></if_stmt>
			
			<if_stmt><if>if<condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Remote node \"%s\", running with pid %d transaction_status %c is bad"</literal></expr></argument>,
							<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>transaction_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumSlaveDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><operator>&amp;</operator><name><name>sdn_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        
        <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Connections at this point should be completely inactive,
             * otherwise abaandon them. We can not allow not cleaned up
             * connection is returned to pool.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name> <operator>==</operator> <name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pgxc_check_socket_health</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Remote node \"%s\", running with pid %d state:%d is bad"</literal></expr></argument>,
                                <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>true</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
                
            </block_content>}</block></if></if_stmt>
			
			<if_stmt><if>if<condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Remote node \"%s\", running with pid %d transaction_status %c is bad"</literal></expr></argument>,
							<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>transaction_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>    
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Collect Coordinator handles */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumCoords</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><operator>&amp;</operator><name><name>co_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Connections at this point should be completely inactive,
                 * otherwise abandon them. We can not allow not cleaned up
                 * connection is returned to pool.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name> <operator>==</operator> <name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pgxc_check_socket_health</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>                
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Remote node \"%s\", running with pid %d state:%d is bad"</literal></expr></argument>,
                                <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><name>true</name></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

				<if_stmt><if>if<condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Remote node \"%s\", running with pid %d transaction_status %c is bad"</literal></expr></argument>,
								<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>transaction_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>true</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>clear_handles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>


    <if_stmt><if>if <condition>(<expr><name>datanode_count</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>coord_count</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>slavedatanode_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"clear versions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Free Datanodes handles */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><operator>&amp;</operator><name><name>dn_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifndef>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"clear handle node name %s versions "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sendGxidVersion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>sendGxidVersion</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></for>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumSlaveDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><operator>&amp;</operator><name><name>sdn_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifndef>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"clear handle node name %s versions "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sendGxidVersion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>sendGxidVersion</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Collect Coordinator handles */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumCoords</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><operator>&amp;</operator><name><name>co_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifndef>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"clear handle node name %s versions "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sendGxidVersion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>sendGxidVersion</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ensure that the supplied buffer has enough capacity and if not, it's
 * extended to an appropriate size.
 *
 * currbuf is the currently used buffer of currsize. bytes_needed is the
 * minimum size required. We shall return the new buffer, if allocated
 * successfully and set newsize_p to contain the size of the repalloced buffer.
 * If allocation fails, NULL is returned.
 *
 * The function checks for requests beyond MaxAllocSize and throw an error.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ensure_buffer_capacity</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>currbuf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>currsize</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bytes_needed</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>newsize_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>newbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>        <name>newsize</name> <init>= <expr><operator>(</operator><name>Size</name><operator>)</operator> <name>currsize</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Size</name><operator>)</operator> <name>bytes_needed</name><operator>)</operator> <operator>&gt;=</operator> <name>MaxAllocSize</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><name>ENOSPC</name><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Cannot enlarge buffer containing %ld bytes by %ld more bytes."</literal></expr></argument>,
                           <argument><expr><name>currsize</name></expr></argument>, <argument><expr><name>bytes_needed</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>bytes_needed</name> <operator>&lt;=</operator> <name>newsize</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>newsize_p</name> <operator>=</operator> <name>currsize</name></expr>;</expr_stmt>
        <return>return <expr><name>currbuf</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * The current size of the buffer should never be zero (init_pgxc_handle
     * guarantees that.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newsize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Double the buffer size until we have enough space to hold bytes_needed
     */</comment>
    <while>while <condition>(<expr><name>bytes_needed</name> <operator>&gt;</operator> <name>newsize</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>newsize</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name>newsize</name></expr>;</expr_stmt></block_content></block></while>

    <comment type="block">/*
     * Clamp to MaxAllocSize in case we went past it.  Note we are assuming
     * here that MaxAllocSize &lt;= INT_MAX/2, else the above loop could
     * overflow.  We will still have newsize &gt;= bytes_needed.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>newsize</name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>MaxAllocSize</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>newsize</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>MaxAllocSize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>newbuf</name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>currbuf</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>newbuf</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* repalloc succeeded, set new size and return the buffer */</comment>
        <expr_stmt><expr><operator>*</operator><name>newsize_p</name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
        <return>return <expr><name>newbuf</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If we fail to double the buffer, try to repalloc a buffer of the given
     * size, rounded to the next multiple of 8192 and see if that works.
     */</comment>
    <expr_stmt><expr><name>newsize</name> <operator>=</operator> <name>bytes_needed</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>newsize</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>bytes_needed</name> <operator>/</operator> <literal type="number">8192</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">8192</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>newbuf</name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>currbuf</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>newbuf</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* repalloc succeeded, set new size and return the buffer */</comment>
        <expr_stmt><expr><operator>*</operator><name>newsize_p</name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
        <return>return <expr><name>newbuf</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* repalloc failed */</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ensure specified amount of data can fit to the incoming buffer and
 * increase it if necessary
 */</comment>
<function><type><name>int</name></type>
<name>ensure_in_buffer_capacity</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>bytes_needed</name></decl></parameter>, <parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>size_t</name></type> <name>newsize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newbuf</name> <init>= <expr><call><name>ensure_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>inBuffer</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>inSize</name></name></expr></argument>,
            <argument><expr><name>bytes_needed</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>newbuf</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>inBuffer</name></name> <operator>=</operator> <name>newbuf</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>inSize</name></name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>EOF</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Ensure specified amount of data can fit to the outgoing buffer and
 * increase it if necessary
 */</comment>
<function><type><name>int</name></type>
<name>ensure_out_buffer_capacity</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>bytes_needed</name></decl></parameter>, <parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>newsize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newbuf</name> <init>= <expr><call><name>ensure_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outSize</name></name></expr></argument>,
            <argument><expr><name>bytes_needed</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>IN_REMOTE_PREPARE</name> <operator>==</operator> <name>twophase_in</name> <operator>&amp;&amp;</operator>
            <operator>(</operator><operator>(</operator><name>PART_PREPARE_SEND_TIMESTAMP</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>&amp;&amp;</operator> 
                <name>SEND_PREPARE_TIMESTAMP</name> <operator>==</operator> <name>capacity_stack</name><operator>)</operator> <operator>||</operator> 
                <operator>(</operator><name>PART_PREPARE_SEND_STARTER</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>&amp;&amp;</operator> 
                    <name>SEND_STARTER</name> <operator>==</operator> <name>capacity_stack</name><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name>PART_PREPARE_SEND_STARTXID</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>&amp;&amp;</operator> 
                    <name>SEND_STARTXID</name> <operator>==</operator> <name>capacity_stack</name><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name>PART_PREPARE_SEND_PARTNODES</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>&amp;&amp;</operator> 
                    <name>SEND_PARTNODES</name> <operator>==</operator> <name>capacity_stack</name><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name>PART_PREPARE_SEND_QUERY</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>&amp;&amp;</operator> 
                    <name>SEND_QUERY</name> <operator>==</operator> <name>capacity_stack</name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>IN_PREPARE_ERROR</name> <operator>==</operator> <name>twophase_in</name> <operator>&amp;&amp;</operator> 
            <name>PREPARE_ERROR_SEND_QUERY</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>&amp;&amp;</operator>
                <name>SEND_QUERY</name> <operator>==</operator> <name>capacity_stack</name><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>IN_REMOTE_ABORT</name> <operator>==</operator> <name>twophase_in</name> <operator>&amp;&amp;</operator>
            <name>PART_ABORT_SEND_ROLLBACK</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>&amp;&amp;</operator>
                <name>SEND_ROLLBACK</name> <operator>==</operator> <name>capacity_stack</name><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>IN_REMOTE_FINISH</name> <operator>==</operator> <name>twophase_in</name> <operator>&amp;&amp;</operator>
            <operator>(</operator><operator>(</operator><name>PART_COMMIT_SEND_TIMESTAMP</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>&amp;&amp;</operator>
                <name>SEND_COMMIT_TIMESTAMP</name> <operator>==</operator> <name>capacity_stack</name><operator>)</operator> <operator>||</operator>
                <operator>(</operator><name>PART_COMMIT_SEND_QUERY</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>&amp;&amp;</operator>
                    <name>SEND_QUERY</name> <operator>==</operator> <name>capacity_stack</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>exception_count</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><literal type="number">2</literal> <operator>==</operator> <name>exception_count</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>complish</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>IN_REMOTE_FINISH</name> <operator>==</operator> <name>twophase_in</name> <operator>&amp;&amp;</operator>
                <operator>(</operator><operator>(</operator><name>PART_COMMIT_SEND_TIMESTAMP</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>&amp;&amp;</operator>
                    <name>SEND_COMMIT_TIMESTAMP</name> <operator>==</operator> <name>capacity_stack</name><operator>)</operator> <operator>||</operator>
                    <operator>(</operator><name>PART_COMMIT_SEND_QUERY</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>&amp;&amp;</operator>
                        <name>SEND_QUERY</name> <operator>==</operator> <name>capacity_stack</name><operator>)</operator><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>run_pg_clean</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>complish</name> <operator>&amp;&amp;</operator> <name>run_pg_clean</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"complete test case"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>newbuf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>capacity_stack</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>IN_PG_CLEAN</name> <operator>==</operator> <name>twophase_in</name> <operator>&amp;&amp;</operator> 
        <operator>(</operator><operator>(</operator><name>PG_CLEAN_SEND_CLEAN</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>&amp;&amp;</operator>
            <name>SEND_PGCLEAN</name> <operator>==</operator> <name>capacity_stack</name><operator>)</operator> <operator>||</operator> 
            <operator>(</operator><name>PG_CLEAN_SEND_READONLY</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>&amp;&amp;</operator>
                <name>SEND_READONLY</name> <operator>==</operator> <name>capacity_stack</name><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name>PG_CLEAN_SEND_AFTER_PREPARE</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>&amp;&amp;</operator>
                <name>SEND_AFTER_PREPARE</name> <operator>==</operator> <name>capacity_stack</name><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name>PG_CLEAN_SEND_TIMESTAMP</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>&amp;&amp;</operator>
                <name>SEND_COMMIT_TIMESTAMP</name> <operator>==</operator> <name>capacity_stack</name><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name>PG_CLEAN_SEND_STARTER</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>&amp;&amp;</operator>
                <name>SEND_STARTER</name> <operator>==</operator> <name>capacity_stack</name><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name>PG_CLEAN_SEND_STARTXID</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>&amp;&amp;</operator>
                <name>SEND_STARTXID</name> <operator>==</operator> <name>capacity_stack</name><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name>PG_CLEAN_SEND_PARTNODES</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>&amp;&amp;</operator>
                <name>SEND_PARTNODES</name> <operator>==</operator> <name>capacity_stack</name><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name>PG_CLEAN_SEND_QUERY</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>&amp;&amp;</operator>
                <name>SEND_QUERY</name> <operator>==</operator> <name>capacity_stack</name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><literal type="number">2</literal> <operator>==</operator> <name>exception_count</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>newbuf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>newbuf</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>=</operator> <name>newbuf</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outSize</name></name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>EOF</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Send specified amount of data from the outgoing buffer over the connection
 */</comment>
<function><type><name>int</name></type>
<name>send_some</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>remaining</name> <init>= <expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* while there's still data to send */</comment>
    <while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>sent</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
        <expr_stmt><expr><name>sent</name> <operator>=</operator> <call><name>send</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <comment type="block">/*
         * Windows can fail on large sends, per KB article Q201213. The failure-point
         * appears to be different in different versions of Windows, but 64k should
         * always be safe.
         */</comment>
        <expr_stmt><expr><name>sent</name> <operator>=</operator> <call><name>send</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">65536</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if_stmt><if>if <condition>(<expr><name>sent</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Anything except EAGAIN/EWOULDBLOCK/EINTR is trouble. If it's
             * EPIPE or ECONNRESET, assume we've lost the backend connection
             * permanently.
             */</comment>
            <switch>switch <condition>(<expr><name>errno</name></expr>)</condition>
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAGAIN</name></cpp:ifdef>
                <case>case <expr><name>EAGAIN</name></expr>:</case>
                    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EWOULDBLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EAGAIN</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>EWOULDBLOCK</name> <operator>!=</operator> <name>EAGAIN</name><operator>)</operator><operator>)</operator></expr></cpp:if>
                <case>case <expr><name>EWOULDBLOCK</name></expr>:</case>
                    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <case>case <expr><name>EINTR</name></expr>:</case>
                    <continue>continue;</continue>

                <case>case <expr><name>EPIPE</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ECONNRESET</name></cpp:ifdef>
                <case>case <expr><name>ECONNRESET</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"server closed the connection unexpectedly\n"</literal>
                    <literal type="string">"\tThis probably means the server terminated abnormally\n"</literal>
                              <literal type="string">"\tbefore or while processing the request.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>handle</name></expr></argument>,
							<argument><expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/*
                     * We used to close the socket here, but that's a bad idea
                     * since there might be unread data waiting (typically, a
                     * NOTICE message from the backend telling us it's
                     * committing hara-kiri...).  Leave the socket open until
                     * pqReadData finds no more data can be read.  But abandon
                     * attempt to send data.
                     */</comment>
                    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

                <default>default:</default>
                    <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"could not send data to server"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* We don't assume it's a fatal error... */</comment>
                    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></switch>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>sent</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>len</name> <operator>-=</operator> <name>sent</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>remaining</name> <operator>-=</operator> <name>sent</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name></type> <name>pool_fd</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>poll_ret</name></decl>;</decl_stmt>

            <comment type="block">/*
             * Wait for the socket to become ready again to receive more data.
             * For some cases, especially while writing large sums of data
             * during COPY protocol and when the remote node is not capable of
             * handling data at the same speed, we might otherwise go in a
             * useless tight loop, consuming all available local resources
             *
             * Use a small timeout of 1s to avoid infinite wait
             */</comment>
            <expr_stmt><expr><name><name>pool_fd</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pool_fd</name><operator>.</operator><name>events</name></name> <operator>=</operator> <name>POLLOUT</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>poll_ret</name> <operator>=</operator> <call><name>poll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pool_fd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>poll_ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EAGAIN</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"poll failed "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>poll_ret</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>pool_fd</name><operator>.</operator><name>revents</name></name> <operator>&amp;</operator> <name>POLLHUP</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"remote end disconnected"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* shift the remaining contents of the buffer */</comment>
    <if_stmt><if>if <condition>(<expr><name>remaining</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>remaining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>=</operator> <name>remaining</name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send PARSE message with specified statement down to the Datanode
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_send_parse</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type> <name>handle</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>statement</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>short</name></type> <name>num_params</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>param_types</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* statement name size (allow NULL) */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>stmtLen</name> <init>= <expr><ternary><condition><expr><name>statement</name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>statement</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <comment type="block">/* size of query string */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>strLen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>         <modifier>*</modifier><modifier>*</modifier></type><name>paramTypes</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_params</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* total size of parameter type names */</comment>
    <decl_stmt><decl><type><name>int</name></type>         <name>paramTypeLen</name></decl>;</decl_stmt>
    <comment type="block">/* message length */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>msgLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>cnt_params</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
    <decl_stmt><decl><type><name>size_t</name></type>        <name>old_outEnd</name> <init>= <expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<decl_stmt><decl><type><name>ResponseCombiner</name>	<modifier>*</modifier></type><name>combiner</name> <init>= <expr><name><name>handle</name><operator>-&gt;</operator><name>combiner</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>				<name>need_rewrite</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>					<name>rewriteLen</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* if there are parameters, param_types should exist */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>num_params</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>param_types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* 2 bytes for number of parameters, preceding the type names */</comment>
    <expr_stmt><expr><name>paramTypeLen</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <comment type="block">/* find names of the types of parameters */</comment>
    <for>for <control>(<init><expr><name>cnt_params</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt_params</name> <operator>&lt;</operator> <name>num_params</name></expr>;</condition> <incr><expr><name>cnt_params</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type> <name>typeoid</name></decl>;</decl_stmt>

        <comment type="block">/* Parameters with no types are simply ignored */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>param_types</name><index>[<expr><name>cnt_params</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>typeoid</name> <operator>=</operator> <name><name>param_types</name><index>[<expr><name>cnt_params</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>typeoid</name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name><name>paramTypes</name><index>[<expr><name>cnt_params</name></expr>]</index></name> <operator>=</operator> <call><name>format_type_be</name><argument_list>(<argument><expr><name>typeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>paramTypeLen</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>paramTypes</name><index>[<expr><name>cnt_params</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>

	<comment type="block">/* size + rewriteLen + stmtLen + strlen + paramTypeLen */</comment>
	<expr_stmt><expr><name>msgLen</name> <operator>=</operator> <literal type="number">4</literal> <operator>+</operator> <name>rewriteLen</name> <operator>+</operator> <name>stmtLen</name> <operator>+</operator> <name>strLen</name> <operator>+</operator> <name>paramTypeLen</name></expr>;</expr_stmt>

    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msgLen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'P'</literal></expr>;</expr_stmt>
    <comment type="block">/* size */</comment>
    <expr_stmt><expr><name>msgLen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msgLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msgLen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <comment type="block">/* statement name */</comment>
    <if_stmt><if>if <condition>(<expr><name>statement</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name>statement</name></expr></argument>, <argument><expr><name>stmtLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <name>stmtLen</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <comment type="block">/* query */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>strLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <name>strLen</name></expr>;</expr_stmt>
    <comment type="block">/* parameter types */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>num_params</name></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>short</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>)</operator><operator>)</operator> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name>num_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>num_params</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <comment type="block">/*
     * instead of parameter ids we should send parameter names (qualified by
     * schema name if required). The OIDs of types can be different on
     * Datanodes.
     */</comment>
    <for>for <control>(<init><expr><name>cnt_params</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt_params</name> <operator>&lt;</operator> <name>num_params</name></expr>;</condition> <incr><expr><name>cnt_params</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name><name>paramTypes</name><index>[<expr><name>cnt_params</name></expr>]</index></name></expr></argument>,
                    <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>paramTypes</name><index>[<expr><name>cnt_params</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>paramTypes</name><index>[<expr><name>cnt_params</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>paramTypes</name><index>[<expr><name>cnt_params</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>paramTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the extended query contains an insert sql command whose
	 * distribute key's value is a function, we caculte the function
	 * and rewrite the insert sql with the const result. So after send
	 * the sql to datanode, it will be cached, However, the sql command
	 * changes as the result of the function, so datanode should use
	 * the new sql instead of cached sql. The we send a 'need_rewrite'
	 * flag to tell the datanode to use new sql.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><operator>(</operator><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator></expr></argument>, <argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>RemoteQuery</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>exec_nodes</name> <init>= <expr><name><name>plan</name><operator>-&gt;</operator><name>exec_nodes</name></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>exec_nodes</name> <operator>&amp;&amp;</operator> <name><name>exec_nodes</name><operator>-&gt;</operator><name>need_rewrite</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'Y'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>need_rewrite</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_rewrite</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'N'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>old_outEnd</name> <operator>+</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>msgLen</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

     <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send PLAN message down to the Data node
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_send_plan</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type> <name>handle</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>statement</name></decl></parameter>,
                    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>planstr</name></decl></parameter>,
					<parameter><decl><type><name>short</name></type> <name>num_params</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>param_types</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>instrument_options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>stmtLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>queryLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>planLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>paramTypeLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>msgLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>paramTypes</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_params</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>short</name></type>        <name>tmp_num_params</name></decl>;</decl_stmt>

    <comment type="block">/* Invalid connection state, return error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* statement name size (do not allow NULL) */</comment>
    <expr_stmt><expr><name>stmtLen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>statement</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <comment type="block">/* source query size (do not allow NULL) */</comment>
    <expr_stmt><expr><name>queryLen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <comment type="block">/* query plan size (do not allow NULL) */</comment>
    <expr_stmt><expr><name>planLen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>planstr</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <comment type="block">/* 2 bytes for number of parameters, preceding the type names */</comment>
    <expr_stmt><expr><name>paramTypeLen</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <comment type="block">/* find names of the types of parameters */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_params</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>paramTypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>format_type_be</name><argument_list>(<argument><expr><name><name>param_types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>paramTypeLen</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>paramTypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></for>
	<comment type="block">/* size + pnameLen + queryLen + parameters + instrument_options */</comment>
	<expr_stmt><expr><name>msgLen</name> <operator>=</operator> <literal type="number">4</literal> <operator>+</operator> <name>queryLen</name> <operator>+</operator> <name>stmtLen</name> <operator>+</operator> <name>planLen</name> <operator>+</operator> <name>paramTypeLen</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msgLen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt>
    <comment type="block">/* size */</comment>
    <expr_stmt><expr><name>msgLen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msgLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msgLen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <comment type="block">/* statement name */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name>statement</name></expr></argument>, <argument><expr><name>stmtLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <name>stmtLen</name></expr>;</expr_stmt>
    <comment type="block">/* source query */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>queryLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <name>queryLen</name></expr>;</expr_stmt>
    <comment type="block">/* query plan */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name>planstr</name></expr></argument>, <argument><expr><name>planLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <name>planLen</name></expr>;</expr_stmt>
    <comment type="block">/* parameter types */</comment>
    <expr_stmt><expr><name>tmp_num_params</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name>num_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_num_params</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp_num_params</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tmp_num_params</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <comment type="block">/*
     * instead of parameter ids we should send parameter names (qualified by
     * schema name if required). The OIDs of types can be different on
     * datanodes.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_params</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>plen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>paramTypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name><name>paramTypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>plen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <name>plen</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>paramTypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>paramTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* instrument_options */</comment>
	<expr_stmt><expr><name>instrument_options</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>instrument_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>instrument_options</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>last_command</name></name> <operator>=</operator> <literal type="char">'a'</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>in_extended_query</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
     <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send BIND message down to the Datanode
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_send_bind</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type> <name>handle</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>portal</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>statement</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>paramlen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>epqctxlen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>epqctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>pnameLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>stmtLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>paramCodeLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>paramValueLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>paramOutLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>epqCtxLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>msgLen</name></decl>;</decl_stmt>

    <comment type="block">/* Invalid connection state, return error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* portal name size (allow NULL) */</comment>
    <expr_stmt><expr><name>pnameLen</name> <operator>=</operator> <ternary><condition><expr><name>portal</name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    <comment type="block">/* statement name size (allow NULL) */</comment>
    <expr_stmt><expr><name>stmtLen</name> <operator>=</operator> <ternary><condition><expr><name>statement</name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>statement</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    <comment type="block">/* size of parameter codes array (always empty for now) */</comment>
    <expr_stmt><expr><name>paramCodeLen</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <comment type="block">/* size of parameter values array, 2 if no params */</comment>
    <expr_stmt><expr><name>paramValueLen</name> <operator>=</operator> <ternary><condition><expr><name>paramlen</name></expr> ?</condition><then> <expr><name>paramlen</name></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr>;</expr_stmt>
    <comment type="block">/* size of output parameter codes array (always empty for now) */</comment>
    <expr_stmt><expr><name>paramOutLen</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<comment type="block">/* size of epq context, 2 if not epq */</comment>
	<expr_stmt><expr><name>epqCtxLen</name> <operator>=</operator> <ternary><condition><expr><name>epqctxlen</name></expr> ?</condition><then> <expr><name>epqctxlen</name></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr>;</expr_stmt>
    <comment type="block">/* size + pnameLen + stmtLen + parameters */</comment>
	<expr_stmt><expr><name>msgLen</name> <operator>=</operator> <literal type="number">4</literal> <operator>+</operator> <name>pnameLen</name> <operator>+</operator> <name>stmtLen</name> <operator>+</operator> <name>paramCodeLen</name> <operator>+</operator> <name>paramValueLen</name> <operator>+</operator> <name>paramOutLen</name> <operator>+</operator> <name>epqCtxLen</name></expr>;</expr_stmt>

    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msgLen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'B'</literal></expr>;</expr_stmt>
    <comment type="block">/* size */</comment>
    <expr_stmt><expr><name>msgLen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msgLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msgLen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <comment type="block">/* portal name */</comment>
    <if_stmt><if>if <condition>(<expr><name>portal</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name>portal</name></expr></argument>, <argument><expr><name>pnameLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <name>pnameLen</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <comment type="block">/* statement name */</comment>
    <if_stmt><if>if <condition>(<expr><name>statement</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name>statement</name></expr></argument>, <argument><expr><name>stmtLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <name>stmtLen</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <comment type="block">/* parameter codes (none) */</comment>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <comment type="block">/* parameter values */</comment>
    <if_stmt><if>if <condition>(<expr><name>paramlen</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>paramlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <name>paramlen</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <comment type="block">/* output parameter codes (none) */</comment>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* output epq context */</comment>
	<if_stmt><if>if <condition>(<expr><name>epqctxlen</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name>epqctx</name></expr></argument>, <argument><expr><name>epqctxlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <name>epqctxlen</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>in_extended_query</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
     <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Send DESCRIBE message (portal or statement) down to the Datanode
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_send_describe</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type> <name>handle</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_statement</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>nameLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>msgLen</name></decl>;</decl_stmt>

    <comment type="block">/* Invalid connection state, return error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* statement or portal name size (allow NULL) */</comment>
    <expr_stmt><expr><name>nameLen</name> <operator>=</operator> <ternary><condition><expr><name>name</name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/* size + statement/portal + name */</comment>
    <expr_stmt><expr><name>msgLen</name> <operator>=</operator> <literal type="number">4</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>nameLen</name></expr>;</expr_stmt>

    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msgLen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'D'</literal></expr>;</expr_stmt>
    <comment type="block">/* size */</comment>
    <expr_stmt><expr><name>msgLen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msgLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msgLen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <comment type="block">/* statement/portal flag */</comment>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>is_statement</name></expr> ?</condition><then> <expr><literal type="char">'S'</literal></expr> </then><else>: <expr><literal type="char">'P'</literal></expr></else></ternary></expr>;</expr_stmt>
    <comment type="block">/* object name */</comment>
    <if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nameLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <name>nameLen</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>in_extended_query</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
     <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Send CLOSE message (portal or statement) down to the Datanode
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_send_close</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type> <name>handle</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_statement</name></decl></parameter>,
                     <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* statement or portal name size (allow NULL) */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>nameLen</name> <init>= <expr><ternary><condition><expr><name>name</name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <comment type="block">/* size + statement/portal + name */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>msgLen</name> <init>= <expr><literal type="number">4</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>nameLen</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msgLen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'C'</literal></expr>;</expr_stmt>
    <comment type="block">/* size */</comment>
    <expr_stmt><expr><name>msgLen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msgLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msgLen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <comment type="block">/* statement/portal flag */</comment>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>is_statement</name></expr> ?</condition><then> <expr><literal type="char">'S'</literal></expr> </then><else>: <expr><literal type="char">'P'</literal></expr></else></ternary></expr>;</expr_stmt>
    <comment type="block">/* object name */</comment>
    <if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nameLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <name>nameLen</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>in_extended_query</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
     <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send EXECUTE message down to the Datanode
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_send_execute</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type> <name>handle</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>portal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fetch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* portal name size (allow NULL) */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>pnameLen</name> <init>= <expr><ternary><condition><expr><name>portal</name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <comment type="block">/* size + pnameLen + fetchLen */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>msgLen</name> <init>= <expr><literal type="number">4</literal> <operator>+</operator> <name>pnameLen</name> <operator>+</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msgLen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'E'</literal></expr>;</expr_stmt>
    <comment type="block">/* size */</comment>
    <expr_stmt><expr><name>msgLen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msgLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msgLen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <comment type="block">/* portal name */</comment>
    <if_stmt><if>if <condition>(<expr><name>portal</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name>portal</name></expr></argument>, <argument><expr><name>pnameLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <name>pnameLen</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* fetch */</comment>
    <expr_stmt><expr><name>fetch</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>fetch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fetch</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_QUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>in_extended_query</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Send FLUSH message down to the Datanode
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_send_flush</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type> <name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* size */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>msgLen</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msgLen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'H'</literal></expr>;</expr_stmt>
    <comment type="block">/* size */</comment>
    <expr_stmt><expr><name>msgLen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msgLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msgLen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>in_extended_query</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <return>return <expr><call><name>pgxc_node_flush</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Send SYNC message down to the Datanode
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_send_sync</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type> <name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* size */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>msgLen</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msgLen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'S'</literal></expr>;</expr_stmt>
    <comment type="block">/* size */</comment>
    <expr_stmt><expr><name>msgLen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msgLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msgLen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>in_extended_query</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>needSync</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <return>return <expr><call><name>pgxc_node_flush</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Send SYNC message down to the Datanode
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_send_my_sync</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type> <name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* size */</comment>
    <decl_stmt><decl><type><name>int</name></type>			<name>msgLen</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msgLen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'L'</literal></expr>;</expr_stmt>
    <comment type="block">/* size */</comment>
    <expr_stmt><expr><name>msgLen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msgLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msgLen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>in_extended_query</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>needSync</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>msgLen</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msgLen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'H'</literal></expr>;</expr_stmt>
    <comment type="block">/* size */</comment>
    <expr_stmt><expr><name>msgLen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msgLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msgLen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>in_extended_query</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <return>return <expr><call><name>pgxc_node_flush</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
<comment type="block">/*
 * Send logical apply message down to the Datanode
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_send_apply</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type> <name>handle</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ignore_pk_conflict</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>    <name>msgLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* size + ignore_pk_conflict + len */</comment>
    <expr_stmt><expr><name>msgLen</name> <operator>=</operator> <literal type="number">4</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msgLen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'a'</literal></expr>;</expr_stmt>        <comment type="block">/* logical apply */</comment>

    <expr_stmt><expr><name>msgLen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msgLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msgLen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>ignore_pk_conflict</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'Y'</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'N'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_QUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>in_extended_query</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
     <return>return <expr><call><name>pgxc_node_flush</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Send series of Extended Query protocol messages to the data node
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_send_query_extended</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>statement</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>portal</name></decl></parameter>,
                              <parameter><decl><type><name>int</name></type> <name>num_params</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>param_types</name></decl></parameter>,
                              <parameter><decl><type><name>int</name></type> <name>paramlen</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>params</name></decl></parameter>,
                              <parameter><decl><type><name>bool</name></type> <name>send_describe</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fetch_size</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* NULL query indicates already prepared statement */</comment>
    <if_stmt><if>if <condition>(<expr><name>query</name></expr>)</condition><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_parse</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>statement</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>num_params</name></expr></argument>, <argument><expr><name>param_types</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_bind</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>portal</name></expr></argument>, <argument><expr><name>statement</name></expr></argument>, <argument><expr><name>paramlen</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>send_describe</name></expr>)</condition><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_describe</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>fetch_size</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_execute</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>portal</name></expr></argument>, <argument><expr><name>fetch_size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_my_sync</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * This method won't return until connection buffer is empty or error occurs
 * To ensure all data are on the wire before waiting for response
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_flush</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <while>while <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>send_some</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int32</name></type> <name>error</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_flush data to datanode:%u fd:%d failed for %s"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"failed to send data to datanode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
            <comment type="block">/*
             * before returning, also update the shared health
             * status field to indicate that this node could be
             * possibly unavailable.
             *
             * Note that this error could be due to a stale handle
             * and it's possible that another backend might have
             * already updated the health status OR the node
             * might have already come back since the last disruption
             */</comment>
            PoolPingNodeRecheck(handle-&gt;nodeoid);
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>error</name></expr>;</expr_stmt>
            <return>return <expr><name>EOF</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This method won't return until network buffer is empty or error occurs
 * To ensure all data in network buffers is read and wasted
  *
  * There are only two possible returns. Return 0 is ok, return is an EOF error when the link is broken.
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_flush_read</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>    <name>is_ready</name><init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>    <name>read_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>	<name>wait_time</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>handle</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>    

    <while>while<condition>(<expr><name>true</name></expr>)</condition>
    <block>{<block_content>        
        <comment type="block">/* consume all data */</comment>
        <while>while <condition>(<expr><call><name>HAS_MESSAGE_BUFFERED</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>is_ready</name> <operator>=</operator> <call><name>is_data_node_ready</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_is_data_enqueued</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>            
            <expr_stmt><expr><call><name>pgxc_node_read_data</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/* break, only if the connection is ready for query. */</comment>
        <if_stmt><if>if <condition>(<expr><name>is_ready</name></expr>)</condition>
        <block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_flush_read node:%s ready for query."</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>        

        <comment type="block">/* break, only if the connection is broken. */</comment>
        <expr_stmt><expr><name>read_result</name> <operator>=</operator> <call><name>pgxc_node_read_data</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If no data can be received, the normal break returns success */</comment>
		<if_stmt><if>if <condition>(<expr><name>read_result</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_flush_read node:%s read failure."</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if>
		<comment type="block">/* If the link breaks, an EOF error is returned */</comment>
		<if type="elseif">else if <condition>(<expr><name>read_result</name> <operator>==</operator> <name>EOF</name> <operator>||</operator> <name>read_result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_flush_read unexpected EOF on node:%s"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>EOF</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>PGXC_CANCEL_DELAY</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_flush_read sleep %dus"</literal></expr></argument>, <argument><expr><name>wait_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>wait_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>wait_time</name> <operator>&lt;</operator> <name>PGXC_CANCEL_DELAY</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>wait_time</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>wait_time</name> <operator>&gt;</operator> <name>PGXC_CANCEL_DELAY</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>wait_time</name> <operator>=</operator> <name>PGXC_CANCEL_DELAY</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send specified statement down to the PGXC node
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pgxc_node_send_query_internal</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type> <name>handle</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
        <parameter><decl><type><name>bool</name></type> <name>rollback</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>strLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>msgLen</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Its appropriate to send ROLLBACK commands on a failed connection, but
     * for everything else we expect the connection to be in a sane state
     */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_send_query - handle-&gt;nodename=%s, handle-&gt;sock=%d, "</literal>
			  <literal type="string">"handle-&gt;read_only=%d, handle-&gt;transaction_status=%c, handle-&gt;state %d, node %s, query: %s"</literal></expr></argument>,
			  <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>read_only</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>transaction_status</name></name></expr></argument>,
			  <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>!</operator><operator>(</operator><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DN_CONNECTION_STATE_ERROR_FATAL</name> <operator>&amp;&amp;</operator> <name>rollback</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_send_query_internal datanode:%u invalid status:%d, no need to send data, return NOW"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>strLen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <comment type="block">/* size + strlen */</comment>
    <expr_stmt><expr><name>msgLen</name> <operator>=</operator> <literal type="number">4</literal> <operator>+</operator> <name>strLen</name></expr>;</expr_stmt>

    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msgLen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'Q'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>msgLen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msgLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msgLen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>strLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <name>strLen</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_QUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>in_extended_query</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
     <return>return <expr><call><name>pgxc_node_flush</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pgxc_node_send_rollback</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
     <if_stmt><if>if <condition>(<expr><literal type="char">'\0'</literal> <operator>!=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>gid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>capacity_stack</name> <operator>=</operator> <name>SEND_ROLLBACK</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><call><name>pgxc_node_send_query_internal</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pgxc_node_send_query</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
     <if_stmt><if>if <condition>(<expr><operator>(</operator><name>IN_REMOTE_PREPARE</name> <operator>==</operator> <name>twophase_in</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>handle</name><operator>-&gt;</operator><name>read_only</name></name><operator>)</operator> <operator>||</operator>
        <name>IN_PREPARE_ERROR</name> <operator>==</operator> <name>twophase_in</name> <operator>||</operator>
        <name>IN_REMOTE_FINISH</name> <operator>==</operator> <name>twophase_in</name> <operator>||</operator>
        <name>IN_PG_CLEAN</name> <operator>==</operator> <name>twophase_in</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>capacity_stack</name> <operator>=</operator> <name>SEND_QUERY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><call><name>pgxc_node_send_query_internal</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send the GID down to the PGXC node
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_send_gid</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>gid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>msglen</name> <init>= <expr><literal type="number">4</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Invalid connection state, return error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_send_gid datanode:%u invalid stauts:%d, no need to send data, return NOW"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msglen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"send gid %s"</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'G'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>msglen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msglen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name>gid</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
<comment type="block">/*
 * Send the startnode down to the PGXC node
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_send_starter</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>startnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>msglen</name> <init>= <expr><literal type="number">4</literal> <operator>+</operator> <call><name>strnlen</name><argument_list>(<argument><expr><name>startnode</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt> 

    <comment type="block">/* Invalid connection state, return error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_send_starter datanode:%u invalid stauts:%d, no need to send data, return NOW"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
    <expr_stmt><expr><name>capacity_stack</name> <operator>=</operator> <name>SEND_STARTER</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msglen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"in function pgxc_node_send_starter, error: out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"send startnode %s"</literal></expr></argument>, <argument><expr><name>startnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'e'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>msglen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msglen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name>startnode</name></expr></argument>, <argument><expr><call><name>strnlen</name><argument_list>(<argument><expr><name>startnode</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <operator>(</operator><call><name>strnlen</name><argument_list>(<argument><expr><name>startnode</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> 
<name>pgxc_node_send_startxid</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>GlobalTransactionId</name></type> <name>transactionid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>msglen</name> <init>= <expr><literal type="number">4</literal> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTransactionId</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>i32</name></decl>;</decl_stmt>

    <comment type="block">/* Invalid connection state, return error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_send_startxid datanode:%u invalid stauts:%d, no need to send data, return NOW"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
    <expr_stmt><expr><name>capacity_stack</name> <operator>=</operator> <name>SEND_STARTXID</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msglen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"in function pgxc_node_send_startxid, error: out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"send transactionid %u"</literal></expr></argument>, <argument><expr><name>transactionid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'x'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>msglen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msglen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>i32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>transactionid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GlobalTransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send the partnodes down to the PGXC node
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_send_partnodes</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>partnodes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>msglen</name> <init>= <expr><literal type="number">4</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>partnodes</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt> 

    <comment type="block">/* Invalid connection state, return error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_send_partnodes datanode:%u invalid stauts:%d, no need to send data, return NOW"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
    <expr_stmt><expr><name>capacity_stack</name> <operator>=</operator> <name>SEND_PARTNODES</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msglen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"in function pgxc_node_send_partnodes, error: out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"send partnodes %s"</literal></expr></argument>, <argument><expr><name>partnodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'R'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>msglen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msglen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name>partnodes</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>partnodes</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>partnodes</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * when execute in pg_clean, we allowed to truncate the exists 2pc file 
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_send_clean</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>msglen</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Invalid connection state, return error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_send_clean datanode:%u invalid stauts:%d, no need to send data, return NOW"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IN_PG_CLEAN</name> <operator>==</operator> <name>twophase_in</name> <operator>&amp;&amp;</operator> 
        <name>PG_CLEAN_SEND_CLEAN</name> <operator>==</operator> <name>twophase_exception_case</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>capacity_stack</name> <operator>=</operator> <name>SEND_PGCLEAN</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msglen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"in function pgxc_node_send_clean, error: out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'n'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>msglen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msglen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pgxc_node_send_readonly</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>msglen</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Invalid connection state, return error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_send_readonly datanode:%u invalid stauts:%d, no need to send data, return NOW"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IN_PG_CLEAN</name> <operator>==</operator> <name>twophase_in</name> <operator>&amp;&amp;</operator> 
        <name>PG_CLEAN_SEND_READONLY</name> <operator>==</operator> <name>twophase_exception_case</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>capacity_stack</name> <operator>=</operator> <name>SEND_READONLY</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msglen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"in function pgxc_node_send_clean, error: out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'r'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>msglen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msglen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pgxc_node_send_after_prepare</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>msglen</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Invalid connection state, return error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_send_after_prepare datanode:%u invalid stauts:%d, no need to send data, return NOW"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IN_PG_CLEAN</name> <operator>==</operator> <name>twophase_in</name> <operator>&amp;&amp;</operator> 
        <name>PG_CLEAN_SEND_AFTER_PREPARE</name> <operator>==</operator> <name>twophase_exception_case</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>capacity_stack</name> <operator>=</operator> <name>SEND_AFTER_PREPARE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msglen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"in function pgxc_node_send_clean, error: out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'A'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>msglen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msglen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Send the GXID down to the PGXC node
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_send_gxid</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>GlobalTransactionId</name></type> <name>gxid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>msglen</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>char</name>         <modifier>*</modifier></type><name>globalXidString</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>globalXidString</name> <operator>=</operator> <call><name>GetGlobalXidNoCheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>NULL</name> <operator>==</operator> <name>globalXidString</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"handle node name %s send version "</literal> <name>UINT64_FORMAT</name> <literal type="string">" global xid %s"</literal></expr></argument>, 
            <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sendGxidVersion</name></name></expr></argument>, <argument><expr><name>globalXidString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Invalid connection state, return error */</comment>
    <expr_stmt><expr><name>msglen</name> <operator>=</operator> <literal type="number">4</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>globalXidString</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_send_gid datanode:%u invalid stauts:%d, no need to send data, return NOW"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msglen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'g'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>msglen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msglen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name>globalXidString</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>globalXidString</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>globalXidString</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>sendGxidVersion</name></name> <operator>=</operator> <call><name>GetGlobalXidVersion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* Invalid connection state, return error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msglen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'g'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>msglen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msglen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gxid</name></expr></argument>, <argument><expr><sizeof>sizeof
            <argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send the Command ID down to the PGXC node
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_send_cmd_id</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>msglen</name> <init>= <expr><name>CMD_ID_MSG_LEN</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i32</name></decl>;</decl_stmt>

    <comment type="block">/* No need to send command ID if its sending flag is not enabled */</comment>
	<comment type="block">/* XXX: parallel worker always send cid */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSendCommandId</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Invalid connection state, return error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_send_cmd_id datanode:%u invalid stauts:%d, no need to send data, return NOW"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msglen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'M'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>msglen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msglen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>i32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>cid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send the snapshot down to the PGXC node
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_send_snapshot</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name>            <name>msglen</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>

    <comment type="block">/* Invalid connection state, return error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_send_snapshot datanode:%u invalid stauts:%d, no need to send data, return NOW"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>local</name></name> <operator>&amp;&amp;</operator> <name>g_set_global_snapshot</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"don't send local snapshot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>msglen</name> <operator>=</operator> <literal type="number">12</literal></expr>;</expr_stmt> <comment type="block">/* 4 bytes for msglen and 8 bytes for timestamp (int64) */</comment>
    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msglen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'s'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>msglen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msglen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"send snapshot start_ts"</literal> <name>INT64_FORMAT</name> <literal type="string">" xid %d."</literal></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr></argument>, <argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>snapshot</name><operator>-&gt;</operator><name>local</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GlobalTimestamp</name></type> <name>start_ts</name> <init>= <expr><name>LocalCommitTimestamp</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_ts</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>snapshot</name><operator>-&gt;</operator><name>start_ts</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>GlobalTimestamp</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send the timestamp down to the PGXC node
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_send_prefinish_timestamp</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>GlobalTimestamp</name></type> <name>timestamp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>     <name>msglen</name> <init>= <expr><literal type="number">12</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* 4 bytes for msglen and 8 bytes for timestamp (int64) */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>    <name>n32</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>    <name>i</name> <init>= <expr><operator>(</operator><name>int64</name><operator>)</operator> <name>timestamp</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Invalid connection state, return error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_send_prefinish_timestamp datanode:%u invalid stauts:%d, no need to send data, return NOW"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"send prefinish timestamp "</literal> <name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msglen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'W'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>msglen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msglen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <comment type="block">/* High order half first */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>INT64_IS_BUSTED</name></cpp:ifdef>
    <comment type="block">/* don't try a right shift of 32 on a 32-bit word */</comment>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <comment type="block">/* Now the low order half */</comment>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_QUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Send the timestamp down to the PGXC node
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_send_prepare_timestamp</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>GlobalTimestamp</name></type> <name>timestamp</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>     <name>msglen</name> <init>= <expr><literal type="number">12</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* 4 bytes for msglen and 8 bytes for timestamp (int64) */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>    <name>n32</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>    <name>i</name> <init>= <expr><operator>(</operator><name>int64</name><operator>)</operator> <name>timestamp</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>GlobalTimestampIsValid</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"prepare timestamp is not valid for sending"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Invalid connection state, return error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_send_prepare_timestamp datanode:%u invalid stauts:%d, no need to send data, return NOW"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>handle</name><operator>-&gt;</operator><name>read_only</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>capacity_stack</name> <operator>=</operator> <name>SEND_PREPARE_TIMESTAMP</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msglen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'Z'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>msglen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msglen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <comment type="block">/* High order half first */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>INT64_IS_BUSTED</name></cpp:ifdef>
    <comment type="block">/* don't try a right shift of 32 on a 32-bit word */</comment>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <comment type="block">/* Now the low order half */</comment>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send the timestamp down to the PGXC node
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_send_global_timestamp</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>GlobalTimestamp</name></type> <name>timestamp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>     <name>msglen</name> <init>= <expr><literal type="number">12</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* 4 bytes for msglen and 8 bytes for timestamp (int64) */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>    <name>n32</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>    <name>i</name> <init>= <expr><operator>(</operator><name>int64</name><operator>)</operator> <name>timestamp</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>GlobalTimestampIsValid</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"timestamp is not valid for sending"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* Invalid connection state, return error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_send_global_timestamp datanode:%u invalid stauts:%d, no need to send data, return NOW"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
    <expr_stmt><expr><name>capacity_stack</name> <operator>=</operator> <name>SEND_COMMIT_TIMESTAMP</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msglen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'T'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>msglen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msglen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <comment type="block">/* High order half first */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>INT64_IS_BUSTED</name></cpp:ifdef>
    <comment type="block">/* don't try a right shift of 32 on a 32-bit word */</comment>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <comment type="block">/* Now the low order half */</comment>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send the timestamp down to the PGXC node
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_send_timestamp</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>TimestampTz</name></type> <name>timestamp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>        <name>msglen</name> <init>= <expr><literal type="number">12</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* 4 bytes for msglen and 8 bytes for timestamp (int64) */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>    <name>n32</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>    <name>i</name> <init>= <expr><operator>(</operator><name>int64</name><operator>)</operator> <name>timestamp</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Invalid connection state, return error */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
			<argument><expr><literal type="string">"pgxc_node_send_timestamp datanode:%u invalid stauts:%d, "</literal>
			<literal type="string">"no need to send data, return NOW"</literal></expr></argument>,
			<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msglen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>msglen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msglen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <comment type="block">/* High order half first */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>INT64_IS_BUSTED</name></cpp:ifdef>
    <comment type="block">/* don't try a right shift of 32 on a 32-bit word */</comment>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <comment type="block">/* Now the low order half */</comment>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
 * Send the Coordinator info down to the PGXC node at the beginning of transaction,
 * In this way, Datanode can print this Coordinator info into logfile, 
 * and those infos can be found in Datanode logfile if needed during debugging
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_send_coord_info</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type> <name>handle</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>coord_pid</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name></type> <name>coord_vxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>	<name>msgLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>	<name>i32</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IS_PGXC_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* size + coord_pid + coord_vxid */</comment>
	<expr_stmt><expr><name>msgLen</name> <operator>=</operator> <literal type="number">4</literal> <operator>+</operator> <literal type="number">4</literal> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>

	<comment type="block">/* msgType + msgLen */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msgLen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_send_coord_info out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>EOF</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'U'</literal></expr>;</expr_stmt>		<comment type="block">/* coord info */</comment>

	<expr_stmt><expr><name>msgLen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msgLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msgLen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>i32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>coord_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>i32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>coord_vxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>pgxc_set_coordinator_proc_pid</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>proc_pid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>pgxc_coordinator_proc_pid</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>IS_PGXC_COORDINATOR</name></expr> ?</condition><then> <expr><name>MyProcPid</name></expr> </then><else>: <expr><name>proc_pid</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>pgxc_set_coordinator_proc_vxid</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>proc_vxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>lxid</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>MyProc</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr> </then><else>: <expr><name>InvalidTransactionId</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>pgxc_coordinator_proc_vxid</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>IS_PGXC_COORDINATOR</name></expr> ?</condition><then> <expr><name>lxid</name></expr> </then><else>: <expr><name>proc_vxid</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pgxc_get_coordinator_proc_pid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><ternary><condition><expr><name>IS_PGXC_COORDINATOR</name></expr> ?</condition><then> <expr><name>MyProcPid</name></expr> </then><else>: <expr><name>pgxc_coordinator_proc_pid</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>TransactionId</name></type>
<name>pgxc_get_coordinator_proc_vxid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>lxid</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>MyProc</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr> </then><else>: <expr><name>InvalidTransactionId</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><ternary><condition><expr><name>IS_PGXC_COORDINATOR</name></expr> ?</condition><then> <expr><name>lxid</name></expr> </then><else>: <expr><name>pgxc_coordinator_proc_vxid</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pgxc_node_send_sessionid</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type> <name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>	<name>msgLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	
	<comment type="block">/* size + sessionid_str + '\0' */</comment>
	<expr_stmt><expr><name>msgLen</name> <operator>=</operator> <literal type="number">4</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>PGXCSessionId</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	
	<comment type="block">/* msgType + msgLen */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msgLen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_send_sessionid out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>EOF</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'o'</literal></expr>;</expr_stmt>		<comment type="block">/* session id */</comment>
	
	<expr_stmt><expr><name>msgLen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msgLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msgLen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name>PGXCSessionId</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>PGXCSessionId</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>PGXCSessionId</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Add another message to the list of errors to be returned back to the client
 * at the convenient time
 */</comment>
<function><type><name>void</name></type>
<name>add_error_message</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Remote node \"%s\", running with pid %d returned an error: %s"</literal></expr></argument>,
            <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>=</operator> <literal type="char">'E'</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>error</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>message</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int32</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"add_error_message node:%s, running with pid %d non first time error before append: %s, error ptr:%lx, "</literal>
				<literal type="string">"handle-&gt;nodename=%s, handle-&gt;sock=%d, "</literal>
			  	<literal type="string">"handle-&gt;read_only=%d, handle-&gt;transaction_status=%c, handle-&gt;state %d"</literal></expr></argument>,
				<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator><name><name>handle</name><operator>-&gt;</operator><name>error</name></name></expr></argument>,
				<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>read_only</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>transaction_status</name></name></expr></argument>,
			  	<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>strnlen</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name></name></expr></argument>, <argument><expr><name>MAX_ERROR_MSG_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name></name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>MAX_ERROR_MSG_LENGTH</name> <operator>-</operator> <name>offset</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"add_error_message node:%s, running with pid %d non first time after append error: %s, ptr:%lx, "</literal>
				<literal type="string">"handle-&gt;nodename=%s, handle-&gt;sock=%d, "</literal>
			  	<literal type="string">"handle-&gt;read_only=%d, handle-&gt;transaction_status=%c, handle-&gt;state %d"</literal></expr></argument>,
				<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <name><name>handle</name><operator>-&gt;</operator><name>error</name></name></expr></argument>,
				<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>read_only</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>transaction_status</name></name></expr></argument>,
			  	<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>        
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name></name></expr></argument>, <argument><expr><name>MAX_ERROR_MSG_LENGTH</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"add_error_message node:%s, running with pid %d first time error: %s, ptr:%lx, "</literal>
				<literal type="string">"handle-&gt;nodename=%s, handle-&gt;sock=%d, "</literal>
			  	<literal type="string">"handle-&gt;read_only=%d, handle-&gt;transaction_status=%c, handle-&gt;state %d"</literal></expr></argument>,
				<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator><name><name>handle</name><operator>-&gt;</operator><name>error</name></name></expr></argument>,
				<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>read_only</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>transaction_status</name></name></expr></argument>,
			  	<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>add_error_message_from_combiner</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>combiner_input</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>combiner</name> <operator>=</operator> <operator>(</operator><name>ResponseCombiner</name><operator>*</operator><operator>)</operator><name>combiner_input</name></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Remote node \"%s\", running with pid %d returned an error: %s"</literal></expr></argument>,
            <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>=</operator> <literal type="char">'E'</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>error</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int32</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>strnlen</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name></name></expr></argument>, <argument><expr><name>MAX_ERROR_MSG_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>errorDetail</name></name> <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>errorHint</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name></name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>MAX_ERROR_MSG_LENGTH</name> <operator>-</operator> <name>offset</name></expr></argument>, <argument><expr><literal type="string">"%s:%s:%s"</literal></expr></argument>, 
                <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorDetail</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorHint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>errorDetail</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name></name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>MAX_ERROR_MSG_LENGTH</name> <operator>-</operator> <name>offset</name></expr></argument>, <argument><expr><literal type="string">"%s:%s"</literal></expr></argument>, 
                <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorDetail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name></name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>MAX_ERROR_MSG_LENGTH</name> <operator>-</operator> <name>offset</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, 
                <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"add_error_message_from_combiner node:%s, running with pid %d non first time error: %s, error ptr:%lx, "</literal>
        		<literal type="string">"handle-&gt;nodename=%s, handle-&gt;sock=%d, "</literal>
			  	<literal type="string">"handle-&gt;read_only=%d, handle-&gt;transaction_status=%c, handle-&gt;state %d"</literal></expr></argument>,
                <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator><name><name>handle</name><operator>-&gt;</operator><name>error</name></name></expr></argument>,
                <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>read_only</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>transaction_status</name></name></expr></argument>,
			  	<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr>)</condition>
    <block>{<block_content>    
        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>errorDetail</name></name> <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>errorHint</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name></name></expr></argument>, <argument><expr><name>MAX_ERROR_MSG_LENGTH</name></expr></argument>, <argument><expr><literal type="string">"%s:%s:%s"</literal></expr></argument>, 
                <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorDetail</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorHint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>errorDetail</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name></name></expr></argument>, <argument><expr><name>MAX_ERROR_MSG_LENGTH</name></expr></argument>, <argument><expr><literal type="string">"%s:%s"</literal></expr></argument>, 
                <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorDetail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name></name></expr></argument>, <argument><expr><name>MAX_ERROR_MSG_LENGTH</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, 
                <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"add_error_message_from_combiner node:%s, running with pid %d first time error: %s, ptr:%lx, "</literal>
				<literal type="string">"handle-&gt;nodename=%s, handle-&gt;sock=%d, "</literal>
			  	<literal type="string">"handle-&gt;read_only=%d, handle-&gt;transaction_status=%c, handle-&gt;state %d"</literal></expr></argument>,
				<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name></name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator><name><name>handle</name><operator>-&gt;</operator><name>error</name></name></expr></argument>,
				<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>read_only</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>transaction_status</name></name></expr></argument>,
			  	<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <return>return;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>load_balancer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<comment type="block">/*
 * Get one of the specified nodes to query replicated data source.
 * If session already owns one or more  of the requested connection,
 * the function returns existing one to avoid contacting pooler.
 * Performs basic load balancing.
 */</comment>
<function><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type>
<name>get_any_handle</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>datanodelist</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>, <decl><type ref="prev"/><name>node</name></decl>;</decl_stmt>

    <comment type="block">/* sanity check */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>datanodelist</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>datanodelist</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_QUERY_CANCELED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid NULL node list"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>HandlesRefreshPending</name></expr>)</condition><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>DoRefreshRemoteHandles</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_QUERY_CANCELED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling transaction due to cluster configuration reset by administrator command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* loop through local datanode handles */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>node</name> <operator>=</operator> <name>load_balancer</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>node</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* At the moment node is an index in the array, and we may need to wrap it */</comment>
        <if_stmt><if>if <condition>(<expr><name>node</name> <operator>&gt;=</operator> <name>NumDataNodes</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>node</name> <operator>-=</operator> <name>NumDataNodes</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/* See if handle is already used */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>dn_handles</name><index>[<expr><name>node</name></expr>]</index></name><operator>.</operator><name>sock</name> <operator>!=</operator> <name>NO_SOCKET</name></expr>)</condition>
        <block>{<block_content>
            <macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>datanodelist</argument>)</argument_list></macro>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>node</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * The node is in the list of requested nodes,
                     * set load_balancer for next time and return the handle
                     */</comment>
                    <expr_stmt><expr><name>load_balancer</name> <operator>=</operator> <name>node</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <return>return <expr><operator>&amp;</operator><name><name>dn_handles</name><index>[<expr><name>node</name></expr>]</index></name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * None of requested nodes is in use, need to get one from the pool.
     * Choose one.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>node</name> <operator>=</operator> <name>load_balancer</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>node</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* At the moment node is an index in the array, and we may need to wrap it */</comment>
        <if_stmt><if>if <condition>(<expr><name>node</name> <operator>&gt;=</operator> <name>NumDataNodes</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>node</name> <operator>-=</operator> <name>NumDataNodes</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Look only at empty slots, we have already checked existing handles */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>dn_handles</name><index>[<expr><name>node</name></expr>]</index></name><operator>.</operator><name>sock</name> <operator>==</operator> <name>NO_SOCKET</name></expr>)</condition>
        <block>{<block_content>
            <macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>datanodelist</argument>)</argument_list></macro>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>node</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* The node is requested */</comment>
                    <comment type="line">//char   *init_str = NULL;</comment>
                    <decl_stmt><decl><type><name>List</name>   <modifier>*</modifier></type><name>allocate</name> <init>= <expr><call><name>list_make1_int</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name>       <modifier>*</modifier></type><name>pids</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name>    <modifier>*</modifier></type><name>fds</name> <init>= <expr><call><name>PoolManagerGetConnections</name><argument_list>(<argument><expr><name>allocate</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>pids</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>PGXCNodeHandle</name>        <modifier>*</modifier></type><name>node_handle</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fds</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pids</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to get pooled connections"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This may happen because one or more nodes are "</literal>
                                     <literal type="string">"currently unreachable, either because of node or "</literal>
                                     <literal type="string">"network failure.\n Its also possible that the target node "</literal>
                                     <literal type="string">"may have hit the connection limit or the pooler is "</literal>
                                     <literal type="string">"configured with low connections.\n Please check "</literal>
                                     <literal type="string">"if all nodes are running fine and also review "</literal>
                                     <literal type="string">"max_connections and max_pool_size configuration "</literal>
                                     <literal type="string">"parameters"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/*
                     * We got a new connection, set on the remote node the session parameters
                     * if defined. The transaction parameter should be sent after BEGIN
                     */</comment>
                    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
                    init_str = PGXCNodeGetSessionParamStr();
                    if (init_str)
                    {
                        if (PoolManagerSetCommand(POOL_CMD_GLOBAL_SET, init_str) &lt; 0)
                            elog(ERROR, "Postgres-XZ: ERROR SET query");
                        <comment type="line">//pgxc_node_set_query(handle, init_str);</comment>
                    }
                    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                    
                    
                    
                    
                    <expr_stmt><expr><name>node_handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>dn_handles</name><index>[<expr><name>node</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pgxc_node_init</name><argument_list>(<argument><expr><name>node_handle</name></expr></argument>, <argument><expr><name><name>fds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>pids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>datanode_count</name><operator>++</operator></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Established a connection with datanode \"%s\","</literal>
                            <literal type="string">"remote backend PID %d, socket fd %d, global session %c"</literal></expr></argument>,
                            <argument><expr><name><name>node_handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>pids</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>fds</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">'T'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * set load_balancer for next time and return the handle
                     */</comment>
                    <expr_stmt><expr><name>load_balancer</name> <operator>=</operator> <name>node</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <return>return <expr><operator>&amp;</operator><name><name>dn_handles</name><index>[<expr><name>node</name></expr>]</index></name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* We should not get here, one of the cases should be met */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Keep compiler quiet */</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * for specified list return array of PGXCNodeHandles
 * acquire from pool if needed.
 * the lenth of returned array is the same as of nodelist
 * For Datanodes, Special case is empty or NIL nodeList, in this case return all the nodes.
 * The returned list should be pfree'd when no longer needed.
 * For Coordinator, do not get a connection if Coordinator list is NIL,
 * Coordinator fds is returned only if transaction uses a DDL
 */</comment>
<function><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type>
<name>get_handles</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>datanodelist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>coordlist</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_coord_only_query</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_global_session</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>raise_error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGXCNodeAllHandles</name>    <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>        <modifier>*</modifier></type><name>node_list_item</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>            <modifier>*</modifier></type><name>dn_allocate</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>            <modifier>*</modifier></type><name>co_allocate</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeHandle</name>        <modifier>*</modifier></type><name>node_handle</name></decl>;</decl_stmt>
    <comment type="line">//char            *init_str    = NULL;</comment>

    <comment type="block">/* index of the result array */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>HandlesRefreshPending</name></expr>)</condition><block type="pseudo"><block_content>
        <if_stmt><if>if <condition>(<expr><call><name>DoRefreshRemoteHandles</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_QUERY_CANCELED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling transaction due to cluster configuration reset by administrator command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PGXCNodeAllHandles</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeAllHandles</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>primary_handle</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>datanode_handles</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>coord_handles</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>co_conn_count</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>coordlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dn_conn_count</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>datanodelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Get Handles for Datanodes
     * If node list is empty execute request on current nodes.
     * It is also possible that the query has to be launched only on Coordinators.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_coord_only_query</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>datanodelist</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We do not have to zero the array - on success all items will be set
             * to correct pointers, on error the array will be freed
             */</comment>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>datanode_handles</name></name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator>
                                       <call><name>palloc</name><argument_list>(<argument><expr><name>NumDataNodes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>datanode_handles</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name>node_handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>dn_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>node_handle</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>node_handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>NO_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>dn_allocate</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>dn_allocate</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * We do not have to zero the array - on success all items will be set
             * to correct pointers, on error the array will be freed
             */</comment>

            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>datanode_handles</name></name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator>
                <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>datanodelist</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>datanode_handles</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <macro><name>foreach</name><argument_list>(<argument>node_list_item</argument>, <argument>datanodelist</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>    <name>node</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>node_list_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>node</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>node</name> <operator>&gt;=</operator> <name>NumDataNodes</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid Datanode number, node number %d, max nodes %d"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>NumDataNodes</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>node_handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>dn_handles</name><index>[<expr><name>node</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>node_handle</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>node_handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>NO_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>dn_allocate</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>dn_allocate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Get Handles for Coordinators
     * If node list is empty execute request on current nodes
     * There are transactions where the Coordinator list is NULL Ex:COPY
     */</comment>

    <if_stmt><if>if <condition>(<expr><name>coordlist</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>coordlist</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We do not have to zero the array - on success all items will be set
             * to correct pointers, on error the array will be freed
             */</comment>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>coord_handles</name></name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>NumCoords</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>coord_handles</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumCoords</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name>node_handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>co_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>node_handle</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>node_handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>NO_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>co_allocate</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>co_allocate</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * We do not have to zero the array - on success all items will be set
             * to correct pointers, on error the array will be freed
             */</comment>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>coord_handles</name></name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator>
                                    <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>coordlist</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>coord_handles</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <comment type="block">/* Some transactions do not need Coordinators, ex: COPY */</comment>
            <macro><name>foreach</name><argument_list>(<argument>node_list_item</argument>, <argument>coordlist</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>            <name>node</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>node_list_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>node</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>node</name> <operator>&gt;=</operator> <name>NumCoords</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid coordinator number, node number %d, max nodes %d"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>NumCoords</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>node_handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>co_handles</name><index>[<expr><name>node</name></expr>]</index></name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>node_handle</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>node_handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>NO_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>co_allocate</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>co_allocate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Pooler can get activated even if list of Coordinator or Datanode is NULL
     * If both lists are NIL, we don't need to call Pooler.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>dn_allocate</name> <operator>||</operator> <name>co_allocate</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>    <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>pids</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name>	<modifier>*</modifier></type><name>fds</name> <init>= <expr><call><name>PoolManagerGetConnections</name><argument_list>(<argument><expr><name>dn_allocate</name></expr></argument>, <argument><expr><name>co_allocate</name></expr></argument>, <argument><expr><name>raise_error</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pids</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fds</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>coordlist</name></expr>)</condition><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>coord_handles</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>coord_handles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>datanodelist</name></expr>)</condition><block type="pseudo"><block_content>
                <if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>datanode_handles</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>datanode_handles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>dn_allocate</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>dn_allocate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>co_allocate</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>co_allocate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to get pooled connections"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This may happen because one or more nodes are "</literal>
                         <literal type="string">"currently unreachable, either because of node or "</literal>
                         <literal type="string">"network failure.\n Its also possible that the target node "</literal>
                         <literal type="string">"may have hit the connection limit or the pooler is "</literal>
                         <literal type="string">"configured with low connections.\n Please check "</literal>
                         <literal type="string">"if all nodes are running fine and also review "</literal>
                         <literal type="string">"max_connections and max_pool_size configuration "</literal>
                         <literal type="string">"parameters"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
        <comment type="block">/*
         * We got a new connection, set on the remote node the session parameters
         * if defined. The transaction parameter should be sent after BEGIN
         */</comment>
        if (is_global_session)
        {
            init_str = PGXCNodeGetSessionParamStr();
            if (init_str)
            {
                if (PoolManagerSetCommand(POOL_CMD_GLOBAL_SET, init_str) &lt; 0)
                    elog(ERROR, "Postgres-XZ: ERROR SET query");
                <comment type="line">//pgxc_node_set_query(handle, init_str);</comment>
            }
        }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>        
        

        <comment type="block">/* Initialisation for Datanodes */</comment>
        <if_stmt><if>if <condition>(<expr><name>dn_allocate</name></expr>)</condition>
        <block>{<block_content>
            <macro><name>foreach</name><argument_list>(<argument>node_list_item</argument>, <argument>dn_allocate</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>            <name>node</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>node_list_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>fdsock</name> <init>= <expr><name><name>fds</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>be_pid</name> <init>= <expr><name><name>pids</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>node</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>node</name> <operator>&gt;=</operator> <name>NumDataNodes</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid Datanode number, node number %d, max nodes %d"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>NumDataNodes</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>node_handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>dn_handles</name><index>[<expr><name>node</name></expr>]</index></name></expr>;</expr_stmt>
				
				<if_stmt><if>if <condition>(<expr><name>be_pid</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>raise_error</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>node_handle</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
				
				<expr_stmt><expr><call><name>pgxc_node_init</name><argument_list>(<argument><expr><name>node_handle</name></expr></argument>, <argument><expr><name>fdsock</name></expr></argument>, <argument><expr><name>is_global_session</name></expr></argument>, <argument><expr><name>be_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>dn_handles</name><index>[<expr><name>node</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>node_handle</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>datanode_count</name><operator>++</operator></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Established a connection with datanode \"%s\","</literal>
                        <literal type="string">"remote backend PID %d, socket fd %d, global session %c"</literal></expr></argument>,
                        <argument><expr><name><name>node_handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>be_pid</name></expr></argument>, <argument><expr><name>fdsock</name></expr></argument>,
                        <argument><expr><ternary><condition><expr><name>is_global_session</name></expr> ?</condition><then> <expr><literal type="char">'T'</literal></expr> </then><else>: <expr><literal type="char">'F'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Established a connection with datanode \"%s\","</literal>
                        <literal type="string">"remote backend PID %d, socket fd %d, global session %c"</literal></expr></argument>,
                        <argument><expr><name><name>node_handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>be_pid</name></expr></argument>, <argument><expr><name>fdsock</name></expr></argument>,
                        <argument><expr><ternary><condition><expr><name>is_global_session</name></expr> ?</condition><then> <expr><literal type="char">'T'</literal></expr> </then><else>: <expr><literal type="char">'F'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

				<if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name></type> <name>nodetype</name> <init>= <expr><name>PGXC_NODE_DATANODE</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type> <name>nodeidx</name> <init>= <expr><call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name><name>node_handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodetype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><name>PGXC_NODE_DATANODE</name> <operator>!=</operator> <name>nodetype</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unexpected node type %c, name %s, index %d, "</literal>
								<literal type="string">"oid %d, max nodes %d"</literal></expr></argument>, <argument><expr><name>nodetype</name></expr></argument>,
								<argument><expr><name><name>node_handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name>nodeidx</name></expr></argument>,
								<argument><expr><name><name>node_handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name>NumDataNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>nodeidx</name> <operator>&lt;</operator> <literal type="number">0</literal>  <operator>||</operator> <name>nodeidx</name> <operator>&gt;=</operator> <name>NumDataNodes</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid datanode index %d, name %s, oid %d, "</literal>
								<literal type="string">"type %c, max nodes %d"</literal></expr></argument>, <argument><expr><name>nodeidx</name></expr></argument>,
								<argument><expr><name><name>node_handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>node_handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>,
								<argument><expr><name>nodetype</name></expr></argument>, <argument><expr><name>NumDataNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><call><name>InactivateDatanodeStatementOnNode</name><argument_list>(<argument><expr><name>nodeidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"Inactivate statement on datanode %s, nodeidx %d, "</literal>
							<literal type="string">"oid %d, type %c, max nodes %d"</literal></expr></argument>, <argument><expr><name><name>node_handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>,
							<argument><expr><name>nodeidx</name></expr></argument>, <argument><expr><name><name>node_handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name>nodetype</name></expr></argument>, <argument><expr><name>NumDataNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
            </block_content>}</block>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Initialisation for Coordinators */</comment>
        <if_stmt><if>if <condition>(<expr><name>co_allocate</name></expr>)</condition>
        <block>{<block_content>
            <macro><name>foreach</name><argument_list>(<argument>node_list_item</argument>, <argument>co_allocate</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>            <name>node</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>node_list_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>be_pid</name> <init>= <expr><name><name>pids</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>fdsock</name> <init>= <expr><name><name>fds</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>node</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>node</name> <operator>&gt;=</operator> <name>NumCoords</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid coordinator number, node number %d, max nodes %d"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>NumCoords</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>node_handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>co_handles</name><index>[<expr><name>node</name></expr>]</index></name></expr>;</expr_stmt>
				
				<if_stmt><if>if <condition>(<expr><name>be_pid</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>raise_error</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>node_handle</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
				
				<expr_stmt><expr><call><name>pgxc_node_init</name><argument_list>(<argument><expr><name>node_handle</name></expr></argument>, <argument><expr><name>fdsock</name></expr></argument>, <argument><expr><name>is_global_session</name></expr></argument>, <argument><expr><name>be_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>co_handles</name><index>[<expr><name>node</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>node_handle</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>coord_count</name><operator>++</operator></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Established a connection with coordinator \"%s\","</literal>
                        <literal type="string">"remote backend PID %d, socket fd %d, global session %c"</literal></expr></argument>,
                        <argument><expr><name><name>node_handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>be_pid</name></expr></argument>, <argument><expr><name>fdsock</name></expr></argument>,
                        <argument><expr><ternary><condition><expr><name>is_global_session</name></expr> ?</condition><then> <expr><literal type="char">'T'</literal></expr> </then><else>: <expr><literal type="char">'F'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Established a connection with datanode \"%s\","</literal>
                        <literal type="string">"remote backend PID %d, socket fd %d, global session %c"</literal></expr></argument>,
                        <argument><expr><name><name>node_handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>be_pid</name></expr></argument>, <argument><expr><name>fdsock</name></expr></argument>,
                        <argument><expr><ternary><condition><expr><name>is_global_session</name></expr> ?</condition><then> <expr><literal type="char">'T'</literal></expr> </then><else>: <expr><literal type="char">'F'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            </block_content>}</block>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>co_allocate</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>co_allocate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>dn_allocate</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>dn_allocate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>PGXCNodeAllHandles</name> <modifier>*</modifier></type>
<name>get_empty_handles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PGXCNodeAllHandles</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeAllHandles</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type>
<name>get_current_handles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>get_empty_handles</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGXCNodeHandle</name>	   <modifier>*</modifier></type><name>node_handle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>					<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PGXCNodeAllHandles</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeAllHandles</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__TBASE__</name></cpp:ifndef>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>datanode_handles</name></name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator>
							   <call><name>palloc</name><argument_list>(<argument><expr><name>NumDataNodes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>datanode_handles</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>node_handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>dn_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>node_handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>dn_conn_count</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>node_handle</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>coord_handles</name></name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator>
                            <call><name>palloc</name><argument_list>(<argument><expr><name>NumCoords</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>coord_handles</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumCoords</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>node_handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>co_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>node_handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>co_conn_count</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>node_handle</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>get_current_cn_handles_internal</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>get_current_dn_handles_internal</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/* get current transaction handles that register in pgxc_node_begin */</comment>
<function><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type>
<name>get_current_txn_handles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>get_empty_handles</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>get_current_txn_cn_handles_internal</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>get_current_txn_dn_handles_internal</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type>
<name>get_current_cn_handles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>get_empty_handles</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>get_current_cn_handles_internal</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type>
<name>get_current_dn_handles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>get_empty_handles</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>get_current_dn_handles_internal</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_current_dn_handles_internal</name><parameter_list>(<parameter><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGXCNodeHandle</name>	   <modifier>*</modifier></type><name>node_handle</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>					<name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>datanode_handles</name></name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator>
            <call><name>palloc</name><argument_list>(<argument><expr><name>NumDataNodes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>datanode_handles</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dn_conn_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>node_handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>dn_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>node_handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>dn_conn_count</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>node_handle</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* get current transaction dn handles that register in pgxc_node_begin */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_current_txn_dn_handles_internal</name><parameter_list>(<parameter><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>					<name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                 <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>current_transaction_handles</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>current_transaction_handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>current_transaction_handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>datanode_handles</name></name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator>
            <call><name>palloc</name><argument_list>(<argument><expr><name>count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>datanode_handles</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dn_conn_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>dn_conn_count</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>current_transaction_handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_current_cn_handles_internal</name><parameter_list>(<parameter><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGXCNodeHandle</name>	   <modifier>*</modifier></type><name>node_handle</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>					<name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>coord_handles</name></name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator>
            <call><name>palloc</name><argument_list>(<argument><expr><name>NumCoords</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>coord_handles</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>co_conn_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumCoords</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>node_handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>co_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>node_handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>co_conn_count</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>node_handle</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* get current transaction cn handles that register in pgxc_node_begin */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_current_txn_cn_handles_internal</name><parameter_list>(<parameter><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>					<name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                 <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>current_transaction_handles</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>current_transaction_handles</name><operator>-&gt;</operator><name>co_conn_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>current_transaction_handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>coord_handles</name></name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator>
            <call><name>palloc</name><argument_list>(<argument><expr><name>count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>coord_handles</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>co_conn_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>co_conn_count</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>current_transaction_handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type>
<name>get_sock_fatal_handles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGXCNodeHandle</name>	   <modifier>*</modifier></type><name>node_handle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>					<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PGXCNodeAllHandles</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeAllHandles</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"get_sock_fatal_handles out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>primary_handle</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>co_conn_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>dn_conn_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>datanode_handles</name></name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator>
							   <call><name>palloc</name><argument_list>(<argument><expr><name>NumDataNodes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>datanode_handles</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"get_sock_fatal_handles out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>node_handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>dn_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>node_handle</name><operator>-&gt;</operator><name>sock_fatal_occurred</name></name> <operator>==</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>dn_conn_count</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>node_handle</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>coord_handles</name></name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator>
							<call><name>palloc</name><argument_list>(<argument><expr><name>NumCoords</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>-&gt;</operator><name>coord_handles</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"get_sock_fatal_handles out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumCoords</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>node_handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>co_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>node_handle</name><operator>-&gt;</operator><name>sock_fatal_occurred</name></name> <operator>==</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name><name>result</name><operator>-&gt;</operator><name>co_conn_count</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>node_handle</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * init current transaction handles for connections
 */</comment>
<function><type><name>void</name></type>
<name>init_transaction_handles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>current_transaction_handles</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>current_transaction_handles</name> <operator>=</operator> <operator>(</operator><name>PGXCNodeAllHandles</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeAllHandles</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>current_transaction_handles</name><operator>-&gt;</operator><name>primary_handle</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>current_transaction_handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>current_transaction_handles</name><operator>-&gt;</operator><name>datanode_handles</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>current_transaction_handles</name><operator>-&gt;</operator><name>datanode_handles</name></name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NumDataNodes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>current_transaction_handles</name><operator>-&gt;</operator><name>datanode_handles</name></name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>current_transaction_handles</name><operator>-&gt;</operator><name>datanode_handles</name></name></expr></argument>, <argument><expr><name>NumDataNodes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>current_transaction_handles</name><operator>-&gt;</operator><name>co_conn_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>current_transaction_handles</name><operator>-&gt;</operator><name>coord_handles</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>current_transaction_handles</name><operator>-&gt;</operator><name>coord_handles</name></name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>NumCoords</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>current_transaction_handles</name><operator>-&gt;</operator><name>coord_handles</name></name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>current_transaction_handles</name><operator>-&gt;</operator><name>coord_handles</name></name></expr></argument>, <argument><expr><name>NumCoords</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * reset current transaction handles
 */</comment>
<function><type><name>void</name></type>
<name>reset_transaction_handles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>current_transaction_handles</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>current_transaction_handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>current_transaction_handles</name><operator>-&gt;</operator><name>co_conn_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * register current transaction handle to current_transaction_handles
 */</comment>
<function><type><name>void</name></type>
<name>register_transaction_handles</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name><modifier>*</modifier></type> <name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>node_type</name> <init>= <expr><name><name>handle</name><operator>-&gt;</operator><name>node_type</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>current_transaction_handles</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>node_type</name> <operator>==</operator> <name>PGXC_NODE_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>current_transaction_handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>current_transaction_handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>handle</name></expr>)</condition>
            <block>{<block_content>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>current_transaction_handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name><name>current_transaction_handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>handle</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>current_transaction_handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name> <operator>&lt;=</operator> <name>NumDataNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>node_type</name> <operator>==</operator> <name>PGXC_NODE_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>current_transaction_handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>current_transaction_handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>handle</name></expr>)</condition>
            <block>{<block_content>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><name><name>current_transaction_handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name><name>current_transaction_handles</name><operator>-&gt;</operator><name>co_conn_count</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>handle</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>current_transaction_handles</name><operator>-&gt;</operator><name>co_conn_count</name></name> <operator>&lt;=</operator> <name>NumCoords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid node_type %c in register_transaction_handles"</literal></expr></argument>, <argument><expr><name>node_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Free PGXCNodeAllHandles structure */</comment>
<function><type><name>void</name></type>
<name>pfree_pgxc_all_handles</name><parameter_list>(<parameter><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>pgxc_handles</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pgxc_handles</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>g_twophase_state</name><operator>.</operator><name>handles</name></name> <operator>==</operator> <name>pgxc_handles</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>handles</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections_num</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>primary_handle</name></name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>primary_handle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>primary_handle</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>datanode_handles</name></name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>datanode_handles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>datanode_handles</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>coord_handles</name></name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>coord_handles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>coord_handles</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pgxc_handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pgxc_handles</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Do translation for non-main cluster */</comment>
<function><type><name>Oid</name></type>
<name>PGXCGetLocalNodeOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nodeoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    
    <if_stmt><if>if<condition>(<expr><name>false</name> <operator>==</operator> <name>IsPGXCMainCluster</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodename</name></decl>;</decl_stmt>
        
        <expr_stmt><expr><name>nodename</name> <operator>=</operator> <call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nodeoid</name> <operator>=</operator> <call><name>get_pgxc_nodeoid</name><argument_list>(<argument><expr><name>nodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>nodeoid</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no such node:%s on cluster %s"</literal></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name>PGXCClusterName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>nodeoid</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type>
<name>PGXCGetMainNodeOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nodeoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>

    <if_stmt><if>if<condition>(<expr><name>false</name> <operator>==</operator> <name>IsPGXCMainCluster</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodename</name></decl>;</decl_stmt>
        
        <expr_stmt><expr><name>nodename</name> <operator>=</operator> <call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nodeoid</name> <operator>=</operator> <call><name>get_pgxc_nodeoid_extend</name><argument_list>(<argument><expr><name>nodename</name></expr></argument>, <argument><expr><name>PGXCMainClusterName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>nodeoid</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no such node:%s on main cluster %s"</literal></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name>PGXCMainClusterName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>nodeoid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PGXCNodeGetNodeId
 *        Look at the data cached for handles and return node position
 *         If node type is PGXC_NODE_COORDINATOR look only in coordinator list,
 *        if node type is PGXC_NODE_DATANODE look only in datanode list,
 *        if other (assume PGXC_NODE_NODE) search both, in last case return actual
 *        node type.
 */</comment>
<function><type><name>int</name></type>
<name>PGXCNodeGetNodeId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nodeoid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>node_type</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PGXCNodeHandlesLookupEnt</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>bool</name></type>            <name>found</name>  <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>node_handles_hash</name></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"node_handles_hash is null."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>NOT_FOUND</name>;</goto>
    </block_content>}</block></if></if_stmt>
    
	<expr_stmt><expr><name>nodeoid</name> <operator>=</operator> <call><name>PGXCGetLocalNodeOid</name><argument_list>(<argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandlesLookupEnt</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>node_handles_hash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodeoid</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>false</name> <operator>==</operator> <name>found</name></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"node_handles_hash does not has %d"</literal></expr></argument>, <argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>NOT_FOUND</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* First check datanodes, they referenced more often */</comment>
    <if_stmt><if>if <condition>(<expr><name>node_type</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><operator>(</operator><operator>*</operator><name>node_type</name> <operator>!=</operator> <name>PGXC_NODE_COORDINATOR</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>node_type</name> <operator>!=</operator> <name>PGXC_NODE_SLAVEDATANODE</name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>dn_handles</name> <operator>&amp;&amp;</operator> <name><name>dn_handles</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>nodeidx</name></name></expr>]</index></name><operator>.</operator><name>nodeoid</name> <operator>==</operator> <name>nodeoid</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>node_type</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>node_type</name> <operator>=</operator> <name>PGXC_NODE_DATANODE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>nodeidx</name></name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>node_type</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><operator>(</operator><operator>*</operator><name>node_type</name> <operator>!=</operator> <name>PGXC_NODE_COORDINATOR</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>node_type</name> <operator>!=</operator> <name>PGXC_NODE_DATANODE</name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>sdn_handles</name> <operator>&amp;&amp;</operator> <name><name>sdn_handles</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>nodeidx</name></name></expr>]</index></name><operator>.</operator><name>nodeoid</name> <operator>==</operator> <name>nodeoid</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>node_type</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>node_type</name> <operator>=</operator> <name>PGXC_NODE_SLAVEDATANODE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>nodeidx</name></name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Then check coordinators */</comment>
    <if_stmt><if>if <condition>(<expr><name>node_type</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><operator>(</operator><operator>*</operator><name>node_type</name> <operator>!=</operator> <name>PGXC_NODE_DATANODE</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>node_type</name> <operator>!=</operator> <name>PGXC_NODE_SLAVEDATANODE</name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>co_handles</name> <operator>&amp;&amp;</operator> <name><name>co_handles</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>nodeidx</name></name></expr>]</index></name><operator>.</operator><name>nodeoid</name> <operator>==</operator> <name>nodeoid</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>node_type</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>node_type</name> <operator>=</operator> <name>PGXC_NODE_COORDINATOR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>nodeidx</name></name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>    

    

<label><name>NOT_FOUND</name>:</label>
    <comment type="block">/* Not found, have caller handling it */</comment>
    <if_stmt><if>if <condition>(<expr><name>node_type</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>node_type</name> <operator>=</operator> <name>PGXC_NODE_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PGXCNodeGetNodeOid
 *        Look at the data cached for handles and return node Oid
 */</comment>
<function><type><name>Oid</name></type>
<name>PGXCNodeGetNodeOid</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nodeid</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>node_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handles</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>node_type</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PGXC_NODE_COORDINATOR</name></expr>:</case>
            <expr_stmt><expr><name>handles</name> <operator>=</operator> <name>co_handles</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PGXC_NODE_DATANODE</name></expr>:</case>
            <expr_stmt><expr><name>handles</name> <operator>=</operator> <name>dn_handles</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>PGXC_NODE_SLAVEDATANODE</name></expr>:</case>
            <expr_stmt><expr><name>handles</name> <operator>=</operator> <name>sdn_handles</name></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <comment type="block">/* Should not happen */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>InvalidOid</name></expr>;</return>
    </block_content>}</block></switch>

    <return>return <expr><name><name>handles</name><index>[<expr><name>nodeid</name></expr>]</index></name><operator>.</operator><name>nodeoid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pgxc_node_str
 *
 * get the name of the node
 */</comment>
<function><type><name>Datum</name></type>
<name>pgxc_node_str</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Name</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* We use palloc0 here to ensure result is zero-padded */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Name</name><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_NAME</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * PGXCNodeGetNodeIdFromName
 *        Return node position in handles array
 */</comment>
<function><type><name>int</name></type>
<name>PGXCNodeGetNodeIdFromName</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>node_name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>node_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>nodeoid</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>node_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>node_type</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>node_type</name> <operator>=</operator> <name>PGXC_NODE_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>nm</name> <operator>=</operator> <call><name>str_tolower</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_COLLATION_OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>nodeoid</name> <operator>=</operator> <call><name>get_pgxc_nodeoid</name><argument_list>(<argument><expr><name>nm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>node_type</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>node_type</name> <operator>=</operator> <name>PGXC_NODE_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name>nodeoid</name></expr></argument>, <argument><expr><name>node_type</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>paramlist_delete_param</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>param_list</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
       <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur_item</name></decl>;</decl_stmt>
       <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>prev_item</name></decl>;</decl_stmt>

       <expr_stmt><expr><name>prev_item</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
       <expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>param_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

       <while>while <condition>(<expr><name>cur_item</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
       <block>{<block_content>
               <decl_stmt><decl><type><name>ParamEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>ParamEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cur_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

               <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
               <block>{<block_content>
                       <comment type="block">/* cur_item must be removed */</comment>
                       <expr_stmt><expr><name>param_list</name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name>param_list</name></expr></argument>, <argument><expr><name>cur_item</name></expr></argument>, <argument><expr><name>prev_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                       <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                       <if_stmt><if>if <condition>(<expr><name>prev_item</name></expr>)</condition><block type="pseudo"><block_content>
                               <expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>prev_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                       <else>else<block type="pseudo"><block_content>
                               <expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>param_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
               </block_content>}</block></if>
               <else>else
               <block>{<block_content>
                       <expr_stmt><expr><name>prev_item</name> <operator>=</operator> <name>cur_item</name></expr>;</expr_stmt>
                       <expr_stmt><expr><name>cur_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>prev_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
               </block_content>}</block></else></if_stmt>
       </block_content>}</block></while>

       <return>return <expr><name>param_list</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ParamEntry</name> <modifier>*</modifier></type>
<name>paramlist_get_paramentry</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>param_list</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cur_item</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>foreach</name><argument_list>(<argument>cur_item</argument>, <argument>param_list</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ParamEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>ParamEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cur_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><name>entry</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ParamEntry</name> <modifier>*</modifier></type>
<name>paramentry_copy</name><parameter_list>(<parameter><decl><type><name>ParamEntry</name> <modifier>*</modifier></type> <name>src_entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParamEntry</name> <modifier>*</modifier></type><name>dst_entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>src_entry</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>dst_entry</name> <operator>=</operator> <operator>(</operator><name>ParamEntry</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ParamEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name><name>dst_entry</name><operator>-&gt;</operator><name>name</name></name><operator>)</operator></expr></argument>,  <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>src_entry</name><operator>-&gt;</operator><name>name</name></name><operator>)</operator></expr></argument>,   <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name><name>dst_entry</name><operator>-&gt;</operator><name>value</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>src_entry</name><operator>-&gt;</operator><name>value</name></name><operator>)</operator></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dst_entry</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>src_entry</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <return>return <expr><name>dst_entry</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Remember new value of a session or transaction parameter, and set same
 * values on newly connected remote nodes.
 */</comment>
<function><type><name>void</name></type>
<name>PGXCNodeSetParam</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>local</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>param_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <comment type="block">/* Get the target hash table and invalidate command string */</comment>
    <if_stmt><if>if <condition>(<expr><name>local</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>param_list</name> <operator>=</operator> <name>local_param_list</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>local_params</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>local_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>param_list</name> <operator>=</operator> <name>session_param_list</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>session_params</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>session_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>param_list</name> <operator>=</operator> <call><name>paramlist_delete_param</name><argument_list>(<argument><expr><name>param_list</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ParamEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>ParamEntry</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ParamEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>name</name></name><operator>)</operator></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>value</name></name><operator>)</operator></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>param_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>param_list</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Special case for
     *     RESET SESSION AUTHORIZATION
     *     SET SESSION AUTHORIZATION TO DEFAULT
     *
     * We must also forget any SET ROLE commands since RESET SESSION
     * AUTHORIZATION also resets current role to session default
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"session_authorization"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>value</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>param_list</name> <operator>=</operator> <call><name>paramlist_delete_param</name><argument_list>(<argument><expr><name>param_list</name></expr></argument>, <argument><expr><literal type="string">"role"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>local</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>local_param_list</name> <operator>=</operator> <name>param_list</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>session_param_list</name> <operator>=</operator> <name>param_list</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Forget all parameter values set either for transaction or both transaction
 * and session.
 */</comment>
<function><type><name>void</name></type>
<name>PGXCNodeResetParams</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>only_local</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>only_local</name> <operator>&amp;&amp;</operator> <name>session_param_list</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* need to explicitly pfree session stuff, it is in TopMemoryContext */</comment>
        <expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>session_param_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>session_param_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>session_params</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>session_params</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>session_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>session_params</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/*
     * no need to explicitly destroy the local_param_list and local_params,
     * it will gone with the transaction memory context.
     */</comment>
    <expr_stmt><expr><name>local_param_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>local_params</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_set_command</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>param_list</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>command</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>local</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name>           <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>                 <name><name>search_path_value</name><index>[<expr><literal type="number">512</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>             <modifier>*</modifier></type><name>p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>             <modifier>*</modifier></type><name>pre</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>            <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                 <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                 <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>                <name>need_set_quota</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>param_list</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>param_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ParamEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>(</operator><name>ParamEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>value</name> <operator>=</operator> <literal type="string">"''"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>quote_guc_value</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* replace $user to "$user" */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>name</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">"search_path"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>value</name></expr><operator>,</operator> <expr><name>pre</name> <operator>=</operator> <name>value</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition>
                <block>{<block_content>
                    
                    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pre</name> <operator>!=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>pre</name> <operator>!=</operator> <literal type="char">','</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>pre</name> <operator>!=</operator> <literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <name>pre</name> <operator>!=</operator> <name>value</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* no need to add quota before $ */</comment>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>bool</name></type> <name>break_loop</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
                        <comment type="block">/* find out match $user exactly or not */</comment>
                        <for>for <control>(<init><expr><name>tmp</name> <operator>=</operator> <name>p</name><operator>+</operator><literal type="number">1</literal></expr><operator>,</operator> <expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>tmp</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name>count</name> <operator>&lt;=</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>tmp</name><operator>++</operator></expr><operator>,</operator> <expr><name>count</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <switch>switch <condition>(<expr><name>count</name></expr>)</condition>
                            <block>{<block_content>
                                <case>case <expr><literal type="number">0</literal></expr>:</case>
                                    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>tmp</name> <operator>!=</operator> <literal type="char">'U'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>tmp</name> <operator>!=</operator> <literal type="char">'u'</literal></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><name>break_loop</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>
                                    <break>break;</break>

                                <case>case <expr><literal type="number">1</literal></expr>:</case>
                                    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>tmp</name> <operator>!=</operator> <literal type="char">'S'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>tmp</name> <operator>!=</operator> <literal type="char">'s'</literal></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><name>break_loop</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>
                                    <break>break;</break>

                                <case>case <expr><literal type="number">2</literal></expr>:</case>
                                    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>tmp</name> <operator>!=</operator> <literal type="char">'E'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>tmp</name> <operator>!=</operator> <literal type="char">'e'</literal></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><name>break_loop</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>
                                    <break>break;</break>
                                    
                                <case>case <expr><literal type="number">3</literal></expr>:</case>
                                    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>tmp</name> <operator>!=</operator> <literal type="char">'R'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>tmp</name> <operator>!=</operator> <literal type="char">'r'</literal></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><name>break_loop</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>
                                    <break>break;</break>
                                    
                                <case>case <expr><literal type="number">4</literal></expr>:</case>
                                    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>tmp</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>*</operator><name>tmp</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><name>need_set_quota</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>
                                    <break>break;</break>
                                <default>default:</default>
                                    <expr_stmt><expr><name>break_loop</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            </block_content>}</block></switch>
                            <comment type="block">/* NOT match */</comment>
                            <if_stmt><if>if <condition>(<expr><name>break_loop</name></expr>)</condition>
                            <block>{<block_content>
                                <break>break;</break>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></for>
                        
                        <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>tmp</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>break_loop</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>need_set_quota</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></else></if_stmt>

                
                    <if_stmt><if>if <condition>(<expr><name>need_set_quota</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>search_path_value</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>need_set_quota</name> <operator>&amp;&amp;</operator> <operator>(</operator><literal type="char">' '</literal> <operator>==</operator> <operator>*</operator><name>p</name> <operator>||</operator> <literal type="char">','</literal> <operator>==</operator> <operator>*</operator><name>p</name><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>search_path_value</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>need_set_quota</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                
                <expr_stmt><expr><name><name>search_path_value</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>pre</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

                <comment type="block">/* length safety check. */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>search_path_value</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">3</literal> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>search_path_value</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
                <block>{<block_content>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <comment type="block">/* case like $user\0 (reach end of string) */</comment>
            <if_stmt><if>if <condition>(<expr><name>need_set_quota</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>search_path_value</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>search_path_value</name></expr></argument>, <argument><expr><literal type="string">"public"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
				<operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>search_path_value</name></expr></argument>, <argument><expr><literal type="string">"PUBLIC"</literal></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"SET %s %s TO %s;"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>local</name></expr> ?</condition><then> <expr><literal type="string">"LOCAL"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
             <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>search_path_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"SET %s %s TO %s, public;"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>local</name></expr> ?</condition><then> <expr><literal type="string">"LOCAL"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
					<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>search_path_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"get_set_command: %s"</literal></expr></argument>, <argument><expr><name><name>command</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><literal type="string">"SET %s %s TO %s;"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>local</name></expr> ?</condition><then> <expr><literal type="string">"LOCAL"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
             <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * Returns SET commands needed to initialize remote session.
 * The command may already be built and valid, return it right away if the case.
 * Otherwise build it up.
 * To support Distributed Session machinery coordinator should generate and
 * send a distributed session identifier to remote nodes. Generate it here.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>PGXCNodeGetSessionParamStr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * If no session parameters are set and that is a coordinator we need to set
     * global_session anyway, even if there were no other parameters.
     * We do not want this string to disappear, so create it in the
     * TopMemoryContext. However if we add first session parameter we will need
     * to free the buffer and recreate it in the same context as the hash table
     * to avoid memory leakage.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>session_params</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>session_params</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If the paramstr invalid build it up */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>session_params</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
		<block>{<block_content>
            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>session_params</name></expr></argument>, <argument><expr><literal type="string">"SET global_session TO %s_%d;"</literal></expr></argument>,
                             <argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>get_set_command</name><argument_list>(<argument><expr><name>session_param_list</name></expr></argument>, <argument><expr><name>session_params</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>session_params</name></expr></argument>, <argument><expr><literal type="string">"SET parentPGXCPid TO %d;"</literal></expr></argument>,
                             <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><ternary><condition><expr><name><name>session_params</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name><name>session_params</name><operator>-&gt;</operator><name>data</name></name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Returns SET commands needed to initialize transaction on a remote session.
 * The command may already be built and valid, return it right away if the case.
 * Otherwise build it up.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>PGXCNodeGetTransactionParamStr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* If no local parameters defined there is nothing to return */</comment>
    <if_stmt><if>if <condition>(<expr><name>local_param_list</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If the paramstr invalid build it up.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>local_params</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>local_params</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>session_param_list</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ParamEntry</name> <modifier>*</modifier></type> <name>entry_txn_iso</name></decl>;</decl_stmt>
        <comment type="block">/* make sure there is 'transaction_isolation' value */</comment>
        <expr_stmt><expr><name>entry_txn_iso</name> <operator>=</operator> <call><name>paramlist_get_paramentry</name><argument_list>(<argument><expr><name>session_param_list</name></expr></argument>, <argument><expr><literal type="string">"transaction_isolation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>entry_txn_iso</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* 'transaction_isolation' could be set only once, if not set, this would be the first time */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>paramlist_get_paramentry</name><argument_list>(<argument><expr><name>local_param_list</name></expr></argument>, <argument><expr><literal type="string">"transaction_isolation"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ParamEntry</name> <modifier>*</modifier></type> <name>entry_txn_iso_tmp</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>entry_txn_iso_tmp</name> <operator>=</operator> <call><name>paramentry_copy</name><argument_list>(<argument><expr><name>entry_txn_iso</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>entry_txn_iso_tmp</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>local_param_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>local_param_list</name></expr></argument>, <argument><expr><name>entry_txn_iso_tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If parameter string exists it is valid, it is truncated when parameters
     * are modified.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>local_params</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>get_set_command</name><argument_list>(<argument><expr><name>local_param_list</name></expr></argument>, <argument><expr><name>local_params</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><ternary><condition><expr><name><name>local_params</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name><name>local_params</name><operator>-&gt;</operator><name>data</name></name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Send down specified query, read and discard all responses until ReadyForQuery
 */</comment>
<function><type><name>void</name></type>
<name>pgxc_node_set_query</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>set_query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_query</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>set_query</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send query %s"</literal></expr></argument>,<argument><expr><name>set_query</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
    <comment type="block">/*
     * Now read responses until ReadyForQuery.
     * XXX We may need to handle possible errors here.
     */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type>    <name>msgtype</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>     <name>msglen</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
        <comment type="block">/*
         * If we are in the process of shutting down, we
         * may be rolling back, and the buffer may contain other messages.
         * We want to avoid a procarray exception
         * as well as an error stack overflow.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>proc_exit_inprogress</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* don't read from from the connection if there is a fatal error */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <comment type="block">/* No data available, read more */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HAS_MESSAGE_BUFFERED</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pgxc_node_receive</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>msgtype</name> <operator>=</operator> <call><name>get_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msglen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>last_command</name></name> <operator>=</operator> <name>msgtype</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Ignore any response except ErrorResponse and ReadyForQuery
         */</comment>

        <if_stmt><if>if <condition>(<expr><name>msgtype</name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition>    <comment type="block">/* ErrorResponse */</comment>
        <block>{<block_content>
                        <expr_stmt><expr><call><name>PGXCNodeHandleError</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>msglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"pgxc_node_set_query: %s"</literal></expr></argument>,<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>msgtype</name> <operator>==</operator> <literal type="char">'Z'</literal></expr>)</condition> <comment type="block">/* ReadyForQuery */</comment>
        <block>{<block_content>
            <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>=</operator> <name><name>msg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>combiner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>RequestInvalidateRemoteHandles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>HandlesInvalidatePending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>RequestRefreshRemoteHandles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>HandlesRefreshPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>PoolerMessagesPending</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>HandlesRefreshPending</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check HandleInvalidatePending flag
 */</comment>
<function><type><name>void</name></type>
<name>CheckInvalidateRemoteHandles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HandlesInvalidatePending</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return ;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DoInvalidateRemoteHandles</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_QUERY_CANCELED</name></expr></argument>)</argument_list></call><operator>,</operator>
				        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling transaction due to cluster configuration reset by administrator command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * For all handles, mark as they are not in use and discard pending input/output
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>DoInvalidateRemoteHandles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>            <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Not reload until transaction is complete.
	 * That contain two condition.
	 * 1. transaction status is idle.
	 * 2. GlobalCommitTimestamp has to be invalid
	 *    which makes sure we are not in 2pc commit phase.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>InterruptHoldoffCount</name> <operator>||</operator> <operator>!</operator><call><name>IsTransactionIdle</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>GetGlobalCommitTimestamp</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>InvalidGlobalTimestamp</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
   	 * Reinitialize session, it updates the shared memory table.
     * Initialize XL executor. This must be done inside a transaction block.
     */</comment>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitMultinodeExecutor</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Disconnect from the pooler to get new connection infos next time */</comment>
	<expr_stmt><expr><call><name>PoolManagerDisconnect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>HandlesInvalidatePending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>HandlesRefreshPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Diff handles using shmem, and remove ALTERed handles
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>DoRefreshRemoteHandles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>            <modifier>*</modifier></type><name>altered</name> <init>= <expr><name>NIL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>deleted</name> <init>= <expr><name>NIL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>added</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>                <modifier>*</modifier></type><name>coOids</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dnOids</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sdnOids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>numCoords</name></decl>, <decl><type ref="prev"/><name>numDNodes</name></decl>, <decl><type ref="prev"/><name>numSlaveDNodes</name></decl>, <decl><type ref="prev"/><name>total_nodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name>res</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>HandlesRefreshPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PgxcNodeGetOidsExtend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>coOids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dnOids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sdnOids</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>numCoords</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numDNodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numSlaveDNodes</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>total_nodes</name> <operator>=</operator> <name>numCoords</name> <operator>+</operator> <name>numDNodes</name> <operator>+</operator> <name>numSlaveDNodes</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>total_nodes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>        <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>   <modifier>*</modifier></type><name>shmoids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name>       <modifier>*</modifier></type><name>allOids</name> <init>= <expr><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>total_nodes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* build array with Oids of all nodes (coordinators first) */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>allOids</name></expr></argument>, <argument><expr><name>coOids</name></expr></argument>, <argument><expr><name>numCoords</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>allOids</name> <operator>+</operator> <name>numCoords</name></expr></argument>, <argument><expr><name>dnOids</name></expr></argument>, <argument><expr><name>numDNodes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>allOids</name> <operator>+</operator> <name>numCoords</name> <operator>+</operator> <name>numDNodes</name></expr></argument>, <argument><expr><name>sdnOids</name></expr></argument>, <argument><expr><name>numSlaveDNodes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>total_nodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>NodeDefinition</name>    <modifier>*</modifier></type><name>nodeDef</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PGXCNodeHandle</name>    <modifier>*</modifier></type><name>handle</name></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>nid</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type> <name>nodeoid</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type> <name>ntype</name> <init>= <expr><name>PGXC_NODE_NONE</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>nodeoid</name> <operator>=</operator> <name><name>allOids</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>shmoids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>shmoids</name></expr></argument>, <argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>nodeDef</name> <operator>=</operator> <call><name>PgxcNodeGetDefinition</name><argument_list>(<argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/*
             * identify an entry with this nodeoid. If found
             * compare the name/host/port entries. If the name is
             * same and other info is different, it's an ALTER.
             * If the local entry does not exist in the shmem, it's
             * a DELETE. If the entry from shmem does not exist
             * locally, it's an ADDITION
             */</comment>
            <expr_stmt><expr><name>nid</name> <operator>=</operator> <call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name>nodeoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ntype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>nid</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* a new node has been added to the shmem */</comment>
                <expr_stmt><expr><name>added</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>added</name></expr></argument>, <argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Node added: name (%s) host (%s) port (%d)"</literal></expr></argument>,
                     <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodeDef</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodeDef</name><operator>-&gt;</operator><name>nodehost</name></name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name><name>nodeDef</name><operator>-&gt;</operator><name>nodeport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>ntype</name> <operator>==</operator> <name>PGXC_NODE_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>co_handles</name><index>[<expr><name>nid</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><name>ntype</name> <operator>==</operator> <name>PGXC_NODE_DATANODE</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>dn_handles</name><index>[<expr><name>nid</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if<condition>(<expr><name>ntype</name> <operator>==</operator> <name>PGXC_NODE_SLAVEDATANODE</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>sdn_handles</name><index>[<expr><name>nid</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Node with non-existent node type!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <comment type="block">/*
                 * compare name, host, port to see if this node
                 * has been ALTERed
                 */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodeDef</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
                    <call><name>strncmp</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodehost</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodeDef</name><operator>-&gt;</operator><name>nodehost</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
                    <name><name>handle</name><operator>-&gt;</operator><name>nodeport</name></name> <operator>!=</operator> <name><name>nodeDef</name><operator>-&gt;</operator><name>nodeport</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Node altered: old name (%s) old host (%s) old port (%d)"</literal>
                            <literal type="string">" new name (%s) new host (%s) new port (%d)"</literal></expr></argument>,
                         <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodehost</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeport</name></name></expr></argument>,
                         <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodeDef</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodeDef</name><operator>-&gt;</operator><name>nodehost</name></name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name><name>nodeDef</name><operator>-&gt;</operator><name>nodeport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>altered</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>altered</name></expr></argument>, <argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* else do nothing */</comment>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nodeDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/*
         * Any entry in backend area but not in shmem means that it has
         * been deleted
         */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumCoords</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PGXCNodeHandle</name>    <modifier>*</modifier></type><name>handle</name> <init>= <expr><operator>&amp;</operator><name><name>co_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type> <name>nodeoid</name> <init>= <expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>shmoids</name></expr></argument>, <argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>deleted</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>deleted</name></expr></argument>, <argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Node deleted: name (%s) host (%s) port (%d)"</literal></expr></argument>,
                     <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodehost</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PGXCNodeHandle</name>    <modifier>*</modifier></type><name>handle</name> <init>= <expr><operator>&amp;</operator><name><name>dn_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type> <name>nodeoid</name> <init>= <expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>shmoids</name></expr></argument>, <argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>deleted</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>deleted</name></expr></argument>, <argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Node deleted: name (%s) host (%s) port (%d)"</literal></expr></argument>,
                     <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodehost</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumSlaveDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PGXCNodeHandle</name>    <modifier>*</modifier></type><name>handle</name> <init>= <expr><operator>&amp;</operator><name><name>sdn_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type> <name>nodeoid</name> <init>= <expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>shmoids</name></expr></argument>, <argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>deleted</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>deleted</name></expr></argument>, <argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Node deleted: name (%s) host (%s) port (%d)"</literal></expr></argument>,
                     <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodehost</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Release palloc'ed memory */</comment>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>coOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dnOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>allOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>shmoids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>deleted</name> <operator>!=</operator> <name>NIL</name> <operator>||</operator> <name>added</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Nodes added/deleted. Reload needed!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>altered</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"No nodes altered. Returning"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PgxcNodeRefreshBackendHandlesShmem</name><argument_list>(<argument><expr><name>altered</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>altered</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>added</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>PGXCNodeSetConnectionState</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>DNConnectionState</name></type> <name>new_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"Changing connection state for node %s, old state %d, "</literal>
            <literal type="string">"new state %d"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>new_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>new_state</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
 * Handle ErrorResponse ('E') message from a Datanode connection for PGXCNodeHandle
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PGXCNodeHandleError</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>msg_body</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>message</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>detail</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>hint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>   <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>  <modifier>*</modifier></type><name>message_combine</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Scan until point to terminating \0
     */</comment>
    <while>while <condition>(<expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>len</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* pointer to the field message */</comment>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><name>msg_body</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name><name>msg_body</name><index>[<expr><name>offset</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">'M'</literal></expr>:</case>	<comment type="block">/* message */</comment>
                <expr_stmt><expr><name>message</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'D'</literal></expr>:</case>	<comment type="block">/* details */</comment>
                <expr_stmt><expr><name>detail</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'H'</literal></expr>:</case>	<comment type="block">/* hint */</comment>
                <expr_stmt><expr><name>hint</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
                <break>break;</break>

                <comment type="block">/* Fields not yet in use */</comment>
            <case>case <expr><literal type="char">'C'</literal></expr>:</case>	<comment type="block">/* code */</comment>
            <case>case <expr><literal type="char">'S'</literal></expr>:</case>	<comment type="block">/* severity */</comment>
            <case>case <expr><literal type="char">'R'</literal></expr>:</case>	<comment type="block">/* routine */</comment>
            <case>case <expr><literal type="char">'P'</literal></expr>:</case>	<comment type="block">/* position string */</comment>
            <case>case <expr><literal type="char">'p'</literal></expr>:</case>	<comment type="block">/* position int */</comment>
            <case>case <expr><literal type="char">'q'</literal></expr>:</case>	<comment type="block">/* int query */</comment>
            <case>case <expr><literal type="char">'W'</literal></expr>:</case>	<comment type="block">/* where */</comment>
            <case>case <expr><literal type="char">'F'</literal></expr>:</case>	<comment type="block">/* file */</comment>
            <case>case <expr><literal type="char">'L'</literal></expr>:</case>	<comment type="block">/* line */</comment>
            <default>default:</default>
                <break>break;</break>
        </block_content>}</block></switch>

        <comment type="block">/* code, message and \0 */</comment>
        <expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name>message_combine</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MAX_ERROR_MSG_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>message_combine</name></expr></argument>, <argument><expr><name>MAX_ERROR_MSG_LENGTH</name></expr></argument>,
             <argument><expr><literal type="string">"message:%s,detail:%s,hint:%s "</literal></expr></argument>,
             <argument><expr><ternary><condition><expr><name>message</name></expr> ?</condition><then> <expr><name>message</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
             <argument><expr><ternary><condition><expr><name>detail</name></expr>  ?</condition><then> <expr><name>detail</name></expr>  </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
             <argument><expr><ternary><condition><expr><name>hint</name></expr> ?</condition><then> <expr><name>hint</name></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>message_combine</name></expr></argument>, <argument><expr><name>MAX_ERROR_MSG_LENGTH</name></expr></argument>,
             <argument><expr><literal type="string">"nodename:%s,backend_pid:%d,message:%s,detail:%s,hint:%s "</literal></expr></argument>,
             <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>,
             <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>,
             <argument><expr><ternary><condition><expr><name>message</name></expr> ?</condition><then> <expr><name>message</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
             <argument><expr><ternary><condition><expr><name>detail</name></expr>  ?</condition><then> <expr><name>detail</name></expr>  </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
             <argument><expr><ternary><condition><expr><name>hint</name></expr> ?</condition><then> <expr><name>hint</name></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>,<argument><expr><name>message_combine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>message_combine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Do a "Diff" of backend NODE metadata and the one present in catalog
 *
 * We do this in order to identify if we should do a destructive
 * cleanup or just invalidation of some specific handles
 */</comment>
<function><type><name>bool</name></type>
<name>PgxcNodeDiffBackendHandles</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>nodes_alter</name></decl></parameter>,
               <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>nodes_delete</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>nodes_add</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>   <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>    <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>altered</name> <init>= <expr><name>NIL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>added</name> <init>= <expr><name>NIL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>deleted</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>catoids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>    <name>nodeoid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>PgxcNodeRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>SnapshotSelf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pgxc_node</name></type>  <name>nodeForm</name> <init>= <expr><operator>(</operator><name>Form_pgxc_node</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type> <name>nodeoid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name>ntype</name> <init>= <expr><name>PGXC_NODE_NONE</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>enable_multi_cluster</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodeForm</name><operator>-&gt;</operator><name>node_cluster_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PGXCClusterName</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>PGXC_NODE_GTM</name> <operator>==</operator> <name><name>nodeForm</name><operator>-&gt;</operator><name>node_type</name></name></expr>)</condition>
		<block>{<block_content>
            <continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name>nodeoid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>catoids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>catoids</name></expr></argument>, <argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * identify an entry with this nodeoid. If found
         * compare the name/host/port entries. If the name is
         * same and other info is different, it's an ALTER.
         * If the local entry does not exist in the catalog, it's
         * a DELETE. If the entry from catalog does not exist
         * locally, it's an ADDITION
         */</comment>
        <expr_stmt><expr><name>nid</name> <operator>=</operator> <call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name>nodeoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ntype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>nid</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* a new node has been added to the catalog */</comment>
            <expr_stmt><expr><name>added</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>added</name></expr></argument>, <argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Node added: name (%s) host (%s) port (%d)"</literal></expr></argument>,
                 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodeForm</name><operator>-&gt;</operator><name>node_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodeForm</name><operator>-&gt;</operator><name>node_host</name></name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><name><name>nodeForm</name><operator>-&gt;</operator><name>node_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>ntype</name> <operator>==</operator> <name>PGXC_NODE_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>co_handles</name><index>[<expr><name>nid</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>ntype</name> <operator>==</operator> <name>PGXC_NODE_DATANODE</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>dn_handles</name><index>[<expr><name>nid</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if<condition>(<expr><name>ntype</name> <operator>==</operator> <name>PGXC_NODE_SLAVEDATANODE</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>sdn_handles</name><index>[<expr><name>nid</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Node with non-existent node type!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="block">/*
             * compare name, host, port to see if this node
             * has been ALTERed
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodeForm</name><operator>-&gt;</operator><name>node_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call>
                <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
                <call><name>strncmp</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodehost</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodeForm</name><operator>-&gt;</operator><name>node_host</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call>
                <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
                <name><name>handle</name><operator>-&gt;</operator><name>nodeport</name></name> <operator>!=</operator> <name><name>nodeForm</name><operator>-&gt;</operator><name>node_port</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Node altered: old name (%s) old host (%s) old port (%d)"</literal>
                        <literal type="string">" new name (%s) new host (%s) new port (%d)"</literal></expr></argument>,
                     <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodehost</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeport</name></name></expr></argument>,
                     <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodeForm</name><operator>-&gt;</operator><name>node_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodeForm</name><operator>-&gt;</operator><name>node_host</name></name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name><name>nodeForm</name><operator>-&gt;</operator><name>node_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/*
                 * If this node itself is being altered, then we need to
                 * resort to a reload. Check so..
                 */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>PGXCNodeName</name></expr></argument>,
                                  <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodeForm</name><operator>-&gt;</operator><name>node_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>res</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>altered</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>altered</name></expr></argument>, <argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* else do nothing */</comment>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Any entry in backend area but not in catalog means that it has
     * been deleted
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumCoords</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>co_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nodeoid</name> <operator>=</operator> <name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>catoids</name></expr></argument>, <argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>deleted</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>deleted</name></expr></argument>, <argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Node deleted: name (%s) host (%s) port (%d)"</literal></expr></argument>,
                 <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodehost</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>dn_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nodeoid</name> <operator>=</operator> <name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>catoids</name></expr></argument>, <argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>deleted</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>deleted</name></expr></argument>, <argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Node deleted: name (%s) host (%s) port (%d)"</literal></expr></argument>,
                 <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodehost</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumSlaveDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>sdn_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nodeoid</name> <operator>=</operator> <name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>catoids</name></expr></argument>, <argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>deleted</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>deleted</name></expr></argument>, <argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Node deleted: name (%s) host (%s) port (%d)"</literal></expr></argument>,
                 <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodehost</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeport</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>nodes_alter</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>nodes_alter</name> <operator>=</operator> <name>altered</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>nodes_delete</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>nodes_delete</name> <operator>=</operator> <name>deleted</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>nodes_add</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>nodes_add</name> <operator>=</operator> <name>added</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>catoids</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>catoids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Refresh specific backend handles associated with
 * nodes in the "nodes_alter" list below
 *
 * The handles are refreshed using shared memory
 */</comment>
<function><type><name>void</name></type>
<name>PgxcNodeRefreshBackendHandlesShmem</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nodes_alter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>nodeoid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>nodes_alter</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name>ntype</name> <init>= <expr><name>PGXC_NODE_NONE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>NodeDefinition</name> <modifier>*</modifier></type><name>nodedef</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>nodeoid</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nid</name> <operator>=</operator> <call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name>nodeoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ntype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>nid</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Looks like node metadata changed again"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>ntype</name> <operator>==</operator> <name>PGXC_NODE_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>co_handles</name><index>[<expr><name>nid</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>ntype</name> <operator>==</operator> <name>PGXC_NODE_DATANODE</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>dn_handles</name><index>[<expr><name>nid</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if<condition>(<expr><name>ntype</name> <operator>==</operator> <name>PGXC_NODE_SLAVEDATANODE</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>handle</name> <operator>=</operator> <operator>&amp;</operator><name><name>sdn_handles</name><index>[<expr><name>nid</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Node with non-existent node type!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * Update the local backend handle data with data from catalog
         * Free the handle first..
         */</comment>
        <expr_stmt><expr><call><name>pgxc_node_free</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Backend (%u), Node (%s) updated locally"</literal></expr></argument>,
             <argument><expr><name>MyBackendId</name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nodedef</name> <operator>=</operator> <call><name>PgxcNodeGetDefinition</name><argument_list>(<argument><expr><name>nodeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodedef</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodehost</name></name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodedef</name><operator>-&gt;</operator><name>nodehost</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeport</name></name> <operator>=</operator> <name><name>nodedef</name><operator>-&gt;</operator><name>nodeport</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nodedef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>HandlePoolerMessages</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>HandlesRefreshPending</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>DoRefreshRemoteHandles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Backend (%u), doing handles refresh"</literal></expr></argument>,
             <argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>NODE_CONNECTION</name> <modifier>*</modifier></type>
<name>PGXCNodeConnectBarely</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>connstr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGconn</name>       <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
    <comment type="block">/* Delegate call to the pglib */</comment>
    <expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>PQconnectdb</name><argument_list>(<argument><expr><name>connstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <return>return <expr><operator>(</operator><name>NODE_CONNECTION</name> <operator>*</operator><operator>)</operator> <name>conn</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>char</name><modifier>*</modifier></type>
<name>PGXCNodeSendShowQuery</name><parameter_list>(<parameter><decl><type><name>NODE_CONNECTION</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql_command</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>        <name>resStatus</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type>  <name><name>number</name><index>[<expr><literal type="number">128</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="char">'0'</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>    <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><operator>(</operator><name>PGconn</name> <operator>*</operator><operator>)</operator> <name>conn</name></expr></argument>, <argument><expr><name>sql_command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>number</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>resStatus</name> <operator>=</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>resStatus</name> <operator>==</operator> <name>PGRES_TUPLES_OK</name> <operator>||</operator> <name>resStatus</name> <operator>==</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
    <block>{<block_content>           
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>number</name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>    
    <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <return>return <expr><name>number</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send SET query to given connection.
 * Query is sent asynchronously and results are consumed
 */</comment>
<function><type><name>int</name></type>
<name>PGXCNodeSendSetQuery</name><parameter_list>(<parameter><decl><type><name>NODE_CONNECTION</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql_command</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errmsg_buf</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>buf_len</name></decl></parameter>, <parameter><decl><type><name>SendSetQueryStatus</name><modifier>*</modifier></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>CommandId</name> <modifier>*</modifier></type><name>cmdId</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>          <name>error</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>          <name>res_status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGresult</name>    <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>time_t</name></type>         <name>now</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>          <name>expired</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPIRE_STRING</name></cpp:macro>       <cpp:value>"timeout expired"</cpp:value></cpp:define>    
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPIRE_STRING_LEN</name></cpp:macro> <cpp:value>15</cpp:value></cpp:define>

    <comment type="block">/* set default status to ok */</comment>
    <expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name>SendSetQuery_OK</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>cmdId</name> <operator>=</operator> <name>InvalidCommandId</name></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQsendQuery</name><argument_list>(<argument><expr><operator>(</operator><name>PGconn</name> <operator>*</operator><operator>)</operator> <name>conn</name></expr></argument>, <argument><expr><name>sql_command</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name>SendSetQuery_SendQuery_ERROR</name></expr>;</expr_stmt>
        
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Consume results from SET commands */</comment>
    <while>while <condition>(<expr><operator>(</operator><name>result</name> <operator>=</operator> <call><name>PQgetResultTimed</name><argument_list>(<argument><expr><operator>(</operator><name>PGconn</name> <operator>*</operator><operator>)</operator> <name>conn</name></expr></argument>, <argument><expr><name>now</name> <operator>+</operator> <name>PGXC_RESULT_TIME_OUT</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>res_status</name> <operator>=</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>res_status</name> <operator>!=</operator> <name>PGRES_TUPLES_OK</name> <operator>&amp;&amp;</operator> <name>res_status</name> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>errmsg_buf</name> <operator>&amp;&amp;</operator> <name>buf_len</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>errmsg_buf</name></expr></argument>, <argument><expr><name>buf_len</name></expr></argument>, <argument><expr><literal type="string">"%s !"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><operator>(</operator><name>PGconn</name> <operator>*</operator><operator>)</operator> <name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>error</name><operator>++</operator></expr>;</expr_stmt>

            <comment type="block">/* Expired when set */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><operator>(</operator><name>PGconn</name> <operator>*</operator><operator>)</operator> <name>conn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>EXPIRE_STRING</name></expr></argument>, <argument><expr><name>EXPIRE_STRING_LEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>expired</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><operator>*</operator><name>cmdId</name> <operator>=</operator> <call><name>PQresultCommandId</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        
        <comment type="block">/* TODO: Check that results are of type 'S' */</comment>
        <expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>expired</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name>SendSetQuery_EXPIRED</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>error</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name>SendSetQuery_Set_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><ternary><condition><expr><name>error</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>node_ready_for_query</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
    <return>return <expr><operator>(</operator><literal type="char">'Z'</literal> <operator>==</operator> <operator>(</operator><name>conn</name><operator>)</operator><operator>-&gt;</operator><name>last_command</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check the socket health status.
 * 
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pgxc_check_socket_health</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sock</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forRead</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forWrite</name></decl></parameter>, <parameter><decl><type><name>time_t</name></type> <name>end_time</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* We use poll(2) if available, otherwise select(2) */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_POLL</name></cpp:ifdef>
    <decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name></type> <name>input_fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>timeout_ms</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>ret</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>forRead</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>forWrite</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>input_fd</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <name>sock</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>input_fd</name><operator>.</operator><name>events</name></name> <operator>=</operator> <name>POLLERR</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>input_fd</name><operator>.</operator><name>revents</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>forRead</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>input_fd</name><operator>.</operator><name>events</name></name> <operator>|=</operator> <name>POLLIN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>forWrite</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>input_fd</name><operator>.</operator><name>events</name></name> <operator>|=</operator> <name>POLLOUT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Compute appropriate timeout interval */</comment>
    <if_stmt><if>if <condition>(<expr><name>end_time</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>time_t</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>timeout_ms</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>time_t</name></type>        <name>now</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>end_time</name> <operator>&gt;</operator> <name>now</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>timeout_ms</name> <operator>=</operator> <operator>(</operator><name>end_time</name> <operator>-</operator> <name>now</name><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>timeout_ms</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>poll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_fd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>timeout_ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>input_fd</name><operator>.</operator><name>revents</name></name> <operator>&amp;</operator> <name>POLLERR</name> <operator>||</operator>
			<name><name>input_fd</name><operator>.</operator><name>revents</name></name> <operator>&amp;</operator> <name>POLLNVAL</name> <operator>||</operator>
			<name><name>input_fd</name><operator>.</operator><name>revents</name></name> <operator>&amp;</operator> <name>POLLHUP</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>                            <comment type="block">/* !HAVE_POLL */</comment>

    <decl_stmt><decl><type><name>fd_set</name></type>        <name>input_mask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>fd_set</name></type>        <name>output_mask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>fd_set</name></type>        <name>except_mask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>ptr_timeout</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>forRead</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>forWrite</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>output_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>except_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>forRead</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>forWrite</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>except_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Compute appropriate timeout interval */</comment>
    <if_stmt><if>if <condition>(<expr><name>end_time</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>time_t</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ptr_timeout</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>time_t</name></type>        <name>now</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>end_time</name> <operator>&gt;</operator> <name>now</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name>end_time</name> <operator>-</operator> <name>now</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>ptr_timeout</name> <operator>=</operator> <operator>&amp;</operator><name>timeout</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><call><name>select</name><argument_list>(<argument><expr><name>sock</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output_mask</name></expr></argument>,
                  <argument><expr><operator>&amp;</operator><name>except_mask</name></expr></argument>, <argument><expr><name>ptr_timeout</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                            <comment type="block">/* HAVE_POLL */</comment>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pgxc_node_send_disconnect</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type> <name>handle</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cursor</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cons</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* size */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>msgLen</name> <init>= <expr><literal type="number">4</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msgLen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'N'</literal></expr>;</expr_stmt>
    <comment type="block">/* size */</comment>
    <expr_stmt><expr><name>msgLen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>msgLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msgLen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>cons</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>cons</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cons</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_QUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>pgxc_node_flush</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>PGXCNodeTypeString</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>node_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name>node_type</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>PGXC_NODE_COORDINATOR</name></expr>:</case>
            <return>return <expr><literal type="string">"Coordinator"</literal></expr>;</return>
            <break>break;</break>
        <case>case <expr><name>PGXC_NODE_DATANODE</name></expr>:</case>
            <return>return <expr><literal type="string">"Datanode"</literal></expr>;</return>
            <break>break;</break>
        <case>case <expr><name>PGXC_NODE_SLAVEDATANODE</name></expr>:</case>
            <return>return <expr><literal type="string">"DatanodeSlave"</literal></expr>;</return>
            <break>break;</break>
        <case>case <expr><name>PGXC_NODE_NONE</name></expr>:</case>
            <return>return <expr><literal type="string">"None"</literal></expr>;</return>
            <break>break;</break>
        <case>case <expr><name>PGXC_NODE_GTM</name></expr>:</case>
            <return>return <expr><literal type="string">"Gtm"</literal></expr>;</return>
            <break>break;</break>    
        <default>default:</default>
            <return>return <expr><literal type="string">"Unknown"</literal></expr>;</return>
            <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
<function><type><name>void</name></type> <name>PGXCGetCoordOidOthers</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>nodelist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>     <name>node_oid</name></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>int</name></type>     <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumCoords</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>node_oid</name>  <operator>=</operator> <name><name>co_handles</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeoid</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>co_handles</name><index>[<expr><name>PGXCNodeId</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>nodeoid</name> <operator>!=</operator> <name>node_oid</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>nodelist</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>node_oid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <return>return ;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>
<name>PGXCGetAllDnOid</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>nodelist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>     <name>node_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>node_oid</name>  <operator>=</operator> <name><name>dn_handles</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeoid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nodelist</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>node_oid</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return ;</return>

</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
 * Return the name of ascii-minimized coordinator as ddl leader cn
 */</comment>
<function><type><name>PGXCNodeHandle</name><modifier>*</modifier></type>
<name>find_ddl_leader_cn</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>			<modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGXCNodeHandle</name>	<modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumCoords</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>co_handles</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodename</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>co_handles</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodename</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>&amp;</operator><name><name>co_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return whether I am the leader cn
 */</comment>
<function><type><specifier>inline</specifier> <name>bool</name></type>
<name>is_ddl_leader_cn</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>first_cn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>(<expr><name>first_cn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>first_cn</name></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>bool</name></type>
<name>is_pgxc_handles_init</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>dn_handles</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>co_handles</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove leader_cn_handle from pgxc_connections
 */</comment>
<function><type><name>void</name></type>
<name>delete_leadercn_handle</name><parameter_list>(<parameter><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>pgxc_connections</name></decl></parameter>,
							<parameter><decl><type><name>PGXCNodeHandle</name><modifier>*</modifier></type> <name>leader_cn_handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>co_conn_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>find_leader_handle</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pgxc_connections</name> <operator>||</operator> <operator>!</operator><name>leader_cn_handle</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>co_conn_count</name> <operator>=</operator> <name><name>pgxc_connections</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>co_conn_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>pgxc_connections</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>leader_cn_handle</name> <operator>||</operator> <name>find_leader_handle</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>i</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>co_conn_count</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>pgxc_connections</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pgxc_connections</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>pgxc_connections</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>find_leader_handle</name></expr>)</condition>
			<block>{<block_content>
			<expr_stmt><expr><name><name>pgxc_connections</name><operator>-&gt;</operator><name>co_conn_count</name></name><operator>--</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>find_leader_handle</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * SerializeSessionId
 *		Dumps the serialized session id onto the memory location at 
 *		start_address for parallel workers
 */</comment>
<function><type><name>void</name></type>
<name>SerializeSessionId</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>maxsize</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start_address</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	
	<if_stmt><if>if<condition>(<expr><name><name>PGXCSessionId</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>start_address</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>PGXCSessionId</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>start_address</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>start_address</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>PGXCSessionId</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * StartParallelWorkerSessionId
 *		Reads the serialized session id and set it on parallel workers
 */</comment>
<function><type><name>void</name></type>
<name>StartParallelWorkerSessionId</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>address</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sidspace</name> <init>= <expr><name>address</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	
	<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>address</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* len */</comment>
		<expr_stmt><expr><name><name>PGXCSessionId</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>PGXCSessionId</name></expr></argument>, <argument><expr><name>sidspace</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
