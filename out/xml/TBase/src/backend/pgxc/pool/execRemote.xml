<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/pgxc/pool/execRemote.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * execRemote.c
 *
 *      Functions to execute commands on remote Datanodes
 *
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2011, PostgreSQL Global Development Group
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 *
 *
 * IDENTIFICATION
 *      src/backend/pgxc/pool/execRemote.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/prepare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gtm/gtm_c.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSubplan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/copyops.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/nodemgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/poolmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_rusage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tuplesort.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/locator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/xc_maintenance_mode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_class.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/explain_dist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/squeue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execParallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeModifyTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/print.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
 * We do not want it too long, when query is terminating abnormally we just
 * want to read in already available data, if datanode connection will reach a
 * consistent state after that, we will go normal clean up procedure: send down
 * ABORT etc., if data node is not responding we will signal pooler to drop
 * the connection.
 * It is better to drop and recreate datanode connection then wait for several
 * seconds while it being cleaned up when, for example, cancelling query.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>END_QUERY_TIMEOUT</name></cpp:macro>    <cpp:value>1000</cpp:value></cpp:define>

<comment type="block">/* Declarations used by guc.c */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>PGXLRemoteFetchSize</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>g_in_plpgsql_exec_fun</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>PlpgsqlDebugPrint</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>need_global_snapshot</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>executed_node_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/* GUC parameter */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>DataRowBufferSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* MBytes */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATA_ROW_BUFFER_SIZE</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(DataRowBufferSize * 1024 * 1024 * (n))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>xact_callback</name></type> <name>function</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>fparams</name></decl>;</decl_stmt>
}</block></struct></type> <name>abort_callback_type</name>;</typedef>

<struct>struct <name>find_params_context</name>
<block>{
    <decl_stmt><decl><type><name>RemoteParam</name> <modifier>*</modifier></type><name>rparams</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>defineParams</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>subplans</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * Buffer size does not affect performance significantly, just do not allow
 * connection buffer grows infinitely
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPY_BUFFER_SIZE</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRIMARY_NODE_WRITEAHEAD</name></cpp:macro> <cpp:value>1024 * 1024</cpp:value></cpp:define>

<comment type="block">/*
 * Flag to track if a temporary object is accessed by the current transaction
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>temp_object_included</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>abort_callback_type</name></type> <name>dbcleanup_info</name> <init>= <expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>pgxc_node_begin</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>conn_count</name></decl></parameter>, <parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier><modifier>*</modifier></type> <name>connections</name></decl></parameter>,
				<parameter><decl><type><name>GlobalTransactionId</name></type> <name>gxid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_tran_block</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>readOnly</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>get_exec_connections</name><parameter_list>(<parameter><decl><type><name>RemoteQueryState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
                     <parameter><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>exec_nodes</name></decl></parameter>,
                     <parameter><decl><type><name>RemoteQueryExecType</name></type> <name>exec_type</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name></type> <name>is_global_session</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgxc_start_command_on_connection</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>,
                    <parameter><decl><type><name>RemoteQueryState</name> <modifier>*</modifier></type><name>remotestate</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgxc_node_remote_count</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dnCount</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name><name>dnNodeIds</name><index>[]</index></name></decl></parameter>,
        <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>coordCount</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name><name>coordNodeIds</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pgxc_node_remote_prepare</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>prepareGID</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>localNode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>implicit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pgxc_node_remote_finish</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>prepareGID</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>commit</name></decl></parameter>,
                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodestring</name></decl></parameter>, <parameter><decl><type><name>GlobalTransactionId</name></type> <name>gxid</name></decl></parameter>,
                        <parameter><decl><type><name>GlobalTransactionId</name></type> <name>prepare_gxid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>
<name>pgxc_node_remote_prefinish</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>prepareGID</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodestring</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*static void pgxc_node_remote_abort_subtxn(void);*/</comment>
<comment type="block">/*static void pgxc_node_remote_commit_subtxn(void);*/</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgxc_abort_connections</name><parameter_list>(<parameter><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>all_handles</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgxc_node_remote_commit</name><parameter_list>(<parameter><decl><type><name>TranscationType</name></type> <name>txn_type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_release_handle</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgxc_node_remote_abort</name><parameter_list>(<parameter><decl><type><name>TranscationType</name></type> <name>txn_type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_release_handle</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>pgxc_node_remote_commit_internal</name><parameter_list>(<parameter><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>handles</name></decl></parameter>, <parameter><decl><type><name>TranscationType</name></type> <name>txn_type</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pgxc_connections_cleanup</name><parameter_list>(<parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>determine_param_types</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,  <parameter><decl><type><name><name>struct</name> <name>find_params_context</name></name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REMOVE_CURR_CONN</name><parameter_list>(<parameter><type><name>combiner</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>if ((combiner)-&gt;current_conn &lt; --((combiner)-&gt;conn_count)) \
    { \
        (combiner)-&gt;connections[(combiner)-&gt;current_conn] = \
                (combiner)-&gt;connections[(combiner)-&gt;conn_count]; \
    } \
    else \
        (combiner)-&gt;current_conn = 0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_STATEMENTS_PER_TRAN</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<comment type="block">/* Variables to collect statistics */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>total_transactions</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>total_statements</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>total_autocommit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>nonautocommit_2pc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>autocommit_2pc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>    <name>current_tran_statements</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name> <modifier>*</modifier></type><name>statements_per_transaction</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name> <modifier>*</modifier></type><name>nodes_per_transaction</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * statistics collection: count a statement
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>stat_statement</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>total_statements</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>current_tran_statements</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * clean memory related to stat transaction
 */</comment>
<function><type><name>void</name></type>
<name>clean_stat_transaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>nodes_per_transaction</name></expr>)</condition>
	<block>{<block_content>
		<return>return ;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>nodes_per_transaction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nodes_per_transaction</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * To collect statistics: count a transaction
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>stat_transaction</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>node_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>total_transactions</name><operator>++</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>statements_per_transaction</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>statements_per_transaction</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><operator>(</operator><name>MAX_STATEMENTS_PER_TRAN</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>statements_per_transaction</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>MAX_STATEMENTS_PER_TRAN</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>current_tran_statements</name> <operator>&gt;</operator> <name>MAX_STATEMENTS_PER_TRAN</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>statements_per_transaction</name><index>[<expr><name>MAX_STATEMENTS_PER_TRAN</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>statements_per_transaction</name><index>[<expr><name>current_tran_statements</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name>current_tran_statements</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>node_count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>node_count</name> <operator>&lt;=</operator> <name>NumDataNodes</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>nodes_per_transaction</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>nodes_per_transaction</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>NumDataNodes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nodes_per_transaction</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NumDataNodes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>nodes_per_transaction</name><index>[<expr><name>node_count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Output collected statistics to the log
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>stat_log</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Total Transactions: %d Total Statements: %d"</literal></expr></argument>, <argument><expr><name>total_transactions</name></expr></argument>, <argument><expr><name>total_statements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Autocommit: %d 2PC for Autocommit: %d 2PC for non-Autocommit: %d"</literal></expr></argument>,
         <argument><expr><name>total_autocommit</name></expr></argument>, <argument><expr><name>autocommit_2pc</name></expr></argument>, <argument><expr><name>nonautocommit_2pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>total_transactions</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>statements_per_transaction</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_STATEMENTS_PER_TRAN</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"%d Statements per Transaction: %d (%d%%)"</literal></expr></argument>,
                     <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>statements_per_transaction</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>statements_per_transaction</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <literal type="number">100</literal> <operator>/</operator> <name>total_transactions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"%d+ Statements per Transaction: %d (%d%%)"</literal></expr></argument>,
             <argument><expr><name>MAX_STATEMENTS_PER_TRAN</name></expr></argument>, <argument><expr><name><name>statements_per_transaction</name><index>[<expr><name>MAX_STATEMENTS_PER_TRAN</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>statements_per_transaction</name><index>[<expr><name>MAX_STATEMENTS_PER_TRAN</name></expr>]</index></name> <operator>*</operator> <literal type="number">100</literal> <operator>/</operator> <name>total_transactions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>nodes_per_transaction</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"%d Nodes per Transaction: %d (%d%%)"</literal></expr></argument>,
                     <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>nodes_per_transaction</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>nodes_per_transaction</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <literal type="number">100</literal> <operator>/</operator> <name>total_transactions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Create a structure to store parameters needed to combine responses from
 * multiple connections as well as state information
 */</comment>
<function><type><name>void</name></type>
<name>InitResponseCombiner</name><parameter_list>(<parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>node_count</name></decl></parameter>,
                       <parameter><decl><type><name>CombineType</name></type> <name>combine_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>node_count</name></name> <operator>=</operator> <name>node_count</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>=</operator> <name>combine_type</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn_rows_consumed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>command_complete_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>=</operator> <name>REQUEST_TYPE_NOT_DEFINED</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>description_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>copy_in_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>copy_out_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>copy_file</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorDetail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorHint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>probing_primary</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>returning_node</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>rowBuffer</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tapenodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>merge_sort</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>extended_query</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tapemarks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tuplesortstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>update_cursor</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_connections</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>remoteCopyType</name></name> <operator>=</operator> <name>REMOTE_COPY_NONE</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name>  <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name></name>      <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tmpslot</name></name>        <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_datarows</name></name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name></name>  <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>is_abort</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_instr_htbl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
 * Parse out row count from the command status response and convert it to integer
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_row_count</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>rowcount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>digits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>pos</name></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>rowcount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <comment type="block">/* skip \0 string terminator */</comment>
    <for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>pos</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>message</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>message</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>rowcount</name> <operator>=</operator> <operator>*</operator><name>rowcount</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <name><name>message</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>digits</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>rowcount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>digits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>digits</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert RowDescription message to a TupleDesc
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>create_tuple_desc</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>msg_body</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TupleDesc</name></type>     <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>i</name></decl>, <decl><type ref="prev"/><name>nattr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16</name></type>        <name>n16</name></decl>;</decl_stmt>

    <comment type="block">/* get number of attributes */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n16</name></expr></argument>, <argument><expr><name>msg_body</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nattr</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name>n16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>msg_body</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>nattr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* decode attributes */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>nattr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attnum</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>typname</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>         <name>oidtypeid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>         <name>typemode</name></decl>, <decl><type ref="prev"/><name>typmod</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>attnum</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name><operator>)</operator> <name>i</name></expr>;</expr_stmt>

        <comment type="block">/* attribute name */</comment>
        <expr_stmt><expr><name>attname</name> <operator>=</operator> <name>msg_body</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>msg_body</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <comment type="block">/* type name */</comment>
        <expr_stmt><expr><name>typname</name> <operator>=</operator> <name>msg_body</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>msg_body</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>typname</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <comment type="block">/* table OID, ignored */</comment>
        <expr_stmt><expr><name>msg_body</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

        <comment type="block">/* column no, ignored */</comment>
        <expr_stmt><expr><name>msg_body</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

        <comment type="block">/* data type OID, ignored */</comment>
        <expr_stmt><expr><name>msg_body</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

        <comment type="block">/* type len, ignored */</comment>
        <expr_stmt><expr><name>msg_body</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

        <comment type="block">/* type mod */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>typemode</name></expr></argument>, <argument><expr><name>msg_body</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>typmod</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>typemode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>msg_body</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

        <comment type="block">/* PGXCTODO text/binary flag? */</comment>
        <expr_stmt><expr><name>msg_body</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

        <comment type="block">/* Get the OID type and mode type from typename */</comment>
        <expr_stmt><expr><call><name>parseTypeString</name><argument_list>(<argument><expr><name>typname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oidtypeid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>, <argument><expr><name>oidtypeid</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Handle CopyOutCommandComplete ('c') message from a Datanode connection
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>HandleCopyOutComplete</name><parameter_list>(<parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>==</operator> <name>REQUEST_TYPE_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>==</operator> <name>REQUEST_TYPE_NOT_DEFINED</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>=</operator> <name>REQUEST_TYPE_COPY_OUT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>!=</operator> <name>REQUEST_TYPE_COPY_OUT</name></expr>)</condition><block type="pseudo"><block_content>
        <comment type="block">/* Inconsistent responses */</comment>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unexpected response from the Datanodes for 'c' message, current request type %d"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* Just do nothing, close message is managed by the Coordinator */</comment>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>copy_out_count</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle CommandComplete ('C') message from a Datanode connection
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>HandleCommandComplete</name><parameter_list>(<parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>msg_body</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>             <name>digits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EState</name>           <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * If we did not receive description we are having rowcount or OK response
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>==</operator> <name>REQUEST_TYPE_NOT_DEFINED</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>=</operator> <name>REQUEST_TYPE_COMMAND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* Extract rowcount */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>!=</operator> <name>COMBINE_TYPE_NONE</name> <operator>&amp;&amp;</operator> <name>estate</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>uint64</name></type>    <name>rowcount</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>digits</name> <operator>=</operator> <call><name>parse_row_count</name><argument_list>(<argument><expr><name>msg_body</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rowcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>digits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Replicated write, make sure they are the same */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>==</operator> <name>COMBINE_TYPE_SAME</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>command_complete_count</name></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * Replicated command may succeed on on node and fail on
                     * another. The example is if distributed table referenced
                     * by a foreign key constraint defined on a partitioned
                     * table. If command deletes rows from the replicated table
                     * they may be referenced on one Datanode but not on other.
                     * So, replicated command on each Datanode either affects
                     * proper number of rows, or returns error. Here if
                     * combiner got an error already, we allow to report it,
                     * not the scaring data corruption message.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>rowcount</name> <operator>!=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr>)</condition>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <block>{<block_content>
                        <comment type="block">/*
                          * In extend query protocol, need to set connection to idle
                          */</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>extended_query</name></name> <operator>&amp;&amp;</operator>
                            <name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DN_CONNECTION_STATE_QUERY</name></expr>)</condition>                    
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>     <name>_PG_REGRESS_</name></cpp:ifdef>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"RESPONSE_COMPLETE_2 set node %s, remote pid %d DN_CONNECTION_STATE_IDLE"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <comment type="block">/* There is a consistency issue in the database with the replicated table */</comment>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Write to replicated table returned different results from the Datanodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <comment type="block">/* first result */</comment>
                    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>=</operator> <name>rowcount</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>+=</operator> <name>rowcount</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>DML_processed</name></name> <operator>+=</operator> <name>rowcount</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>=</operator> <name>COMBINE_TYPE_NONE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* If response checking is enable only then do further processing */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>ck_resp_rollback</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>msg_body</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Subsequent clean up routine will be checking this flag
             * to determine nodes where to send ROLLBACK PREPARED.
             * On current node PREPARE has failed and the two-phase record
             * does not exist, so clean this flag as if PREPARE was not sent
             * to that node and avoid erroneous command.
             */</comment>
            <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>ck_resp_rollback</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <comment type="block">/*
             * Set the error, if none, to force throwing.
             * If there is error already, it will be thrown anyway, do not add
             * this potentially confusing message
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ErrorContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>=</operator>
                                <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"unexpected ROLLBACK from remote node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/*
                 * ERRMSG_PRODUCER_ERROR
                 * Messages with this code are replaced by others, if they are
                 * received, so if node will send relevant error message that
                 * one will be replaced.
                 */</comment>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorCode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'X'</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorCode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'X'</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorCode</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorCode</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'1'</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorCode</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>command_complete_count</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle RowDescription ('T') message from a Datanode connection
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HandleRowDescription</name><parameter_list>(<parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>msg_body</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>==</operator> <name>REQUEST_TYPE_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>==</operator> <name>REQUEST_TYPE_NOT_DEFINED</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>=</operator> <name>REQUEST_TYPE_QUERY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>!=</operator> <name>REQUEST_TYPE_QUERY</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Inconsistent responses */</comment>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unexpected response from the Datanodes for 'T' message, current request type %d"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
	
	<comment type="block">/* should ignore received tuple desc if already got one to avoid duplicate name issue */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<call><name>IsA</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>RemoteQuery</name> <operator>*</operator><operator>)</operator> <name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>ignore_tuple_desc</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	
    <comment type="block">/* Increment counter and check if it was first */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>description_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>description_count</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>create_tuple_desc</name><argument_list>(<argument><expr><name>msg_body</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>description_count</name></name><operator>++</operator></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
<comment type="block">/*
 * Handle Apply ('4') message from a Datanode connection
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>HandleApplyDone</name><parameter_list>(<parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>==</operator> <name>REQUEST_TYPE_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>==</operator> <name>REQUEST_TYPE_NOT_DEFINED</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>=</operator> <name>REQUEST_TYPE_COMMAND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>!=</operator> <name>REQUEST_TYPE_COMMAND</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Inconsistent responses */</comment>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unexpected response from the Datanodes for '4' message, current request type %d"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>command_complete_count</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * Handle CopyInResponse ('G') message from a Datanode connection
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>HandleCopyIn</name><parameter_list>(<parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>==</operator> <name>REQUEST_TYPE_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>==</operator> <name>REQUEST_TYPE_NOT_DEFINED</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>=</operator> <name>REQUEST_TYPE_COPY_IN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>!=</operator> <name>REQUEST_TYPE_COPY_IN</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Inconsistent responses */</comment>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unexpected response from the Datanodes for 'G' message, current request type %d"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/*
     * The normal PG code will output an G message when it runs in the
     * Coordinator, so do not proxy message here, just count it.
     */</comment>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>copy_in_count</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle CopyOutResponse ('H') message from a Datanode connection
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>HandleCopyOut</name><parameter_list>(<parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>==</operator> <name>REQUEST_TYPE_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>==</operator> <name>REQUEST_TYPE_NOT_DEFINED</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>=</operator> <name>REQUEST_TYPE_COPY_OUT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>!=</operator> <name>REQUEST_TYPE_COPY_OUT</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Inconsistent responses */</comment>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unexpected response from the Datanodes for 'H' message, current request type %d"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/*
     * The normal PG code will output an H message when it runs in the
     * Coordinator, so do not proxy message here, just count it.
     */</comment>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>copy_out_count</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle CopyOutDataRow ('d') message from a Datanode connection
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>HandleCopyDataRow</name><parameter_list>(<parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>msg_body</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>==</operator> <name>REQUEST_TYPE_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>==</operator> <name>REQUEST_TYPE_NOT_DEFINED</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>=</operator> <name>REQUEST_TYPE_COPY_OUT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Inconsistent responses */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>!=</operator> <name>REQUEST_TYPE_COPY_OUT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unexpected response from the Datanodes for 'd' message, current request type %d"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* count the row */</comment>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>processed</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* Output remote COPY operation to correct location */</comment>
    <switch>switch <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>remoteCopyType</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>REMOTE_COPY_FILE</name></expr>:</case>
            <comment type="block">/* Write data directly to file */</comment>
            <expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><name>msg_body</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>copy_file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>REMOTE_COPY_STDOUT</name></expr>:</case>
            <comment type="block">/* Send back data to client */</comment>
            <expr_stmt><expr><call><name>pq_putmessage</name><argument_list>(<argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name>msg_body</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>REMOTE_COPY_TUPLESTORE</name></expr>:</case>
            <comment type="block">/*
             * Do not store trailing \n character.
             * When tuplestore data are loaded to a table it automatically
             * inserts line ends.
             */</comment>
            <expr_stmt><expr><call><name>tuplestore_putmessage</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>tuplestorestate</name></name></expr></argument>, <argument><expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>msg_body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>REMOTE_COPY_NONE</name></expr>:</case>
        <default>default:</default>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Should not happen */</comment>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Handle DataRow ('D') message from a Datanode connection
 * The function returns true if data row is accepted and successfully stored
 * within the combiner.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>HandleDataRow</name><parameter_list>(<parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>msg_body</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* We expect previous message is consumed */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>==</operator> <name>REQUEST_TYPE_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>!=</operator> <name>REQUEST_TYPE_QUERY</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Inconsistent responses */</comment>
        <decl_stmt><decl><type><name>char</name></type> <name><name>data_buf</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
        
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>data_buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>msg_body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">4095</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">4095</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>data_buf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unexpected response from the data nodes for 'D' message, current request type %d, data %s"</literal></expr></argument>,
                     <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name></expr></argument>, <argument><expr><name>data_buf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If we got an error already ignore incoming data rows from other nodes
     * Still we want to continue reading until get CommandComplete
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Replicated INSERT/UPDATE/DELETE with RETURNING: receive only tuples
     * from one node, skip others as duplicates
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>==</operator> <name>COMBINE_TYPE_SAME</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Do not return rows when probing primary, instead return when doing
         * first normal node. Just save some CPU and traffic in case if
         * probing fails.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>probing_primary</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>returning_node</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>returning_node</name></name> <operator>!=</operator> <name>node</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>returning_node</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * We are copying message because it points into connection buffer, and
     * will be overwritten on next socket read
     */</comment>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>=</operator> <operator>(</operator><name>RemoteDataRow</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RemoteDataRowData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>, <argument><expr><name>msg_body</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name><operator>-&gt;</operator><name>msglen</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name><operator>-&gt;</operator><name>msgnode</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Handle ErrorResponse ('E') message from a Datanode connection
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>HandleError</name><parameter_list>(<parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>msg_body</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APPEND_LENGTH</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>message_trans</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* parse error message */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>code</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>message</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>detail</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>hint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>   <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Scan until point to terminating \0
     */</comment>
    <while>while <condition>(<expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>len</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* pointer to the field message */</comment>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><name>msg_body</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name><name>msg_body</name><index>[<expr><name>offset</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">'C'</literal></expr>:</case>    <comment type="block">/* code */</comment>
                <expr_stmt><expr><name>code</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'M'</literal></expr>:</case>    <comment type="block">/* message */</comment>
                <expr_stmt><expr><name>message</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><literal type="char">'D'</literal></expr>:</case>    <comment type="block">/* details */</comment>
                <expr_stmt><expr><name>detail</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'H'</literal></expr>:</case>    <comment type="block">/* hint */</comment>
                <expr_stmt><expr><name>hint</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
                <break>break;</break>

            <comment type="block">/* Fields not yet in use */</comment>
            <case>case <expr><literal type="char">'S'</literal></expr>:</case>    <comment type="block">/* severity */</comment>
            <case>case <expr><literal type="char">'R'</literal></expr>:</case>    <comment type="block">/* routine */</comment>
            <case>case <expr><literal type="char">'P'</literal></expr>:</case>    <comment type="block">/* position string */</comment>
            <case>case <expr><literal type="char">'p'</literal></expr>:</case>    <comment type="block">/* position int */</comment>
            <case>case <expr><literal type="char">'q'</literal></expr>:</case>    <comment type="block">/* int query */</comment>
            <case>case <expr><literal type="char">'W'</literal></expr>:</case>    <comment type="block">/* where */</comment>
            <case>case <expr><literal type="char">'F'</literal></expr>:</case>    <comment type="block">/* file */</comment>
            <case>case <expr><literal type="char">'L'</literal></expr>:</case>    <comment type="block">/* line */</comment>
            <default>default:</default>
                <break>break;</break>
        </block_content>}</block></switch>

        <comment type="block">/* code, message and \0 */</comment>
        <expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * We may have special handling for some errors, default handling is to
     * throw out error with the same message. We can not ereport immediately
     * because we should read from this and other connections until
     * ReadyForQuery is received, so we just store the error message.
     * If multiple connections return errors only first one is reported.
     *
     * The producer error may be hiding primary error, so if previously received
     * error is a producer error allow it to be overwritten.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
            <call><name>MAKE_SQLSTATE</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorCode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorCode</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                          <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorCode</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorCode</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,
                          <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorCode</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ERRCODE_PRODUCER_ERROR</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ErrorContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>     <name>_PG_REGRESS_</name></cpp:ifdef>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>message_trans</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <comment type="block">/* output more details */</comment>
        <if_stmt><if>if <condition>(<expr><name>message</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>message_trans</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call><operator>+</operator><name>APPEND_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>message_trans</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call><operator>+</operator><name>APPEND_LENGTH</name></expr></argument>,
                <argument><expr><literal type="string">"nodename:%s,backend_pid:%d,message:%s"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>,<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>,<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>=</operator> <name>message_trans</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Error Code is exactly 5 significant bytes */</comment>
        <if_stmt><if>if <condition>(<expr><name>code</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorCode</name></name></expr></argument>, <argument><expr><name>code</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>detail</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorDetail</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>detail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>hint</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorHint</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If the PREPARE TRANSACTION command fails for whatever reason, we don't
     * want to send down ROLLBACK PREPARED to this node. Otherwise, it may end
     * up rolling back an unrelated prepared transaction with the same GID as
     * used by this transaction
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>ck_resp_rollback</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>ck_resp_rollback</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If Datanode have sent ErrorResponse it will never send CommandComplete.
     * Increment the counter to prevent endless waiting for it.
     */</comment>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>command_complete_count</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * HandleCmdComplete -
 *    combine deparsed sql statements execution results
 *
 * Input parameters:
 *    commandType is dml command type
 *    combineTag is used to combine the completion result
 *    msg_body is execution result needed to combine
 *    len is msg_body size
 */</comment>
<function><type><name>void</name></type>
<name>HandleCmdComplete</name><parameter_list>(<parameter><decl><type><name>CmdType</name></type> <name>commandType</name></decl></parameter>, <parameter><decl><type><name>CombineTag</name> <modifier>*</modifier></type><name>combine</name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg_body</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>    <name>digits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>    <name>originrowcount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>    <name>rowcount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>    <name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>msg_body</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* if there's nothing in combine, just copy the msg_body */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>combine</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>combine</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>msg_body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combine</name><operator>-&gt;</operator><name>cmdType</name></name> <operator>=</operator> <name>commandType</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* commandType is conflict */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>combine</name><operator>-&gt;</operator><name>cmdType</name></name> <operator>!=</operator> <name>commandType</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <comment type="block">/* get the processed row number from msg_body */</comment>
        <expr_stmt><expr><name>digits</name> <operator>=</operator> <call><name>parse_row_count</name><argument_list>(<argument><expr><name>msg_body</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rowcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"digits is %d\n"</literal></expr></argument>, <argument><expr><name>digits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>digits</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* no need to combine */</comment>
        <if_stmt><if>if <condition>(<expr><name>digits</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <comment type="block">/* combine the processed row number */</comment>
        <expr_stmt><expr><call><name>parse_row_count</name><argument_list>(<argument><expr><name><name>combine</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>combine</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>originrowcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"originrowcount is %lu, rowcount is %lu\n"</literal></expr></argument>, <argument><expr><name>originrowcount</name></expr></argument>, <argument><expr><name>rowcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>total</name> <operator>=</operator> <name>originrowcount</name> <operator>+</operator> <name>rowcount</name></expr>;</expr_stmt>

    </block_content>}</block></else></if_stmt>

    <comment type="block">/* output command completion tag */</comment>
    <switch>switch <condition>(<expr><name>commandType</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>CMD_SELECT</name></expr>:</case>
            <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>combine</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>CMD_INSERT</name></expr>:</case>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>combine</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>COMPLETION_TAG_BUFSIZE</name></expr></argument>,
               <argument><expr><literal type="string">"INSERT %u %lu"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>combine</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>COMPLETION_TAG_BUFSIZE</name></expr></argument>,
                     <argument><expr><literal type="string">"UPDATE %lu"</literal></expr></argument>, <argument><expr><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>CMD_DELETE</name></expr>:</case>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>combine</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>COMPLETION_TAG_BUFSIZE</name></expr></argument>,
                     <argument><expr><literal type="string">"DELETE %lu"</literal></expr></argument>, <argument><expr><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>combine</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

</block_content>}</block></function>

<comment type="block">/*
 * HandleDatanodeCommandId ('M') message from a Datanode connection
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>HandleDatanodeCommandId</name><parameter_list>(<parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>msg_body</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>n32</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CommandId</name></type>    <name>cid</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>msg_body</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get the command Id */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>msg_body</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cid</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If received command Id is higher than current one, set it to a new value */</comment>
    <if_stmt><if>if <condition>(<expr><name>cid</name> <operator>&gt;</operator> <call><name>GetReceivedCommandId</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>SetReceivedCommandId</name><argument_list>(<argument><expr><name>cid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Record waited-for XIDs received from the remote nodes into the transaction
 * state
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>HandleWaitXids</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>msg_body</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>xid_count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>n32</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cur</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Get the xid count */</comment>
    <expr_stmt><expr><name>xid_count</name> <operator>=</operator> <name>len</name> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <expr_stmt><expr><name>cur</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>xid_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cur</name> <operator>&lt;</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>msg_body</name><index>[<expr><name>cur</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cur</name> <operator>=</operator> <name>cur</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TransactionRecordXidWait</name><argument_list>(<argument><expr><call><name>ntohl</name><argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>HandleGlobalTransactionId</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>msg_body</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GlobalTransactionId</name></type> <name>xid</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>==</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>GlobalTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>msg_body</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GlobalTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SetTopTransactionId</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
 * Examine the specified combiner state and determine if command was completed
 * successfully
 */</comment>
<function><type><name>bool</name></type>
<name>validate_combiner</name><parameter_list>(<parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* There was error message while combining */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"validate_combiner there is errorMessage in combiner, errorMessage: %s"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Check if state is defined */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>==</operator> <name>REQUEST_TYPE_NOT_DEFINED</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"validate_combiner request_type is REQUEST_TYPE_NOT_DEFINED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check all nodes completed */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>==</operator> <name>REQUEST_TYPE_COMMAND</name>
            <operator>||</operator> <name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>==</operator> <name>REQUEST_TYPE_QUERY</name><operator>)</operator>
            <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>command_complete_count</name></name> <operator>!=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>node_count</name></name></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"validate_combiner request_type is %d, command_complete_count:%d not equal node_count:%d"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>command_complete_count</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>node_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check count of description responses */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>==</operator> <name>REQUEST_TYPE_QUERY</name> <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>description_count</name></name> <operator>!=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>node_count</name></name><operator>)</operator> 
        <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>,<argument><expr><name>RemoteSubplanState</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"validate_combiner request_type is REQUEST_TYPE_QUERY, description_count:%d not equal node_count:%d"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>description_count</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>node_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check count of copy-in responses */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>==</operator> <name>REQUEST_TYPE_COPY_IN</name>
            <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>copy_in_count</name></name> <operator>!=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>node_count</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"validate_combiner request_type is REQUEST_TYPE_COPY_IN, copy_in_count:%d not equal node_count:%d"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>copy_in_count</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>node_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Check count of copy-out responses */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>==</operator> <name>REQUEST_TYPE_COPY_OUT</name>
            <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>copy_out_count</name></name> <operator>!=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>node_count</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"validate_combiner request_type is REQUEST_TYPE_COPY_OUT, copy_out_count:%d not equal node_count:%d"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>copy_out_count</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>node_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Add other checks here as needed */</comment>

    <comment type="block">/* All is good if we are here */</comment>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Close combiner and free allocated memory, if it is not needed
 */</comment>
<function><type><name>void</name></type>
<name>CloseCombiner</name><parameter_list>(<parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* in some cases the memory is allocated in connections handle, we can not free it and it is not necessary to free it here, because the memory context will be reset. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    if (combiner-&gt;connections)
    {
        pfree(combiner-&gt;connections);
        combiner-&gt;connections = NULL;
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>FreeTupleDesc</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>errorDetail</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorDetail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorDetail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>errorHint</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorHint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorHint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_connections</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_connections</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_connections</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>tapenodes</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>tapenodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tapenodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>tapemarks</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>tapemarks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tapemarks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_instr_htbl</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_instr_htbl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_instr_htbl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Validate combiner and release storage freeing allocated memory
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ValidateAndCloseCombiner</name><parameter_list>(<parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>valid</name> <init>= <expr><call><name>validate_combiner</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>CloseCombiner</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>valid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * It is possible if multiple steps share the same Datanode connection, when
 * executor is running multi-step query or client is running multiple queries
 * using Extended Query Protocol. After returning next tuple ExecRemoteQuery
 * function passes execution control to the executor and then it can be given
 * to the same RemoteQuery or to different one. It is possible that before
 * returning a tuple the function do not read all Datanode responses. In this
 * case pending responses should be read in context of original RemoteQueryState
 * till ReadyForQuery message and data rows should be stored (buffered) to be
 * available when fetch from that RemoteQueryState is requested again.
 * BufferConnection function does the job.
 * If a RemoteQuery is going to use connection it should check connection state.
 * DN_CONNECTION_STATE_QUERY indicates query has data to read and combiner
 * points to the original RemoteQueryState. If combiner differs from "this" the
 * connection should be buffered.
 */</comment>
<function><type><name>void</name></type>
<name>BufferConnection</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_prefetch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>combiner</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>combiner</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_QUERY</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Buffer connection %u to step %s"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * When BufferConnection is invoked CurrentContext is related to other
     * portal, which is trying to control the connection.
     * TODO See if we can find better context to switch to
     */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Verify the connection is in use by the combiner */</comment>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>&lt;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr>]</index></name> <operator>==</operator> <name>conn</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>&lt;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>tapemarks</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tapemarks</name></name> <operator>=</operator> <operator>(</operator><name>ListCell</name><operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If current bookmark for the current tape is not set it means either
     * first row in the buffer is from the current tape or no rows from
     * the tape in the buffer, so if first row is not from current
     * connection bookmark the last cell in the list.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>tapemarks</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
            <call><name>list_length</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>rowBuffer</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RemoteDataRow</name></type> <name>dataRow</name> <init>= <expr><operator>(</operator><name>RemoteDataRow</name><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>rowBuffer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>dataRow</name><operator>-&gt;</operator><name>msgnode</name></name> <operator>!=</operator> <name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tapemarks</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr>]</index></name> <operator>=</operator> <call><name>list_tail</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>rowBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/*
     * Buffer data rows until data node return number of rows specified by the
     * fetch_size parameter of last Execute message (PortalSuspended message)
     * or end of result set is reached (CommandComplete message)
     */</comment>
    <while>while <condition>(<expr><name>true</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

        <comment type="block">/* Move to buffer currentRow (received from the data node) */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>merge_sort</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>node_index</name> <init>= <expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr></init></decl>;</decl_stmt>
                
                <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name> <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><name>node_index</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tmpslot</name><operator>-&gt;</operator><name>tts_datarow</name></name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><name>node_index</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>tmpslot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name><index>[<expr><name>node_index</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>List</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name></name> <operator>=</operator> <operator>(</operator><name>long</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                            
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name><index>[<expr><name>node_index</name></expr>]</index></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name><index>[<expr><name>node_index</name></expr>]</index></name></expr></argument>,
                                                                    <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name><index>[<expr><name>node_index</name></expr>]</index></name> <operator>+=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name><operator>-&gt;</operator><name>msglen</name></name></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name><index>[<expr><name>node_index</name></expr>]</index></name> <operator>&gt;=</operator> <call><name>DATA_ROW_BUFFER_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* init datarow buffer */</comment>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name> <operator>=</operator> <operator>(</operator><name>Tuplestorestate</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Tuplestorestate</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>

                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><name>node_index</name></expr>]</index></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><name>node_index</name></expr>]</index></name> <operator>=</operator> <call><name>tuplestore_begin_datarow</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"BufferConnection:connection %d dataRowMemSize %ld exceed max rowBufferSize %d, need to store"</literal>
                                      <literal type="string">" datarow in tuplestore."</literal></expr></argument>, <argument><expr><name>node_index</name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name><index>[<expr><name>node_index</name></expr>]</index></name></expr></argument>,
                                      <argument><expr><call><name>DATA_ROW_BUFFER_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                        
                        <comment type="block">/* data row count in tuplestore */</comment>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>

                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>tmpslot</name></name></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>TupleDesc</name></type> <name>desc</name> <init>= <expr><call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tmpslot</name></name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>        
                <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name> <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* put into tuplestore */</comment>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tmpslot</name><operator>-&gt;</operator><name>tts_datarow</name></name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>tmpslot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* init datarow size */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name></name> <operator>=</operator> <operator>(</operator><name>long</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>rowBuffer</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>rowBuffer</name></name></expr></argument>,
                                                  <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name><operator>-&gt;</operator><name>msglen</name></name></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <call><name>DATA_ROW_BUFFER_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                                            <comment type="block">/* init datarow buffer */</comment>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name> <operator>=</operator> <operator>(</operator><name>Tuplestorestate</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Tuplestorestate</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>

                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>tuplestore_begin_datarow</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"BufferConnection:dataRowMemSize %ld exceed max rowBufferSize %d, need to store"</literal>
                                      <literal type="string">" datarow in tuplestore."</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                                      <argument><expr><call><name>DATA_ROW_BUFFER_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>

                        <comment type="block">/* data row count in tuplestore */</comment>
                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>

                        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>tmpslot</name></name></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>TupleDesc</name></type> <name>desc</name> <init>= <expr><call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tmpslot</name></name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>handle_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * If response message is a DataRow it will be handled on the next
         * iteration.
         * PortalSuspended will cause connection state change and break the loop
         * The same is for CommandComplete, but we need additional handling -
         * remove connection from the list of active connections.
         * We may need to add handling error response
         */</comment>

        <comment type="block">/* Most often result check first */</comment>
        <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_DATAROW</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * The row is in the combiner-&gt;currentRow, on next iteration it will
             * be moved to the buffer
             */</comment>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_EOF</name></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		    <if_stmt><if>if <condition>(<expr><name>need_prefetch</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * We encountered incomplete message, try to read more.
                 * Here if we read timeout, then we move to other connections to read, because we
                 * easily got deadlock if a specific cursor run as producer on two nodes. If we can
                 * consume data from all all connections, we can break the deadlock loop.
                 */</comment>
                <decl_stmt><decl><type><name>bool</name></type>   <name>bComplete</name>          <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>DNConnectionState</name></type> <name>state</name>   <init>= <expr><name>DN_CONNECTION_STATE_IDLE</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>    <name>i</name>                  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>    <name>ret</name> 			      <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>save_conn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name>  	      <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name> 	      <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

                <expr_stmt><expr><name>save_conn</name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
                <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>conn</name>  <operator>=</operator> <name>save_conn</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>state</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt> <comment type="block">/* Save the connection state. */</comment>
                    <expr_stmt><expr><name>ret</name>   <operator>=</operator> <call><name>pgxc_node_receive</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>DNStatus_OK</name> <operator>==</operator> <name>ret</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* We got data, handle it. */</comment>
                        <break>break;</break>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>DNStatus_ERR</name> <operator>==</operator> <name>ret</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to receive more data from data node %u"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="block">/* Restore the saved state of connection. */</comment>
                        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>

                    <comment type="block">/* Try to read data from other connections. */</comment>
                    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <expr_stmt><expr><name>conn</name>  <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>save_conn</name> <operator>!=</operator> <name>conn</name> <operator>&amp;&amp;</operator> <name>conn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/* Save the connection state. */</comment>
                            <expr_stmt><expr><name>state</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>DN_CONNECTION_STATE_QUERY</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pgxc_node_receive</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><name>DNStatus_OK</name> <operator>==</operator> <name>ret</name></expr>)</condition>
                                <block>{<block_content>
                                    <comment type="block">/* We got data, prefetch it. */</comment>
                                    <expr_stmt><expr><name>bComplete</name> <operator>=</operator> <call><name>PreFetchConnection</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <if_stmt><if>if <condition>(<expr><name>bComplete</name></expr>)</condition>
                                    <block>{<block_content>
                                        <comment type="block">/* Receive Complete on one connection, we need retry to read from current_conn. */</comment>
                                        <break>break;</break>
                                    </block_content>}</block></if>
                                    <else>else
                                    <block>{<block_content>
                                        <comment type="block">/* Maybe Suspend or Expired, just move to next connection and read. */</comment>
                                        <continue>continue;</continue>
                                    </block_content>}</block></else></if_stmt>
                                </block_content>}</block></if>
                                <if type="elseif">else if <condition>(<expr><name>DNStatus_EXPIRED</name> <operator>==</operator> <name>ret</name></expr>)</condition>
                                <block>{<block_content>
                                    <comment type="block">/* Restore the saved state of connection. */</comment>
                                    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
                                    <continue>continue;</continue>
                                </block_content>}</block></if>
                                <else>else
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to receive more data from data node %u"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></else></if_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></while>
                <continue>continue;</continue>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* incomplete message, read more */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_receive</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>conn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
                                               <argument><expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"Failed to fetch from data node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <comment type="block">/* incomplete message, read more */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_receive</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>conn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
                        <argument><expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"Failed to fetch from data node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if>

        <comment type="block">/*
         * End of result set is reached, so either set the pointer to the
         * connection to NULL (combiner with sort) or remove it from the list
         * (combiner without sort)
         */</comment>
        <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_COMPLETE</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If combiner is doing merge sort we should set reference to the
             * current connection to NULL in the array, indicating the end
             * of the tape is reached. FetchTuple will try to access the buffer
             * first anyway.
             * Since we remove that reference we can not determine what node
             * number was this connection, but we need this info to find proper
             * tuple in the buffer if we are doing merge sort. So store node
             * number in special array.
             * NB: We can not test if combiner-&gt;tuplesortstate is set here:
             * connection may require buffering inside tuplesort_begin_merge
             * - while pre-read rows from the tapes, one of the tapes may be
             * the local connection with RemoteSubplan in the tree. The
             * combiner-&gt;tuplesortstate is set only after tuplesort_begin_merge
             * returns.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>merge_sort</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>tapenodes</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tapenodes</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator>
                            <call><name>palloc0</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tapenodes</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr>]</index></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* Remove current connection, move last in-place, adjust current_conn */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>&lt;</operator> <operator>--</operator><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr>]</index></name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
            <comment type="block">/*
             * If combiner runs Simple Query Protocol we need to read in
             * ReadyForQuery. In case of Extended Query Protocol it is not
             * sent and we should quit.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>extended_query</name></name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unexpected FATAL ERROR on Connection to Datanode %s pid %d"</literal></expr></argument>,
                             <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_ERROR</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>extended_query</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Need to sync connection to enable receiving commands
                 * by the datanode
                 */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_sync</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to sync msg to node %s backend_pid:%d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Succeed to sync msg to node %s backend_pid:%d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_SUSPENDED</name> <operator>||</operator> <name>res</name> <operator>==</operator> <name>RESPONSE_READY</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Now it is OK to quit */</comment>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_QUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>combiner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Prefetch data from specific connection.
 */</comment>
<function><type><name>bool</name></type> <name>PreFetchConnection</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>node_index</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>              <name>bComplete</name>  <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DNConnectionState</name></type> <name>state</name>   <init>= <expr><name>DN_CONNECTION_STATE_IDLE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                  <name>ret</name>          <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name>   <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>combiner</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>     <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name>              <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name>           <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

    
    <if_stmt><if>if <condition>(<expr><name>combiner</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>bComplete</name></expr>;</return>
    </block_content>}</block></if></if_stmt>


    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"PreFetchConnection connection %u to step %s"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    
    <comment type="block">/*
     * When BufferConnection is invoked CurrentContext is related to other
     * portal, which is trying to control the connection.
     * TODO See if we can find better context to switch to
     */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>tapemarks</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tapemarks</name></name> <operator>=</operator> <operator>(</operator><name>ListCell</name><operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ListCell</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If current bookmark for the current tape is not set it means either
     * first row in the buffer is from the current tape or no rows from
     * the tape in the buffer, so if first row is not from current
     * connection bookmark the last cell in the list.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>tapemarks</name><index>[<expr><name>node_index</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
            <call><name>list_length</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>rowBuffer</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RemoteDataRow</name></type> <name>dataRow</name> <init>= <expr><operator>(</operator><name>RemoteDataRow</name><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>rowBuffer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>dataRow</name><operator>-&gt;</operator><name>msgnode</name></name> <operator>!=</operator> <name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tapemarks</name><index>[<expr><name>node_index</name></expr>]</index></name> <operator>=</operator> <call><name>list_tail</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>rowBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>merge_sort</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>List</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Buffer data rows until data node return number of rows specified by the
     * fetch_size parameter of last Execute message (PortalSuspended message)
     * or end of result set is reached (CommandComplete message)
     */</comment>
    <while>while <condition>(<expr><name>true</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

        <comment type="block">/* Move to buffer currentRow (received from the data node) */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>msglen</name> <init>= <expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name><operator>-&gt;</operator><name>msglen</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>merge_sort</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name></name> <operator>=</operator> <operator>(</operator><name>long</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name><index>[<expr><name>node_index</name></expr>]</index></name> <operator>&gt;=</operator> <call><name>DATA_ROW_BUFFER_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* init datarow buffer */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name> <operator>=</operator> <operator>(</operator><name>Tuplestorestate</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Tuplestorestate</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><name>node_index</name></expr>]</index></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><name>node_index</name></expr>]</index></name> <operator>=</operator> <call><name>tuplestore_begin_datarow</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name> <operator>/</operator> <name>NumDataNodes</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"PreFetchConnection:connection %d dataRowMemSize %ld exceed max rowBufferSize %d, need to store"</literal>
                                  <literal type="string">" datarow in tuplestore."</literal></expr></argument>, <argument><expr><name>node_index</name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name><index>[<expr><name>node_index</name></expr>]</index></name></expr></argument>,
                                  <argument><expr><call><name>DATA_ROW_BUFFER_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                    
                    <comment type="block">/* data row count in tuplestore */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>tmpslot</name></name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>TupleDesc</name></type> <name>desc</name> <init>= <expr><call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tmpslot</name></name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tmpslot</name><operator>-&gt;</operator><name>tts_datarow</name></name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><name>node_index</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>tmpslot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name><index>[<expr><name>node_index</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name><index>[<expr><name>node_index</name></expr>]</index></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name><index>[<expr><name>node_index</name></expr>]</index></name></expr></argument>,
                                                                    <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name><index>[<expr><name>node_index</name></expr>]</index></name> <operator>+=</operator> <name>msglen</name></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* init datarow size */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name></name> <operator>=</operator> <operator>(</operator><name>long</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* exceed buffer size, store into tuplestore */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <call><name>DATA_ROW_BUFFER_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>                
                    <comment type="block">/* init datarow buffer */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name> <operator>=</operator> <operator>(</operator><name>Tuplestorestate</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Tuplestorestate</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>tuplestore_begin_datarow</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name> <operator>/</operator> <name>NumDataNodes</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"PreFetchConnection:dataRowMemSize %ld exceed max rowBufferSize %d, need to store"</literal>
                                  <literal type="string">" datarow in tuplestore."</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                                  <argument><expr><call><name>DATA_ROW_BUFFER_SIZE</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/* data row count in tuplestore */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>tmpslot</name></name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>TupleDesc</name></type> <name>desc</name> <init>= <expr><call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tmpslot</name></name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/* put into tuplestore */</comment>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tmpslot</name><operator>-&gt;</operator><name>tts_datarow</name></name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>tmpslot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>msglen</name></expr>;</expr_stmt>
                    
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>rowBuffer</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>rowBuffer</name></name></expr></argument>,
                                          <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>handle_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * If response message is a DataRow it will be handled on the next
         * iteration.
         * PortalSuspended will cause connection state change and break the loop
         * The same is for CommandComplete, but we need additional handling -
         * remove connection from the list of active connections.
         * We may need to add handling error response
         */</comment>

        <comment type="block">/* Most often result check first */</comment>
        <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_DATAROW</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * The row is in the combiner-&gt;currentRow, on next iteration it will
             * be moved to the buffer
             */</comment>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* incomplete message, read more */</comment>
        <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_EOF</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Here we will keep waiting without timeout. */</comment>
            <expr_stmt><expr><name>state</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pgxc_node_receive</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
            <if_stmt><if>if <condition>(<expr><name>DNStatus_ERR</name> <operator>==</operator> <name>ret</name></expr>)</condition>
            <block>{<block_content>                
                <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"Failed to fetch from data node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>DNStatus_EXPIRED</name> <operator>==</operator> <name>ret</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Restore the connection state. */</comment>
                <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>

        <comment type="block">/*
         * End of result set is reached, so either set the pointer to the
         * connection to NULL (combiner with sort) or remove it from the list
         * (combiner without sort)
         */</comment>
        <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_COMPLETE</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>extended_query</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * If combiner is doing merge sort we should set reference to the
                 * current connection to NULL in the array, indicating the end
                 * of the tape is reached. FetchTuple will try to access the buffer
                 * first anyway.
                 * Since we remove that reference we can not determine what node
                 * number was this connection, but we need this info to find proper
                 * tuple in the buffer if we are doing merge sort. So store node
                 * number in special array.
                 * NB: We can not test if combiner-&gt;tuplesortstate is set here:
                 * connection may require buffering inside tuplesort_begin_merge
                 * - while pre-read rows from the tapes, one of the tapes may be
                 * the local connection with RemoteSubplan in the tree. The
                 * combiner-&gt;tuplesortstate is set only after tuplesort_begin_merge
                 * returns.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>merge_sort</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>node_index</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>tapenodes</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tapenodes</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tapenodes</name><index>[<expr><name>node_index</name></expr>]</index></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name> <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><name>node_index</name></expr>]</index></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"connection %d put %d datarows into tuplestore."</literal></expr></argument>, <argument><expr><name>node_index</name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name><index>[<expr><name>node_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if>            
                <if type="elseif">else if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>extended_query</name></name></expr>)</condition>
                <block>{<block_content>    
                    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>            
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CommandComplete remove extend query connection %s backend_pid:%d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <comment type="block">/* Remove connection with node_index, move last in-place. Here the node_index &gt; current_conn*/</comment>
                    <if_stmt><if>if <condition>(<expr><name>node_index</name> <operator>&lt;</operator> <operator>--</operator><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>node_index</name></expr>]</index></name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>]</index></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn_rows_consumed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name>bComplete</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>&gt;=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>=</operator> <name>node_index</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * If combiner runs Simple Query Protocol we need to read in
                 * ReadyForQuery. In case of Extended Query Protocol it is not
                 * sent and we should quit.
                 */</comment>
                <break>break;</break>
            </block_content>}</block></if>        
            <if type="elseif">else if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unexpected FATAL ERROR on Connection to Datanode %s pid %d"</literal></expr></argument>,
                             <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_READY</name></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>            
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ReadyForQuery remove connection %s backend_pid:%d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="block">/* If we are doing merge sort clean current connection and return
             * NULL, otherwise remove current connection, move last in-place,
             * adjust current_conn and continue if it is not last connection */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>merge_sort</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>node_index</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>                
                <expr_stmt><expr><name>bComplete</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            
            <if_stmt><if>if <condition>(<expr><name>node_index</name> <operator>&lt;</operator> <operator>--</operator><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>node_index</name></expr>]</index></name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn_rows_consumed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>bComplete</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>&gt;=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>=</operator> <name>node_index</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><name>bComplete</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_ERROR</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>extended_query</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Need to sync connection to enable receiving commands
                 * by the datanode
                 */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_sync</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to sync msg to node %s backend_pid:%d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    

                    
                </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Succeed to sync msg to node %s backend_pid:%d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_SUSPENDED</name> <operator>||</operator> <name>res</name> <operator>==</operator> <name>RESPONSE_READY</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Now it is OK to quit */</comment>
            <break>break;</break>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_TUPDESC</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>,
                                  <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Now slot is responsible for freeng the descriptor */</comment>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_QUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pgxc_node_report_error</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>bComplete</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * copy the datarow from combiner to the given slot, in the slot's memory
 * context
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CopyDataRowTupleToSlot</name><parameter_list>(<parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RemoteDataRow</name></type>     <name>datarow</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>    <name>oldcontext</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>datarow</name> <operator>=</operator> <operator>(</operator><name>RemoteDataRow</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RemoteDataRowData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name><operator>-&gt;</operator><name>msglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>datarow</name><operator>-&gt;</operator><name>msgnode</name></name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name><operator>-&gt;</operator><name>msgnode</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>datarow</name><operator>-&gt;</operator><name>msglen</name></name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name><operator>-&gt;</operator><name>msglen</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>datarow</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>, <argument><expr><name><name>datarow</name><operator>-&gt;</operator><name>msglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecStoreDataRowTuple</name><argument_list>(<argument><expr><name>datarow</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * FetchTuple
 *
        Get next tuple from one of the datanode connections.
 * The connections should be in combiner-&gt;connections, if "local" dummy
 * connection presents it should be the last active connection in the array.
 *      If combiner is set up to perform merge sort function returns tuple from
 * connection defined by combiner-&gt;current_conn, or NULL slot if no more tuple
 * are available from the connection. Otherwise it returns tuple from any
 * connection or NULL slot if no more available connections.
 *         Function looks into combiner-&gt;rowBuffer before accessing connection
 * and return a tuple from there if found.
 *         Function may wait while more data arrive from the data nodes. If there
 * is a locally executed subplan function advance it and buffer resulting rows
 * instead of waiting.
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>FetchTuple</name><parameter_list>(<parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>             <name>nodeOid</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>begin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>end</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Case if we run local subplan.
     * We do not have remote connections, so just get local tuple and return it
     */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	    <comment type="block">/* 
		 * if dn_instrument is not null, means this node is initialized for recv
		 * instrument from remote, not execute it locally too.
		 */</comment>
	    <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><call><name>outerPlanState</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>dn_instrument</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RemoteSubplanState</name> <modifier>*</modifier></type><name>planstate</name> <init>= <expr><operator>(</operator><name>RemoteSubplanState</name> <operator>*</operator><operator>)</operator> <name>combiner</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RemoteSubplan</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>RemoteSubplan</name> <operator>*</operator><operator>)</operator> <name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* Advance subplan in a loop until we have something to return */</comment>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Datum</name></type>     <name>value</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>     <name>isnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>     <name>numnodes</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>        <name>i</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* If locator is not defined deliver all the results */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>locator</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>slot</name></expr>;</return></block_content></block></if></if_stmt>

            <comment type="block">/*
             * If NULL tuple is returned we done with the subplan, finish it up and
             * return NULL
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

            <comment type="block">/* Get partitioning value if defined */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>distributionKey</name></name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>distributionKey</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* Determine target nodes */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
            <expr_stmt><expr><name>numnodes</name> <operator>=</operator> <call><name>GET_NODES</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><name>numnodes</name> <operator>=</operator> <call><name>GET_NODES</name><argument_list>(<argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numnodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <comment type="block">/* Deliver the node */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>dest_nodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>PGXCNodeId</name><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>slot</name></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>begin</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Get current connection
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>&gt;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>conn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * If doing merge sort determine the node number.
     * It may be needed to get buffered row.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>merge_sort</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>conn</name> <operator>||</operator> <name><name>combiner</name><operator>-&gt;</operator><name>tapenodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nodeOid</name> <operator>=</operator> <ternary><condition><expr><name>conn</name></expr> ?</condition><then> <expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr> </then><else>:
                         <expr><name><name>combiner</name><operator>-&gt;</operator><name>tapenodes</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nodeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<label><name>READ_ROWBUFFER</name>:</label>
    <comment type="block">/*
     * First look into the row buffer.
     * When we are performing merge sort we need to get from the buffer record
     * from the connection marked as "current". Otherwise get first.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>rowBuffer</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RemoteDataRow</name></type> <name>dataRow</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>merge_sort</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Getting buffered tuple from node %x"</literal></expr></argument>, <argument><expr><name>nodeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>prev</name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>tapemarks</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr>]</index></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>prev</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Start looking through the list from the bookmark.
                 * Probably the first cell we check contains row from the needed
                 * node. Otherwise continue scanning until we encounter one,
                 * advancing prev pointer as well.
                 */</comment>
                <while>while<condition>(<expr><operator>(</operator><name>lc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>dataRow</name> <operator>=</operator> <operator>(</operator><name>RemoteDataRow</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>dataRow</name><operator>-&gt;</operator><name>msgnode</name></name> <operator>==</operator> <name>nodeOid</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>=</operator> <name>dataRow</name></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>prev</name> <operator>=</operator> <name>lc</name></expr>;</expr_stmt>
                </block_content>}</block></while>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * Either needed row is the first in the buffer or no such row
                 */</comment>
                <expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>rowBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>dataRow</name> <operator>=</operator> <operator>(</operator><name>RemoteDataRow</name><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>dataRow</name><operator>-&gt;</operator><name>msgnode</name></name> <operator>==</operator> <name>nodeOid</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>=</operator> <name>dataRow</name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>lc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
            
            <if_stmt><if>if <condition>(<expr><name>lc</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Delete cell from the buffer. Before we delete we must check
                 * the bookmarks, if the cell is a bookmark for any tape.
                 * If it is the case we are deleting last row of the current
                 * block from the current tape. That tape should have bookmark
                 * like current, and current bookmark will be advanced when we
                 * read the tape once again.
                 */</comment>
                <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>tapemarks</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>lc</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tapemarks</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Found buffered tuple from node %x"</literal></expr></argument>, <argument><expr><name>nodeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>rowBuffer</name></name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>rowBuffer</name></name></expr></argument>,
                                                       <argument><expr><name>lc</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Update tapemark"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tapemarks</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr>]</index></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>dataRow</name> <operator>=</operator> <operator>(</operator><name>RemoteDataRow</name><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>rowBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>=</operator> <name>dataRow</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>rowBuffer</name></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>rowBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* fetch datarow from prerowbuffers */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>merge_sort</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RemoteDataRow</name></type> <name>dataRow</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>node_index</name> <init>= <expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name></name> <operator>&amp;&amp;</operator>
                <call><name>list_length</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name><index>[<expr><name>node_index</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>dataRow</name> <operator>=</operator> <operator>(</operator><name>RemoteDataRow</name><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name><index>[<expr><name>node_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>=</operator> <name>dataRow</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name><index>[<expr><name>node_index</name></expr>]</index></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name><index>[<expr><name>node_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* fetch data in tuplestore */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>merge_sort</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>node_index</name> <init>= <expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr></init></decl>;</decl_stmt>
            
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name> <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><name>node_index</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><name>node_index</name></expr>]</index></name></expr></argument>, 
                                           <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>tmpslot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tmpslot</name><operator>-&gt;</operator><name>tts_shouldFreeRow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>tmpslot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name><index>[<expr><name>node_index</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* sanity check */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name><index>[<expr><name>node_index</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"connection %d has %d datarows left in tuplestore."</literal></expr></argument>, 
                                     <argument><expr><name>node_index</name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name><index>[<expr><name>node_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"fetch all datarows from %d tuplestore."</literal></expr></argument>, <argument><expr><name>node_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/* 
                      * datarows fetched from tuplestore in memory will be freed by caller, 
                      * we do not need to free them in tuplestore_end, tuplestore_set_tupdeleted
                      * avoid to free memtuples in tuplestore_end.
                      */</comment>
                    <comment type="line">//tuplestore_set_tupdeleted(combiner-&gt;dataRowBuffer[node_index]);</comment>
                    <expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><name>node_index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><name>node_index</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name><index>[<expr><name>node_index</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name> <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, 
                                           <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>tmpslot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tmpslot</name><operator>-&gt;</operator><name>tts_shouldFreeRow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>tmpslot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* sanity check */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"%d datarows left in tuplestore."</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"fetch all datarows from tuplestore."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/* 
                      * datarows fetched from tuplestore in memory will be freed by caller, 
                      * we do not need to free them in tuplestore_end, tuplestore_set_tupdeleted
                      * avoid to free memtuples in tuplestore_end.
                      */</comment>
                    <comment type="line">//tuplestore_set_tupdeleted(combiner-&gt;dataRowBuffer[0]);</comment>
                    <expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* If we have node message in the currentRow slot, and it is from a proper
     * node, consume it.  */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>merge_sort</name></name> <operator>||</operator>
               <name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name><operator>-&gt;</operator><name>msgnode</name></name> <operator>==</operator> <name>nodeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CopyDataRowTupleToSlot</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* 
              * usually, we need more time to get first tuple, so
              * do not include that time.
              */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_total_time</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_tuples</name></name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_total_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_tuples</name></name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_total_time</name></name> <operator>+=</operator> <operator>(</operator><name>end</name> <operator>-</operator> <name>begin</name><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <return>return <expr><name>slot</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <while>while <condition>(<expr><name>conn</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

        <comment type="block">/* Going to use a connection, buffer it if needed */</comment>
        <expr_stmt><expr><call><name>CHECK_OWNERSHIP</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If current connection is idle it means portal on the data node is
         * suspended. Request more and try to get it
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>extended_query</name></name> <operator>&amp;&amp;</operator>
                <name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * We do not allow to suspend if querying primary node, so that
             * only may mean the current node is secondary and subplan was not
             * executed there yet. Return and go on with second phase.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>probing_primary</name></name></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><name>NULL</name></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_execute</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><name>PGXLRemoteFetchSize</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send execute cursor '%s' to node %u"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_flush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed flush cursor '%s' node %u"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_receive</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>conn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed receive data from node %u cursor '%s'"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* read messages */</comment>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>handle_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_DATAROW</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CopyDataRowTupleToSlot</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn_rows_consumed</name></name><operator>++</operator></expr>;</expr_stmt>

            <comment type="block">/*
             * If we are running simple query protocol, yield the connection
             * after we process PGXLRemoteFetchSize rows from the connection.
             * This should allow us to consume rows quickly from other
             * connections, while this node gets chance to generate more rows
             * which would then be processed in the next iteration.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>extended_query</name></name> <operator>&amp;&amp;</operator>
                <name><name>combiner</name><operator>-&gt;</operator><name>current_conn_rows_consumed</name></name> <operator>&gt;=</operator> <name>PGXLRemoteFetchSize</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>&gt;=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn_rows_consumed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* 
                  * usually, we need more time to get first tuple, so
                  * do not include that time.
                  */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_total_time</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_tuples</name></name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_total_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_tuples</name></name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_total_time</name></name> <operator>+=</operator> <operator>(</operator><name>end</name> <operator>-</operator> <name>begin</name><operator>)</operator></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <return>return <expr><name>slot</name></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_EOF</name></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <comment type="block">/* 
             * We encountered incomplete message, try to read more.
             * Here if we read timeout, then we move to other connections to read, because we
             * easily got deadlock if a specific cursor run as producer on two nodes. If we can
             * consume data from all all connections, we can break the deadlock loop.
             */</comment>            
            <decl_stmt><decl><type><name>bool</name></type>   <name>bComplete</name>          <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>DNConnectionState</name></type> <name>state</name>   <init>= <expr><name>DN_CONNECTION_STATE_IDLE</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>    <name>i</name>                  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>    <name>ret</name>                   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>save_conn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name>            <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name>           <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt>    

            <expr_stmt><expr><name>save_conn</name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
            <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>conn</name>  <operator>=</operator> <name>save_conn</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>state</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt> <comment type="block">/* Save the connection state. */</comment>
                <expr_stmt><expr><name>ret</name>   <operator>=</operator> <call><name>pgxc_node_receive</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>DNStatus_OK</name> <operator>==</operator> <name>ret</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* We got data, handle it. */</comment>
                    <break>break;</break>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>DNStatus_ERR</name> <operator>==</operator> <name>ret</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to receive more data from data node %u"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Restore the saved state of connection. */</comment>
                    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <comment type="block">/* Try to read data from other connections. */</comment>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><name>conn</name>  <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>save_conn</name> <operator>!=</operator> <name>conn</name> <operator>&amp;&amp;</operator> <name>conn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* Save the connection state. */</comment>
                        <expr_stmt><expr><name>state</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>DN_CONNECTION_STATE_QUERY</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pgxc_node_receive</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>DNStatus_OK</name> <operator>==</operator> <name>ret</name></expr>)</condition>
                            <block>{<block_content>
                                <comment type="block">/* We got data, prefetch it. */</comment>
                                <expr_stmt><expr><name>bComplete</name> <operator>=</operator> <call><name>PreFetchConnection</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><name>bComplete</name></expr>)</condition>
                                <block>{<block_content>
                                    <comment type="block">/* Receive Complete on one connection, we need retry to read from current_conn. */</comment>
                                    <break>break;</break>
                                </block_content>}</block></if>
                                <else>else
                                <block>{<block_content>
                                    <comment type="block">/* Maybe Suspend or Expired, just move to next connection and read. */</comment>
                                    <continue>continue;</continue>
                                </block_content>}</block></else></if_stmt>
                            </block_content>}</block></if>
                            <if type="elseif">else if <condition>(<expr><name>DNStatus_EXPIRED</name> <operator>==</operator> <name>ret</name></expr>)</condition>
                            <block>{<block_content>
                                <comment type="block">/* Restore the saved state of connection. */</comment>
                                <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
                                <continue>continue;</continue>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to receive more data from data node %u"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>    
            </block_content>}</block></while>
            <continue>continue;</continue>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <comment type="block">/* incomplete message, read more */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_receive</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>conn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to receive more data from data node %u"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <continue>continue;</continue>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_SUSPENDED</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If we are doing merge sort or probing primary node we should
             * remain on the same node, so query next portion immediately.
             * Otherwise leave node suspended and fetch lazily.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>merge_sort</name></name> <operator>||</operator> <name><name>combiner</name><operator>-&gt;</operator><name>probing_primary</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_execute</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><name>PGXLRemoteFetchSize</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send execute cursor '%s' to node %u"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_flush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed flush cursor '%s' node %u"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_receive</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>conn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed receive node from node %u cursor '%s'"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Tell the node to fetch data in background, next loop when we 
             * pgxc_node_receive, data is already there, so we can run faster
             * */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_execute</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><name>PGXLRemoteFetchSize</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send execute cursor '%s' to node %u"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_flush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed flush cursor '%s' node %u"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>&gt;=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn_rows_consumed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_COMPLETE</name></expr>)</condition>
        <block>{<block_content>        
            <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unexpected FATAL ERROR on Connection to Datanode %s pid %d"</literal></expr></argument>,
                                       <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * In case of Simple Query Protocol we should receive ReadyForQuery
             * before removing connection from the list. In case of Extended
             * Query Protocol we may remove connection right away.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>extended_query</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* If we are doing merge sort clean current connection and return
                 * NULL, otherwise remove current connection, move last in-place,
                 * adjust current_conn and continue if it is not last connection */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>merge_sort</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                    <comment type="block">/* data left in row_buffer, read it */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name></name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> 
                        <operator>(</operator><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name> <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr>]</index></name><operator>)</operator></expr>)</condition>
                    <block>{<block_content>    
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"FetchTuple:data left in rowbuffer while merge_sort."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>conn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                            <goto>goto <name>READ_ROWBUFFER</name>;</goto>
                    </block_content>}</block></if></if_stmt> 

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>bool</name></type> <name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                
                        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>merge_sort</name></name></expr>)</condition>
                        <block>{<block_content>
                            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                            <block>{<block_content>
                                <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                                    <break>break;</break></block_content></block></if></if_stmt>
                            </block_content>}</block></for>
                
                            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        </block_content>}</block></else></if_stmt>
                
                        <if_stmt><if>if <condition>(<expr><name>done</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Number of datarows fetched in FetchTuple: %lu datarows."</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_datarows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_datarows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                    <return>return <expr><name>NULL</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
                
                <expr_stmt><expr><call><name>REMOVE_CURR_CONN</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn_rows_consumed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* data left in row_buffer, read it */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>rowBuffer</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
                        <operator>(</operator><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name> <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"FetchTuple:data left in rowbuffer in extended_query."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <goto>goto <name>READ_ROWBUFFER</name>;</goto>
                    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                    <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>bool</name></type> <name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                
                        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>merge_sort</name></name></expr>)</condition>
                        <block>{<block_content>
                            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                            <block>{<block_content>
                                <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                                    <break>break;</break></block_content></block></if></if_stmt>
                            </block_content>}</block></for>
                
                            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        </block_content>}</block></else></if_stmt>
                
                        <if_stmt><if>if <condition>(<expr><name>done</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Number of datarows fetched in FetchTuple: %lu datarows."</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_datarows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_datarows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                        
                    <return>return <expr><name>NULL</name></expr>;</return>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_ERROR</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If doing Extended Query Protocol we need to sync connection,
             * otherwise subsequent commands will be ignored.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>extended_query</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_sync</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to sync msg to node %s backend_pid:%d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Succeed to sync msg to node %s backend_pid:%d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/*
             * Do not wait for response from primary, it needs to wait
             * for other nodes to respond. Instead go ahead and send query to
             * other nodes. It will fail there, but we can continue with
             * normal cleanup.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>probing_primary</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>REMOVE_CURR_CONN</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_READY</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* If we are doing merge sort clean current connection and return
             * NULL, otherwise remove current connection, move last in-place,
             * adjust current_conn and continue if it is not last connection */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>merge_sort</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <comment type="block">/* data left in row_buffer, read it */</comment>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name></name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> 
                    <operator>(</operator><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name> <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr>]</index></name><operator>)</operator></expr>)</condition>
                <block>{<block_content>    
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"FetchTuple:data left in rowbuffer while merge_sort."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>conn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                        <goto>goto <name>READ_ROWBUFFER</name>;</goto>
                </block_content>}</block></if></if_stmt> 

                
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>bool</name></type> <name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            
                    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>merge_sort</name></name></expr>)</condition>
                    <block>{<block_content>
                        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                                <break>break;</break></block_content></block></if></if_stmt>
                        </block_content>}</block></for>
            
                        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></else></if_stmt>
            
                    <if_stmt><if>if <condition>(<expr><name>done</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Number of datarows fetched in FetchTuple: %lu datarows."</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_datarows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_datarows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <return>return <expr><name>NULL</name></expr>;</return>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>REMOVE_CURR_CONN</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* data left in row_buffer, read it */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>rowBuffer</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
                    <operator>(</operator><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name> <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"FetchTuple:data left in rowbuffer in simple_query."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <goto>goto <name>READ_ROWBUFFER</name>;</goto>
                </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>bool</name></type> <name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            
                    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>merge_sort</name></name></expr>)</condition>
                    <block>{<block_content>
                        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                                <break>break;</break></block_content></block></if></if_stmt>
                        </block_content>}</block></for>
            
                        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></else></if_stmt>
            
                    <if_stmt><if>if <condition>(<expr><name>done</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Number of datarows fetched in FetchTuple: %lu datarows."</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_datarows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_datarows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <return>return <expr><name>NULL</name></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_TUPDESC</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>,
                                  <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Now slot is responsible for freeng the descriptor */</comment>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_ASSIGN_GXID</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Do nothing. It must have been handled in handle_response() */</comment>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_WAITXIDS</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Do nothing. It must have been handled in handle_response() */</comment>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="line">// Can not get here?</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>merge_sort</name></name></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block></for>

            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>done</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Number of datarows fetched in FetchTuple: %lu datarows."</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_datarows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_datarows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pgxc_node_receive_copy_begin</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>conn_count</name></decl></parameter>, <parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier><modifier>*</modifier></type> <name>connections</name></decl></parameter>,
                         <parameter><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type> <name>timeout</name></decl></parameter>, <parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>         <name>ret</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>count</name> <init>= <expr><name>conn_count</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name><name>to_receive</name><index>[<expr><name>conn_count</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* make a copy of the pointers to the connections */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>to_receive</name></expr></argument>, <argument><expr><name>connections</name></expr></argument>, <argument><expr><name>conn_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Read results.
     * Note we try and read from Datanode connections even if there is an error on one,
     * so as to avoid reading incorrect results on the next statement.
     * Other safegaurds exist to avoid this, however.
     */</comment>
    <while>while <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pgxc_node_receive</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>to_receive</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>DNStatus_ERR</name> <operator>==</operator> <name>ret</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_receive_copy_begin pgxc_node_receive data from node number:%d failed"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>EOF</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        
        <while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>=  <expr><call><name>handle_response</name><argument_list>(<argument><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"Received response %d on connection to node %s"</literal></expr></argument>,
                    <argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <switch>switch <condition>(<expr><name>result</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>RESPONSE_EOF</name></expr>:</case> <comment type="block">/* have something to read, keep receiving */</comment>
                    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>RESPONSE_COMPLETE</name></expr>:</case>
                    <if_stmt><if>if <condition>(<expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>state</name> <operator>!=</operator> <name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* Continue read until ReadyForQuery */</comment>
                        <break>break;</break>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="block">/* error occurred, set buffer logically empty */</comment>
                        <expr_stmt><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>inStart</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>inCursor</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>inEnd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <comment type="block">/* fallthru */</comment>
                <case>case <expr><name>RESPONSE_READY</name></expr>:</case>
                    <comment type="block">/* fallthru */</comment>
                <case>case <expr><name>RESPONSE_COPY</name></expr>:</case>
                    <comment type="block">/* Handling is done, do not track this connection */</comment>
                    <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
                    <comment type="block">/* Move last connection in place */</comment>
                    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>to_receive</name><index>[<expr><name>count</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <break>break;</break>
                <case>case <expr><name>RESPONSE_ERROR</name></expr>:</case>
                    <comment type="block">/* no handling needed, just wait for ReadyForQuery */</comment>
                    <break>break;</break>

                <case>case <expr><name>RESPONSE_WAITXIDS</name></expr>:</case>
                <case>case <expr><name>RESPONSE_ASSIGN_GXID</name></expr>:</case>
                <case>case <expr><name>RESPONSE_TUPDESC</name></expr>:</case>
                    <break>break;</break>

                <case>case <expr><name>RESPONSE_DATAROW</name></expr>:</case>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <break>break;</break>

                <default>default:</default>
                    <comment type="block">/* Inconsistent responses */</comment>
                    <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"Unexpected response from the Datanodes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Unexpected response from the Datanodes, result = %d, request type %d"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* Stop tracking and move last connection in place */</comment>
                    <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>to_receive</name><index>[<expr><name>count</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></while>
    </block_content>}</block></while>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Handle responses from the Datanode connections
 */</comment>
<function><type><name>int</name></type>
<name>pgxc_node_receive_responses</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>conn_count</name></decl></parameter>, <parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier><modifier>*</modifier></type> <name>connections</name></decl></parameter>,
                         <parameter><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type> <name>timeout</name></decl></parameter>, <parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type>        <name>has_errmsg</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>connection_index</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>int</name></type>            <name>ret</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>count</name> <init>= <expr><name>conn_count</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name><name>to_receive</name><index>[<expr><name>conn_count</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>func_ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>last_fatal_conn_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type>         <name><name>receive_to_connections</name><index>[<expr><name>conn_count</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
    <comment type="block">/* make a copy of the pointers to the connections */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>to_receive</name></expr></argument>, <argument><expr><name>connections</name></expr></argument>, <argument><expr><name>conn_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Read results.
     * Note we try and read from Datanode connections even if there is an error on one,
     * so as to avoid reading incorrect results on the next statement.
     * Other safegaurds exist to avoid this, however.
     */</comment>
    <while>while <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pgxc_node_receive</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>to_receive</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>DNStatus_ERR</name> <operator>==</operator> <name>ret</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>conn_loop</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>rece_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>fatal_conn_inner</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
            <expr_stmt><expr><name>has_errmsg</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_receive_responses pgxc_node_receive data from node number:%d failed"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* mark has error */</comment>
            <expr_stmt><expr><name>func_ret</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>to_receive</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>conn_count</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><name>fatal_conn_inner</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <for>for<control>(<init><expr><name>conn_loop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>conn_loop</name> <operator>&lt;</operator> <name>conn_count</name></expr>;</condition><incr><expr><name>conn_loop</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>            
                <expr_stmt><expr><name><name>receive_to_connections</name><index>[<expr><name>conn_loop</name></expr>]</index></name> <operator>=</operator> <name>conn_loop</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                
                <if_stmt><if>if <condition>(<expr><name><name>connections</name><index>[<expr><name>conn_loop</name></expr>]</index></name><operator>-&gt;</operator><name>state</name> <operator>!=</operator> <name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>to_receive</name><index>[<expr><name>rece_idx</name></expr>]</index></name> <operator>=</operator> <name><name>connections</name><index>[<expr><name>conn_loop</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                    <expr_stmt><expr><name><name>receive_to_connections</name><index>[<expr><name>rece_idx</name></expr>]</index></name> <operator>=</operator> <name>conn_loop</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><name>rece_idx</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>fatal_conn_inner</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>
            
            <if_stmt><if>if <condition>(<expr><name>last_fatal_conn_count</name> <operator>==</operator> <name>fatal_conn_inner</name></expr>)</condition>
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                <comment type="block">/* 
                 *if exit abnormally reset response_operation for next call 
                 */</comment>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>response_operation</name></name> <operator>=</operator> <name>OTHER_OPERATIONS</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <return>return <expr><name>EOF</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>last_fatal_conn_count</name> <operator>=</operator> <name>fatal_conn_inner</name></expr>;</expr_stmt>
            
            <expr_stmt><expr><name>count</name> <operator>=</operator> <name>rece_idx</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>         
        
        <while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int32</name></type> <name>nbytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>=  <expr><call><name>handle_response</name><argument_list>(<argument><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>     <name>_PG_REGRESS_</name></cpp:ifdef>            
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Received response %d on connection to node %s"</literal></expr></argument>,
                    <argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"Received response %d on connection to node %s"</literal></expr></argument>,
                    <argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <switch>switch <condition>(<expr><name>result</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>RESPONSE_EOF</name></expr>:</case> <comment type="block">/* have something to read, keep receiving */</comment>
                    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>RESPONSE_COMPLETE</name></expr>:</case>
                    <if_stmt><if>if <condition>(<expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>state</name> <operator>!=</operator> <name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* Continue read until ReadyForQuery */</comment>
                        <break>break;</break>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="block">/* error occurred, set buffer logically empty */</comment>
                        <expr_stmt><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>inStart</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>inCursor</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>inEnd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <comment type="block">/* fallthru */</comment>
                <case>case <expr><name>RESPONSE_READY</name></expr>:</case>
                    <comment type="block">/* fallthru */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_errmsg</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>connection_index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>connection_index</name> <operator>=</operator> <name><name>receive_to_connections</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <expr_stmt><expr><call><name>UpdateLocalTwoPhaseState</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>connection_index</name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <case>case <expr><name>RESPONSE_COPY</name></expr>:</case>
                    <comment type="block">/* try to read every byte from peer. */</comment>
                    <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>pgxc_node_is_data_enqueued</name><argument_list>(<argument><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>nbytes</name></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int32</name></type>               <name>ret</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>DNConnectionState</name></type> <name>estate</name> <init>=  <expr><name>DN_CONNECTION_STATE_IDLE</name></expr></init></decl>;</decl_stmt>
                        <comment type="block">/* Have data in buffer, try to receive and retry. */</comment>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Pending response %d bytes on connection to node %s, pid %d try to read again. "</literal></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nodename</name></expr></argument>, <argument><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>backend_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>estate</name>                 <operator>=</operator> <name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>state</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>state</name> <operator>=</operator> <name>DN_CONNECTION_STATE_QUERY</name></expr>;</expr_stmt>                        
                        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pgxc_node_receive</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition>
                        <block>{<block_content>
                            <switch>switch <condition>(<expr><name>ret</name></expr>)</condition>
                            <block>{<block_content>
                                <case>case <expr><name>DNStatus_ERR</name></expr>:</case>                    
                                    <block>{<block_content>
                                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_receive Pending data %d bytes from node:%s pid:%d failed for ERROR:%s. "</literal></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nodename</name></expr></argument>, <argument><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>backend_pid</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                        
                                        <break>break;</break>
                                    </block_content>}</block>
                                    
                                <case>case <expr><name>DNStatus_EXPIRED</name></expr>:</case>                            
                                    <block>{<block_content>
                                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_receive Pending data %d bytes from node:%s pid:%d failed for EXPIRED. "</literal></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nodename</name></expr></argument>, <argument><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>backend_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        <break>break;</break>
                                    </block_content>}</block>    
                                <default>default:</default>
                                    <block>{<block_content>
                                        <comment type="block">/* Can not be here.*/</comment>
                                        <break>break;</break>
                                    </block_content>}</block>
                            </block_content>}</block></switch>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>state</name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
                        <break>break;</break>                        
                    </block_content>}</block></if></if_stmt>
                    
                    <comment type="block">/* Handling is done, do not track this connection */</comment>
                    <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
                    <comment type="block">/* Move last connection in place */</comment>
                    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>to_receive</name><index>[<expr><name>count</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <break>break;</break>
                <case>case <expr><name>RESPONSE_ERROR</name></expr>:</case>
                    <comment type="block">/* no handling needed, just wait for ReadyForQuery */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_errmsg</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>connection_index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>connection_index</name> <operator>=</operator> <name><name>receive_to_connections</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <expr_stmt><expr><call><name>UpdateLocalTwoPhaseState</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>connection_index</name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <break>break;</break>

                <case>case <expr><name>RESPONSE_WAITXIDS</name></expr>:</case>
                <case>case <expr><name>RESPONSE_ASSIGN_GXID</name></expr>:</case>
                <case>case <expr><name>RESPONSE_TUPDESC</name></expr>:</case>
                    <break>break;</break>

                <case>case <expr><name>RESPONSE_DATAROW</name></expr>:</case>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <break>break;</break>

                <default>default:</default>
                    <comment type="block">/* Inconsistent responses */</comment>
                    <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"Unexpected response from the Datanodes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Unexpected response from the Datanodes, result = %d, request type %d"</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* Stop tracking and move last connection in place */</comment>
                    <expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>to_receive</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>to_receive</name><index>[<expr><name>count</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></while>
    </block_content>}</block></while>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>response_operation</name></name> <operator>=</operator> <name>OTHER_OPERATIONS</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>func_ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read next message from the connection and update the combiner
 * and connection state accordingly
 * If we are in an error state we just consume the messages, and do not proxy
 * Long term, we should look into cancelling executing statements
 * and closing the connections.
 * It returns if states need to be handled
 * Return values:
 * RESPONSE_EOF - need to receive more data for the connection
 * RESPONSE_READY - got ReadyForQuery
 * RESPONSE_COMPLETE - done with the connection, but not yet ready for query.
 * Also this result is output in case of error
 * RESPONSE_SUSPENDED - got PortalSuspended
 * RESPONSE_TUPLEDESC - got tuple description
 * RESPONSE_DATAROW - got data row
 * RESPONSE_COPY - got copy response
 * RESPONSE_BARRIER_OK - barrier command completed successfully
 */</comment>
<function><type><name>int</name></type>
<name>handle_response</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>msg_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>msg_type</name></decl>;</decl_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * If we are in the process of shutting down, we
         * may be rolling back, and the buffer may contain other messages.
         * We want to avoid a procarray exception
         * as well as an error stack overflow.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>proc_exit_inprogress</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Don't read from from the connection if there is a fatal error.
         * We still return RESPONSE_COMPLETE, not RESPONSE_ERROR, since
         * Handling of RESPONSE_ERROR assumes sending SYNC message, but
         * State DN_CONNECTION_STATE_ERROR_FATAL indicates connection is
         * not usable.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>     <name>_PG_REGRESS_</name></cpp:ifdef>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"RESPONSE_COMPLETE_1 from node %s, remote pid %d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <return>return <expr><name>RESPONSE_COMPLETE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* No data available, exit */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HAS_MESSAGE_BUFFERED</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>RESPONSE_EOF</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>combiner</name></name> <operator>==</operator> <name>combiner</name> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>combiner</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* TODO handle other possible responses */</comment>
        <expr_stmt><expr><name>msg_type</name> <operator>=</operator> <call><name>get_message</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"handle_response - received message %c, node %s, "</literal>
                <literal type="string">"current_state %d"</literal></expr></argument>, <argument><expr><name>msg_type</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>last_command</name></name> <operator>=</operator> <name>msg_type</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Add some protection code when receiving a messy message,
         * close the connection, and throw error
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>msg_len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
                    <argument><expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"handle_response, fatal_conn=%p, fatal_conn-&gt;nodename=%s, fatal_conn-&gt;sock=%d, "</literal>
				<literal type="string">"fatal_conn-&gt;read_only=%d, fatal_conn-&gt;transaction_status=%c, "</literal>
				<literal type="string">"fatal_conn-&gt;sock_fatal_occurred=%d, conn-&gt;backend_pid=%d, fatal_conn-&gt;error=%s"</literal></expr></argument>, 
				<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>read_only</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name></expr></argument>,
				<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock_fatal_occurred</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>,  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>=</operator> <name>NO_SOCKET</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sock_fatal_occurred</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Received messy message from node:%s host:%s port:%d pid:%d, "</literal>
                            <literal type="string">"inBuffer:%p inSize:%lu inStart:%lu inEnd:%lu inCursor:%lu msg_len:%d, "</literal>
                            <literal type="string">"This probably means the remote node terminated abnormally "</literal>
                            <literal type="string">"before or while processing the request. "</literal></expr></argument>,
                            <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodehost</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeport</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>,
                            <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inBuffer</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inSize</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inStart</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inEnd</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>inCursor</name></name></expr></argument>, <argument><expr><name>msg_len</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <switch>switch <condition>(<expr><name>msg_type</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">'\0'</literal></expr>:</case>            <comment type="block">/* Not enough data in the buffer */</comment>
                <return>return <expr><name>RESPONSE_EOF</name></expr>;</return>
                
            <case>case <expr><literal type="char">'c'</literal></expr>:</case>            <comment type="block">/* CopyToCommandComplete */</comment>
                <expr_stmt><expr><call><name>HandleCopyOutComplete</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
                
            <case>case <expr><literal type="char">'C'</literal></expr>:</case>            <comment type="block">/* CommandComplete */</comment>
                <expr_stmt><expr><call><name>HandleCommandComplete</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>msg_len</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>combiner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <comment type="block">/* 
                 * In case of simple query protocol, wait for the ReadyForQuery
                 * before marking connection as Idle
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>extended_query</name></name> <operator>&amp;&amp;</operator>
                    <name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DN_CONNECTION_STATE_QUERY</name></expr>)</condition>                    
                <block>{<block_content>
                    <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>     <name>_PG_REGRESS_</name></cpp:ifdef>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"RESPONSE_COMPLETE_2 set node %s, remote pid %d DN_CONNECTION_STATE_IDLE"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>     <name>_PG_REGRESS_</name></cpp:ifdef>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"RESPONSE_COMPLETE_2 from node %s, remote pid %d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <return>return <expr><name>RESPONSE_COMPLETE</name></expr>;</return>
                
            <case>case <expr><literal type="char">'T'</literal></expr>:</case>            <comment type="block">/* RowDescription */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DN_CONNECTION_DEBUG</name></cpp:ifdef>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>have_row_desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>have_row_desc</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <if_stmt><if>if <condition>(<expr><call><name>HandleRowDescription</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>msg_len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>RESPONSE_TUPDESC</name></expr>;</return></block_content></block></if></if_stmt>
                <break>break;</break>
                
            <case>case <expr><literal type="char">'D'</literal></expr>:</case>            <comment type="block">/* DataRow */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DN_CONNECTION_DEBUG</name></cpp:ifdef>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>have_row_desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>recv_datarows</name></name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_datarows</name></name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/* Do not return if data row has not been actually handled */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>HandleDataRow</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>msg_len</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"HandleDataRow from node %s, remote pid %d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>RESPONSE_DATAROW</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
                
            <case>case <expr><literal type="char">'s'</literal></expr>:</case>            <comment type="block">/* PortalSuspended */</comment>
                <comment type="block">/* No activity is expected on the connection until next query */</comment>
                <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>RESPONSE_SUSPENDED</name></expr>;</return>
                
            <case>case <expr><literal type="char">'1'</literal></expr>:</case> <comment type="block">/* ParseComplete */</comment>
            <case>case <expr><literal type="char">'2'</literal></expr>:</case> <comment type="block">/* BindComplete */</comment>
            <case>case <expr><literal type="char">'3'</literal></expr>:</case> <comment type="block">/* CloseComplete */</comment>
            <case>case <expr><literal type="char">'n'</literal></expr>:</case> <comment type="block">/* NoData */</comment>
                <comment type="block">/* simple notifications, continue reading */</comment>
                <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUBSCRIPTION__</name></cpp:ifdef>
            <case>case <expr><literal type="char">'4'</literal></expr>:</case> <comment type="block">/* ApplyDone */</comment>
                <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HandleApplyDone</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>RESPONSE_READY</name></expr>;</return>
                <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <case>case <expr><literal type="char">'G'</literal></expr>:</case> <comment type="block">/* CopyInResponse */</comment>
                <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_COPY_IN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HandleCopyIn</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Done, return to caller to let it know the data can be passed in */</comment>
                <return>return <expr><name>RESPONSE_COPY</name></expr>;</return>
                
            <case>case <expr><literal type="char">'H'</literal></expr>:</case> <comment type="block">/* CopyOutResponse */</comment>
                <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_COPY_OUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HandleCopyOut</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>RESPONSE_COPY</name></expr>;</return>
                
            <case>case <expr><literal type="char">'d'</literal></expr>:</case> <comment type="block">/* CopyOutDataRow */</comment>
                <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_COPY_OUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>HandleCopyDataRow</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>msg_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
                
            <case>case <expr><literal type="char">'E'</literal></expr>:</case>            <comment type="block">/* ErrorResponse */</comment>
                <expr_stmt><expr><call><name>HandleError</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>msg_len</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>add_error_message_from_combiner</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/*
                 * In case the remote node was running an extended query
                 * protocol and reported an error, it will keep ignoring all
                 * subsequent commands until it sees a SYNC message. So make
                 * sure that we send down SYNC even before sending a ROLLBACK
                 * command
                 */</comment>
             
                <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorNode</name></name>   <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>backend_pid</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr>;</expr_stmt>
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>in_extended_query</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>needSync</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>     <name>_PG_REGRESS_</name></cpp:ifdef>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"HandleError from node %s, remote pid %d, errorMessage:%s"</literal></expr></argument>, 
                        <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <return>return <expr><name>RESPONSE_ERROR</name></expr>;</return>
                
            <case>case <expr><literal type="char">'A'</literal></expr>:</case>            <comment type="block">/* NotificationResponse */</comment>
            <case>case <expr><literal type="char">'N'</literal></expr>:</case>            <comment type="block">/* NoticeResponse */</comment>
            <case>case <expr><literal type="char">'S'</literal></expr>:</case>            <comment type="block">/* SetCommandComplete */</comment>
                <comment type="block">/*
                 * Ignore these to prevent multiple messages, one from each
                 * node. Coordinator will send one for DDL anyway
                 */</comment>
                <break>break;</break>
                
            <case>case <expr><literal type="char">'Z'</literal></expr>:</case>            <comment type="block">/* ReadyForQuery */</comment>
            <block>{<block_content>
                <comment type="block">/*
                 * Return result depends on previous connection state.
                 * If it was PORTAL_SUSPENDED Coordinator want to send down
                 * another EXECUTE to fetch more rows, otherwise it is done
                 * with the connection
                 */</comment>
                <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>=</operator> <name><name>msg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>combiner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"remote_node %s remote_pid %d, conn-&gt;transaction_status %c"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DN_CONNECTION_DEBUG</name></cpp:ifdef>
                <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>have_row_desc</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"ConnectionFetchDatarows: remote_node %s remote_pid %d, datarows %ld"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>recv_datarows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>     <name>_PG_REGRESS_</name></cpp:ifdef>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"ReadyForQuery from node %s, remote pid %d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <return>return <expr><name>RESPONSE_READY</name></expr>;</return>
            </block_content>}</block>
            
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
            <case>case <expr><literal type="char">'Y'</literal></expr>:</case>            <comment type="block">/* ReadyForCommit */</comment>
            <block>{<block_content>
                <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>combiner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DN_CONNECTION_DEBUG</name></cpp:ifdef>
                <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>have_row_desc</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"ReadyForQuery from node %s, remote pid %d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>RESPONSE_READY</name></expr>;</return>
            </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <case>case <expr><literal type="char">'M'</literal></expr>:</case>            <comment type="block">/* Command Id */</comment>
                <expr_stmt><expr><call><name>HandleDatanodeCommandId</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>msg_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
                
            <case>case <expr><literal type="char">'b'</literal></expr>:</case>
                <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>RESPONSE_BARRIER_OK</name></expr>;</return>
                
            <case>case <expr><literal type="char">'I'</literal></expr>:</case>            <comment type="block">/* EmptyQuery */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>     <name>_PG_REGRESS_</name></cpp:ifdef>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"RESPONSE_COMPLETE_3 from node %s, remote pid %d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <return>return <expr><name>RESPONSE_COMPLETE</name></expr>;</return>
                
            <case>case <expr><literal type="char">'W'</literal></expr>:</case>
                <expr_stmt><expr><call><name>HandleWaitXids</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>msg_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
                <return>return <expr><name>RESPONSE_WAITXIDS</name></expr>;</return>
                
            <case>case <expr><literal type="char">'x'</literal></expr>:</case>
                <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
                <expr_stmt><expr><call><name>HandleGlobalTransactionId</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>msg_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"should not set global xid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <return>return <expr><name>RESPONSE_ASSIGN_GXID</name></expr>;</return>
                
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<case>case <expr><literal type="char">'i'</literal></expr>:</case> <comment type="block">/* Remote Instrument */</comment>
				<if_stmt><if>if <condition>(<expr><name>msg_len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>HandleRemoteInstr</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>msg_len</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeid</name></name></expr></argument>, <argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* just break to return EOF. */</comment>
				<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <default>default:</default>
                <comment type="block">/* sync lost? */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Received unsupported message type: %c"</literal></expr></argument>, <argument><expr><name>msg_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* stop reading */</comment>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"RESPONSE_COMPLETE_4 from node %s, remote pid %d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>RESPONSE_COMPLETE</name></expr>;</return>
        </block_content>}</block></switch>
    </block_content>}</block></for>
    <comment type="block">/* never happen, but keep compiler quiet */</comment>
    <return>return <expr><name>RESPONSE_EOF</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Has the data node sent Ready For Query
 */</comment>

<function><type><name>bool</name></type>
<name>is_data_node_ready</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type> <name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>msg_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>msg_type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>      <name>data_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <comment type="block">/* No data available, exit */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HAS_MESSAGE_BUFFERED</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>    

        
        <comment type="block">/*
        * If the length of one data row is longger than MaxAllocSize&gt;&gt;1, 
        * it seems there was something wrong,
        * to close this connection should be a better way to save reading loop and avoid overload read buffer.
        */</comment>
        <expr_stmt><expr><name>data_len</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>conn</name><operator>)</operator><operator>-&gt;</operator><name>inBuffer</name> <operator>+</operator> <operator>(</operator><name>conn</name><operator>)</operator><operator>-&gt;</operator><name>inCursor</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>data_len</name> <operator>&gt;=</operator> <operator>(</operator><name>MaxAllocSize</name><operator>&gt;&gt;</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"size:%lu too big in buffer, close socket on node:%u now"</literal></expr></argument>, <argument><expr><name>data_len</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>=</operator> <name>NO_SOCKET</name></expr>;</expr_stmt>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>


        <expr_stmt><expr><name>msg_type</name> <operator>=</operator> <call><name>get_message</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><literal type="char">'Z'</literal> <operator>==</operator> <name>msg_type</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Return result depends on previous connection state.
             * If it was PORTAL_SUSPENDED Coordinator want to send down
             * another EXECUTE to fetch more rows, otherwise it is done
             * with the connection
             */</comment>
            <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>last_command</name></name> <operator>=</operator> <name>msg_type</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>=</operator> <name><name>msg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_IDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>combiner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <comment type="block">/* never happen, but keep compiler quiet */</comment>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send BEGIN command to the Datanodes or Coordinators and receive responses.
 * Also send the GXID for the transaction.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pgxc_node_begin</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>conn_count</name></decl></parameter>, <parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier><modifier>*</modifier></type><name>connections</name></decl></parameter>,
				<parameter><decl><type><name>GlobalTransactionId</name></type> <name>gxid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_tran_block</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>readOnly</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive>    <cpp:macro><name>SET_CMD_LENGTH</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>timeout</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResponseCombiner</name></type> <name>combiner</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>timestamp</name> <init>= <expr><call><name>GetCurrentGTMStartTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name><name>new_connections</name><index>[<expr><name>conn_count</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>new_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>init_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>             <name><name>set_cmd</name><index>[<expr><name>SET_CMD_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>     <name>begin_cmd</name> <init>= <expr><literal type="string">"BEGIN"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>     <name>begin_subtxn_cmd</name> <init>= <expr><literal type="string">"BEGIN_SUBTXN"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>        <name>begin_both_cmd</name> <init>= <expr><literal type="string">"BEGIN;BEGIN_SUBTXN"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>     <name>cmd</name> <init>= <expr><name>begin_cmd</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name>need_send_begin</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * If no remote connections, we don't have anything to do
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>conn_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>conn_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>readOnly</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsConnFromDatanode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>read_only</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/*
         * PGXC TODO - A connection should not be in DN_CONNECTION_STATE_QUERY
         * state when we are about to send a BEGIN TRANSACTION command to the
         * node. We should consider changing the following to an assert and fix
         * any bugs reported
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>state</name> <operator>==</operator> <name>DN_CONNECTION_STATE_QUERY</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>BufferConnection</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Send global session id */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_sessionid</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_begin sending session id failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>EOF</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

        <comment type="block">/* Send GXID and check for errors */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_gxid</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>gxid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_begin gxid %u is invalid."</literal></expr></argument>, <argument><expr><name>gxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>EOF</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

		<comment type="block">/* Send timestamp and check for errors */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>GlobalTimestampIsValid</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>pgxc_node_send_timestamp</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_begin sending timestamp fails: local start"</literal>
					<literal type="string">" timestamp"</literal> <name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>EOF</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <call><name>GlobalTransactionIdIsValid</name><argument_list>(<argument><expr><name>gxid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>need_tran_block</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>IS_PGXC_REMOTE_COORDINATOR</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>need_tran_block</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>need_tran_block</name> <operator>&amp;&amp;</operator> <literal type="char">'I'</literal> <operator>==</operator> <name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>transaction_status</name></expr> )</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>need_send_begin</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>plpgsql_need_begin_sub_txn</name> <operator>&amp;&amp;</operator>
			<literal type="char">'I'</literal> <operator>==</operator> <name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>transaction_status</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>need_send_begin</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cmd</name> <operator>=</operator> <name>begin_both_cmd</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>plpgsql_need_begin_txn</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>plpgsql_need_begin_sub_txn</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>PlpgsqlDebugPrint</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[PLPGSQL] pgxc_node_begin cmd:%s conn-&gt;plpgsql_need_begin_txn "</literal>
						<literal type="string">"was true, and conn-&gt;plpgsql_need_begin_sub_txn was true. "</literal>
						<literal type="string">"in_plpgsql_exec_fun:%d"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>g_in_plpgsql_exec_fun</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>plpgsql_need_begin_txn</name> <operator>&amp;&amp;</operator>
				<literal type="char">'I'</literal> <operator>==</operator> <name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>transaction_status</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>need_send_begin</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>plpgsql_need_begin_txn</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>PlpgsqlDebugPrint</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[PLPGSQL] pgxc_node_begin cmd:%s conn-&gt;plpgsql_need_begin_txn "</literal>
						<literal type="string">"was true, g_in_plpgsql_exec_fun:%d, conn-&gt;plpgsql_need_begin_sub_txn:%d"</literal></expr></argument>,
							<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>g_in_plpgsql_exec_fun</name></expr></argument>, <argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>plpgsql_need_begin_sub_txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>plpgsql_need_begin_sub_txn</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>need_send_begin</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cmd</name> <operator>=</operator> <name>begin_subtxn_cmd</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>plpgsql_need_begin_sub_txn</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>PlpgsqlDebugPrint</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[PLPGSQL] pgxc_node_begin cmd:%s conn-&gt;plpgsql_need_begin_sub_txn was"</literal>
						<literal type="string">" true, g_in_plpgsql_exec_fun:%d, conn-&gt;plpgsql_need_begin_txn:%d"</literal></expr></argument>,
							<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>g_in_plpgsql_exec_fun</name></expr></argument>, <argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>plpgsql_need_begin_txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><literal type="char">'T'</literal> <operator>!=</operator> <name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>transaction_status</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"[PLPGSQL] pgxc_node_begin need_begin_sub_txn wrong"</literal>
						<literal type="string">"transaction_status[%c]"</literal></expr></argument>, <argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>transaction_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If exec savepoint command, we make sure begin should send(NB:can be
		 * sent only once) before send savepoint
		 */</comment>
		<if_stmt><if>if <condition>(<expr><literal type="char">'I'</literal> <operator>==</operator> <name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>transaction_status</name> <operator>&amp;&amp;</operator> <call><name>SavepointDefined</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>need_send_begin</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* 
		 * Send the Coordinator info down to the PGXC node at the beginning of
		 * transaction, In this way, Datanode can print this Coordinator info
		 * into logfile, and those infos can be found in Datanode logifile if
		 * needed during debugging
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>need_send_begin</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_COORDINATOR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pgxc_node_send_coord_info</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"[PLPGSQL] pgxc_node_begin need_tran_block %d,"</literal>
				<literal type="string">"connections[%d]-&gt;transaction_status %c need_send_begin:%d"</literal></expr></argument>,
				<argument><expr><name>need_tran_block</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>transaction_status</name></expr></argument>,
				<argument><expr><name>need_send_begin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Send BEGIN if not already in transaction */</comment>
        <if_stmt><if>if <condition>(<expr><name>need_send_begin</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Send the BEGIN TRANSACTION command and check for errors */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_query</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><name>EOF</name></expr>;</return>
            </block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_begin send %s to node %s, pid:%d"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>,
					<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nodename</name></expr></argument>, <argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>backend_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>new_connections</name><index>[<expr><name>new_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<comment type="block">/* if send begin, register current connection */</comment>
			<expr_stmt><expr><call><name>register_transaction_handles</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * If we did not send a BEGIN command to any node, we are done. Otherwise,
     * we need to check for any errors and report them
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>new_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>InitResponseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><name>new_count</name></expr></argument>, <argument><expr><name>COMBINE_TYPE_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * Make sure there are zeroes in unused fields
     */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Receive responses */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_receive_responses</name><argument_list>(<argument><expr><name>new_count</name></expr></argument>, <argument><expr><name>new_connections</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_begin receive response fails."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Verify status */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ValidateAndCloseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_begin validating response fails."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Send virtualXID to the remote nodes using SET command */</comment>
    
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>set_cmd</name></expr></argument>, <argument><expr><name>SET_CMD_LENGTH</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PGXCNodeSetParam</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"coordinator_lxid"</literal></expr></argument>, <argument><expr><name>set_cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <comment type="block">/* after transactions are started send down local set commands */</comment>
    <expr_stmt><expr><name>init_str</name> <operator>=</operator> <call><name>PGXCNodeGetTransactionParamStr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>    
    if (PoolManagerSetCommand(new_connections, new_count, POOL_CMD_LOCAL_SET, init_str) &lt; 0)
    {        
        elog(ERROR, "pgxc_node_begin TBase ERROR SET, query:%s, new_count:%d", init_str, new_count);
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>init_str</name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>new_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
			<expr_stmt><expr><call><name>pgxc_node_set_query</name><argument_list>(<argument><expr><name><name>new_connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>init_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_begin send %s to node %s, pid:%d"</literal></expr></argument>, <argument><expr><name>init_str</name></expr></argument>,
					<argument><expr><name><name>new_connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nodename</name></expr></argument>, <argument><expr><name><name>new_connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>backend_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* No problem, let's get going */</comment>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Execute DISCARD ALL command on all allocated nodes to remove all session
 * specific stuff before releasing them to pool for reuse by other sessions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgxc_node_remote_cleanup_all</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>handles</name> <init>= <expr><call><name>get_current_handles</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name><name>new_connections</name><index>[<expr><name><name>handles</name><operator>-&gt;</operator><name>co_conn_count</name></name> <operator>+</operator> <name><name>handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>new_conn_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>i</name></decl>;</decl_stmt>
	<comment type="block">/* if it's called by sub-commit or sub-abort, DO NOT reset global_session */</comment>
	<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>resetcmd</name> <init>= <expr><literal type="string">"RESET ALL;"</literal>
                               <literal type="string">"RESET SESSION AUTHORIZATION;"</literal>
                               <literal type="string">"RESET transaction_isolation;"</literal>
                               <literal type="string">"RESET global_session"</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_remote_cleanup_all - handles-&gt;co_conn_count %d,"</literal>
            <literal type="string">"handles-&gt;dn_conn_count %d"</literal></expr></argument>, <argument><expr><name><name>handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr></argument>,
            <argument><expr><name><name>handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * We must handle reader and writer connections both since even a read-only
     * needs to be cleaned up.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>handles</name><operator>-&gt;</operator><name>co_conn_count</name></name> <operator>+</operator> <name><name>handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

	<comment type="block">/* Do not cleanup connections if we have prepared statements on nodes */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HaveActiveDatanodeStatements</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Send down snapshot followed by DISCARD ALL command.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name><name>handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* At this point connection should be in IDLE state */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<comment type="block">/* 
		 * At the end of the transaction, 
		 * clean up the CN info sent to the DN in pgxc_node_begin
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pgxc_node_send_coord_info</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/*
         * We must go ahead and release connections anyway, so do not throw
         * an error if we have a problem here.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_query</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>resetcmd</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to clean up data nodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>new_connections</name><index>[<expr><name>new_conn_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>handle</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>combiner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name><name>handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* At this point connection should be in IDLE state */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<comment type="block">/* 
		 * At the end of the transaction, 
		 * clean up the CN info sent to the DN in pgxc_node_begin
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pgxc_node_send_coord_info</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/*
         * We must go ahead and release connections anyway, so do not throw
         * an error if we have a problem here.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_query</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>resetcmd</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to clean up data nodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>new_connections</name><index>[<expr><name>new_conn_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>handle</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>combiner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>new_conn_count</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ResponseCombiner</name></type> <name>combiner</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>InitResponseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><name>new_conn_count</name></expr></argument>, <argument><expr><name>COMBINE_TYPE_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Receive responses */</comment>
        <expr_stmt><expr><call><name>pgxc_node_receive_responses</name><argument_list>(<argument><expr><name>new_conn_count</name></expr></argument>, <argument><expr><name>new_connections</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Count how many coordinators and datanodes are involved in this transaction
 * so that we can save that information in the GID
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgxc_node_remote_count</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dnCount</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name><name>dnNodeIds</name><index>[]</index></name></decl></parameter>,
        <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>coordCount</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name><name>coordNodeIds</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>handles</name> <init>= <expr><call><name>get_current_handles</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>dnCount</name> <operator>=</operator> <operator>*</operator><name>coordCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <comment type="block">/*
         * Skip empty slots
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>NO_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>==</operator> <literal type="char">'T'</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>read_only</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>dnNodeIds</name><index>[<expr><operator>*</operator><name>dnCount</name></expr>]</index></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>nodeid</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>dnCount</name> <operator>=</operator> <operator>*</operator><name>dnCount</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <comment type="block">/*
         * Skip empty slots
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>NO_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>==</operator> <literal type="char">'T'</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>read_only</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>coordNodeIds</name><index>[<expr><operator>*</operator><name>coordCount</name></expr>]</index></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>nodeid</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>coordCount</name> <operator>=</operator> <operator>*</operator><name>coordCount</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare nodes which ran write operations during the transaction.
 * Read only remote transactions are committed and connections are released
 * back to the pool.
 * Function returns the list of nodes where transaction is prepared, including
 * local node, if requested, in format expected by the GTM server.
 * If something went wrong the function tries to abort prepared transactions on
 * the nodes where it succeeded and throws error. A warning is emitted if abort
 * prepared fails.
 * After completion remote connection handles are released.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pgxc_node_remote_prepare</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>prepareGID</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>localNode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>implicit</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>             <name>isOK</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type>     <name>nodestr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>prepare_cmd</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name> <argument_list>(<argument><expr><literal type="number">64</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>abort_cmd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GlobalTransactionId</name></type> <name>startnodeXid</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>GlobalTransactionId</name></type> <name>auxXid</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>char</name>           <modifier>*</modifier></type><name>commit_cmd</name> <init>= <expr><literal type="string">"COMMIT TRANSACTION"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResponseCombiner</name></type> <name>combiner</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier><modifier>*</modifier></type><name>connections</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>conn_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<comment type="block">/* get current transaction handles that we register when pgxc_node_begin */</comment>
	<decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>handles</name> <init>= <expr><call><name>get_current_txn_handles</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>GlobalTimestamp</name></type> <name>global_prepare_ts</name> <init>= <expr><name>InvalidGlobalTimestamp</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
    <comment type="block">/* conn_state_index record index in g_twophase_state.conn_state or g_twophase_state.datanode_state */</comment>
    <decl_stmt><decl><type><name>int</name></type>             <name>conn_state_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>int</name></type>             <name>twophase_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type>  <name>partnodes</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>connections</name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>TBASE_MAX_DATANODE_NUMBER</name> <operator>+</operator> <name>TBASE_MAX_COORDINATOR_NUMBER</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>connections</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory for connections"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nodestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>localNode</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nodestr</name></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>prepare_cmd</name></expr></argument>, <argument><expr><literal type="string">"PREPARE TRANSACTION '%s'"</literal></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
    <expr_stmt><expr><name>twophase_in</name> <operator>=</operator> <name>IN_REMOTE_PREPARE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <if_stmt><if>if<condition>(<expr><name>implicit</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"prepare remote transaction xid %d gid %s"</literal></expr></argument>, <argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>global_prepare_ts</name> <operator>=</operator> <call><name>GetGlobalTimestampGTM</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>PART_PREPARE_GET_TIMESTAMP</name> <operator>==</operator> <name>twophase_exception_case</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>global_prepare_ts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>GlobalTimestampIsValid</name><argument_list>(<argument><expr><name>global_prepare_ts</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to get global timestamp for PREPARED command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"prepare phase get global prepare timestamp gid %s, time "</literal> <name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>, <argument><expr><name>global_prepare_ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>SetGlobalPrepareTimestamp</name><argument_list>(<argument><expr><name>global_prepare_ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
    <comment type="block">/* 
     *g_twophase_state is cleared under the following circumstances:
     *1.after explicit 'prepare transaction', since implicit twophase trans can be created after explicit prepare;
     *2.in CleanupTransaction after AbortTransaction;
     *3.in FinishPreparedTransaction;
     *under all the above situations, g_twophase_state must be cleared here
     */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>     
    Assert('\0' == g_twophase_state.gid[0]);
    Assert(TWO_PHASE_INITIALTRANS == g_twophase_state.state);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    
    <expr_stmt><expr><call><name>ClearLocalTwoPhaseState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>get_partnodes</name><argument_list>(<argument><expr><name>handles</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>partnodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* 
     *if conn-&gt;readonly == true, that is no update in this trans, do not record in g_twophase_state 
     */</comment>
    <if_stmt><if>if <condition>(<expr><literal type="char">'\0'</literal> <operator>!=</operator> <name><name>partnodes</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>is_start_node</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <comment type="block">/* strlen of prepareGID is checked in MarkAsPreparing, it satisfy strlen(gid) &gt;= GIDSIZE  */</comment>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>gid</name></name></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>TWO_PHASE_PREPARING</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SetLocalTwoPhaseStateHandles</name><argument_list>(<argument><expr><name>handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_node_name</name></name></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>, 
                <argument><expr><call><name>strnlen</name><argument_list>(<argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>participants</name></name></expr></argument>, <argument><expr><name><name>partnodes</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>partnodes</name><operator>.</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* 
         *if startnode participate this twophase trans, then send CurrentTransactionId, 
         *or just send 0 as TransactionId 
         */</comment>
         
        <expr_stmt><expr><name>startnodeXid</name> <operator>=</operator> <call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_xid</name></name> <operator>=</operator> <name>startnodeXid</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>enable_distri_print</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><literal type="char">'\0'</literal> <operator>==</operator> <name><name>g_twophase_state</name><operator>.</operator><name>start_node_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"remote prepare record remote 2pc on node:%s,  gid: %s, startnode:%s, startxid: %u, "</literal>
                                             <literal type="string">"partnodes:%s, localxid: %u"</literal></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>gid</name></name></expr></argument>, 
                                                 <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_node_name</name></name></expr></argument>, 
                                                 <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_xid</name></name></expr></argument>, 
                                                 <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>participants</name></name></expr></argument>, 
                                                 <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"remote prepare record remote 2pc on node:%s,  gid: %s, startnode:%s, startxid: %u, "</literal>
                                             <literal type="string">"partnodes:%s, localxid: %u"</literal></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>gid</name></name></expr></argument>, 
                                                 <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_node_name</name></name></expr></argument>, 
                                                 <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_xid</name></name></expr></argument>, 
                                                 <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>participants</name></name></expr></argument>, 
                                                 <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * If something went wrong already we have nothing to do here. The error
         * will be reported at the end of the function, and we will rollback
         * remotes as part of the error handling.
         * Just skip to clean up section and check if we have already prepared
         * somewhere, we should abort that prepared transaction.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isOK</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>prepare_err</name>;</goto></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Skip empty slots
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>NO_SOCKET</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_remote_prepare, remote node %s's connection handle is invalid, backend_pid: %d"</literal></expr></argument>,
                 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>==</operator> <literal type="char">'T'</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Read in any pending input */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>BufferConnection</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>read_only</name></name></expr>)</condition>
            <block>{<block_content>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
                <if_stmt><if>if<condition>(<expr><name>implicit</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"send prepare timestamp for xid %d gid %s prepare ts "</literal> <name>INT64_FORMAT</name></expr></argument>,<argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>,
                                                        <argument><expr><name>prepareGID</name></expr></argument>, <argument><expr><name>global_prepare_ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_prepare_timestamp</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>global_prepare_ts</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send global prepare committs for PREPARED command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/* Send down prepare command */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_query</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>commit_cmd</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * not a big deal, it was read only, the connection will be
                     * abandoned later.
                     */</comment>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send COMMIT command to "</literal>
                                <literal type="string">"the node %u"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Read responses from these */</comment>
                    <expr_stmt><expr><name><name>connections</name><index>[<expr><name>conn_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                <comment type="block">/* 
                 *only record connections that satisfy !conn-&gt;readonly 
                 */</comment>
                <expr_stmt><expr><name>twophase_index</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>datanode_index</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>is_participant</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>handle_idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>state</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
                <if_stmt><if>if<condition>(<expr><name>implicit</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"send prepare timestamp for xid %d gid %s prepare ts "</literal> <name>INT64_FORMAT</name></expr></argument>,<argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>,
                                                        <argument><expr><name>prepareGID</name></expr></argument>, <argument><expr><name>global_prepare_ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_prepare_timestamp</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>global_prepare_ts</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                        <comment type="block">/* record connection error */</comment>
                        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                            <name>TWO_PHASE_SEND_TIMESTAMP_ERROR</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> 
                            <name>TWO_PHASE_PREPARE_ERROR</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send global prepare committs for PREPARED command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_starter</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* record connection error */</comment>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                        <name>TWO_PHASE_SEND_STARTER_ERROR</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> 
                        <name>TWO_PHASE_PREPARE_ERROR</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send startnode for PREPARED command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_startxid</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>startnodeXid</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* record connection error */</comment>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                        <name>TWO_PHASE_SEND_STARTXID_ERROR</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> 
                        <name>TWO_PHASE_PREPARE_ERROR</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send startxid for PREPARED command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>!=</operator> <name><name>partnodes</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>enable_distri_print</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"twophase trans: %s, partnodes: %s"</literal></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>, <argument><expr><name><name>partnodes</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_partnodes</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>partnodes</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* record connection error */</comment>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                        <name>TWO_PHASE_SEND_PARTICIPANTS_ERROR</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> 
                        <name>TWO_PHASE_PREPARE_ERROR</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send partnodes for PREPARED command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
                <comment type="block">/* Send down prepare command */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_query</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>prepare_cmd</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                    <comment type="block">/* record connection error */</comment>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                        <name>TWO_PHASE_SEND_QUERY_ERROR</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> 
                        <name>TWO_PHASE_PREPARE_ERROR</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <comment type="block">/*
                     * That is the trouble, we really want to prepare it.
                     * Just emit warning so far and go to clean up.
                     */</comment>
                    <expr_stmt><expr><name>isOK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send PREPARE TRANSACTION command to "</literal>
                                <literal type="string">"the node %u"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodename</name> <init>= <expr><call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>nodestr</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nodestr</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nodestr</name></expr></argument>, <argument><expr><name>nodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* Read responses from these */</comment>
                    <expr_stmt><expr><name><name>connections</name><index>[<expr><name>conn_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
                    <comment type="block">/*
                     * If it fails on remote node it would just return ROLLBACK.
                     * Set the flag for the message handler so the response is
                     * verified.
                     */</comment>
                    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>ck_resp_rollback</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                        <name>TWO_PHASE_HEALTHY</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>twophase_index</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>connections_num</name></name></expr>;</expr_stmt>
                    <comment type="block">/* 
                     * g_twophase_state.connections stores relation among connections, coord_state, datanode_state
                     * for example, in receive_response, receive a readyforquery from connection[i]
                     * if (g_twophase_state.connections[i].node_type == coordinator) then 
                     * twophase_index = g_twophase_state.connections[i].conn_trans_state_index
                     * and we update g_twophase_state.coord_state[twophase_index] = COMMITTED OR ABORTTED
                     */</comment>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>node_type</name> <operator>=</operator> <name>PGXC_NODE_DATANODE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_trans_state_index</name> <operator>=</operator> 
                        <name><name>g_twophase_state</name><operator>.</operator><name>datanode_index</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections_num</name></name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_index</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Probably can not happen, if there was a error the engine would
             * abort anyway, even in case of explicit PREPARE.
             * Anyway, just in case...
             */</comment>
            <expr_stmt><expr><name>isOK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"remote node %u is in error state"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * If something went wrong already we have nothing to do here. The error
         * will be reported at the end of the function, and we will rollback
         * remotes as part of the error handling.
         * Just skip to clean up section and check if we have already prepared
         * somewhere, we should abort that prepared transaction.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isOK</name></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>prepare_err</name>;</goto></block_content></block></if></if_stmt>

        <comment type="block">/*
         * Skip empty slots
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>NO_SOCKET</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_remote_prepare, remote node %s's connection handle is invalid, backend_pid: %d"</literal></expr></argument>,
                 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>==</operator> <literal type="char">'T'</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>read_only</name></name></expr>)</condition>
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
                <if_stmt><if>if<condition>(<expr><name>implicit</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"send prepare timestamp for xid %d gid %s prepare ts "</literal> <name>INT64_FORMAT</name></expr></argument>,<argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>,
                                                        <argument><expr><name>prepareGID</name></expr></argument>, <argument><expr><name>global_prepare_ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_prepare_timestamp</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>global_prepare_ts</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send global prepare committs for PREPARED command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/* Send down prepare command */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_query</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>commit_cmd</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * not a big deal, it was read only, the connection will be
                     * abandoned later.
                     */</comment>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send COMMIT command to "</literal>
                                <literal type="string">"the node %u"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Read responses from these */</comment>
                    <expr_stmt><expr><name><name>connections</name><index>[<expr><name>conn_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                <expr_stmt><expr><name>twophase_index</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>coord_index</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>is_participant</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>handle_idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt> 
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>state</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
                <if_stmt><if>if<condition>(<expr><name>implicit</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"send prepare timestamp for xid %d gid %s prepare ts "</literal> <name>INT64_FORMAT</name></expr></argument>,<argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>,
                                                        <argument><expr><name>prepareGID</name></expr></argument>, <argument><expr><name>global_prepare_ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_prepare_timestamp</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>global_prepare_ts</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                        <comment type="block">/* record connection error */</comment>
                        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                            <name>TWO_PHASE_SEND_TIMESTAMP_ERROR</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> 
                            <name>TWO_PHASE_PREPARE_ERROR</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send global prepare committs for PREPARED command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_starter</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* record connection error */</comment>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                        <name>TWO_PHASE_SEND_STARTER_ERROR</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> 
                        <name>TWO_PHASE_PREPARE_ERROR</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send startnode for PREPARED command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_startxid</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>startnodeXid</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* record connection error */</comment>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                        <name>TWO_PHASE_SEND_STARTXID_ERROR</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> 
                        <name>TWO_PHASE_PREPARE_ERROR</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send startxid for PREPARED command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>!=</operator> <name><name>partnodes</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>enable_distri_print</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"twophase trans: %s, partnodes: %s"</literal></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>, <argument><expr><name><name>partnodes</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_partnodes</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>partnodes</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* record connection error */</comment>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                        <name>TWO_PHASE_SEND_PARTICIPANTS_ERROR</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> 
                        <name>TWO_PHASE_PREPARE_ERROR</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send partnodes for PREPARED command"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <comment type="block">/* Send down prepare command */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_query</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>prepare_cmd</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                    <comment type="block">/* record connection error */</comment>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                        <name>TWO_PHASE_SEND_QUERY_ERROR</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> 
                        <name>TWO_PHASE_PREPARE_ERROR</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <comment type="block">/*
                     * That is the trouble, we really want to prepare it.
                     * Just emit warning so far and go to clean up.
                     */</comment>
                    <expr_stmt><expr><name>isOK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send PREPARE TRANSACTION command to "</literal>
                                <literal type="string">"the node %u"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodename</name> <init>= <expr><call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>nodestr</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nodestr</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nodestr</name></expr></argument>, <argument><expr><name>nodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* Read responses from these */</comment>
                    <expr_stmt><expr><name><name>connections</name><index>[<expr><name>conn_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
                    <comment type="block">/*
                     * If it fails on remote node it would just return ROLLBACK.
                     * Set the flag for the message handler so the response is
                     * verified.
                     */</comment>
                    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>ck_resp_rollback</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                        <name>TWO_PHASE_HEALTHY</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>twophase_index</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>connections_num</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_trans_state_index</name> <operator>=</operator> 
                        <name><name>g_twophase_state</name><operator>.</operator><name>coord_index</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>node_type</name> <operator>=</operator> 
                        <name>PGXC_NODE_COORDINATOR</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections_num</name></name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_index</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Probably can not happen, if there was a error the engine would
             * abort anyway, even in case of explicit PREPARE.
             * Anyway, just in case...
             */</comment>
            <expr_stmt><expr><name>isOK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"remote node %u is in error state"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>SetSendCommandId</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>PREPARE_ERROR_SEND_QUERY</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>||</operator>
        <name>PREPARE_ERROR_RESPONSE_ERROR</name> <operator>==</operator> <name>twophase_exception_case</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>isOK</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>PART_ABORT_SEND_ROLLBACK</name> <operator>==</operator> <name>twophase_exception_case</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"PART_ABORT_SEND_ROLLBACK in twophase tests"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isOK</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>prepare_err</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* exit if nothing has been prepared */</comment>
    <if_stmt><if>if <condition>(<expr><name>conn_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
        <comment type="block">/*
         * Receive and check for any errors. In case of errors, we don't bail out
         * just yet. We first go through the list of connections and look for
         * errors on each connection. This is important to ensure that we run
         * an appropriate ROLLBACK command later on (prepared transactions must be
         * rolled back with ROLLBACK PREPARED commands).
         *
         * PGXCTODO - There doesn't seem to be a solid mechanism to track errors on
         * individual connections. The transaction_status field doesn't get set
         * every time there is an error on the connection. The combiner mechanism is
         * good for parallel proessing, but I think we should have a leak-proof
         * mechanism to track connection status
         */</comment>
        <expr_stmt><expr><call><name>InitResponseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>COMBINE_TYPE_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>response_operation</name></name> <operator>=</operator> <name>REMOTE_PREPARE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Receive responses */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pgxc_node_receive_responses</name><argument_list>(<argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>connections</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>||</operator> <operator>!</operator><call><name>validate_combiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>prepare_err</name>;</goto></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>CloseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* Before exit clean the flag, to avoid unnecessary checks */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>conn_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ck_resp_rollback</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></for>

        <expr_stmt><expr><call><name>clear_handles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>prepare_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>TWO_PHASE_PREPARE_END</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>partnodes</name><operator>.</operator><name>maxlen</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>partnodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>partnodes</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>connections</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>connections</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name><name>nodestr</name><operator>.</operator><name>data</name></name></expr>;</return>

<label><name>prepare_err</name>:</label>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name><name>partnodes</name><operator>.</operator><name>maxlen</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>partnodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>partnodes</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* read ReadyForQuery from connections which sent commit/commit prepared */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isOK</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>conn_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ResponseCombiner</name></type> <name>combiner3</name></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>InitResponseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner3</name></expr></argument>, <argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>COMBINE_TYPE_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>response_operation</name></name> <operator>=</operator> <name>REMOTE_PREPARE_ERROR</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/* Receive responses */</comment>
            <expr_stmt><expr><call><name>pgxc_node_receive_responses</name><argument_list>(<argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>connections</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>combiner3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CloseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
    <expr_stmt><expr><name>twophase_in</name> <operator>=</operator> <name>IN_PREPARE_ERROR</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

     <expr_stmt><expr><name>abort_cmd</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name> <argument_list>(<argument><expr><literal type="number">64</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>abort_cmd</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK PREPARED '%s'"</literal></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>

    <expr_stmt><expr><name>auxXid</name> <operator>=</operator> <call><name>GetAuxilliaryTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>conn_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections_num</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>conn_state_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * PREPARE succeeded on that node, roll it back there
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>ck_resp_rollback</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>ck_resp_rollback</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Error while PREPARING transaction %s on "</literal>
                             <literal type="string">"node %s. Administrative action may be required "</literal>
                             <literal type="string">"to abort this transaction on the node"</literal></expr></argument>,
                             <argument><expr><name>prepareGID</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* sanity checks */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
            <comment type="block">/* update datanode_state = TWO_PHASE_ABORTTING in prepare_err */</comment>
            <while>while <condition>(<expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_index</name></name> <operator>&gt;=</operator> <name>conn_state_index</name> <operator>&amp;&amp;</operator> 
                  <name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>conn_state_index</name></expr>]</index></name><operator>.</operator><name>handle_idx</name> <operator>!=</operator> <name>i</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>conn_state_index</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
            <if_stmt><if>if <condition>(<expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_index</name></name> <operator>&lt;</operator> <name>conn_state_index</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"in pgxc_node_remote_prepare can not find twophase_state for node %s"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>conn_state_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name>TWO_PHASE_ABORTTING</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="block">/* Send down abort prepared command */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_gxid</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>auxXid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>conn_state_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                    <name>TWO_PHASE_SEND_GXID_ERROR</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>conn_state_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator>
					<name>TWO_PHASE_ABORT_ERROR</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/*
                 * Prepared transaction is left on the node, but we can not
                 * do anything with that except warn the user.
                 */</comment>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send xid %u to "</literal>
								<literal type="string">"the node %u"</literal></expr></argument>, <argument><expr><name>auxXid</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_query</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>abort_cmd</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>conn_state_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                    <name>TWO_PHASE_SEND_QUERY_ERROR</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>conn_state_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name>TWO_PHASE_ABORT_ERROR</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/*
                 * Prepared transaction is left on the node, but we can not
                 * do anything with that except warn the user.
                 */</comment>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send ABORT PREPARED command to "</literal>
                                <literal type="string">"the node %u"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* Read responses from these */</comment>
                <expr_stmt><expr><name><name>connections</name><index>[<expr><name>conn_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>conn_state_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> <name>TWO_PHASE_HEALTHY</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>twophase_index</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>connections_num</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_trans_state_index</name> <operator>=</operator> <name>conn_state_index</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>node_type</name> <operator>=</operator> <name>PGXC_NODE_DATANODE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections_num</name></name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>conn_state_index</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
    <expr_stmt><expr><name>conn_state_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>ck_resp_rollback</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>ck_resp_rollback</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Error while PREPARING transaction %s on "</literal>
                             <literal type="string">"node %s. Administrative action may be required "</literal>
                             <literal type="string">"to abort this transaction on the node"</literal></expr></argument>,
                             <argument><expr><name>prepareGID</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* sanity checks */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
            <while>while <condition>(<expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_index</name></name> <operator>&gt;=</operator> <name>conn_state_index</name> <operator>&amp;&amp;</operator> 
                  <name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>conn_state_index</name></expr>]</index></name><operator>.</operator><name>handle_idx</name> <operator>!=</operator> <name>i</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>conn_state_index</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
            <if_stmt><if>if <condition>(<expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_index</name></name> <operator>&lt;</operator> <name>conn_state_index</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"in pgxc_node_remote_prepare can not find twophase_state for node %s"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>conn_state_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name>TWO_PHASE_ABORTTING</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/* Send down abort prepared command */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_gxid</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>auxXid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>conn_state_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                    <name>TWO_PHASE_SEND_GXID_ERROR</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>conn_state_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator>
					<name>TWO_PHASE_ABORT_ERROR</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/*
                 * Prepared transaction is left on the node, but we can not
                 * do anything with that except warn the user.
                 */</comment>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send xid %u to "</literal>
								<literal type="string">"the node %u"</literal></expr></argument>, <argument><expr><name>auxXid</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_query</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>abort_cmd</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>conn_state_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                    <name>TWO_PHASE_SEND_QUERY_ERROR</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>conn_state_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name>TWO_PHASE_ABORT_ERROR</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/*
                 * Prepared transaction is left on the node, but we can not
                 * do anything with that except warn the user.
                 */</comment>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send ABORT PREPARED command to "</literal>
                                <literal type="string">"the node %u"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* Read responses from these */</comment>
                <expr_stmt><expr><name><name>connections</name><index>[<expr><name>conn_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>conn_state_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> <name>TWO_PHASE_HEALTHY</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>twophase_index</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>connections_num</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_trans_state_index</name> <operator>=</operator> <name>conn_state_index</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>node_type</name> <operator>=</operator> <name>PGXC_NODE_COORDINATOR</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections_num</name></name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>conn_state_index</name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>conn_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Just read out responses, throw error from the first combiner */</comment>
        <decl_stmt><decl><type><name>ResponseCombiner</name></type> <name>combiner2</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>InitResponseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner2</name></expr></argument>, <argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>COMBINE_TYPE_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>response_operation</name></name> <operator>=</operator> <name>REMOTE_PREPARE_ABORT</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Receive responses */</comment>
        <expr_stmt><expr><call><name>pgxc_node_receive_responses</name><argument_list>(<argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>connections</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>combiner2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If the flag is set we are here because combiner carries error message
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>isOK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pgxc_node_report_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to PREPARE transaction on one or more nodes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>temp_object_included</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>PersistentConnections</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Clean up remote sessions */</comment>
		<expr_stmt><expr><call><name>pgxc_node_remote_cleanup_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>release_handles</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>clear_handles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>abort_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    <comment type="block">/*
     * If the flag is set we are here because combiner carries error message
     */</comment>
    if (isOK)
        pgxc_node_report_error(&amp;combiner);
    else
        elog(ERROR, "failed to PREPARE transaction on one or more nodes");
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>connections</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>connections</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
 * Commit transactions on remote nodes.
 * If barrier lock is set wait while it is released.
 * Release remote connection after completion.
 *
 * For DDL, DN will commit before CN does.
 * Because DDL normally has conflict locks, when CN gets committed,
 * DNs will be in a consistent state for blocked user transactions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgxc_node_remote_commit</name><parameter_list>(<parameter><decl><type><name>TranscationType</name></type> <name>txn_type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_release_handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>conn_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_txn_has_parallel_ddl</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* normal cases */</comment>
        <expr_stmt><expr><name>conn_count</name> <operator>=</operator> <call><name>pgxc_node_remote_commit_internal</name><argument_list>(<argument><expr><call><name>get_current_handles</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>txn_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* make sure first DN then CN */</comment>
        <expr_stmt><expr><name>conn_count</name> <operator>=</operator>  <call><name>pgxc_node_remote_commit_internal</name><argument_list>(<argument><expr><call><name>get_current_dn_handles</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>txn_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>conn_count</name> <operator>+=</operator> <call><name>pgxc_node_remote_commit_internal</name><argument_list>(<argument><expr><call><name>get_current_cn_handles</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>txn_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>stat_transaction</name><argument_list>(<argument><expr><name>conn_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>temp_object_included</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>PersistentConnections</name> <operator>&amp;&amp;</operator> <name>need_release_handle</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Clean up remote sessions */</comment>
        <expr_stmt><expr><call><name>pgxc_node_remote_cleanup_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>release_handles</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>clear_handles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Commit transactions on remote nodes.
 * If barrier lock is set wait while it is released.
 * Release remote connection after completion.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>
<name>pgxc_node_remote_commit_internal</name><argument_list>(<argument><expr><name>PGXCNodeAllHandles</name> <operator>*</operator><name>handles</name></expr></argument>, <argument><expr><name>TranscationType</name> <name>txn_type</name></expr></argument>)</argument_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
static <name>void</name>
<name>pgxc_node_remote_commit</name><argument_list>(<argument><expr><name>TranscationType</name> <name>txn_type</name></expr></argument>, <argument><expr><name>bool</name> <name>need_release_handle</name></expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>				<name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>commitCmd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResponseCombiner</name></type> <name>combiner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier><modifier>*</modifier></type><name>connections</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>conn_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <switch>switch <condition>(<expr><name>txn_type</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>TXN_TYPE_CommitTxn</name></expr>:</case>
            <expr_stmt><expr><name>commitCmd</name> <operator>=</operator> <literal type="string">"COMMIT TRANSACTION"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>TXN_TYPE_CommitSubTxn</name></expr>:</case>
            <expr_stmt><expr><name>commitCmd</name> <operator>=</operator> <literal type="string">"COMMIT_SUBTXN"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_remote_commit invalid TranscationType:%d"</literal></expr></argument>, <argument><expr><name>txn_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    GlobalTimestamp   global_committs = InvalidGlobalTimestamp; 

    if(IS_PGXC_COORDINATOR)
    {
        global_committs = GetGlobalTimestampGTM();
        if(!GlobalTimestampIsValid(global_committs)){
            ereport(ERROR,
            (errcode(ERRCODE_INTERNAL_ERROR),
             errmsg("failed to get global timestamp for commit command")));
        }
        elog(DEBUG8, "commit get global commit timestamp xid %d time " INT64_FORMAT, 
                GetTopTransactionIdIfAny(), global_committs);
        SetGlobalCommitTimestamp(global_committs);<comment type="block">/* Save for local commit */</comment>
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* palloc will FATAL when out of memory */</comment>
    <expr_stmt><expr><name>connections</name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>TBASE_MAX_DATANODE_NUMBER</name> <operator>+</operator> <name>TBASE_MAX_COORDINATOR_NUMBER</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>SetSendCommandId</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Barrier:
     *
     * We should acquire the BarrierLock in SHARE mode here to ensure that
     * there are no in-progress barrier at this point. This mechanism would
     * work as long as LWLock mechanism does not starve a EXCLUSIVE lock
     * requester
     */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>BarrierLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Skip empty slots */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>NO_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * We do not need to commit remote node if it is not in transaction.
         * If transaction is in error state the commit command will cause
         * rollback, that is OK
         */</comment>
        <comment type="line">//if (conn-&gt;transaction_status != 'I' &amp;&amp; (!is_subtxn || (is_subtxn &amp;&amp; NodeHasBeginSubTxn(conn-&gt;nodeoid))))</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>!=</operator> <literal type="char">'I'</literal> <operator>&amp;&amp;</operator> <name>TXN_TYPE_CommitTxn</name> <operator>==</operator> <name>txn_type</name><operator>)</operator> <operator>||</operator>
             <operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>!=</operator> <literal type="char">'I'</literal> <operator>&amp;&amp;</operator> <name>TXN_TYPE_CommitSubTxn</name> <operator>==</operator> <name>txn_type</name> <operator>&amp;&amp;</operator> <call><name>NodeHasBeginSubTxn</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Read in any pending input */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition>
            <block>{<block_content>
				<expr_stmt><expr><call><name>BufferConnection</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>    
            if(IS_PGXC_COORDINATOR)
            {
                if (pgxc_node_send_global_timestamp(conn, global_committs))
                {
                    ereport(ERROR,
                            (errcode(ERRCODE_INTERNAL_ERROR),
                             errmsg("failed to send global committs for commit command")));
                }
            }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_query</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>commitCmd</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Do not bother with clean up, just bomb out. The error handler
                 * will invoke RollbackTransaction which will do the work.
                 */</comment>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pgxc_node_remote_commit failed to send COMMIT command to the node %s, pid:%d, for %s"</literal></expr></argument>,
                                <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* Read responses from these */</comment>
                <expr_stmt><expr><name><name>connections</name><index>[<expr><name>conn_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Skip empty slots */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>NO_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/*
         * We do not need to commit remote node if it is not in transaction.
         * If transaction is in error state the commit command will cause
         * rollback, that is OK
         */</comment>
        <comment type="line">//if (conn-&gt;transaction_status != 'I' &amp;&amp; (!is_subtxn || (is_subtxn &amp;&amp; NodeHasBeginSubTxn(conn-&gt;nodeoid))))</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>!=</operator> <literal type="char">'I'</literal> <operator>&amp;&amp;</operator> <name>TXN_TYPE_CommitTxn</name> <operator>==</operator> <name>txn_type</name><operator>)</operator> <operator>||</operator>
             <operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>!=</operator> <literal type="char">'I'</literal> <operator>&amp;&amp;</operator> <name>TXN_TYPE_CommitSubTxn</name> <operator>==</operator> <name>txn_type</name> <operator>&amp;&amp;</operator> <call><name>NodeHasBeginSubTxn</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>    
            if(IS_PGXC_COORDINATOR)
            {
                if (pgxc_node_send_global_timestamp(conn, global_committs))
                {
                    ereport(ERROR,
                            (errcode(ERRCODE_INTERNAL_ERROR),
                             errmsg("failed to send global committs for commit command")));
                }
            }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_query</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>commitCmd</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Do not bother with clean up, just bomb out. The error handler
                 * will invoke RollbackTransaction which will do the work.
                 */</comment>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pgxc_node_remote_commit failed to send COMMIT command to the node %s, pid:%d, for %s"</literal></expr></argument>,
                                <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* Read responses from these */</comment>
                <expr_stmt><expr><name><name>connections</name><index>[<expr><name>conn_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Release the BarrierLock.
     */</comment>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>BarrierLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>conn_count</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>InitResponseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>COMBINE_TYPE_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* Receive responses */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pgxc_node_receive_responses</name><argument_list>(<argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>connections</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_remote_commit pgxc_node_receive_responses of COMMIT failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>EOF</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>validate_combiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_remote_commit validate_combiner responese of COMMIT failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>EOF</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>    

		<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>.</operator><name>errorMessage</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pgxc_node_report_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to COMMIT the transaction on one or more nodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>CloseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__TBASE__</name></cpp:ifndef>
	<expr_stmt><expr><call><name>stat_transaction</name><argument_list>(<argument><expr><name>conn_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>temp_object_included</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>PersistentConnections</name> <operator>&amp;&amp;</operator> <name>need_release_handle</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Clean up remote sessions */</comment>
			<expr_stmt><expr><call><name>pgxc_node_remote_cleanup_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>release_handles</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><call><name>clear_handles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>connections</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>connections</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<return>return <expr><name>conn_count</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></decl></decl_stmt>

<comment type="block">/*
 * Set the node begin transaction in plpgsql function
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetPlpgsqlTransactionBegin</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>nodeOid</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>NeedBeginTxn</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NodeHasBeginTxn</name><argument_list>(<argument><expr><name>nodeOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>plpgsql_need_begin_txn</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetNodeBeginTxn</name><argument_list>(<argument><expr><name>nodeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>PlpgsqlDebugPrint</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[PLPGSQL] ExecRemoteUtility conn nodename:%s "</literal>
					<literal type="string">"backendpid:%d sock:%d nodeoid:%u need_begin_txn"</literal></expr></argument>,
					<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>,
					<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>NeedBeginSubTxn</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>NodeHasBeginSubTxn</name><argument_list>(<argument><expr><name>nodeOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>plpgsql_need_begin_sub_txn</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetNodeBeginSubTxn</name><argument_list>(<argument><expr><name>nodeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>PlpgsqlDebugPrint</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[PLPGSQL] ExecRemoteUtility conn nodename:%s "</literal>
					<literal type="string">"backendpid:%d sock:%d nodeoid:%u need_begin_sub_txn"</literal></expr></argument>,
					<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>,
					<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
<function><type><name>void</name></type> <name>InitLocalTwoPhaseState</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>participants_capacity</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>is_start_node</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>in_pg_clean</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>is_readonly</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>is_after_prepare</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>gid</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><name>GIDSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>TWO_PHASE_INITIALTRANS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_index</name></name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>datanode_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>isprinted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_node_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>handles</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_xid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections_num</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>response_operation</name></name> <operator>=</operator> <name>OTHER_OPERATIONS</name></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name></name> <operator>=</operator> <operator>(</operator><name>ConnTransState</name> <operator>*</operator><operator>)</operator><call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, 
                                    <argument><expr><name>TBASE_MAX_COORDINATOR_NUMBER</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConnTransState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name></name> <operator>=</operator> <operator>(</operator><name>ConnTransState</name> <operator>*</operator><operator>)</operator><call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, 
                                    <argument><expr><name>TBASE_MAX_DATANODE_NUMBER</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ConnTransState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* since participates conclude nodename and  ","*/</comment>
    <expr_stmt><expr><name>participants_capacity</name> <operator>=</operator> <operator>(</operator><name>NAMEDATALEN</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <operator>(</operator><name>TBASE_MAX_DATANODE_NUMBER</name> <operator>+</operator> <name>TBASE_MAX_COORDINATOR_NUMBER</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>participants</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><name>participants_capacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections</name></name> <operator>=</operator> <operator>(</operator><name>AllConnNodeInfo</name> <operator>*</operator><operator>)</operator><call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>TBASE_MAX_DATANODE_NUMBER</name> <operator>+</operator> <name>TBASE_MAX_COORDINATOR_NUMBER</name><operator>)</operator> <operator>*</operator>
                                  <sizeof>sizeof<argument_list>(<argument><expr><name>AllConnNodeInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>SetLocalTwoPhaseStateHandles</name><parameter_list>(<parameter><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>handles</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>handles</name></name> <operator>=</operator> <name>handles</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections_num</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>UpdateLocalTwoPhaseState</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>response_handle</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conn_index</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errmsg</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>twophase_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TwoPhaseTransState</name></type> <name>state</name> <init>= <expr><name>TWO_PHASE_INITIALTRANS</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>RESPONSE_READY</name> <operator>!=</operator> <name>result</name> <operator>&amp;&amp;</operator> <name>RESPONSE_ERROR</name> <operator>!=</operator> <name>result</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name><name>g_twophase_state</name><operator>.</operator><name>response_operation</name></name> <operator>==</operator> <name>OTHER_OPERATIONS</name> <operator>||</operator>
      <operator>!</operator><call><name>IsTransactionState</name><argument_list>()</argument_list></call> <operator>||</operator> 
      <name><name>g_twophase_state</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>TWO_PHASE_INITIALTRANS</name></expr>)</condition>
    <block>{<block_content>
       <return>return ;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>handles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>RESPONSE_ERROR</name> <operator>==</operator> <name>result</name></expr>)</condition>
    <block>{<block_content>
        <switch>switch <condition>(<expr><name><name>g_twophase_state</name><operator>.</operator><name>state</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>TWO_PHASE_PREPARING</name></expr>:</case>
                <comment type="block">/* receive response in pgxc_node_remote_prepare or at the begining of prepare_err */</comment>
                <if_stmt><if>if <condition>(<expr><name>REMOTE_PREPARE</name> <operator>==</operator> <name><name>g_twophase_state</name><operator>.</operator><name>response_operation</name></name> <operator>||</operator> 
                  <name>REMOTE_PREPARE_ERROR</name> <operator>==</operator> <name><name>g_twophase_state</name><operator>.</operator><name>response_operation</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>state</name> <operator>=</operator> <name>TWO_PHASE_PREPARE_ERROR</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
                    <if_stmt><if>if <condition>(<expr><name>IN_REMOTE_PREPARE</name> <operator>==</operator> <name>twophase_in</name> <operator>&amp;&amp;</operator> 
                        <name>PART_PREPARE_RESPONSE_ERROR</name> <operator>==</operator> <name>twophase_exception_case</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>complish</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>run_pg_clean</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>STOP</name></expr></argument>, <argument><expr><literal type="string">"PART_PREPARE_RESPONSE_ERROR in pg_clean tests"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>REMOTE_PREPARE_ABORT</name> <operator>==</operator> <name><name>g_twophase_state</name><operator>.</operator><name>response_operation</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>state</name> <operator>=</operator> <name>TWO_PHASE_ABORT_ERROR</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
                    <if_stmt><if>if <condition>(<expr><name>IN_PREPARE_ERROR</name> <operator>==</operator> <name>twophase_in</name> <operator>&amp;&amp;</operator> 
                        <name>PREPARE_ERROR_RESPONSE_ERROR</name> <operator>==</operator> <name>twophase_exception_case</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>complish</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"PREPARE_ERROR_RESPONSE_ERROR in pg_clean tests"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></if></if_stmt>
            <case>case <expr><name>TWO_PHASE_PREPARED</name></expr>:</case>
                <break>break;</break>

            <case>case <expr><name>TWO_PHASE_COMMITTING</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>REMOTE_FINISH_COMMIT</name> <operator>==</operator> <name><name>g_twophase_state</name><operator>.</operator><name>response_operation</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>state</name> <operator>=</operator> <name>TWO_PHASE_COMMIT_ERROR</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            <case>case <expr><name>TWO_PHASE_COMMITTED</name></expr>:</case>
                <break>break;</break>
                
            <case>case <expr><name>TWO_PHASE_ABORTTING</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>REMOTE_FINISH_ABORT</name> <operator>==</operator> <name><name>g_twophase_state</name><operator>.</operator><name>response_operation</name></name> <operator>||</operator>
                  <name>REMOTE_ABORT</name> <operator>==</operator> <name><name>g_twophase_state</name><operator>.</operator><name>response_operation</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>state</name> <operator>=</operator> <name>TWO_PHASE_ABORT_ERROR</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            <case>case <expr><name>TWO_PHASE_ABORTTED</name></expr>:</case>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>result</name> <operator>&lt;</operator> <name>TWO_PHASE_INITIALTRANS</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>result</name> <operator>&gt;</operator> <name>TWO_PHASE_ABORT_ERROR</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
        </block_content>}</block></switch>
        
        <if_stmt><if>if <condition>(<expr><name>TWO_PHASE_INITIALTRANS</name> <operator>!=</operator> <name>state</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* update coord_state or datanode_state */</comment>
            <expr_stmt><expr><name>twophase_index</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>connections</name><index>[<expr><name>conn_index</name></expr>]</index></name><operator>.</operator><name>conn_trans_state_index</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>PGXC_NODE_COORDINATOR</name> <operator>==</operator> <name><name>g_twophase_state</name><operator>.</operator><name>connections</name><index>[<expr><name>conn_index</name></expr>]</index></name><operator>.</operator><name>node_type</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>enable_distri_print</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>index</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>handle_idx</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"In UpdateLocalTwoPhaseState connections[%d] imply node: %s, g_twophase_state.coord_state[%d] imply node: %s"</literal></expr></argument>, 
                            <argument><expr><name>conn_index</name></expr></argument>, 
                            <argument><expr><name><name>response_handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, 
                            <argument><expr><name>twophase_index</name></expr></argument>, 
                            <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>index</name></expr>]</index></name><operator>-&gt;</operator><name>nodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>enable_distri_print</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>index</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>handle_idx</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"In UpdateLocalTwoPhaseState connections[%d] imply node: %s, g_twophase_state.datanode_state[%d] imply node: %s"</literal></expr></argument>, 
                            <argument><expr><name>conn_index</name></expr></argument>, 
                            <argument><expr><name><name>response_handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, 
                            <argument><expr><name>twophase_index</name></expr></argument>, 
                            <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>index</name></expr>]</index></name><operator>-&gt;</operator><name>nodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>RESPONSE_READY</name> <operator>==</operator> <name>result</name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>==</operator> <name>errmsg</name></expr>)</condition>
    <block>{<block_content>
        <switch>switch <condition>(<expr><name><name>g_twophase_state</name><operator>.</operator><name>state</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>TWO_PHASE_PREPARING</name></expr>:</case>
                <comment type="block">/* receive response in pgxc_node_remote_prepare or at the begining of prepare_err */</comment>
                <if_stmt><if>if <condition>(<expr><name>REMOTE_PREPARE</name> <operator>==</operator> <name><name>g_twophase_state</name><operator>.</operator><name>response_operation</name></name> <operator>||</operator> 
                  <name>REMOTE_PREPARE_ERROR</name> <operator>==</operator> <name><name>g_twophase_state</name><operator>.</operator><name>response_operation</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>state</name> <operator>=</operator> <name>TWO_PHASE_PREPARED</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>REMOTE_PREPARE_ABORT</name> <operator>==</operator> <name><name>g_twophase_state</name><operator>.</operator><name>response_operation</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>state</name> <operator>=</operator> <name>TWO_PHASE_ABORTTED</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            <case>case <expr><name>TWO_PHASE_PREPARED</name></expr>:</case>
                <break>break;</break>
        
            <case>case <expr><name>TWO_PHASE_COMMITTING</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>REMOTE_FINISH_COMMIT</name> <operator>==</operator> <name><name>g_twophase_state</name><operator>.</operator><name>response_operation</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>state</name> <operator>=</operator> <name>TWO_PHASE_COMMITTED</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            <case>case <expr><name>TWO_PHASE_COMMITTED</name></expr>:</case>
                <break>break;</break>
            <case>case <expr><name>TWO_PHASE_ABORTTING</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><name>REMOTE_FINISH_ABORT</name> <operator>==</operator> <name><name>g_twophase_state</name><operator>.</operator><name>response_operation</name></name> <operator>||</operator>
                  <name>REMOTE_ABORT</name> <operator>==</operator> <name><name>g_twophase_state</name><operator>.</operator><name>response_operation</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>state</name> <operator>=</operator> <name>TWO_PHASE_ABORTTED</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            <case>case <expr><name>TWO_PHASE_ABORTTED</name></expr>:</case>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>result</name> <operator>&lt;</operator> <name>TWO_PHASE_INITIALTRANS</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>result</name> <operator>&gt;</operator> <name>TWO_PHASE_ABORT_ERROR</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
        </block_content>}</block></switch>

        <if_stmt><if>if <condition>(<expr><name>TWO_PHASE_INITIALTRANS</name> <operator>!=</operator> <name>state</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>twophase_index</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>connections</name><index>[<expr><name>conn_index</name></expr>]</index></name><operator>.</operator><name>conn_trans_state_index</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>PGXC_NODE_COORDINATOR</name> <operator>==</operator> <name><name>g_twophase_state</name><operator>.</operator><name>connections</name><index>[<expr><name>conn_index</name></expr>]</index></name><operator>.</operator><name>node_type</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>enable_distri_print</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>index</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>handle_idx</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"In UpdateLocalTwoPhaseState connections[%d] imply node: %s, g_twophase_state.coord_state[%d] imply node: %s"</literal></expr></argument>, 
                            <argument><expr><name>conn_index</name></expr></argument>, 
                            <argument><expr><name><name>response_handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, 
                            <argument><expr><name>twophase_index</name></expr></argument>, 
                            <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>index</name></expr>]</index></name><operator>-&gt;</operator><name>nodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>enable_distri_print</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>index</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>handle_idx</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"In UpdateLocalTwoPhaseState connections[%d] imply node: %s, g_twophase_state.datanode_state[%d] imply node: %s"</literal></expr></argument>, 
                            <argument><expr><name>conn_index</name></expr></argument>, 
                            <argument><expr><name><name>response_handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, 
                            <argument><expr><name>twophase_index</name></expr></argument>, 
                            <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>index</name></expr>]</index></name><operator>-&gt;</operator><name>nodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>ClearLocalTwoPhaseState</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>TWO_PHASE_PREPARED</name> <operator>==</operator> <name><name>g_twophase_state</name><operator>.</operator><name>state</name></name> <operator>&amp;&amp;</operator> 
            <call><name>IsXidImplicit</name><argument_list>(<argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"clear g_twophase_state of transaction '%s' in state '%s'"</literal></expr></argument>, 
                <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>gid</name></name></expr></argument>, <argument><expr><call><name>GetTransStateString</name><argument_list>(<argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>in_pg_clean</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>is_start_node</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>is_readonly</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>is_after_prepare</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>gid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>TWO_PHASE_INITIALTRANS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>isprinted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_node_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>handles</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>participants</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_xid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections_num</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>response_operation</name></name> <operator>=</operator> <name>OTHER_OPERATIONS</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type><name>GetTransStateString</name><parameter_list>(<parameter><decl><type><name>TwoPhaseTransState</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <switch>switch <condition>(<expr><name>state</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>TWO_PHASE_INITIALTRANS</name></expr>:</case>
            <return>return <expr><literal type="string">"TWO_PHASE_INITIALTRANS"</literal></expr>;</return>
        <case>case <expr><name>TWO_PHASE_PREPARING</name></expr>:</case>
            <return>return <expr><literal type="string">"TWO_PHASE_PREPARING"</literal></expr>;</return>
        <case>case <expr><name>TWO_PHASE_PREPARED</name></expr>:</case>
            <return>return <expr><literal type="string">"TWO_PHASE_PREPARED"</literal></expr>;</return>
        <case>case <expr><name>TWO_PHASE_PREPARE_ERROR</name></expr>:</case>
            <return>return <expr><literal type="string">"TWO_PHASE_PREPARE_ERROR"</literal></expr>;</return>
        <case>case <expr><name>TWO_PHASE_COMMITTING</name></expr>:</case>
            <return>return <expr><literal type="string">"TWO_PHASE_COMMITTING"</literal></expr>;</return>
        <case>case <expr><name>TWO_PHASE_COMMIT_END</name></expr>:</case>
            <return>return <expr><literal type="string">"TWO_PHASE_COMMIT_END"</literal></expr>;</return>
        <case>case <expr><name>TWO_PHASE_COMMITTED</name></expr>:</case>
            <return>return <expr><literal type="string">"TWO_PHASE_COMMITTED"</literal></expr>;</return>
        <case>case <expr><name>TWO_PHASE_COMMIT_ERROR</name></expr>:</case>
            <return>return <expr><literal type="string">"TWO_PHASE_COMMIT_ERROR"</literal></expr>;</return>
        <case>case <expr><name>TWO_PHASE_ABORTTING</name></expr>:</case>
            <return>return <expr><literal type="string">"TWO_PHASE_ABORTTING"</literal></expr>;</return>
        <case>case <expr><name>TWO_PHASE_ABORT_END</name></expr>:</case>
            <return>return <expr><literal type="string">"TWO_PHASE_ABORT_END"</literal></expr>;</return>
        <case>case <expr><name>TWO_PHASE_ABORTTED</name></expr>:</case>
            <return>return <expr><literal type="string">"TWO_PHASE_ABORTTED"</literal></expr>;</return>
        <case>case <expr><name>TWO_PHASE_ABORT_ERROR</name></expr>:</case>
            <return>return <expr><literal type="string">"TWO_PHASE_ABORT_ERROR"</literal></expr>;</return>
        <case>case <expr><name>TWO_PHASE_UNKNOW_STATUS</name></expr>:</case>
            <return>return <expr><literal type="string">"TWO_PHASE_UNKNOW_STATUS"</literal></expr>;</return>
        <default>default:</default>
            <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></switch>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type><name>GetConnStateString</name><parameter_list>(<parameter><decl><type><name>ConnState</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <switch>switch <condition>(<expr><name>state</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>TWO_PHASE_HEALTHY</name></expr>:</case>
            <return>return <expr><literal type="string">"TWO_PHASE_HEALTHY"</literal></expr>;</return>
        <case>case <expr><name>TWO_PHASE_SEND_GXID_ERROR</name></expr>:</case>
            <return>return <expr><literal type="string">"TWO_PHASE_SEND_GXID_ERROR"</literal></expr>;</return>
        <case>case <expr><name>TWO_PHASE_SEND_TIMESTAMP_ERROR</name></expr>:</case>
            <return>return <expr><literal type="string">"TWO_PHASE_SEND_TIMESTAMP_ERROR"</literal></expr>;</return>
        <case>case <expr><name>TWO_PHASE_SEND_STARTER_ERROR</name></expr>:</case>
            <return>return <expr><literal type="string">"TWO_PHASE_SEND_STARTER_ERROR"</literal></expr>;</return>
        <case>case <expr><name>TWO_PHASE_SEND_STARTXID_ERROR</name></expr>:</case>
            <return>return <expr><literal type="string">"TWO_PHASE_SEND_STARTXID_ERROR"</literal></expr>;</return>
        <case>case <expr><name>TWO_PHASE_SEND_PARTICIPANTS_ERROR</name></expr>:</case>
            <return>return <expr><literal type="string">"TWO_PHASE_SEND_PARTICIPANTS_ERROR"</literal></expr>;</return>
        <case>case <expr><name>TWO_PHASE_SEND_QUERY_ERROR</name></expr>:</case>
            <return>return <expr><literal type="string">"TWO_PHASE_SEND_QUERY_ERROR"</literal></expr>;</return>
        <default>default:</default>
            <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></switch>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>get_partnodes</name><parameter_list>(<parameter><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type> <name>handles</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>participants</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_readonly</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>gid</name> <operator>=</operator> <call><name>GetPrepareGID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><name>participants</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* start node participate the twophase transaction */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name> <operator>&amp;&amp;</operator> 
        <operator>(</operator><call><name>isXactWriteLocalNode</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>IsXidImplicit</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>participants</name></expr></argument>, <argument><expr><literal type="string">"%s,"</literal></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>NO_SOCKET</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"get_partnodes, remote node %s's connection handle is invalid, backend_pid: %d"</literal></expr></argument>,
                 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>==</operator> <literal type="char">'T'</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>read_only</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>is_readonly</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>participants</name></expr></argument>, <argument><expr><literal type="string">"%s,"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"get_partnodes, remote node %s is in error state, backend_pid: %d"</literal></expr></argument>,
                 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
 
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>NO_SOCKET</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"get_partnodes, remote node %s's connection handle is invalid, backend_pid: %d"</literal></expr></argument>,
                 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>==</operator> <literal type="char">'T'</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>read_only</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>is_readonly</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>participants</name></expr></argument>, <argument><expr><literal type="string">"%s,"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"get_partnodes, remote node %s is in error state, backend_pid: %d"</literal></expr></argument>,
                 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>is_readonly</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsXidImplicit</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>is_readonly</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
 * Rollback transactions on remote nodes.
 * Release remote connection after completion.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgxc_node_remote_abort</name><parameter_list>(<parameter><decl><type><name>TranscationType</name></type> <name>txn_type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_release_handle</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROLLBACK_PREPARED_CMD_LEN</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>bool</name></type>                  <name>force_release_handle</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>int</name></type>                <name>ret</name>    <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>           <modifier>*</modifier></type><name>rollbackCmd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResponseCombiner</name></type> <name>combiner</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier><modifier>*</modifier></type><name>connections</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>conn_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier><modifier>*</modifier></type><name>sync_connections</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>sync_conn_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>handles</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name>rollback_implict_txn</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type>             <name>twophase_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <switch>switch <condition>(<expr><name>txn_type</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>TXN_TYPE_RollbackTxn</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><literal type="char">'\0'</literal> <operator>!=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>gid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><comment type="line">//NULL != GetPrepareGID())</comment>
            <block>{<block_content>
                <expr_stmt><expr><name>rollbackCmd</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>ROLLBACK_PREPARED_CMD_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>rollbackCmd</name></expr></argument>, <argument><expr><name>ROLLBACK_PREPARED_CMD_LEN</name></expr></argument>, <argument><expr><literal type="string">"rollback prepared '%s'"</literal></expr></argument>, <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt><comment type="line">//GetPrepareGID());</comment>
                <expr_stmt><expr><name>rollback_implict_txn</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
                <expr_stmt><expr><name>twophase_in</name> <operator>=</operator> <name>IN_REMOTE_ABORT</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>rollbackCmd</name> <operator>=</operator> <literal type="string">"ROLLBACK TRANSACTION"</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>
        <case>case <expr><name>TXN_TYPE_RollbackSubTxn</name></expr>:</case>
            <expr_stmt><expr><name>rollbackCmd</name> <operator>=</operator> <literal type="string">"ROLLBACK_SUBTXN"</literal></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>TXN_TYPE_CleanConnection</name></expr>:</case>
            <return>return;</return>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_remote_abort invalid TranscationType:%d"</literal></expr></argument>, <argument><expr><name>txn_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>handles</name> <operator>=</operator> <call><name>get_current_handles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* palloc will FATAL when out of memory .*/</comment>
    <expr_stmt><expr><name>connections</name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>TBASE_MAX_DATANODE_NUMBER</name> <operator>+</operator> <name>TBASE_MAX_COORDINATOR_NUMBER</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sync_connections</name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>TBASE_MAX_DATANODE_NUMBER</name> <operator>+</operator> <name>TBASE_MAX_COORDINATOR_NUMBER</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    

    <expr_stmt><expr><call><name>SetSendCommandId</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_remote_abort - dn_conn_count %d, co_conn_count %d"</literal></expr></argument>,
            <argument><expr><name><name>handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr></argument>, <argument><expr><name><name>handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Send Sync if needed. */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Skip empty slots */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>NO_SOCKET</name></expr>)</condition>
        <block>{<block_content>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>!=</operator> <literal type="char">'I'</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Read in any pending input */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition>
            <block>{<block_content>
				<expr_stmt><expr><call><name>BufferConnection</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * If the remote session was running extended query protocol when
             * it failed, it will expect a SYNC message before it accepts any
             * other command
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>needSync</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pgxc_node_send_sync</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
                        <argument><expr><literal type="string">"Failed to send SYNC command"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send SYNC command nodename:%s, pid:%d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Read responses from these */</comment>
                    <expr_stmt><expr><name><name>sync_connections</name><index>[<expr><name>sync_conn_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>EOF</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"send SYNC command to CN nodename %s, backend_pid %d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Skip empty slots */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>NO_SOCKET</name></expr>)</condition>
        <block>{<block_content>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>!=</operator> <literal type="char">'I'</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Send SYNC if the remote session is expecting one */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>needSync</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pgxc_node_send_sync</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
                        <argument><expr><literal type="string">"Failed to send SYNC command nodename"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send SYNC command nodename:%s, pid:%d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Read responses from these */</comment>
                    <expr_stmt><expr><name><name>sync_connections</name><index>[<expr><name>sync_conn_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>EOF</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"send SYNC command to DN nodename %s, backend_pid %d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>sync_conn_count</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>InitResponseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><name>sync_conn_count</name></expr></argument>, <argument><expr><name>COMBINE_TYPE_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Receive responses */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pgxc_node_receive_responses</name><argument_list>(<argument><expr><name>sync_conn_count</name></expr></argument>, <argument><expr><name>sync_connections</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_remote_abort pgxc_node_receive_responses of SYNC failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>EOF</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>validate_combiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_remote_abort validate_combiner responese of SYNC failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>EOF</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>.</operator><name>errorMessage</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send SYNC to on one or more nodes errmsg:%s"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>.</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send SYNC to on one or more nodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>CloseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>        

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name>sync_conn_count</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_is_data_enqueued</name><argument_list>(<argument><expr><name><name>sync_connections</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_remote_abort data left over in fd:%d, remote backendpid:%d"</literal></expr></argument>,
                            <argument><expr><name><name>sync_connections</name><index>[<expr><name>ii</name></expr>]</index></name><operator>-&gt;</operator><name>sock</name></expr></argument>, <argument><expr><name><name>sync_connections</name><index>[<expr><name>ii</name></expr>]</index></name><operator>-&gt;</operator><name>backend_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>TWO_PHASE_ABORTTING</name> <operator>==</operator> <name><name>g_twophase_state</name><operator>.</operator><name>state</name></name> <operator>&amp;&amp;</operator> <name>rollback_implict_txn</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SetLocalTwoPhaseStateHandles</name><argument_list>(<argument><expr><name>handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Skip empty slots */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>NO_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"node %s, conn-&gt;transaction_status %c"</literal></expr></argument>,
                <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>,
                <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>!=</operator> <literal type="char">'I'</literal> <operator>&amp;&amp;</operator> <name>TXN_TYPE_RollbackTxn</name> <operator>==</operator> <name>txn_type</name><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name>rollback_implict_txn</name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>ck_resp_rollback</name></name> <operator>&amp;&amp;</operator> <name>TXN_TYPE_RollbackTxn</name> <operator>==</operator> <name>txn_type</name><operator>)</operator> <operator>||</operator> 
            <operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>!=</operator> <literal type="char">'I'</literal> <operator>&amp;&amp;</operator> <name>TXN_TYPE_RollbackSubTxn</name> <operator>==</operator> <name>txn_type</name> <operator>&amp;&amp;</operator> <call><name>NodeHasBeginSubTxn</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>rollback_implict_txn</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>twophase_index</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>datanode_index</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>handle_idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>is_participant</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name>TWO_PHASE_ABORTTING</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>            
            <comment type="block">/*
             * Do not matter, is there committed or failed transaction,
             * just send down rollback to finish it.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_rollback</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>rollbackCmd</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><name>rollback_implict_txn</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>twophase_index</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>datanode_index</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name>TWO_PHASE_ABORT_ERROR</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> <name>TWO_PHASE_SEND_QUERY_ERROR</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_index</name></name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>EOF</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
                        <argument><expr><literal type="string">"failed to send ROLLBACK TRANSACTION command"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send ROLLBACK TRANSACTION command nodename:%s, pid:%d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>                

            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><name>rollback_implict_txn</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>twophase_index</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>connections_num</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_trans_state_index</name> <operator>=</operator> 
                        <name><name>g_twophase_state</name><operator>.</operator><name>datanode_index</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>node_type</name> <operator>=</operator> 
                        <name>PGXC_NODE_DATANODE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>twophase_index</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>datanode_index</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                        <name>TWO_PHASE_HEALTHY</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_index</name></name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections_num</name></name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/* Read responses from these */</comment>
                <expr_stmt><expr><name><name>connections</name><index>[<expr><name>conn_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>ck_resp_rollback</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>ck_resp_rollback</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Skip empty slots */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>NO_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>        

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>!=</operator> <literal type="char">'I'</literal> <operator>&amp;&amp;</operator> <name>TXN_TYPE_RollbackTxn</name> <operator>==</operator> <name>txn_type</name><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name>rollback_implict_txn</name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>ck_resp_rollback</name></name> <operator>&amp;&amp;</operator> <name>TXN_TYPE_RollbackTxn</name> <operator>==</operator> <name>txn_type</name><operator>)</operator> <operator>||</operator> 
            <operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>!=</operator> <literal type="char">'I'</literal> <operator>&amp;&amp;</operator> <name>TXN_TYPE_RollbackSubTxn</name> <operator>==</operator> <name>txn_type</name> <operator>&amp;&amp;</operator> <call><name>NodeHasBeginSubTxn</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>            
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>rollback_implict_txn</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>twophase_index</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>coord_index</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>handle_idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>is_participant</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> 
                    <name>TWO_PHASE_ABORTTING</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>            
            <comment type="block">/*
             * Do not matter, is there committed or failed transaction,
             * just send down rollback to finish it.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_rollback</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>rollbackCmd</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><name>rollback_implict_txn</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>twophase_index</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>coord_index</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> 
                        <name>TWO_PHASE_ABORT_ERROR</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                        <name>TWO_PHASE_SEND_QUERY_ERROR</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_index</name></name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>EOF</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
                        <argument><expr><literal type="string">"failed to send ROLLBACK TRANSACTION command"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send ROLLBACK TRANSACTION command nodename:%s, pid:%d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>                
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
                <if_stmt><if>if <condition>(<expr><name>rollback_implict_txn</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>twophase_index</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>connections_num</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_trans_state_index</name> <operator>=</operator> 
                        <name><name>g_twophase_state</name><operator>.</operator><name>coord_index</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>node_type</name> <operator>=</operator> 
                        <name>PGXC_NODE_COORDINATOR</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> <name>TWO_PHASE_HEALTHY</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_index</name></name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections_num</name></name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/* Read responses from these */</comment>
                <expr_stmt><expr><name><name>connections</name><index>[<expr><name>conn_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>ck_resp_rollback</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>ck_resp_rollback</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>conn_count</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>InitResponseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>COMBINE_TYPE_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>rollback_implict_txn</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>response_operation</name></name> <operator>=</operator> <name>REMOTE_ABORT</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Receive responses */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pgxc_node_receive_responses</name><argument_list>(<argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>connections</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_remote_abort pgxc_node_receive_responses of ROLLBACK failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>EOF</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>validate_combiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_remote_abort validate_combiner responese of ROLLBACK failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_remote_abort validate_combiner responese of ROLLBACK failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>EOF</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>    

        <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>        
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>.</operator><name>errorMessage</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send ROLLBACK to on one or more nodes errmsg:%s"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>.</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send ROLLBACK to on one or more nodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>CloseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>stat_transaction</name><argument_list>(<argument><expr><name>conn_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name>force_release_handle</name> <operator>=</operator> <call><name>validate_handles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>force_release_handle</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"found bad remote node connections, force release handles now"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>release_handles</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    
    
	<comment type="block">/* do not cleanup remote session for subtrans */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>temp_object_included</name> <operator>&amp;&amp;</operator> <name>need_release_handle</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Clean up remote sessions */</comment>
		<expr_stmt><expr><call><name>pgxc_node_remote_cleanup_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>release_handles</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>clear_handles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>connections</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>connections</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>sync_connections</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sync_connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sync_connections</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Begin COPY command
 * The copy_connections array must have room for NumDataNodes items
 */</comment>
<function><type><name>void</name></type>
<name>DataNodeCopyBegin</name><parameter_list>(<parameter><decl><type><name>RemoteCopyData</name> <modifier>*</modifier></type><name>rcstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodelist</name> <init>= <expr><name><name>rcstate</name><operator>-&gt;</operator><name>rel_loc</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier><modifier>*</modifier></type><name>connections</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>need_tran_block</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GlobalTransactionId</name></type> <name>gxid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResponseCombiner</name></type> <name>combiner</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Snapshot</name></type> <name>snapshot</name> <init>= <expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>conn_count</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CommandId</name></type> <name>cid</name> <init>= <expr><call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Get needed datanode connections */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rcstate</name><operator>-&gt;</operator><name>is_from</name></name> <operator>&amp;&amp;</operator> <call><name>IsLocatorReplicated</name><argument_list>(<argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>rel_loc</name><operator>-&gt;</operator><name>locatorType</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Connections is a single handle to read from */</comment>
        <expr_stmt><expr><name>connections</name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>connections</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>get_any_handle</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>conn_count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>pgxc_handles</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>pgxc_handles</name> <operator>=</operator> <call><name>get_handles</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>connections</name> <operator>=</operator> <name><name>pgxc_handles</name><operator>-&gt;</operator><name>datanode_handles</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name> <operator>==</operator> <name>conn_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pgxc_handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * If more than one nodes are involved or if we are already in a
     * transaction block, we must the remote statements in a transaction block
     */</comment>
    <expr_stmt><expr><name>need_tran_block</name> <operator>=</operator> <operator>(</operator><name>conn_count</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>TransactionBlockStatusCode</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="char">'T'</literal><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"conn_count = %d, need_tran_block = %s"</literal></expr></argument>, <argument><expr><name>conn_count</name></expr></argument>,
            <argument><expr><ternary><condition><expr><name>need_tran_block</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Gather statistics */</comment>
    <expr_stmt><expr><call><name>stat_statement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>stat_transaction</name><argument_list>(<argument><expr><name>conn_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>gxid</name> <operator>=</operator> <call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Start transaction on connections where it is not started */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>pgxc_node_begin</name><argument_list>(<argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>connections</name></expr></argument>, <argument><expr><name>gxid</name></expr></argument>, <argument><expr><name>need_tran_block</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not begin transaction on data nodes."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * COPY TO do not use locator, it just takes connections from it, and
     * we do not look up distribution data type in this case.
     * So always use LOCATOR_TYPE_RROBIN to avoid errors because of not
     * defined partType if real locator type is HASH or MODULO.
     * Create locator before sending down query, because createLocator may
     * fail and we leave with dirty connections.
     * If we get an error now datanode connection will be clean and error
     * handler will issue transaction abort.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
    <expr_stmt><expr><name><name>rcstate</name><operator>-&gt;</operator><name>locator</name></name> <operator>=</operator> <call><name>createLocator</name><argument_list>(
                <argument><expr><ternary><condition><expr><name><name>rcstate</name><operator>-&gt;</operator><name>is_from</name></name></expr> ?</condition><then> <expr><name><name>rcstate</name><operator>-&gt;</operator><name>rel_loc</name><operator>-&gt;</operator><name>locatorType</name></name></expr>
                        </then><else>: <expr><name>LOCATOR_TYPE_RROBIN</name></expr></else></ternary></expr></argument>,
                <argument><expr><ternary><condition><expr><name><name>rcstate</name><operator>-&gt;</operator><name>is_from</name></name></expr> ?</condition><then> <expr><name>RELATION_ACCESS_INSERT</name></expr> </then><else>: <expr><name>RELATION_ACCESS_READ</name></expr></else></ternary></expr></argument>,
                <argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>dist_type</name></name></expr></argument>,
                <argument><expr><name>LOCATOR_LIST_POINTER</name></expr></argument>,
                <argument><expr><name>conn_count</name></expr></argument>,
                <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>connections</name></expr></argument>,
                <argument><expr><name>NULL</name></expr></argument>,
                <argument><expr><name>false</name></expr></argument>,
                <argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>rel_loc</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>, <argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>rel_loc</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>,
                <argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>sec_dist_type</name></name></expr></argument>, <argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>rel_loc</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>,
                <argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>rel_loc</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name><name>rcstate</name><operator>-&gt;</operator><name>locator</name></name> <operator>=</operator> <call><name>createLocator</name><argument_list>(
                <argument><expr><ternary><condition><expr><name><name>rcstate</name><operator>-&gt;</operator><name>is_from</name></name></expr> ?</condition><then> <expr><name><name>rcstate</name><operator>-&gt;</operator><name>rel_loc</name><operator>-&gt;</operator><name>locatorType</name></name></expr>
                        </then><else>: <expr><name>LOCATOR_TYPE_RROBIN</name></expr></else></ternary></expr></argument>,
                <argument><expr><ternary><condition><expr><name><name>rcstate</name><operator>-&gt;</operator><name>is_from</name></name></expr> ?</condition><then> <expr><name>RELATION_ACCESS_INSERT</name></expr> </then><else>: <expr><name>RELATION_ACCESS_READ</name></expr></else></ternary></expr></argument>,
                <argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>dist_type</name></name></expr></argument>,
                <argument><expr><name>LOCATOR_LIST_POINTER</name></expr></argument>,
                <argument><expr><name>conn_count</name></expr></argument>,
                <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>connections</name></expr></argument>,
                <argument><expr><name>NULL</name></expr></argument>,
                <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Send query to nodes */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>conn_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>CHECK_OWNERSHIP</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>snapshot</name> <operator>&amp;&amp;</operator> <call><name>pgxc_node_send_snapshot</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"Can not send request"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>freeLocator</name><argument_list>(<argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rcstate</name><operator>-&gt;</operator><name>locator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_cmd_id</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>cid</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send command ID to Datanodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_query</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>query_buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"Can not send request"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>freeLocator</name><argument_list>(<argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rcstate</name><operator>-&gt;</operator><name>locator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * We are expecting CopyIn response, but do not want to send it to client,
     * caller should take care about this, because here we do not know if
     * client runs console or file copy
     */</comment>
    <expr_stmt><expr><call><name>InitResponseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>COMBINE_TYPE_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * Make sure there are zeroes in unused fields
     */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Receive responses */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_receive_copy_begin</name><argument_list>(<argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>connections</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call>
            <operator>||</operator> <operator>!</operator><call><name>ValidateAndCloseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>DataNodeCopyFinish</name><argument_list>(<argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>freeLocator</name><argument_list>(<argument><expr><name><name>rcstate</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rcstate</name><operator>-&gt;</operator><name>locator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Send a data row to the specified nodes
 */</comment>
<function><type><name>int</name></type>
<name>DataNodeCopyIn</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data_row</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
        <parameter><decl><type><name>int</name></type> <name>conn_count</name></decl></parameter>, <parameter><decl><type><name>PGXCNodeHandle</name><modifier>*</modifier><modifier>*</modifier></type> <name>copy_connections</name></decl></parameter>,
        <parameter><decl><type><name>bool</name></type> <name>binary</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* size + data row + \n in CSV mode */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>msgLen</name> <init>= <expr><literal type="number">4</literal> <operator>+</operator> <name>len</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>binary</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nLen</name> <init>= <expr><call><name>htonl</name><argument_list>(<argument><expr><name>msgLen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>conn_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name><name>copy_connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DN_CONNECTION_STATE_COPY_IN</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* precalculate to speed up access */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>bytes_needed</name> <init>= <expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msgLen</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* flush buffer if it is almost full */</comment>
            <if_stmt><if>if <condition>(<expr><name>bytes_needed</name> <operator>&gt;</operator> <name>COPY_BUFFER_SIZE</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>to_send</name> <init>= <expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* First look if data node has sent a error message */</comment>
                <decl_stmt><decl><type><name>int</name></type> <name>read_status</name> <init>= <expr><call><name>pgxc_node_read_data</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>read_status</name> <operator>==</operator> <name>EOF</name> <operator>||</operator> <name>read_status</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"failed to read data from data node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>EOF</name></expr>;</return>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>inStart</name></name> <operator>&lt;</operator> <name><name>handle</name><operator>-&gt;</operator><name>inEnd</name></name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ResponseCombiner</name></type> <name>combiner</name></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>InitResponseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>COMBINE_TYPE_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/*
                     * Make sure there are zeroes in unused fields
                     */</comment>
                    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * Validate the combiner but only if we see a proper
                     * resposne for our COPY message. The problem is that
                     * sometimes we might receive async messages such as
                     * 'M' which is used to send back command ID generated and
                     * consumed by the datanode. While the message gets handled
                     * in handle_response(), we don't want to declare receipt
                     * of an invalid message below.
                     *
                     * If there is an actual error of some sort then the
                     * connection state is will be set appropriately and we
                     * shall catch that subsequently.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>handle_response</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RESPONSE_COPY</name> <operator>&amp;&amp;</operator>
                        <operator>!</operator><call><name>ValidateAndCloseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>DN_CONNECTION_STATE_ERROR</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * Try to send down buffered data if we have
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>to_send</name> <operator>&amp;&amp;</operator> <call><name>send_some</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>to_send</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"failed to send data to data node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>EOF</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name>bytes_needed</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'d'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name>data_row</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>binary</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>in_extended_query</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"Invalid data node connection"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>EOF</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint64</name></type>
<name>DataNodeCopyOut</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name><modifier>*</modifier><modifier>*</modifier></type> <name>copy_connections</name></decl></parameter>,
                              <parameter><decl><type><name>int</name></type> <name>conn_count</name></decl></parameter>, <parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>copy_file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ResponseCombiner</name></type> <name>combiner</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>processed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>         <name>error</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>InitResponseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>COMBINE_TYPE_SUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * Make sure there are zeroes in unused fields
     */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>.</operator><name>processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <comment type="block">/* If there is an existing file where to copy data, pass it to combiner */</comment>
    <if_stmt><if>if <condition>(<expr><name>copy_file</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>combiner</name><operator>.</operator><name>copy_file</name></name> <operator>=</operator> <name>copy_file</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>.</operator><name>remoteCopyType</name></name> <operator>=</operator> <name>REMOTE_COPY_FILE</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>combiner</name><operator>.</operator><name>copy_file</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>.</operator><name>remoteCopyType</name></name> <operator>=</operator> <name>REMOTE_COPY_STDOUT</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>error</name> <operator>=</operator> <operator>(</operator><call><name>pgxc_node_receive_responses</name><argument_list>(<argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>copy_connections</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>processed</name> <operator>=</operator> <name><name>combiner</name><operator>.</operator><name>processed</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ValidateAndCloseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>error</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unexpected response from the data nodes when combining, request type %d"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>.</operator><name>request_type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>processed</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>uint64</name></type>
<name>DataNodeCopyStore</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name><modifier>*</modifier><modifier>*</modifier></type> <name>copy_connections</name></decl></parameter>,
                                <parameter><decl><type><name>int</name></type> <name>conn_count</name></decl></parameter>, <parameter><decl><type><name>Tuplestorestate</name><modifier>*</modifier></type> <name>store</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ResponseCombiner</name></type> <name>combiner</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type>        <name>processed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>         <name>error</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>InitResponseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>COMBINE_TYPE_SUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * Make sure there are zeroes in unused fields
     */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>.</operator><name>processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>.</operator><name>remoteCopyType</name></name> <operator>=</operator> <name>REMOTE_COPY_TUPLESTORE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>.</operator><name>tuplestorestate</name></name> <operator>=</operator> <name>store</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>error</name> <operator>=</operator> <operator>(</operator><call><name>pgxc_node_receive_responses</name><argument_list>(<argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>copy_connections</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>processed</name> <operator>=</operator> <name><name>combiner</name><operator>.</operator><name>processed</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ValidateAndCloseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>error</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unexpected response from the data nodes when combining, request type %d"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>.</operator><name>request_type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>processed</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Finish copy process on all connections
 */</comment>
<function><type><name>void</name></type>
<name>DataNodeCopyFinish</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>conn_count</name></decl></parameter>, <parameter><decl><type><name>PGXCNodeHandle</name><modifier>*</modifier><modifier>*</modifier></type> <name>connections</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>        <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResponseCombiner</name></type> <name>combiner</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>         <name>error</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>conn_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DN_CONNECTION_STATE_COPY_IN</name> <operator>||</operator> <name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DN_CONNECTION_STATE_COPY_OUT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>DataNodeCopyEnd</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    
    <comment type="block">/*
     * Make sure there are zeroes in unused fields
     */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>InitResponseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>COMBINE_TYPE_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>error</name> <operator>=</operator> <operator>(</operator><call><name>pgxc_node_receive_responses</name><argument_list>(<argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>connections</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <name>error</name></expr>;</expr_stmt>    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>validate_combiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>error</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>.</operator><name>errorMessage</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pgxc_node_report_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Error while running COPY"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>CloseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * End copy process on a connection
 */</comment>
<function><type><name>bool</name></type>
<name>DataNodeCopyEnd</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>         <name>nLen</name> <init>= <expr><call><name>htonl</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>handle</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* msgType + msgLen */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>is_error</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'c'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>in_extended_query</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <comment type="block">/* We need response right away, so send immediately */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_flush</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
 * Get Node connections of all Datanodes
 */</comment>
<function><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type>
<name>get_exec_connections_all_dn</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>is_global_session</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>pgxc_handles_connections</name> <init>= <expr><call><name>get_exec_connections</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>EXEC_ON_DATANODES</name></expr></argument>, <argument><expr><name>is_global_session</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><name>pgxc_handles_connections</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Get Node connections depending on the connection type:
 * Datanodes Only, Coordinators only or both types
 * If exec_nodes is NIL and exec_type is EXEC_ON_ALL_NODES
 * connect to all nodes except myself
 */</comment>
<function><type><specifier>static</specifier> <name>PGXCNodeAllHandles</name> <modifier>*</modifier></type>
<name>get_exec_connections</name><parameter_list>(<parameter><decl><type><name>RemoteQueryState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>,
                     <parameter><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>exec_nodes</name></decl></parameter>,
                     <parameter><decl><type><name>RemoteQueryExecType</name></type> <name>exec_type</name></decl></parameter>,
                     <parameter><decl><type><name>bool</name></type> <name>is_global_session</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>        <modifier>*</modifier></type><name>nodelist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>List</name>        <modifier>*</modifier></type><name>temp_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>List</name>        <modifier>*</modifier></type><name>primarynode</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>coordlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>primaryconnection</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>co_conn_count</name></decl>, <decl><type ref="prev"/><name>dn_conn_count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_query_coord_only</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>pgxc_handles</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>missing_ok</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>exec_nodes</name></expr> ?</condition><then> <expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>missing_ok</name></name></expr> </then><else>: <expr><name>false</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>EXEC_ON_CURRENT</name> <operator>!=</operator> <name>exec_type</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>exec_nodes</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"In parallel worker, exec_nodes can't be NULL!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <if_stmt><if>if <condition>(<expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>accesstype</name></name> <operator>!=</operator> <name>RELATION_ACCESS_READ</name> <operator>&amp;&amp;</operator> <name><name>exec_nodes</name><operator>-&gt;</operator><name>accesstype</name></name> <operator>!=</operator> <name>RELATION_ACCESS_READ_FQS</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Only read access can run in parallel worker!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>exec_type</name> <operator>!=</operator> <name>EXEC_ON_DATANODES</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Parallel worker can only run query on datanodes!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If query is launched only on Coordinators, we have to inform get_handles
     * not to ask for Datanode connections even if list of Datanodes is NIL.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>exec_type</name> <operator>==</operator> <name>EXEC_ON_COORDS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>is_query_coord_only</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>exec_type</name> <operator>==</operator> <name>EXEC_ON_CURRENT</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>get_current_handles</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>exec_nodes</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>en_expr</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* execution time determining of target Datanodes */</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>nodes</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type> <name>partvalue</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
            <decl_stmt><decl><type><name>bool</name></type> <name>secisnull</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type> <name>secValue</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rel_loc_info</name></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>rewrite_done</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>partvalue</name> <operator>=</operator> <name><name>exec_nodes</name><operator>-&gt;</operator><name>rewrite_value</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>isnull</name> <operator>=</operator> <name><name>exec_nodes</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>en_expr</name></name></expr></argument>,
                                             <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			    <comment type="block">/* For explain, no need to execute expr. */</comment>
			    <if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>eflags</name></name> <operator>!=</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name></expr>)</condition><block type="pseudo"><block_content>
			    	<expr_stmt><expr><name>partvalue</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
                                           <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>combiner</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></argument>,
                                           <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
			
			<expr_stmt><expr><name>rel_loc_info</name> <operator>=</operator> <call><name>GetRelationLocInfo</name><argument_list>(<argument><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>en_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>sec_en_expr</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>sec_en_expr</name></name></expr></argument>,
                                             <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* For explain, no need to execute expr. */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>eflags</name></name> <operator>!=</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>secValue</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
                                        <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>combiner</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>secisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>secisnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>secValue</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>eflags</name></name> <operator>==</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>GetRelationNodesForExplain</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>,
												   <argument><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>accesstype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
            <comment type="block">/* PGXCTODO what is the type of partvalue here */</comment>
            <expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>GetRelationNodes</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>,
                                     <argument><expr><name>partvalue</name></expr></argument>,
                                     <argument><expr><name>isnull</name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                                     <argument><expr><name>secValue</name></expr></argument>,
                                     <argument><expr><name>secisnull</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                     <argument><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>accesstype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <comment type="block">/*
             * en_expr is set by pgxc_set_en_expr only for distributed
             * relations while planning DMLs, hence a select for update
             * on a replicated table here is an assertion
             */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>exec_nodes</name><operator>-&gt;</operator><name>accesstype</name></name> <operator>==</operator> <name>RELATION_ACCESS_READ_FOR_UPDATE</name> <operator>&amp;&amp;</operator>
                        <call><name>IsRelationReplicated</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>nodes</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>nodelist</name> <operator>=</operator> <name><name>nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>primarynode</name> <operator>=</operator> <name><name>nodes</name><operator>-&gt;</operator><name>primarynodelist</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>FreeRelationLocInfo</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>en_relid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rel_loc_info</name> <init>= <expr><call><name>GetRelationLocInfo</name><argument_list>(<argument><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>en_relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
            <decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>nodes</name> <init>= <expr><call><name>GetRelationNodes</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>accesstype</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>nodes</name> <init>= <expr><call><name>GetRelationNodes</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>accesstype</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/*
             * en_relid is set only for DMLs, hence a select for update on a
             * replicated table here is an assertion
             */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>exec_nodes</name><operator>-&gt;</operator><name>accesstype</name></name> <operator>==</operator> <name>RELATION_ACCESS_READ_FOR_UPDATE</name> <operator>&amp;&amp;</operator>
                        <call><name>IsRelationReplicated</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Use the obtained list for given table */</comment>
            <if_stmt><if>if <condition>(<expr><name>nodes</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>nodelist</name> <operator>=</operator> <name><name>nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Special handling for ROUND ROBIN distributed tables. The target
             * node must be determined at the execution time
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_RROBIN</name> <operator>&amp;&amp;</operator> <name>nodes</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>nodelist</name> <operator>=</operator> <name><name>nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>primarynode</name> <operator>=</operator> <name><name>nodes</name><operator>-&gt;</operator><name>primarynodelist</name></name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>nodes</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>exec_type</name> <operator>==</operator> <name>EXEC_ON_DATANODES</name> <operator>||</operator> <name>exec_type</name> <operator>==</operator> <name>EXEC_ON_ALL_NODES</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>nodelist</name> <operator>=</operator> <name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>primarynode</name> <operator>=</operator> <name><name>exec_nodes</name><operator>-&gt;</operator><name>primarynodelist</name></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>nodes</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>FreeRelationLocInfo</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>exec_type</name> <operator>==</operator> <name>EXEC_ON_DATANODES</name> <operator>||</operator> <name>exec_type</name> <operator>==</operator> <name>EXEC_ON_ALL_NODES</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>nodelist</name> <operator>=</operator> <name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>exec_type</name> <operator>==</operator> <name>EXEC_ON_COORDS</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>coordlist</name> <operator>=</operator> <name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>primarynode</name> <operator>=</operator> <name><name>exec_nodes</name><operator>-&gt;</operator><name>primarynodelist</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Set node list and DN number */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>exec_type</name> <operator>==</operator> <name>EXEC_ON_ALL_NODES</name> <operator>||</operator>
         <name>exec_type</name> <operator>==</operator> <name>EXEC_ON_DATANODES</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Primary connection is included in this number of connections if it exists */</comment>
        <expr_stmt><expr><name>dn_conn_count</name> <operator>=</operator> <name>NumDataNodes</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>exec_type</name> <operator>==</operator> <name>EXEC_ON_DATANODES</name> <operator>||</operator> <name>exec_type</name> <operator>==</operator> <name>EXEC_ON_ALL_NODES</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>primarynode</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>dn_conn_count</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>dn_conn_count</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>dn_conn_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Set Coordinator list and Coordinator number */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>exec_type</name> <operator>==</operator> <name>EXEC_ON_ALL_NODES</name><operator>)</operator> <operator>||</operator>
        <operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name>coordlist</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>exec_type</name> <operator>==</operator> <name>EXEC_ON_COORDS</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>coordlist</name> <operator>=</operator> <call><name>GetAllCoordNodes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>co_conn_count</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>coordlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>exec_type</name> <operator>==</operator> <name>EXEC_ON_COORDS</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>co_conn_count</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>coordlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>co_conn_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    
	<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>exec_type</name> <operator>==</operator> <name>EXEC_ON_ALL_NODES</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nodelist</name> <operator>=</operator> <call><name>GetAllDataNodes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dn_conn_count</name> <operator>=</operator> <name>NumDataNodes</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int32</name></type>   <name>i</name>          <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>   <name>worker_num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>    <name>length</name>       <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    
        <decl_stmt><decl><type><name>int32</name></type>   <name>step</name>        <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>   <name>begin_node</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type>   <name>end_node</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ParallelWorkerStatus</name> <modifier>*</modifier></type><name>parallel_status</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name>             <modifier>*</modifier></type><name>node_list_item</name>    <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>parallel_status</name> <operator>=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>parallel_status</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>temp_list</name>       <operator>=</operator> <name>nodelist</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nodelist</name>        <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>worker_num</name> <operator>=</operator> <call><name>ExecGetForWorkerNumber</name><argument_list>(<argument><expr><name>parallel_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>temp_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>worker_num</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>DIVIDE_UP</name><argument_list>(<argument><expr><name>length</name></expr></argument>, <argument><expr><name>worker_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* Last worker. */</comment>
        <if_stmt><if>if <condition>(<expr><name>ParallelWorkerNumber</name> <operator>==</operator> <operator>(</operator><name>worker_num</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>begin_node</name> <operator>=</operator> <name>ParallelWorkerNumber</name> <operator>*</operator> <name>step</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>end_node</name>   <operator>=</operator> <name>length</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>begin_node</name> <operator>=</operator> <name>ParallelWorkerNumber</name> <operator>*</operator> <name>step</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>end_node</name>   <operator>=</operator> <name>begin_node</name> <operator>+</operator> <name>step</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Form the execNodes of our own node. */</comment>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>node_list_item</argument>, <argument>temp_list</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>    <name>node</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>node_list_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>begin_node</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>end_node</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>nodelist</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>end_node</name></expr>)</condition>
            <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>temp_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name>nodelist</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>dn_conn_count</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>coordlist</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Parallel worker can not run query on coordinator!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>        
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Get other connections (non-primary) */</comment>
	<expr_stmt><expr><name>pgxc_handles</name> <operator>=</operator> <call><name>get_handles</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>, <argument><expr><name>coordlist</name></expr></argument>, <argument><expr><name>is_query_coord_only</name></expr></argument>, <argument><expr><name>is_global_session</name></expr></argument>, <argument><expr><operator>!</operator><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pgxc_handles</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not obtain connection from pool"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Get connection for primary node, if used */</comment>
    <if_stmt><if>if <condition>(<expr><name>primarynode</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Let's assume primary connection is always a Datanode connection for the moment */</comment>
        <decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>pgxc_conn_res</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>pgxc_conn_res</name> <operator>=</operator> <call><name>get_handles</name><argument_list>(<argument><expr><name>primarynode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>is_global_session</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* primary connection is unique */</comment>
        <expr_stmt><expr><name>primaryconnection</name> <operator>=</operator> <name><name>pgxc_conn_res</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pgxc_conn_res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>primaryconnection</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not obtain connection from pool"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>primary_handle</name></name> <operator>=</operator> <name>primaryconnection</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>missing_ok</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* compact handle list exclude missing nodes */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<while>while <condition>(<expr><name>dn_conn_count</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>dn_conn_count</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>DN_CONNECTION_STATE_ERROR</name><argument_list>(<argument><expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* find last healthy handle */</comment>
				<while>while <condition>(<expr><name>dn_conn_count</name> <operator>-</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>i</name> <operator>&amp;&amp;</operator>
				       <call><name>DN_CONNECTION_STATE_ERROR</name><argument_list>(<argument><expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>dn_conn_count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>dn_conn_count</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
				
				<comment type="block">/* replace bad handle with last healthy handle */</comment>
				<expr_stmt><expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
					<name><name>pgxc_handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>dn_conn_count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<comment type="block">/* exclude bad handle */</comment>
				<expr_stmt><expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>dn_conn_count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>dn_conn_count</name><operator>--</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		
		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>co_conn_count</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>co_conn_count</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>DN_CONNECTION_STATE_ERROR</name><argument_list>(<argument><expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* find last healthy handle */</comment>
				<while>while <condition>(<expr><name>co_conn_count</name> <operator>-</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>i</name> <operator>&amp;&amp;</operator>
				       <call><name>DN_CONNECTION_STATE_ERROR</name><argument_list>(<argument><expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>co_conn_count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>co_conn_count</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
				
				<comment type="block">/* replace bad handle with last healthy handle */</comment>
				<expr_stmt><expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
					<name><name>pgxc_handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>co_conn_count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<comment type="block">/* exclude bad handle */</comment>
				<expr_stmt><expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>co_conn_count</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>co_conn_count</name><operator>--</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>
	
    <comment type="block">/* Depending on the execution type, we still need to save the initial node counts */</comment>
    <expr_stmt><expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name> <operator>=</operator> <name>dn_conn_count</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>co_conn_count</name></name> <operator>=</operator> <name>co_conn_count</name></expr>;</expr_stmt>

    <return>return <expr><name>pgxc_handles</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgxc_start_command_on_connection</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>connection</name></decl></parameter>,
                                    <parameter><decl><type><name>RemoteQueryState</name> <modifier>*</modifier></type><name>remotestate</name></decl></parameter>,
                                    <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CommandId</name></type>    <name>cid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name> <init>= <expr><operator>(</operator><name>ResponseCombiner</name> <operator>*</operator><operator>)</operator> <name>remotestate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQuery</name>    <modifier>*</modifier></type><name>step</name> <init>= <expr><operator>(</operator><name>RemoteQuery</name> <operator>*</operator><operator>)</operator> <name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>CHECK_OWNERSHIP</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"pgxc_start_command_on_connection - node %s, state %d"</literal></expr></argument>,
            <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Scan descriptor would be valid and would contain a valid snapshot
     * in cases when we need to send out of order command id to data node
     * e.g. in case of a fetch
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>snapshot</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>cid</name> <operator>=</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>curcid</name></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>cid</name> <operator>==</operator> <name>InvalidCommandId</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"commandId in snapshot is invalid."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cid</name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>cid</name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>cid</name> <operator>=</operator> <call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_cmd_id</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>cid</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>snapshot</name> <operator>&amp;&amp;</operator> <call><name>pgxc_node_send_snapshot</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>step</name><operator>-&gt;</operator><name>statement</name></name> <operator>&amp;&amp;</operator> <name><name>step</name><operator>-&gt;</operator><name>statement</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator> <operator>||</operator>
		<name><name>step</name><operator>-&gt;</operator><name>cursor</name></name> <operator>||</operator>
		<name><name>remotestate</name><operator>-&gt;</operator><name>rqs_num_params</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* need to use Extended Query Protocol */</comment>
        <decl_stmt><decl><type><name>int</name></type>    <name>fetch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>    <name>prepared</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>    <name>nodetype</name> <init>= <expr><name>PGXC_NODE_DATANODE</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>exec_nodes</name> <init>= <expr><name><name>step</name><operator>-&gt;</operator><name>exec_nodes</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* if prepared statement is referenced see if it is already
         * exist */</comment>
		<if_stmt><if>if <condition>(<expr><name>exec_nodes</name> <operator>&amp;&amp;</operator> <name><name>exec_nodes</name><operator>-&gt;</operator><name>need_rewrite</name></name> <operator>==</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>prepared</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>statement</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>prepared</name> <operator>=</operator>
                <call><name>ActivateDatanodeStatementOnNode</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>statement</name></name></expr></argument>,
                        <argument><expr><call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name><name>connection</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>nodetype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>prepared</name> <operator>&amp;&amp;</operator> <name>exec_nodes</name> <operator>&amp;&amp;</operator> <name><name>exec_nodes</name><operator>-&gt;</operator><name>need_rewrite</name></name> <operator>==</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>prepared</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * execute and fetch rows only if they will be consumed
         * immediately by the sorter
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>cursor</name></name></expr>)</condition>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <block>{<block_content>
            <comment type="block">/* we need all rows one time */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>dml_on_coordinator</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>fetch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>fetch</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><name>fetch</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>extended_query</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_query_extended</name><argument_list>(<argument><expr><name>connection</name></expr></argument>,
                            <argument><expr><ternary><condition><expr><name>prepared</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name><name>step</name><operator>-&gt;</operator><name>sql_statement</name></name></expr></else></ternary></expr></argument>,
                            <argument><expr><name><name>step</name><operator>-&gt;</operator><name>statement</name></name></expr></argument>,
                            <argument><expr><name><name>step</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>,
                            <argument><expr><name><name>remotestate</name><operator>-&gt;</operator><name>rqs_num_params</name></name></expr></argument>,
                            <argument><expr><name><name>remotestate</name><operator>-&gt;</operator><name>rqs_param_types</name></name></expr></argument>,
                            <argument><expr><name><name>remotestate</name><operator>-&gt;</operator><name>paramval_len</name></name></expr></argument>,
                            <argument><expr><name><name>remotestate</name><operator>-&gt;</operator><name>paramval_data</name></name></expr></argument>,
                            <argument><expr><ternary><condition><expr><name><name>step</name><operator>-&gt;</operator><name>has_row_marks</name></name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name><name>step</name><operator>-&gt;</operator><name>read_only</name></name></expr></else></ternary></expr></argument>,
                            <argument><expr><name>fetch</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>extended_query</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_query</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>sql_statement</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get snapshot and gxid for remote utility.
 */</comment>
<function><type><name>void</name></type>
<name>GetGlobInfoForRemoteUtility</name><parameter_list>(<parameter><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>GlobalTransactionId</name> <modifier>*</modifier></type><name>gxid</name></decl></parameter>,
							<parameter><decl><type><name>Snapshot</name> <modifier>*</modifier></type><name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>                <name>utility_need_transcation</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<comment type="block">/* Some DDL such as ROLLBACK, SET does not need transaction */</comment>
	<expr_stmt><expr><name>utility_need_transcation</name> <operator>=</operator>
			<operator>(</operator><operator>!</operator><call><name>ExecDDLWithoutAcquireXid</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>parsetree</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>is_set</name></name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>utility_need_transcation</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>		
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[SAVEPOINT] node-&gt;sql_statement:%s"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sql_statement</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>gxid</name> <operator>=</operator> <call><name>GetCurrentTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><call><name>ActiveSnapshotSet</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>snapshot</name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>	
	<if_stmt><if>if <condition>(<expr><name>utility_need_transcation</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GlobalTransactionIdIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>gxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to get next transaction ID"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* 
		 * Distributed DDLs only dispatch from the requested coordinator, thus
		 * we skip sending gxid to avoid cycling.
		 *
		 * Note: except for 'set_config_option'.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>gxid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Send snapshot/cmdid/query to remote node.
 */</comment>
<function><type><name>void</name></type>
<name>SendTxnInfo</name><parameter_list>(<parameter><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
			<parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DN_CONNECTION_STATE_QUERY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>BufferConnection</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>snapshot</name> <operator>&amp;&amp;</operator> <call><name>pgxc_node_send_snapshot</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send snapshot to %s"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_cmd_id</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>cid</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send command ID to %s"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_query</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sql_statement</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send command to %s"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check response of remote connection.
 */</comment>
<function><type><name>bool</name></type>
<name>CheckRemoteRespond</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>,
					<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>index</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>conn_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>handle_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_EOF</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>index</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_COMPLETE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Ignore, wait for ReadyForQuery */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unexpected FATAL ERROR on Connection to "</literal>
							<literal type="string">"Datanode %s pid %d"</literal></expr></argument>,
						<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_ERROR</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Ignore, wait for ReadyForQuery */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_READY</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>index</name><operator>)</operator> <operator>&lt;</operator> <operator>--</operator><operator>(</operator><operator>*</operator><name>conn_count</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_TUPDESC</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unexpected response from %s pid %d"</literal></expr></argument>,
						<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_DATAROW</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unexpected response from %s pid %d"</literal></expr></argument>,
						<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Receive remote response and chek receive status.
 */</comment>
<function><type><name>void</name></type> <name>RemoteReceiveAndCheck</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>conn_count</name></decl></parameter>, <parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier><modifier>*</modifier></type><name>conns</name></decl></parameter>,
							<parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
     * Stop if all commands are completed or we got a data row and
     * initialized state node for subsequent invocations
     */</comment>
    <while>while <condition>(<expr><name>conn_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>		<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>	<name>remote_ready</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Wait until one of the connections has data available */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_receive</name><argument_list>(<argument><expr><name>conn_count</name></expr></argument>,
                              <argument><expr><name>conns</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Got error
             * TODO(Tbase): How do we check the error here?
             */</comment>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>conn_count</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>remote_ready</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>conns</name><index>[<expr><name>conn_count</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>conns</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>remote_ready</name> <operator>=</operator> <call><name>CheckRemoteRespond</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>combiner</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>conn_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></while>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
 * Send ddl to leader cn, the function only be invoked
 * in parallel ddl mode.
 */</comment>
<function><type><name>void</name></type>
<name>LeaderCnExecRemoteUtility</name><parameter_list>(<parameter><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
								<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>leader_cn_conn</name></decl></parameter>,
								<parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>need_tran_block</name></decl></parameter>,
								<parameter><decl><type><name>GlobalTransactionId</name></type> <name>gxid</name></decl></parameter>,
								<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
								<parameter><decl><type><name>CommandId</name></type> <name>cid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>cn_cout</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>init_str</name> <init>= <expr><call><name>PGXCNodeGetSessionParamStr</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>init_str</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pgxc_node_set_query</name><argument_list>(<argument><expr><name>leader_cn_conn</name></expr></argument>, <argument><expr><name>init_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><call><name>SetPlpgsqlTransactionBegin</name><argument_list>(<argument><expr><name>leader_cn_conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pgxc_node_begin</name><argument_list>(<argument><expr><name>cn_cout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leader_cn_conn</name></expr></argument>, <argument><expr><name>gxid</name></expr></argument>,
						<argument><expr><name>need_tran_block</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not begin transaction on leader coordinator"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Send other txn related messages to leader cn */</comment>
	<expr_stmt><expr><call><name>SendTxnInfo</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>leader_cn_conn</name></expr></argument>, <argument><expr><name>cid</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RemoteReceiveAndCheck</name><argument_list>(<argument><expr><name>cn_cout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leader_cn_conn</name></expr></argument>, <argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Execute utility statement on multiple Datanodes
 * It does approximately the same as
 *
 * RemoteQueryState *state = ExecInitRemoteQuery(plan, estate, flags);
 * Assert(TupIsNull(ExecRemoteQuery(state));
 * ExecEndRemoteQuery(state)
 *
 * But does not need an Estate instance and does not do some unnecessary work,
 * like allocating tuple slots.
 */</comment>
<function><type><name>void</name></type>
<name>ExecRemoteUtility</name><parameter_list>(<parameter><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>leader_cn_conn</name></decl></parameter>, <parameter><decl><type><name>ParallelDDLRemoteType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
ExecRemoteUtility<parameter_list>(<parameter><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
    <decl_stmt><decl><type><name>RemoteQueryState</name> <modifier>*</modifier></type><name>remotestate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>              <name>force_autocommit</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>force_autocommit</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQueryExecType</name></type> <name>exec_type</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>exec_type</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GlobalTransactionId</name></type> <name>gxid</name> <init>= <expr><name>InvalidGlobalTransactionId</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Snapshot</name></type> <name>snapshot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>pgxc_connections</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>					<name>co_conn_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>					<name>dn_conn_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>need_tran_block</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExecDirectType</name></type>        <name>exec_direct_type</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>exec_direct_type</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CommandId</name></type>    <name>cid</name> <init>= <expr><call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>    

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>force_autocommit</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>RegisterTransactionLocalNode</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>remotestate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteQueryState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>combiner</name> <operator>=</operator> <operator>(</operator><name>ResponseCombiner</name> <operator>*</operator><operator>)</operator><name>remotestate</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>InitResponseCombiner</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>combine_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Do not set global_session if it is a utility statement. 
     * Avoids CREATE NODE error on cluster configuration.
     */</comment>
    <expr_stmt><expr><name>pgxc_connections</name> <operator>=</operator> <call><name>get_exec_connections</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>exec_nodes</name></name></expr></argument>, <argument><expr><name>exec_type</name></expr></argument>, 
                                            <argument><expr><name>exec_direct_type</name> <operator>!=</operator> <name>EXEC_DIRECT_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>EXCLUED_LEADER_DDL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>delete_leadercn_handle</name><argument_list>(<argument><expr><name>pgxc_connections</name></expr></argument>, <argument><expr><name>leader_cn_conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>dn_conn_count</name> <operator>=</operator> <name><name>pgxc_connections</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>co_conn_count</name> <operator>=</operator> <name><name>pgxc_connections</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</expr_stmt>

    <comment type="block">/* exit right away if no nodes to run command on */</comment>
    <if_stmt><if>if <condition>(<expr><name>dn_conn_count</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>co_conn_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>pgxc_connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>force_autocommit</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>need_tran_block</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>need_tran_block</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
	 * Commands launched through EXECUTE DIRECT do not need start a
	 * transaction
	 */</comment>
    <if_stmt><if>if <condition>(<expr><name>exec_direct_type</name> <operator>==</operator> <name>EXEC_DIRECT_UTILITY</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>need_tran_block</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <comment type="block">/* This check is not done when analyzing to limit dependencies */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ACTIVE_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot run EXECUTE DIRECT with utility inside a "</literal>
							<literal type="string">"transaction block"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>GetGlobInfoForRemoteUtility</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gxid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>    
	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>ONLY_LEADER_DDL</name></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>LeaderCnExecRemoteUtility</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>leader_cn_conn</name></expr></argument>, <argument><expr><name>combiner</name></expr></argument>,
									<argument><expr><name>need_tran_block</name></expr></argument>, <argument><expr><name>gxid</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>cid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>pgxc_connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgxc_node_report_error</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
    </block_content>}</block></if>
	<else>else
    <block>{<block_content>
        <comment type="block">/* Set node begin transaction in plpgsql function for CN/DN */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dn_conn_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>SetPlpgsqlTransactionBegin</name><argument_list>(<argument><expr><name><name>pgxc_connections</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>  
        
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>co_conn_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>SetPlpgsqlTransactionBegin</name><argument_list>(<argument><expr><name><name>pgxc_connections</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>     
	</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

    <comment type="block">/*
	 * DDL will firstly be executed on coordinators then datanodes
	 * which will avoid deadlocks in cluster.
	 * Let us assume that user sql and ddl hold conflict locks,
	 * then there will be two situations:
	 * 1. The coordinator is not locked, user sql will see datanodes with no lock.
	 * 2. The coordinator is locked, user sql will wait for ddl to complete.
     *
     * Send BEGIN control command to all coordinator nodes
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_begin</name><argument_list>(<argument><expr><name>co_conn_count</name></expr></argument>,
                        <argument><expr><name><name>pgxc_connections</name><operator>-&gt;</operator><name>coord_handles</name></name></expr></argument>,
                        <argument><expr><name>gxid</name></expr></argument>,
                        <argument><expr><name>need_tran_block</name></expr></argument>,
                        <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not begin transaction on coordinators"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Send other txn related messages to coordinator nodes */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>co_conn_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>pgxc_connections</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SendTxnInfo</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>cid</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Stop if all commands are completed or we got a data row and
     * initialized state node for subsequent invocations
     */</comment>
	<expr_stmt><expr><call><name>RemoteReceiveAndCheck</name><argument_list>(<argument><expr><name>co_conn_count</name></expr></argument>, 
                              <argument><expr><name><name>pgxc_connections</name><operator>-&gt;</operator><name>coord_handles</name></name></expr></argument>,
							<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>LOCAL_PARALLEL_DDL</name> <operator>&amp;&amp;</operator> <name>combiner</name> <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr>)</condition>
            <block>{<block_content>
		<expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>pgxc_connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgxc_node_report_error</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Send BEGIN control command to all data nodes
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pgxc_node_begin</name><argument_list>(<argument><expr><name>dn_conn_count</name></expr></argument>,
						<argument><expr><name><name>pgxc_connections</name><operator>-&gt;</operator><name>datanode_handles</name></name></expr></argument>,
						<argument><expr><name>gxid</name></expr></argument>,
						<argument><expr><name>need_tran_block</name></expr></argument>,
						<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>	
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not begin transaction on Datanodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Send other txn related messages to data nodes */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dn_conn_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>pgxc_connections</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>SendTxnInfo</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>cid</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>RemoteReceiveAndCheck</name><argument_list>(<argument><expr><name>dn_conn_count</name></expr></argument>, 
							  <argument><expr><name><name>pgxc_connections</name><operator>-&gt;</operator><name>datanode_handles</name></name></expr></argument>,
							<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We have processed all responses from nodes and if we have error message
	 * pending we can report it. All connections should be in consistent state
	 * now and so they can be released to the pool after ROLLBACK.
	 */</comment>
	<expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>pgxc_connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgxc_node_report_error</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Called when the backend is ending.
 */</comment>
<function><type><name>void</name></type>
<name>PGXCNodeCleanAndRelease</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>

    <comment type="block">/* Disconnect from Pooler, if any connection is still held Pooler close it */</comment>
    <expr_stmt><expr><call><name>PoolManagerDisconnect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Close connection with GTM */</comment>
    <expr_stmt><expr><call><name>CloseGTM</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Dump collected statistics to the log */</comment>
    <expr_stmt><expr><call><name>stat_log</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecCloseRemoteStatementInternal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nodelist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>all_handles</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeHandle</name>      <modifier>*</modifier><modifier>*</modifier></type><name>connections</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResponseCombiner</name></type>    <name>combiner</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                    <name>conn_count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                 <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Exit if nodelist is empty */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* get needed Datanode connections */</comment>
	<expr_stmt><expr><name>all_handles</name> <operator>=</operator> <call><name>get_handles</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>conn_count</name> <operator>=</operator> <name><name>all_handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>connections</name> <operator>=</operator> <name><name>all_handles</name><operator>-&gt;</operator><name>datanode_handles</name></name></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>conn_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>state</name> <operator>==</operator> <name>DN_CONNECTION_STATE_QUERY</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>BufferConnection</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_close</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>stmt_name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * statements are not affected by statement end, so consider
             * unclosed statement on the Datanode as a fatal issue and
             * force connection is discarded
             */</comment>
            <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                    <argument><expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to close Datanode statemrnt"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_sync</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                    <argument><expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to close Datanode statement"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to sync msg to node %s backend_pid:%d"</literal></expr></argument>, <argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nodename</name></expr></argument>, <argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>backend_pid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_CLOSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>InitResponseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>COMBINE_TYPE_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * Make sure there are zeroes in unused fields
     */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>conn_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_receive</name><argument_list>(<argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>connections</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>conn_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                        <argument><expr><name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to close Datanode statement"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>conn_count</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>handle_response</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_EOF</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_READY</name> <operator>||</operator>
                    <name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>state</name> <operator>==</operator> <name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>--</operator><name>conn_count</name> <operator>&gt;</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>connections</name><index>[<expr><name>conn_count</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>ValidateAndCloseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>all_handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * close remote statement needs to be inside a transaction so that syscache can be accessed
 */</comment>
<function><type><name>void</name></type>
<name>ExecCloseRemoteStatement</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmt_name</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nodelist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>need_abort</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsTransactionIdle</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>need_abort</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ExecCloseRemoteStatementInternal</name><argument_list>(<argument><expr><name>stmt_name</name></expr></argument>, <argument><expr><name>nodelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>need_abort</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>AbortCurrentTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * DataNodeCopyInBinaryForAll
 *
 * In a COPY TO, send to all Datanodes PG_HEADER for a COPY TO in binary mode.
 */</comment>
<function><type><name>int</name></type>
<name>DataNodeCopyInBinaryForAll</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>msg_buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>conn_count</name></decl></parameter>,
                                      <parameter><decl><type><name>PGXCNodeHandle</name><modifier>*</modifier><modifier>*</modifier></type> <name>connections</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>         <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>msgLen</name> <init>= <expr><literal type="number">4</literal> <operator>+</operator> <name>len</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nLen</name> <init>= <expr><call><name>htonl</name><argument_list>(<argument><expr><name>msgLen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>conn_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DN_CONNECTION_STATE_COPY_IN</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* msgType + msgLen */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>ensure_out_buffer_capacity</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>msgLen</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name><index>[<expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'d'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nLen</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>outBuffer</name></name> <operator>+</operator> <name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name></expr></argument>, <argument><expr><name>msg_buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>outEnd</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"Invalid Datanode connection"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>EOF</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Encode parameter values to format of DataRow message (the same format is
 * used in Bind) to prepare for sending down to Datanodes.
 * The data row is copied to RemoteQueryState.paramval_data.
 */</comment>
<function><type><name>void</name></type>
<name>SetDataRowForExtParams</name><parameter_list>(<parameter><decl><type><name>ParamListInfo</name></type> <name>paraminfo</name></decl></parameter>, <parameter><decl><type><name>RemoteQueryState</name> <modifier>*</modifier></type><name>rq_state</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16</name></type> <name>n16</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>real_num_params</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>RemoteQuery</name><operator>*</operator><operator>)</operator> <name><name>rq_state</name><operator>-&gt;</operator><name>combiner</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If there are no parameters, there is no data to BIND. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>paraminfo</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>rq_state</name><operator>-&gt;</operator><name>paramval_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * It is necessary to fetch parameters
     * before looking at the output value.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>paraminfo</name><operator>-&gt;</operator><name>numParams</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>param</name> <operator>=</operator> <operator>&amp;</operator><name><name>paraminfo</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>paraminfo</name><operator>-&gt;</operator><name>paramFetch</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call>(<modifier>*</modifier><name><name>paraminfo</name><operator>-&gt;</operator><name>paramFetch</name></name>) <argument_list>(<argument><expr><name>paraminfo</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * This is the last parameter found as useful, so we need
         * to include all the previous ones to keep silent the remote
         * nodes. All the parameters prior to the last usable having no
         * type available will be considered as NULL entries.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>real_num_params</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * If there are no parameters available, simply leave.
     * This is possible in the case of a query called through SPI
     * and using no parameters.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>real_num_params</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>rq_state</name><operator>-&gt;</operator><name>paramval_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rq_state</name><operator>-&gt;</operator><name>paramval_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Number of parameter values */</comment>
    <expr_stmt><expr><name>n16</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name>real_num_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n16</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Parameter values */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>real_num_params</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>&amp;</operator><name><name>paraminfo</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>n32</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Parameters with no types are considered as NULL and treated as integer
         * The same trick is used for dropped columns for remote DML generation.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>isnull</name></name> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>        <name>typOutput</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>    <name>typIsVarlena</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type>    <name>pval</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>pstring</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>        <name>len</name></decl>;</decl_stmt>

            <comment type="block">/* Get info needed to output the value */</comment>
            <expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typOutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIsVarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * If we have a toasted datum, forcibly detoast it here to avoid
             * memory leakage inside the type's output routine.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>typIsVarlena</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>pval</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>pval</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="block">/* Convert Datum to string */</comment>
            <expr_stmt><expr><name>pstring</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typOutput</name></expr></argument>, <argument><expr><name>pval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* copy data to the buffer */</comment>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>pstring</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>


    <comment type="block">/*
     * If parameter types are not already set, infer them from
     * the paraminfo.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>rq_num_params</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Use the already known param types for BIND. Parameter types
         * can be already known when the same plan is executed multiple
         * times.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>rq_num_params</name></name> <operator>!=</operator> <name>real_num_params</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Number of user-supplied parameters do not match "</literal>
                        <literal type="string">"the number of remote parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>rq_state</name><operator>-&gt;</operator><name>rqs_num_params</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>rq_num_params</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rq_state</name><operator>-&gt;</operator><name>rqs_param_types</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>rq_param_types</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>rq_state</name><operator>-&gt;</operator><name>rqs_num_params</name></name> <operator>=</operator> <name>real_num_params</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rq_state</name><operator>-&gt;</operator><name>rqs_param_types</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>real_num_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>real_num_params</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>rq_state</name><operator>-&gt;</operator><name>rqs_param_types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>paraminfo</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ptype</name></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Assign the newly allocated data row to paramval */</comment>
    <expr_stmt><expr><name><name>rq_state</name><operator>-&gt;</operator><name>paramval_data</name></name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rq_state</name><operator>-&gt;</operator><name>paramval_len</name></name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Clear per transaction remote information
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_Remote</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>PGXCNodeResetParams</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>reset_transaction_handles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Invoked when local transaction is about to be committed.
 * If nodestring is specified commit specified prepared transaction on remote
 * nodes, otherwise commit remote nodes which are in transaction.
 */</comment>
<function><type><name>void</name></type>
<name>PreCommit_Remote</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>prepareGID</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodestring</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>preparedLocalNode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>rusage</name></name></type>        <name>start_r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type>        <name>start_t</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_gtm_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ResetUsageCommon</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start_r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Made node connections persistent if we are committing transaction
     * that touched temporary tables. We never drop that flag, so after some
     * transaction has created a temp table the session's remote connections
     * become persistent.
     * We do not need to set that flag if transaction that has created a temp
     * table finally aborts - remote connections are not holding temporary
     * objects in this case.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name> <operator>&amp;&amp;</operator>
        <operator>(</operator><name>MyXactFlags</name> <operator>&amp;</operator> <name>XACT_FLAGS_ACCESSEDTEMPREL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>temp_object_included</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>


    <comment type="block">/*
     * OK, everything went fine. At least one remote node is in PREPARED state
     * and the transaction is successfully prepared on all the involved nodes.
     * Now we are ready to commit the transaction. We need a new GXID to send
     * down the remote nodes to execute the forthcoming COMMIT PREPARED
     * command. So grab one from the GTM and track it. It will be closed along
     * with the main transaction at the end.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>nodestring</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>preparedLocalNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"2PC commit precommit remote gid %s"</literal></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>pgxc_node_remote_finish</name><argument_list>(<argument><expr><name>prepareGID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>nodestring</name></expr></argument>,
                                <argument><expr><call><name>GetAuxilliaryTransactionId</name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name>GetTopGlobalTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>IsTwoPhaseCommitRequired</name><argument_list>(<argument><expr><name>preparedLocalNode</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        
        <if_stmt><if>if<condition>(<expr><name>enable_distri_debug</name> <operator>&amp;&amp;</operator> <call><name>GetTopGlobalTransactionId</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>GetGlobalXidNoCheck</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Non-2PC Commit transaction top xid %u"</literal></expr></argument>, <argument><expr><call><name>GetTopGlobalTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>LogCommitTranGTM</name><argument_list>(<argument><expr><call><name>GetTopGlobalTransactionId</name><argument_list>()</argument_list></call></expr></argument>, 
                             <argument><expr><call><name>GetGlobalXid</name><argument_list>()</argument_list></call></expr></argument>,
                             <argument><expr><name>NULL</name></expr></argument>, 
                             <argument><expr><literal type="number">1</literal></expr></argument>, 
                             <argument><expr><name>true</name></expr></argument>,
                             <argument><expr><name>true</name></expr></argument>, 
                             <argument><expr><name>InvalidGlobalTimestamp</name></expr></argument>, 
                             <argument><expr><name>InvalidGlobalTimestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>is_distri_report</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>pgxc_node_remote_commit</name><argument_list>(<argument><expr><name>TXN_TYPE_CommitTxn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_gtm_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ShowUsageCommon</name><argument_list>(<argument><expr><literal type="string">"PreCommit_Remote"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    
</block_content>}</block></function>

<comment type="block">/*
 * Whether node need clean: last command is not finished
 * 'Z' message: ready for query
 * 'C' message: command complete
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>node_need_clean</name><parameter_list>(<parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name> <operator>||</operator>
		<operator>(</operator><operator>(</operator><literal type="char">'Z'</literal> <operator>!=</operator> <name><name>handle</name><operator>-&gt;</operator><name>last_command</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><literal type="char">'C'</literal> <operator>!=</operator> <name><name>handle</name><operator>-&gt;</operator><name>last_command</name></name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Do abort processing for the transaction. We must abort the transaction on
 * all the involved nodes. If a node has already prepared a transaction, we run
 * ROLLBACK PREPARED command on the node. Otherwise, a simple ROLLBACK command
 * is sufficient.
 *
 * We must guard against the case when a transaction is prepared succefully on
 * all the nodes and some error occurs after we send a COMMIT PREPARED message
 * to at lease one node. Such a transaction must not be aborted to preserve
 * global consistency. We handle this case by recording the nodes involved in
 * the transaction at the GTM and keep the transaction open at the GTM so that
 * its reported as "in-progress" on all the nodes until resolved
 *
 *   SPECIAL WARNGING:
 *   ONLY LOG LEVEL ELOG CALL allowed here, else will cause coredump or resource leak in some rare condition.
 */</comment>
 
<function><type><name>bool</name></type>
<name>PreAbort_Remote</name><parameter_list>(<parameter><decl><type><name>TranscationType</name></type> <name>txn_type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_release_handle</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/*
     * We are about to abort current transaction, and there could be an
     * unexpected error leaving the node connection in some state requiring
     * clean up, like COPY or pending query results.
     * If we are running copy we should send down CopyFail message and read
     * all possible incoming messages, there could be copy rows (if running
     * COPY TO) ErrorResponse, ReadyForQuery.
     * If there are pending results (connection state is DN_CONNECTION_STATE_QUERY)
     * we just need to read them in and discard, all necessary commands are
     * already sent. The end of input could be CommandComplete or
     * PortalSuspended, in either case subsequent ROLLBACK closes the portal.
     */</comment>
    <decl_stmt><decl><type><name>bool</name></type>                 <name>cancel_ret</name>   <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>all_handles</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeHandle</name>       <modifier>*</modifier><modifier>*</modifier></type><name>clean_nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                    <name>node_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                    <name>cancel_dn_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>cancel_co_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name>                    <modifier>*</modifier></type><name>cancel_dn_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name>                    <modifier>*</modifier></type><name>cancel_co_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                 <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>rusage</name></name></type>        <name>start_r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type>        <name>start_t</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_pgxc_handles_init</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>clean_nodes</name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>NumCoords</name> <operator>+</operator> <name>NumDataNodes</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cancel_dn_list</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>NumDataNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cancel_co_list</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>NumCoords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <if_stmt><if>if <condition>(<expr><name>log_gtm_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ResetUsageCommon</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start_r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>all_handles</name> <operator>=</operator> <call><name>get_current_handles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * Find "dirty" coordinator connections.
     * COPY is never running on a coordinator connections, we just check for
     * pending data.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>all_handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name><name>all_handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr>)</condition>
		<block>{<block_content>		
			<if_stmt><if>if <condition>(<expr><call><name>node_need_clean</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Forget previous combiner if any since input will be handled by
				 * different one.
				 */</comment>
				<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>combiner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>clean_nodes</name><index>[<expr><name>node_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>handle</name></expr>;</expr_stmt>				
				<expr_stmt><expr><name><name>cancel_co_list</name><index>[<expr><name>cancel_co_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>			
				
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>	
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PreAbort_Remote node:%s pid:%d status:%d need clean."</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>													
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>in_extended_query</name></name></expr>)</condition>
                <block>{<block_content>                
                    <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_sync</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to sync msg to node:%s pid:%d when abort"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                    
                    </block_content>}</block></if></if_stmt>
                    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>            
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Succeed to sync msg to node:%s pid:%d when abort"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                                    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></if></if_stmt>

            </block_content>}</block></if>
            <else>else
            <block>{<block_content>

                <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>needSync</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid node:%s pid:%d needSync flag"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>    
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PreAbort_Remote node:%s pid:%d status:%d no need clean."</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                                    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"PreAbort_Remote cn node %s pid %d, invalid socket %d!"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></for>

    <comment type="block">/*
     * The same for data nodes, but cancel COPY if it is running.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>all_handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name><name>all_handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr>)</condition>
		<block>{<block_content>		
			<if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DN_CONNECTION_STATE_COPY_IN</name> <operator>||</operator>
				<name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DN_CONNECTION_STATE_COPY_OUT</name></expr>)</condition>
			<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>	
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PreAbort_Remote node:%s pid:%d status:%d need clean."</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt> 												
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>in_extended_query</name></name></expr>)</condition>
                <block>{<block_content>                
                    <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_sync</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to sync msg to node:%s pid:%d when abort"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                    

                    </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>            
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Succeed to sync msg to node:%s pid:%d when abort"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                                    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                </block_content>}</block></if></if_stmt>
                

                <expr_stmt><expr><call><name>DataNodeCopyEnd</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/*
                 * Forget previous combiner if any since input will be handled by
                 * different one.
                 */</comment>
                <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>combiner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <comment type="block">/*
                 * if datanode report error, there is no need to send cancel to it, 
                 * and would not wait this datanode reponse. 
                 */</comment>
                <if_stmt><if>if <condition>(<expr><literal type="char">'E'</literal> <operator>!=</operator> <name><name>handle</name><operator>-&gt;</operator><name>transaction_status</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>clean_nodes</name><index>[<expr><name>node_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>handle</name></expr>;</expr_stmt>                
                    <expr_stmt><expr><name><name>cancel_dn_list</name><index>[<expr><name>cancel_dn_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>				
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>node_need_clean</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Forget previous combiner if any since input will be handled by
				 * different one.
				 */</comment>
				<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>combiner</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>clean_nodes</name><index>[<expr><name>node_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>handle</name></expr>;</expr_stmt>				
				<expr_stmt><expr><name><name>cancel_dn_list</name><index>[<expr><name>cancel_dn_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>	
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PreAbort_Remote node:%s pid:%d status:%d need clean."</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>												
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>in_extended_query</name></name></expr>)</condition>
                <block>{<block_content>                
                    <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_sync</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to sync msg to node:%s pid:%d when abort"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                    
                    </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>            
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Succeed to sync msg to node:%s pid:%d when abort"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                                    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>needSync</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid node:%s pid:%d needSync flag"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                                        
                </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>    
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PreAbort_Remote node:%s pid:%d status:%d no need clean."</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                                
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"PreAbort_Remote dn node %s pid %d, invalid socket %d!"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>cancel_co_count</name> <operator>||</operator> <name>cancel_dn_count</name></expr>)</condition>
    <block>{<block_content>
        
        <comment type="block">/*
         * Cancel running queries on the datanodes and the coordinators.
         */</comment>
        <expr_stmt><expr><name>cancel_ret</name> <operator>=</operator> <call><name>PoolManagerCancelQuery</name><argument_list>(<argument><expr><name>cancel_dn_count</name></expr></argument>, 
                                            <argument><expr><name>cancel_dn_list</name></expr></argument>, 
                                            <argument><expr><name>cancel_co_count</name></expr></argument>,
                                            <argument><expr><name>cancel_co_list</name></expr></argument>,
                                            <argument><expr><name>SIGNAL_SIGINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>cancel_ret</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"PreAbort_Remote cancel query failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Now read and discard any data from the connections found "dirty"
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>node_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>            
        <decl_stmt><decl><type><name>ResponseCombiner</name></type> <name>combiner</name></decl>;</decl_stmt>    

        <expr_stmt><expr><call><name>InitResponseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><name>node_count</name></expr></argument>, <argument><expr><name>COMBINE_TYPE_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>.</operator><name>extended_query</name></name> <operator>=</operator> <name><name>clean_nodes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>in_extended_query</name></expr>;</expr_stmt>
        <comment type="block">/*
         * Make sure there are zeroes in unused fields
         */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ScanState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>.</operator><name>connections</name></name> <operator>=</operator> <name>clean_nodes</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>.</operator><name>conn_count</name></name> <operator>=</operator> <name>node_count</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>.</operator><name>request_type</name></name> <operator>=</operator> <name>REQUEST_TYPE_ERROR</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>.</operator><name>is_abort</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    
        <expr_stmt><expr><call><name>pgxc_connections_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* prevent pfree'ing local variable */</comment>
        <expr_stmt><expr><name><name>combiner</name><operator>.</operator><name>connections</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>CloseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>pgxc_abort_connections</name><argument_list>(<argument><expr><name>all_handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>    
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>nbytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>ii</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>ii</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name>node_count</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>pgxc_node_is_data_enqueued</name><argument_list>(<argument><expr><name><name>clean_nodes</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>nbytes</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"PreAbort_Remote %d bytes data left over in fd:%d remote backendpid:%d nodename:%s"</literal></expr></argument>,
                            <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name><name>clean_nodes</name><index>[<expr><name>ii</name></expr>]</index></name><operator>-&gt;</operator><name>sock</name></expr></argument>, <argument><expr><name><name>clean_nodes</name><index>[<expr><name>ii</name></expr>]</index></name><operator>-&gt;</operator><name>backend_pid</name></expr></argument>, <argument><expr><name><name>clean_nodes</name><index>[<expr><name>ii</name></expr>]</index></name><operator>-&gt;</operator><name>nodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>clean_nodes</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>clean_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>clean_nodes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>cancel_dn_list</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cancel_dn_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cancel_dn_list</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>cancel_co_list</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cancel_co_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cancel_co_list</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>    

    <expr_stmt><expr><call><name>pgxc_node_remote_abort</name><argument_list>(<argument><expr><name>txn_type</name></expr></argument>, <argument><expr><name>need_release_handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Drop the connections to ensure aborts are handled properly.
	 *
	 * XXX We should really be consulting PersistentConnections parameter and
	 * keep the connections if its set. But as a short term measure, to address
	 * certain issues for aborted transactions, we drop the connections.
	 * Revisit and fix the issue
	 */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"temp_object_included %d"</literal></expr></argument>, <argument><expr><name>temp_object_included</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* cleanup and release handles is already done in pgxc_node_remote_abort */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>	
	if (release_handle)
	{
		if (!temp_object_included)
		{
			<comment type="block">/* Clean up remote sessions */</comment>
			pgxc_node_remote_cleanup_all();
			release_handles();
		}
	}
	
	clear_handles();
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>all_handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_gtm_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ShowUsageCommon</name><argument_list>(<argument><expr><literal type="string">"PreAbort_Remote"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Invoked when local transaction is about to be prepared.
 * If invoked on a Datanode just commit transaction on remote connections,
 * since secondary sessions are read only and never need to be prepared.
 * Otherwise run PREPARE on remote connections, where writable commands were
 * sent (connections marked as not read-only).
 * If that is explicit PREPARE (issued by client) notify GTM.
 * In case of implicit PREPARE not involving local node (ex. caused by
 * INSERT, UPDATE or DELETE) commit prepared transaction immediately.
 * Return list of node names where transaction was actually prepared, include
 * the name of the local node if localNode is true.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>PrePrepare_Remote</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>prepareGID</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>localNode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>implicit</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* Always include local node if running explicit prepare */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type>    <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nodestring</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>rusage</name></name></type>        <name>start_r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type>        <name>start_t</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_gtm_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ResetUsageCommon</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start_r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Primary session is doing 2PC, just commit secondary processes and exit
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pgxc_node_remote_commit</name><argument_list>(<argument><expr><name>TXN_TYPE_CommitTxn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"2PC commit PrePrepare_Remote xid %d"</literal></expr></argument>, <argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>nodestring</name> <operator>=</operator> <call><name>pgxc_node_remote_prepare</name><argument_list>(<argument><expr><name>prepareGID</name></expr></argument>,
                                                <argument><expr><operator>!</operator><name>implicit</name> <operator>||</operator> <name>localNode</name></expr></argument>,
                                                <argument><expr><name>implicit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
    <expr_stmt><expr><name>twophase_in</name> <operator>=</operator> <name>IN_OTHER</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>nodestring</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Remote Prepare Transaction gid:%s Failed"</literal></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>nodestring</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>localNode</name> <operator>||</operator> <operator>!</operator><call><name>IsXidImplicit</name><argument_list>(<argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>TWO_PHASE_PREPARED</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>implicit</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Save the node list and gid on GTM. */</comment>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>StartPreparedTranGTM</name><argument_list>(<argument><expr><call><name>GetTopGlobalTransactionId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>, <argument><expr><name>nodestring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>PART_PREPARE_PREPARE_GTM</name> <operator>==</operator> <name>twophase_exception_case</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>complish</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ALL_PREPARE_PREPARE_GTM is running"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Prepare Transaction gid:%s on GTM failed"</literal></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"commit phase xid %d implicit %d local node %d prepareGID %s"</literal></expr></argument>, 
                            <argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>implicit</name></expr></argument>, <argument><expr><name>localNode</name></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/*
     * If no need to commit on local node go ahead and commit prepared
     * transaction right away.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>implicit</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>localNode</name> <operator>&amp;&amp;</operator> <name>nodestring</name></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>        
        <comment type="block">/* 
         * if start node not participate, still record 2pc before  pgxc_node_remote_finish,  
         * and it will be flushed and sync to slave node when record commit_timestamp
         */</comment>
        <expr_stmt><expr><call><name>record_2pc_involved_nodes_xid</name><argument_list>(<argument><expr><name>prepareGID</name></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_xid</name></name></expr></argument>, 
            <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>participants</name></name></expr></argument>, <argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_xid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>pgxc_node_remote_finish</name><argument_list>(<argument><expr><name>prepareGID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>nodestring</name></expr></argument>,
                                <argument><expr><call><name>GetAuxilliaryTransactionId</name><argument_list>()</argument_list></call></expr></argument>,
                                <argument><expr><call><name>GetTopGlobalTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nodestring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nodestring</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_gtm_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ShowUsageCommon</name><argument_list>(<argument><expr><literal type="string">"PrePrepare_Remote"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>nodestring</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Invoked immediately after local node is prepared.
 * Notify GTM about completed prepare.
 */</comment>
<function><type><name>void</name></type>
<name>PostPrepare_Remote</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>prepareGID</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>implicit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__TBASE__</name></cpp:ifndef>
    <decl_stmt><decl><type><name><name>struct</name> <name>rusage</name></name></type>        <name>start_r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type>        <name>start_t</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_gtm_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ResetUsageCommon</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start_r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>implicit</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PrepareTranGTM</name><argument_list>(<argument><expr><call><name>GetTopGlobalTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_gtm_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ShowUsageCommon</name><argument_list>(<argument><expr><literal type="string">"PostPrepare_Remote"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>reset_transaction_handles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if 2PC is required for consistent commit: if there was write
 * activity on two or more nodes within current transaction.
 */</comment>
<function><type><name>bool</name></type>
<name>IsTwoPhaseCommitRequired</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>localWrite</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
	<decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>handles</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>                <name>found</name> <init>= <expr><name>localWrite</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                 <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type>                                     <name>sock_fatal_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Never run 2PC on Datanode-to-Datanode connection */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>MyXactFlags</name> <operator>&amp;</operator> <name>XACT_FLAGS_ACCESSEDTEMPREL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Transaction accessed temporary objects - "</literal>
                <literal type="string">"2PC will not be used and that can lead to data inconsistencies "</literal>
                <literal type="string">"in case of failures"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If no XID assigned, no need to run 2PC since neither coordinator nor any
     * remote nodes did write operation
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<expr_stmt><expr><name>handles</name> <operator>=</operator> <call><name>get_sock_fatal_handles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sock_fatal_count</name> <operator>=</operator> <name><name>handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name> <operator>+</operator> <name><name>handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"IsTwoPhaseCommitRequired, fatal_conn=%p, fatal_conn-&gt;nodename=%s, fatal_conn-&gt;sock=%d, "</literal>
			<literal type="string">"fatal_conn-&gt;read_only=%d, fatal_conn-&gt;transaction_status=%c, "</literal>
			<literal type="string">"fatal_conn-&gt;sock_fatal_occurred=%d, conn-&gt;backend_pid=%d, fatal_conn-&gt;error=%s"</literal></expr></argument>, 
			<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>read_only</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name></expr></argument>,
			<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock_fatal_occurred</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>,  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"IsTwoPhaseCommitRequired, fatal_conn=%p, fatal_conn-&gt;nodename=%s, fatal_conn-&gt;sock=%d, "</literal>
			<literal type="string">"fatal_conn-&gt;read_only=%d, fatal_conn-&gt;transaction_status=%c, "</literal>
			<literal type="string">"fatal_conn-&gt;sock_fatal_occurred=%d, conn-&gt;backend_pid=%d, fatal_conn-&gt;error=%s"</literal></expr></argument>, 
			<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>read_only</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name></expr></argument>,
			<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock_fatal_occurred</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>,  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>sock_fatal_count</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"IsTwoPhaseCommitRequired, Found %d sock fatal handles exist"</literal></expr></argument>, <argument><expr><name>sock_fatal_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* get current transaction handles that we register when pgxc_node_begin */</comment>
	<expr_stmt><expr><name>handles</name> <operator>=</operator> <call><name>get_current_txn_handles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"IsTwoPhaseCommitRequired, conn-&gt;nodename=%s, conn-&gt;sock=%d, conn-&gt;read_only=%d, conn-&gt;transaction_status=%c"</literal></expr></argument>, 
			<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>read_only</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>NO_SOCKET</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"IsTwoPhaseCommitRequired, remote node %s's connection handle is invalid, backend_pid: %d"</literal></expr></argument>,
                 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>read_only</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>==</operator> <literal type="char">'T'</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>true</name></expr>;</return> <comment type="block">/* second found */</comment>
            </block_content>}</block></if>    
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> <comment type="block">/* first found */</comment>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"IsTwoPhaseCommitRequired, remote node %s is in error state, backend_pid: %d"</literal></expr></argument>,
                    <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"IsTwoPhaseCommitRequired, conn-&gt;nodename=%s, conn-&gt;sock=%d, conn-&gt;read_only=%d, conn-&gt;transaction_status=%c"</literal></expr></argument>, 
			<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>read_only</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>NO_SOCKET</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"IsTwoPhaseCommitRequired, remote node %s's connection handle is invalid, backend_pid: %d"</literal></expr></argument>,
                 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>read_only</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>==</operator> <literal type="char">'T'</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>true</name></expr>;</return> <comment type="block">/* second found */</comment>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> <comment type="block">/* first found */</comment>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>transaction_status</name></name> <operator>==</operator> <literal type="char">'E'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"IsTwoPhaseCommitRequired, remote node %s is in error state, backend_pid: %d"</literal></expr></argument>,
                 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"IsTwoPhaseCommitRequired return false"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* An additional phase for explicitly prepared transactions */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgxc_node_remote_prefinish</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>prepareGID</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodestring</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PGXCNodeHandle</name>       <modifier>*</modifier></type><name><name>connections</name><index>[<expr><name>TBASE_MAX_COORDINATOR_NUMBER</name> <operator>+</operator> <name>TBASE_MAX_DATANODE_NUMBER</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                    <name>conn_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResponseCombiner</name></type>    <name>combiner</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>pgxc_handles</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>               <modifier>*</modifier></type><name>nodename</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>               <modifier>*</modifier></type><name>nodelist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>               <modifier>*</modifier></type><name>coordlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                    <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GlobalTimestamp</name></type>    <name>global_committs</name></decl>;</decl_stmt>
    <comment type="block">/*
     * Now based on the nodestring, run COMMIT/ROLLBACK PREPARED command on the
     * remote nodes and also finish the transaction locally is required
     */</comment>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_remote_prefinish nodestring %s gid %s"</literal></expr></argument>, <argument><expr><name>nodestring</name></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_remote_prefinish start GTM timestamp nodestring %s gid %s"</literal></expr></argument>, <argument><expr><name>nodestring</name></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>global_committs</name> <operator>=</operator> <call><name>GetGlobalTimestampGTM</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>ALL_PREPARE_REMOTE_PREFINISH</name> <operator>==</operator> <name>twophase_exception_case</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>global_committs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>complish</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>GlobalTimestampIsValid</name><argument_list>(<argument><expr><name>global_committs</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to get global timestamp for prefinish command gid %s"</literal></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"prefinish phase get global timestamp gid %s, time "</literal> <name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>, <argument><expr><name>global_committs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>SetGlobalPrepareTimestamp</name><argument_list>(<argument><expr><name>global_committs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><comment type="block">/* Save for local commit */</comment>
    <expr_stmt><expr><call><name>EndExplicitGlobalPrepare</name><argument_list>(<argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    
    <expr_stmt><expr><name>nodename</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>nodestring</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>nodename</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>        <name>nodeIndex</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>    <name>nodetype</name></decl>;</decl_stmt>

        <comment type="block">/* Get node type and index */</comment>
        <expr_stmt><expr><name>nodetype</name> <operator>=</operator> <name>PGXC_NODE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nodeIndex</name> <operator>=</operator> <call><name>PGXCNodeGetNodeIdFromName</name><argument_list>(<argument><expr><name>nodename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nodetype</name> <operator>==</operator> <name>PGXC_NODE_NONE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC Node %s: object not defined"</literal></expr></argument>,
                            <argument><expr><name>nodename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Check if node is requested is the self-node or not */</comment>
        <if_stmt><if>if <condition>(<expr><name>nodetype</name> <operator>==</operator> <name>PGXC_NODE_COORDINATOR</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>nodeIndex</name> <operator>!=</operator> <name>PGXCNodeId</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>coordlist</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>coordlist</name></expr></argument>, <argument><expr><name>nodeIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>nodelist</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>, <argument><expr><name>nodeIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>nodename</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>nodelist</name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>coordlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>pgxc_handles</name> <operator>=</operator> <call><name>get_handles</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>, <argument><expr><name>coordlist</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pgxc_handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_gid</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send GID to the node %u"</literal></expr></argument>,
                            <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_prefinish_timestamp</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>global_committs</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send prefinish timestamp to the node %u"</literal></expr></argument>,  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_flush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Do not bother with clean up, just bomb out. The error handler
             * will invoke RollbackTransaction which will do the work.
             */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pgxc_node_remote_prefinish failed to send prefinish command to the node %u for %s"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Read responses from these */</comment>
            <expr_stmt><expr><name><name>connections</name><index>[<expr><name>conn_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"prefinish add connection"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

    </block_content>}</block></for>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pgxc_handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_gid</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send GID to the node %u"</literal></expr></argument>,
                            <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_prefinish_timestamp</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>global_committs</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to send prefinish timestamp to the node %u"</literal></expr></argument>,  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_flush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Do not bother with clean up, just bomb out. The error handler
             * will invoke RollbackTransaction which will do the work.
             */</comment>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pgxc_node_remote_prefinish failed to send prefinish command to the node %u for %s"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Read responses from these */</comment>
            <expr_stmt><expr><name><name>connections</name><index>[<expr><name>conn_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"prefinish add connection"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>conn_count</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>InitResponseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>COMBINE_TYPE_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Receive responses */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_receive_responses</name><argument_list>(<argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>connections</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>.</operator><name>errorMessage</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgxc_node_report_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to COMMIT the transaction on one or more nodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>CloseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>pgxc_handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
 * Execute COMMIT/ABORT PREPARED issued by the remote client on remote nodes.
 * Contacts GTM for the list of involved nodes and for work complete
 * notification. Returns true if prepared transaction on local node needs to be
 * finished too.
 */</comment>
<function><type><name>bool</name></type>
<name>FinishRemotePreparedTransaction</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>prepareGID</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>commit</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>                   <modifier>*</modifier></type><name>nodestring</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>                    <modifier>*</modifier><name>savenodestring</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GlobalTransactionId</name></type>        <name>gxid</name></decl>, <decl><type ref="prev"/><name>prepare_gxid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>                    <name>prepared_local</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
	<comment type="block">/*
	 * Since g_twophase_state is cleared after prepare phase,
	 * g_twophase_state shoud be assigned here
	 */</comment>
	<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>gid</name></name></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>, <argument><expr><name>GIDSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>start_node_name</name></name></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>TWO_PHASE_PREPARED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>is_start_node</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Get the list of nodes involved in this transaction.
     *
     * This function returns the GXID of the prepared transaction. It also
     * returns a fresh GXID which can be used for running COMMIT PREPARED
     * commands on the remote nodes. Both these GXIDs can then be either
     * committed or aborted together.
     *
     * XXX While I understand that we get the prepared and a new GXID with a
     * single call, it doesn't look nicer and create confusion. We should
     * probably split them into two parts. This is used only for explicit 2PC
     * which should not be very common in XC
     *
     * In xc_maintenance_mode mode, we don't fail if the GTM does not have
     * knowledge about the prepared transaction. That may happen for various
     * reasons such that an earlier attempt cleaned up it from GTM or GTM was
     * restarted in between. The xc_maintenance_mode is a kludge to come out of
     * such situations. So it seems alright to not be too strict about the
     * state
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>ALL_PREPARE_FINISH_REMOTE_PREPARED</name> <operator>==</operator> <name>twophase_exception_case</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>complish</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ALL_PREPARE_FINISH_REMOTE_PREPARED complish"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>GetGIDDataGTM</name><argument_list>(<argument><expr><name>prepareGID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gxid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prepare_gxid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodestring</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
        <operator>!</operator><name>xc_maintenance_mode</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>g_twophase_state</name><operator>.</operator><name>is_readonly</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"prepared transaction with identifier \"%s\" does not exist"</literal></expr></argument>,
                        <argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Please note that with xc_maintenance_mode = on, COMMIT/ROLLBACK PREPARED will not
     * propagate to remote nodes. Only GTM status is cleaned up.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>xc_maintenance_mode</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>commit</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pgxc_node_remote_commit</name><argument_list>(<argument><expr><name>TXN_TYPE_CommitTxn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CommitPreparedTranGTM</name><argument_list>(<argument><expr><name>prepare_gxid</name></expr></argument>, <argument><expr><name>gxid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>pgxc_node_remote_abort</name><argument_list>(<argument><expr><name>TXN_TYPE_RollbackTxn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RollbackTranGTM</name><argument_list>(<argument><expr><name>prepare_gxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>RollbackTranGTM</name><argument_list>(<argument><expr><name>gxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
    <comment type="block">/* 
     * not allowed user commit residual transaction in xc_maintenance_mode, 
     * since we need commit them in unified timestamp
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>xc_maintenance_mode</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can not commit transaction '%s' in xc_maintainence_mode"</literal></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>nodestring</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>g_twophase_state</name><operator>.</operator><name>participants</name></name></expr></argument>, <argument><expr><name>nodestring</name></expr></argument>,<argument><expr><operator>(</operator><operator>(</operator><name>NAMEDATALEN</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <operator>(</operator><name>TBASE_MAX_DATANODE_NUMBER</name> <operator>+</operator> <name>TBASE_MAX_COORDINATOR_NUMBER</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>nodestring</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>savenodestring</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><name>nodestring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pgxc_node_remote_prefinish</name><argument_list>(<argument><expr><name>prepareGID</name></expr></argument>, <argument><expr><name>savenodestring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>prepared_local</name> <operator>=</operator> <call><name>pgxc_node_remote_finish</name><argument_list>(<argument><expr><name>prepareGID</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>, <argument><expr><name>nodestring</name></expr></argument>,
                                             <argument><expr><name>gxid</name></expr></argument>, <argument><expr><name>prepare_gxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>nodestring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>

    <if_stmt><if>if <condition>(<expr><name>commit</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * XXX For explicit 2PC, there will be enough delay for any
         * waited-committed transactions to send a final COMMIT message to the
         * GTM.
         */</comment>
        <expr_stmt><expr><call><name>CommitPreparedTranGTM</name><argument_list>(<argument><expr><name>prepare_gxid</name></expr></argument>, <argument><expr><name>gxid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>RollbackTranGTM</name><argument_list>(<argument><expr><name>prepare_gxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RollbackTranGTM</name><argument_list>(<argument><expr><name>gxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>FinishGIDGTM</name><argument_list>(<argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>SetCurrentHandlesReadonly</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>prepared_local</name></expr>;</return>
</block_content>}</block></function>





<comment type="block">/*
 * Complete previously prepared transactions on remote nodes.
 * Release remote connection after completion.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pgxc_node_remote_finish</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>prepareGID</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>commit</name></decl></parameter>,
                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodestring</name></decl></parameter>, <parameter><decl><type><name>GlobalTransactionId</name></type> <name>gxid</name></decl></parameter>,
                        <parameter><decl><type><name>GlobalTransactionId</name></type> <name>prepare_gxid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>               <modifier>*</modifier></type><name>finish_cmd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier><modifier>*</modifier></type><name>connections</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                    <name>conn_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResponseCombiner</name></type>    <name>combiner</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>pgxc_handles</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>                <name>prepared_local</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>               <modifier>*</modifier></type><name>nodename</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>               <modifier>*</modifier></type><name>nodelist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>               <modifier>*</modifier></type><name>coordlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                    <name>i</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>GlobalTimestamp</name></type>    <name>global_committs</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
    <comment type="block">/* 
     *any send error in twophase trans will set all_conn_healthy to false 
     *all transaction call pgxc_node_remote_finish is twophase trans
     *only called by starter: set g_twophase_state just before send msg to remote nodes
     */</comment>
    <decl_stmt><decl><type><name>bool</name></type>               <name>all_conn_healthy</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>twophase_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TESTS__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>ALL_PREPARE_REMOTE_FINISH</name> <operator>==</operator> <name>twophase_exception_case</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>complish</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"stop transaction '%s' in ALL_PREPARE_REMOTE_FINISH"</literal></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>PART_ABORT_REMOTE_FINISH</name> <operator>==</operator> <name>twophase_exception_case</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>complish</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"PART_ABORT_REMOTE_FINISH complete"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>PART_COMMIT_SEND_TIMESTAMP</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>||</operator> 
        <name>PART_COMMIT_SEND_QUERY</name> <operator>==</operator> <name>twophase_exception_case</name> <operator>||</operator>
        <name>PART_COMMIT_RESPONSE_ERROR</name> <operator>==</operator> <name>twophase_exception_case</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>twophase_in</name> <operator>=</operator> <name>IN_REMOTE_FINISH</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>connections</name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>TBASE_MAX_DATANODE_NUMBER</name> <operator>+</operator> <name>TBASE_MAX_COORDINATOR_NUMBER</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>connections</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory for connections"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/*
     * Now based on the nodestring, run COMMIT/ROLLBACK PREPARED command on the
     * remote nodes and also finish the transaction locally is required
     */</comment>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_remote_finish nodestring %s gid %s"</literal></expr></argument>, <argument><expr><name>nodestring</name></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG8</name></expr></argument>, <argument><expr><literal type="string">"pgxc_node_remote_finish start GTM timestamp nodestring %s gid %s"</literal></expr></argument>, <argument><expr><name>nodestring</name></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>delay_before_acquire_committs</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>delay_before_acquire_committs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>global_committs</name> <operator>=</operator> <call><name>GetGlobalTimestampGTM</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>GlobalTimestampIsValid</name><argument_list>(<argument><expr><name>global_committs</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to get global timestamp for %s PREPARED command"</literal></expr></argument>,
                <argument><expr><ternary><condition><expr><name>commit</name></expr> ?</condition><then> <expr><literal type="string">"COMMIT"</literal></expr> </then><else>: <expr><literal type="string">"ROLLBACK"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"commit phase get global commit timestamp gid %s, time "</literal> <name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>, <argument><expr><name>global_committs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//record_2pc_commit_timestamp(prepareGID, global_committs);</comment>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>delay_after_acquire_committs</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>delay_after_acquire_committs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>SetGlobalCommitTimestamp</name><argument_list>(<argument><expr><name>global_committs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><comment type="block">/* Save for local commit */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>nodename</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>nodestring</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>nodename</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>        <name>nodeIndex</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>    <name>nodetype</name></decl>;</decl_stmt>

        <comment type="block">/* Get node type and index */</comment>
        <expr_stmt><expr><name>nodetype</name> <operator>=</operator> <name>PGXC_NODE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nodeIndex</name> <operator>=</operator> <call><name>PGXCNodeGetNodeIdFromName</name><argument_list>(<argument><expr><name>nodename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nodetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nodetype</name> <operator>==</operator> <name>PGXC_NODE_NONE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC Node %s: object not defined"</literal></expr></argument>,
                            <argument><expr><name>nodename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Check if node is requested is the self-node or not */</comment>
        <if_stmt><if>if <condition>(<expr><name>nodetype</name> <operator>==</operator> <name>PGXC_NODE_COORDINATOR</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>nodeIndex</name> <operator>==</operator> <name>PGXCNodeId</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>prepared_local</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>coordlist</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>coordlist</name></expr></argument>, <argument><expr><name>nodeIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>nodelist</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>, <argument><expr><name>nodeIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>nodename</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><name>nodelist</name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name>coordlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>prepared_local</name></expr>;</return></block_content></block></if></if_stmt>


	<expr_stmt><expr><name>pgxc_handles</name> <operator>=</operator> <call><name>get_handles</name><argument_list>(<argument><expr><name>nodelist</name></expr></argument>, <argument><expr><name>coordlist</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>SetLocalTwoPhaseStateHandles</name><argument_list>(<argument><expr><name>pgxc_handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>finish_cmd</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">64</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>commit</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>finish_cmd</name></expr></argument>, <argument><expr><literal type="string">"COMMIT PREPARED '%s'"</literal></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>finish_cmd</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK PREPARED '%s'"</literal></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>enable_distri_debug</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>node_count</name> <init>= <expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name> <operator>+</operator> <name><name>pgxc_handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if<condition>(<expr><name>prepared_local</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>node_count</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if<condition>(<expr><name>enable_distri_print</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Commit transaction prepareGID %s nodestring %s top xid %u auxid %u "</literal><name>INT64_FORMAT</name><literal type="string">" "</literal><name>INT64_FORMAT</name></expr></argument>,
                <argument><expr><name>prepareGID</name></expr></argument>, <argument><expr><name>nodestring</name></expr></argument>, <argument><expr><call><name>GetAuxilliaryTransactionId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>GetTopGlobalTransactionId</name><argument_list>()</argument_list></call></expr></argument>,
                <argument><expr><call><name>GetGlobalPrepareTimestamp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>GetGlobalCommitTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>LogCommitTranGTM</name><argument_list>(<argument><expr><call><name>GetTopGlobalTransactionId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>, 
                             <argument><expr><name>nodestring</name></expr></argument>, 
                             <argument><expr><name>node_count</name></expr></argument>,
                             <argument><expr><name>true</name></expr></argument>,
                             <argument><expr><name>true</name></expr></argument>, 
                             <argument><expr><call><name>GetGlobalPrepareTimestamp</name><argument_list>()</argument_list></call></expr></argument>, 
                             <argument><expr><call><name>GetGlobalCommitTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>is_distri_report</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>state</name></name> <operator>=</operator> <ternary><condition><expr><name>commit</name></expr> ?</condition><then> <expr><name>TWO_PHASE_COMMITTING</name></expr> </then><else>: <expr><name>TWO_PHASE_ABORTTING</name></expr></else></ternary></expr>;</expr_stmt>
    <comment type="block">/*
     * transaction start node record 2pc file just before
     * send query to remote participants
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name> <operator>&amp;&amp;</operator> <name>commit</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * record commit timestamp in 2pc file for start node
         */</comment>
        <expr_stmt><expr><call><name>record_2pc_commit_timestamp</name><argument_list>(<argument><expr><name>prepareGID</name></expr></argument>, <argument><expr><name>global_committs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pgxc_handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
        <expr_stmt><expr><name>twophase_index</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>datanode_index</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>is_participant</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>handle_idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>state</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>        

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_gxid</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>gxid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
            <comment type="line">// *record conn state :send gxid fail</comment>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                <name>TWO_PHASE_SEND_GXID_ERROR</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name> <operator>=</operator> 
                <ternary><condition><expr><operator>(</operator><name>commit</name> <operator>==</operator> <name>true</name><operator>)</operator></expr> ?</condition><then> <expr><name>TWO_PHASE_COMMIT_ERROR</name></expr> </then><else>: <expr><name>TWO_PHASE_ABORT_ERROR</name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name>all_conn_healthy</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_index</name></name><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>        
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_global_timestamp</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>global_committs</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                <name>TWO_PHASE_SEND_TIMESTAMP_ERROR</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> 
                <ternary><condition><expr><operator>(</operator><name>commit</name> <operator>==</operator> <name>true</name><operator>)</operator></expr> ?</condition><then> <expr><name>TWO_PHASE_COMMIT_ERROR</name></expr> </then><else>: <expr><name>TWO_PHASE_ABORT_ERROR</name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name>all_conn_healthy</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_index</name></name><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_query</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>finish_cmd</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
            <comment type="line">// record conn state :send gxid fail</comment>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                <name>TWO_PHASE_SEND_QUERY_ERROR</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> 
                <ternary><condition><expr><operator>(</operator><name>commit</name> <operator>==</operator> <name>true</name><operator>)</operator></expr> ?</condition><then> <expr><name>TWO_PHASE_COMMIT_ERROR</name></expr> </then><else>: <expr><name>TWO_PHASE_ABORT_ERROR</name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name>all_conn_healthy</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_index</name></name><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Read responses from these */</comment>
            <expr_stmt><expr><name><name>connections</name><index>[<expr><name>conn_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                <name>TWO_PHASE_HEALTHY</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>twophase_index</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>connections_num</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>node_type</name> <operator>=</operator> <name>PGXC_NODE_DATANODE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_trans_state_index</name> <operator>=</operator> 
                <name><name>g_twophase_state</name><operator>.</operator><name>datanode_index</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections_num</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>datanode_index</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Make sure datanode commit first */</comment>
    <if_stmt><if>if <condition>(<expr><name>conn_count</name> <operator>&amp;&amp;</operator> <name>is_txn_has_parallel_ddl</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>InitResponseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>COMBINE_TYPE_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>response_operation</name></name> <operator>=</operator>
                <ternary><condition><expr><operator>(</operator><name>commit</name> <operator>==</operator> <name>true</name><operator>)</operator></expr> ?</condition><then> <expr><name>REMOTE_FINISH_COMMIT</name></expr> </then><else>: <expr><name>REMOTE_FINISH_ABORT</name></expr></else></ternary></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Receive responses */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_receive_responses</name><argument_list>(<argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>connections</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <operator>!</operator><call><name>validate_combiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>.</operator><name>errorMessage</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgxc_node_report_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to COMMIT the transaction on one or more nodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>CloseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>conn_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pgxc_handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>pgxc_handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
        <expr_stmt><expr><name>twophase_index</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>coord_index</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>is_participant</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>handle_idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>state</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__USE_GLOBAL_SNAPSHOT__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_gxid</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>gxid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                <name>TWO_PHASE_SEND_GXID_ERROR</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name> <operator>=</operator> 
                <ternary><condition><expr><operator>(</operator><name>commit</name> <operator>==</operator> <name>true</name><operator>)</operator></expr> ?</condition><then> <expr><name>TWO_PHASE_COMMIT_ERROR</name></expr> </then><else>: <expr><name>TWO_PHASE_ABORT_ERROR</name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name>all_conn_healthy</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_index</name></name><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__SUPPORT_DISTRIBUTED_TRANSACTION__</name></cpp:ifdef>        
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_global_timestamp</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>global_committs</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                <name>TWO_PHASE_SEND_TIMESTAMP_ERROR</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> 
                <ternary><condition><expr><operator>(</operator><name>commit</name> <operator>==</operator> <name>true</name><operator>)</operator></expr> ?</condition><then> <expr><name>TWO_PHASE_COMMIT_ERROR</name></expr> </then><else>: <expr><name>TWO_PHASE_ABORT_ERROR</name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name>all_conn_healthy</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_index</name></name><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_query</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>finish_cmd</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> 
                <name>TWO_PHASE_SEND_QUERY_ERROR</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> 
                <ternary><condition><expr><operator>(</operator><name>commit</name> <operator>==</operator> <name>true</name><operator>)</operator></expr> ?</condition><then> <expr><name>TWO_PHASE_COMMIT_ERROR</name></expr> </then><else>: <expr><name>TWO_PHASE_ABORT_ERROR</name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name>all_conn_healthy</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_index</name></name><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Read responses from these */</comment>
            <expr_stmt><expr><name><name>connections</name><index>[<expr><name>conn_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_state</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_state</name> <operator>=</operator> <name>TWO_PHASE_HEALTHY</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>twophase_index</name> <operator>=</operator> <name><name>g_twophase_state</name><operator>.</operator><name>connections_num</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>node_type</name> <operator>=</operator> <name>PGXC_NODE_COORDINATOR</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections</name><index>[<expr><name>twophase_index</name></expr>]</index></name><operator>.</operator><name>conn_trans_state_index</name> <operator>=</operator> 
                <name><name>g_twophase_state</name><operator>.</operator><name>coord_index</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>connections_num</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>coord_index</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>conn_count</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>InitResponseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>COMBINE_TYPE_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>response_operation</name></name> <operator>=</operator> 
            <ternary><condition><expr><operator>(</operator><name>commit</name> <operator>==</operator> <name>true</name><operator>)</operator></expr> ?</condition><then> <expr><name>REMOTE_FINISH_COMMIT</name></expr> </then><else>: <expr><name>REMOTE_FINISH_ABORT</name></expr></else></ternary></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Receive responses */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_receive_responses</name><argument_list>(<argument><expr><name>conn_count</name></expr></argument>, <argument><expr><name>connections</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call> <operator>||</operator>
                <operator>!</operator><call><name>validate_combiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>.</operator><name>errorMessage</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>pgxc_node_report_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to COMMIT the transaction on one or more nodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>CloseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>all_conn_healthy</name> <operator>==</operator> <name>false</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>commit</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to send COMMIT PREPARED '%s' to one or more nodes"</literal></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to send ROLLBACK PREPARED '%s' to one or more nodes"</literal></expr></argument>, <argument><expr><name>prepareGID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>temp_object_included</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>PersistentConnections</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Clean up remote sessions */</comment>
		<expr_stmt><expr><call><name>pgxc_node_remote_cleanup_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>release_handles</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>clear_handles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>pgxc_handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>reset_transaction_handles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>finish_cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TWO_PHASE_TRANS__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>prepared_local</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>state</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>commit</name> <operator>==</operator> <name>true</name><operator>)</operator></expr> ?</condition><then> <expr><name>TWO_PHASE_COMMIT_END</name></expr> </then><else>: <expr><name>TWO_PHASE_ABORT_END</name></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>g_twophase_state</name><operator>.</operator><name>state</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>commit</name> <operator>==</operator> <name>true</name><operator>)</operator></expr> ?</condition><then> <expr><name>TWO_PHASE_COMMITTED</name></expr> </then><else>: <expr><name>TWO_PHASE_ABORTTED</name></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ClearLocalTwoPhaseState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

    <if_stmt><if>if <condition>(<expr><name>connections</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>connections</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <return>return <expr><name>prepared_local</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *
 * Simplified versions of ExecInitRemoteQuery, ExecRemoteQuery and
 * ExecEndRemoteQuery: in XCP they are only used to execute simple queries.
 *
 *****************************************************************************/</comment>
<function><type><name>RemoteQueryState</name> <modifier>*</modifier></type>
<name>ExecInitRemoteQuery</name><parameter_list>(<parameter><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RemoteQueryState</name>   <modifier>*</modifier></type><name>remotestate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResponseCombiner</name>   <modifier>*</modifier></type><name>combiner</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>remotestate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteQueryState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>remotestate</name><operator>-&gt;</operator><name>eflags</name></name> <operator>=</operator> <name>eflags</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>combiner</name> <operator>=</operator> <operator>(</operator><name>ResponseCombiner</name> <operator>*</operator><operator>)</operator> <name>remotestate</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>InitResponseCombiner</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>combine_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecRemoteQuery</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>=</operator> <name>REQUEST_TYPE_QUERY</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ExecInitResultTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecAssignResultTypeFromTL</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>remotestate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If there are parameters supplied, get them into a form to be sent to the
     * Datanodes with bind message. We should not have had done this before.
     */</comment>
    <expr_stmt><expr><call><name>SetDataRowForExtParams</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name></expr></argument>, <argument><expr><name>remotestate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We need expression context to evaluate */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>exec_nodes</name></name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>en_expr</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>en_expr</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>vartype</name> <operator>==</operator> <name>TIDOID</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Special case if expression does not need to be evaluated */</comment>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* prepare expression evaluation */</comment>
            <expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>remotestate</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Execute step of PGXC plan.
 * The step specifies a command to be executed on specified nodes.
 * On first invocation connections to the data nodes are initialized and
 * command is executed. Further, as well as within subsequent invocations,
 * responses are received until step is completed or there is a tuple to emit.
 * If there is a tuple it is returned, otherwise returned NULL. The NULL result
 * from the function indicates completed step.
 * The function returns at most one tuple per invocation.
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecRemoteQuery</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>RemoteQueryState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>RemoteQueryState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name> <init>= <expr><operator>(</operator><name>ResponseCombiner</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQuery</name>    <modifier>*</modifier></type><name>step</name> <init>= <expr><operator>(</operator><name>RemoteQuery</name> <operator>*</operator><operator>)</operator> <name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>resultslot</name> <init>= <expr><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>query_Done</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GlobalTransactionId</name></type> <name>gxid</name> <init>= <expr><name>InvalidGlobalTransactionId</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Snapshot</name></type>        <name>snapshot</name> <init>= <expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier><modifier>*</modifier></type><name>connections</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>primaryconnection</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>                <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>                <name>regular_conn_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>                <name>total_conn_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>            <name>need_tran_block</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>pgxc_connections</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Get connections for Datanodes only, utilities and DDLs
         * are launched in ExecRemoteUtility
         */</comment>
        <expr_stmt><expr><name>pgxc_connections</name> <operator>=</operator> <call><name>get_exec_connections</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>exec_nodes</name></name></expr></argument>,
                                                <argument><expr><name><name>step</name><operator>-&gt;</operator><name>exec_type</name></name></expr></argument>,
                                                <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>==</operator> <name>EXEC_ON_DATANODES</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>connections</name> <operator>=</operator> <name><name>pgxc_connections</name><operator>-&gt;</operator><name>datanode_handles</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>total_conn_count</name> <operator>=</operator> <name>regular_conn_count</name> <operator>=</operator> <name><name>pgxc_connections</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>regular_conn_count</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>need_global_snapshot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>regular_conn_count</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>need_global_snapshot</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type> <name>nodeid</name> <init>= <expr><call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>nodeoid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				
				<expr_stmt><expr><name>executed_node_list</name> <operator>=</operator> <call><name>list_append_unique_int</name><argument_list>(<argument><expr><name>executed_node_list</name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>executed_node_list</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>need_global_snapshot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>==</operator> <name>EXEC_ON_COORDS</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>connections</name> <operator>=</operator> <name><name>pgxc_connections</name><operator>-&gt;</operator><name>coord_handles</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>total_conn_count</name> <operator>=</operator> <name>regular_conn_count</name> <operator>=</operator> <name><name>pgxc_connections</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <expr_stmt><expr><name>need_global_snapshot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>==</operator> <name>EXEC_ON_ALL_NODES</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>total_conn_count</name> <operator>=</operator> <name>regular_conn_count</name> <operator>=</operator>
				<name><name>pgxc_connections</name><operator>-&gt;</operator><name>dn_conn_count</name></name> <operator>+</operator> <name><name>pgxc_connections</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</expr_stmt>
			
			<expr_stmt><expr><name>connections</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>total_conn_count</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>connections</name></expr></argument>, <argument><expr><name><name>pgxc_connections</name><operator>-&gt;</operator><name>datanode_handles</name></name></expr></argument>,
			       <argument><expr><name><name>pgxc_connections</name><operator>-&gt;</operator><name>dn_conn_count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>connections</name> <operator>+</operator> <name><name>pgxc_connections</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr></argument>, <argument><expr><name><name>pgxc_connections</name><operator>-&gt;</operator><name>coord_handles</name></name></expr></argument>,
			       <argument><expr><name><name>pgxc_connections</name><operator>-&gt;</operator><name>co_conn_count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
			<expr_stmt><expr><name>need_global_snapshot</name> <operator>=</operator> <name>g_set_global_snapshot</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/* set snapshot as needed */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_set_global_snapshot</name> <operator>&amp;&amp;</operator> <call><name>SetSnapshot</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>snapshot</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>state</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><name>primaryconnection</name> <operator>=</operator> <name><name>pgxc_connections</name><operator>-&gt;</operator><name>primary_handle</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/* initialize */</comment>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_node_count</name></name> <operator>=</operator> <name>regular_conn_count</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_tuples</name></name>      <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_total_time</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_datarows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/*
         * Primary connection is counted separately but is included in total_conn_count if used.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>primaryconnection</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>regular_conn_count</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * We save only regular connections, at the time we exit the function
         * we finish with the primary connection and deal only with regular
         * connections on subsequent invocations
         */</comment>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>node_count</name></name> <operator>=</operator> <name>regular_conn_count</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Start transaction on data nodes if we are in explicit transaction
		 * or going to use extended query protocol or write to multiple nodes
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>force_autocommit</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>need_tran_block</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>need_tran_block</name> <operator>=</operator> <name><name>step</name><operator>-&gt;</operator><name>cursor</name></name> <operator>||</operator>
					<operator>(</operator><operator>!</operator><name><name>step</name><operator>-&gt;</operator><name>read_only</name></name> <operator>&amp;&amp;</operator> <name>total_conn_count</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator>
					<operator>(</operator><call><name>TransactionBlockStatusCode</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="char">'T'</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<comment type="block">/* Set plpgsql transaction begin for all connections */</comment>
		<if_stmt><if>if <condition>(<expr><name>primaryconnection</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SetPlpgsqlTransactionBegin</name><argument_list>(<argument><expr><name>primaryconnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>regular_conn_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SetPlpgsqlTransactionBegin</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
        <expr_stmt><expr><call><name>stat_statement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>stat_transaction</name><argument_list>(<argument><expr><name>total_conn_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>gxid</name> <operator>=</operator> <call><name>GetCurrentTransactionIdIfAny</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* See if we have a primary node, execute on it first before the others */</comment>
        <if_stmt><if>if <condition>(<expr><name>primaryconnection</name></expr>)</condition>
        <block>{<block_content>    
            <comment type="line">//elog(LOG, "[PLPGSQL]ExecRemoteQuery has primaryconnection");</comment>
            <comment type="line">//primaryconnection-&gt;read_only = true;</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name></name> <operator>=</operator> <operator>&amp;</operator><name>primaryconnection</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<if_stmt><if>if <condition>(<expr><call><name>pgxc_node_begin</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>primaryconnection</name></expr></argument>, <argument><expr><name>gxid</name></expr></argument>, <argument><expr><name>need_tran_block</name></expr></argument>,
								<argument><expr><name><name>step</name><operator>-&gt;</operator><name>read_only</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not begin transaction on data node:%s."</literal></expr></argument>,
								 <argument><expr><name><name>primaryconnection</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* If explicit transaction is needed gxid is already sent */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgxc_start_command_on_connection</name><argument_list>(<argument><expr><name>primaryconnection</name></expr></argument>,
												  <argument><expr><name>node</name></expr></argument>,
												  <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pgxc_node_remote_abort</name><argument_list>(<argument><expr><name>TXN_TYPE_RollbackTxn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>pgxc_connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send command to data nodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>==</operator> <name>COMBINE_TYPE_SAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pgxc_node_receive</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>primaryconnection</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Make sure the command is completed on the primary node */</comment>
			<while>while <condition>(<expr><name>true</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>handle_response</name><argument_list>(<argument><expr><name>primaryconnection</name></expr></argument>, <argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_READY</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_EOF</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pgxc_node_receive</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>primaryconnection</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_COMPLETE</name> <operator>||</operator> <name>res</name> <operator>==</operator> <name>RESPONSE_ERROR</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_COMPLETE</name> <operator>&amp;&amp;</operator>
						<name><name>primaryconnection</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unexpected FATAL ERROR on Connection to Datanode %s pid %d"</literal></expr></argument>,
										<argument><expr><name><name>primaryconnection</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>,
										<argument><expr><name><name>primaryconnection</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					</block_content>}</block></if></if_stmt>
				    <comment type="block">/* Get ReadyForQuery */</comment>
					<continue>continue;</continue>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_ASSIGN_GXID</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unexpected response from data node"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></while>
			<if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pgxc_node_report_error</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>regular_conn_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name></name> <operator>=</operator> <name>connections</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>=</operator> <name>regular_conn_count</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>regular_conn_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="line">//connections[i]-&gt;read_only = true;</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<expr_stmt><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>recv_datarows</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<if_stmt><if>if <condition>(<expr><call><name>pgxc_node_begin</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>gxid</name></expr></argument>, <argument><expr><name>need_tran_block</name></expr></argument>,
								<argument><expr><name><name>step</name><operator>-&gt;</operator><name>read_only</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not begin transaction on data node:%s."</literal></expr></argument>,
								 <argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nodename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* If explicit transaction is needed gxid is already sent */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgxc_start_command_on_connection</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pgxc_node_remote_abort</name><argument_list>(<argument><expr><name>TXN_TYPE_RollbackTxn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>pgxc_connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send command to data nodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>combiner</name> <operator>=</operator> <name>combiner</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>cursor</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>conn_size</name> <init>= <expr><name>regular_conn_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name> <operator>=</operator> <name><name>step</name><operator>-&gt;</operator><name>cursor</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_count</name></name> <operator>=</operator> <name>regular_conn_count</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_connections</name></name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>conn_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_connections</name></name></expr></argument>, <argument><expr><name>connections</name></expr></argument>, <argument><expr><name>conn_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name></name> <operator>=</operator> <name>connections</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>=</operator> <name>regular_conn_count</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_count</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>cursor_count</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>connections</name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_connections</name></name></expr></argument>,
                   <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name></name> <operator>=</operator> <name>connections</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>query_Done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>sort</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SimpleSort</name> <modifier>*</modifier></type><name>sort</name> <init>= <expr><name><name>step</name><operator>-&gt;</operator><name>sort</name></name></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * First message is already in the buffer
             * Further fetch will be under tuplesort control
             * If query does not produce rows tuplesort will not
             * be initialized
             */</comment>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tuplesortstate</name></name> <operator>=</operator> <call><name>tuplesort_begin_merge</name><argument_list>(
                                   <argument><expr><name><name>resultslot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
                                   <argument><expr><name><name>sort</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>,
                                   <argument><expr><name><name>sort</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
                                   <argument><expr><name><name>sort</name><operator>-&gt;</operator><name>sortOperators</name></name></expr></argument>,
                                   <argument><expr><name><name>sort</name><operator>-&gt;</operator><name>sortCollations</name></name></expr></argument>,
                                   <argument><expr><name><name>sort</name><operator>-&gt;</operator><name>nullsFirst</name></name></expr></argument>,
                                   <argument><expr><name>combiner</name></expr></argument>,
                                   <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>tuplesortstate</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>tuplesort_gettupleslot</name><argument_list>(<argument><expr><operator>(</operator><name>Tuplesortstate</name> <operator>*</operator><operator>)</operator> <name><name>combiner</name><operator>-&gt;</operator><name>tuplesortstate</name></name></expr></argument>,
                                      <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>resultslot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>resultslot</name></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>resultslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>FetchTuple</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>slot</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pgxc_node_report_error</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"FetchTuple: recv_node_count:%d, recv_tuples:%lu, "</literal>
                    <literal type="string">"recv_total_time:%ld, avg_time:%lf."</literal></expr></argument>,
                    <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_node_count</name></name></expr></argument>,<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_tuples</name></name></expr></argument>,
                    <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_total_time</name></name></expr></argument>,
                    <argument><expr><ternary><condition><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_tuples</name></name></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name><name>combiner</name><operator>-&gt;</operator><name>recv_total_time</name></name><operator>)</operator><operator>/</operator>
                    <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name><name>combiner</name><operator>-&gt;</operator><name>recv_tuples</name></name><operator>)</operator></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecReScanRemoteQuery
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecReScanRemoteQuery</name><parameter_list>(<parameter><decl><type><name>RemoteQueryState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name> <init>= <expr><operator>(</operator><name>ResponseCombiner</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * If we haven't queried remote nodes yet, just return. If outerplan'
     * chgParam is not NULL then it will be re-scanned by ExecProcNode,
     * else - no reason to re-scan it at all.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>query_Done</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If we execute locally rescan local copy of the plan
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Consume any possible pending input
     */</comment>
    <expr_stmt><expr><call><name>pgxc_connections_cleanup</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* misc cleanup */</comment>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>command_complete_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>description_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Force query is re-bound with new parameters
     */</comment>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>query_Done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * Clean up and discard any data on the data node connections that might not
 * handled yet, including pending on the remote connection.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgxc_connections_cleanup</name><parameter_list>(<parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives    </comment>
    <decl_stmt><decl><type><name>int32</name></type>    <name>ret</name>     <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name>  <operator>=</operator> <name>END_QUERY_TIMEOUT</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <operator>(</operator><name>END_QUERY_TIMEOUT</name> <operator>%</operator> <literal type="number">1000</literal><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
            
    <comment type="block">/* clean up the buffer */</comment>
    <expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>rowBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>rowBuffer</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* clean up tuplestore */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>merge_sort</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>prerowBuffers</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name> <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowBuffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>nDataRows</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>dataRowMemSize</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Read in and discard remaining data from the connections, if any
     */</comment>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Possible if we are doing merge sort.
         * We can do usual procedure and move connections around since we are
         * cleaning up and do not care what connection at what position
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>conn</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>REMOVE_CURR_CONN</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* throw away current message that may be in the buffer */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pgxc_node_receive</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition>
        <block>{<block_content>
            <switch>switch <condition>(<expr><name>ret</name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>DNStatus_ERR</name></expr>:</case>                    
                    <block>{<block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Failed to read response from data node:%s pid:%d when ending query for ERROR, node status:%d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block>
                    
                <case>case <expr><name>DNStatus_EXPIRED</name></expr>:</case>                            
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Failed to read response from data node:%s pid:%d when ending query for EXPIRED, node status:%d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block>    
                <default>default:</default>
                    <block>{<block_content>
                        <comment type="block">/* Can not be here.*/</comment>
                        <break>break;</break>
                    </block_content>}</block>
            </block_content>}</block></switch>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>handle_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_EOF</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Continue to consume the data, until all connections are abosulately done. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_is_data_enqueued</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>proc_exit_inprogress</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>DNConnectionState</name></type> <name>state</name> <init>= <expr><name>DN_CONNECTION_STATE_IDLE</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>state</name>       <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>state</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>DN_CONNECTION_STATE_QUERY</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pgxc_node_receive</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition>
                <block>{<block_content>
                    <switch>switch <condition>(<expr><name>ret</name></expr>)</condition>
                    <block>{<block_content>
                        <case>case <expr><name>DNStatus_ERR</name></expr>:</case>                    
                            <block>{<block_content>
								<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Failed to read response from data node:%u when ending query for ERROR, state:%d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <break>break;</break>
                            </block_content>}</block>
                            
                        <case>case <expr><name>DNStatus_EXPIRED</name></expr>:</case>                            
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Failed to read response from data node:%u when ending query for EXPIRED, state:%d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <break>break;</break>
                            </block_content>}</block>    
                        <default>default:</default>
                            <block>{<block_content>
                                <comment type="block">/* Can not be here.*/</comment>
                                <break>break;</break>
                            </block_content>}</block>
                    </block_content>}</block></switch>
                </block_content>}</block></if></if_stmt>
                
                <if_stmt><if>if <condition>(<expr><name>DN_CONNECTION_STATE_IDLE</name> <operator>==</operator> <name>state</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><operator>!</operator><name>proc_exit_inprogress</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DN_CONNECTION_STATE_QUERY</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>=</operator> <operator>(</operator><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>RESPONSE_ERROR</name> <operator>==</operator> <name>res</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>needSync</name></name></expr>)</condition>
            <block>{<block_content>                
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_sync</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to sync msg to node:%s pid:%d when clean"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                    
                </block_content>}</block></if></if_stmt>
                
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>            
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Succeed to sync msg to node:%s pid:%d when clean"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                                    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>needSync</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

            </block_content>}</block></if></if_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if type="elseif">else if <condition>(<expr><name>RESPONSE_COPY</name> <operator>==</operator> <name>res</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>is_abort</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DN_CONNECTION_STATE_COPY_IN</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>DataNodeCopyEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        
            
        <comment type="block">/* no data is expected */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DN_CONNECTION_STATE_IDLE</name> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr>)</condition>
        <block>{<block_content>
                        
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifdef>    
            <decl_stmt><decl><type><name>int32</name></type> <name>nbytes</name> <init>= <expr><call><name>pgxc_node_is_data_enqueued</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>)</condition>
            <block>{<block_content>

                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node:%s pid:%d status:%d %d bytes dataleft over."</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                             

            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>REMOVE_CURR_CONN</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Connection owner is different, so no our data pending at
         * the connection, nothing to read in.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>combiner</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>combiner</name></name> <operator>!=</operator> <name>combiner</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"pgxc_connections_cleanup is different, remove connection:%s"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>REMOVE_CURR_CONN</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        
    </block_content>}</block></while>

    <comment type="block">/*
     * Release tuplesort resources
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>tuplesortstate</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Free these before tuplesort_end, because these arrays may appear
         * in the tuplesort's memory context, tuplesort_end deletes this
         * context and may invalidate the memory.
         * We still want to free them here, because these may be in different
         * context.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>tapenodes</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>tapenodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tapenodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>tapemarks</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>tapemarks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tapemarks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/*
         * tuplesort_end invalidates minimal tuple if it is in the slot because
         * deletes the TupleSort memory context, causing seg fault later when
         * releasing tuple table
         */</comment>
        <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><operator>(</operator><name>Tuplesortstate</name> <operator>*</operator><operator>)</operator> <name><name>combiner</name><operator>-&gt;</operator><name>tuplesortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tuplesortstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * End the remote query
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndRemoteQuery</name><parameter_list>(<parameter><decl><type><name>RemoteQueryState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name> <init>= <expr><operator>(</operator><name>ResponseCombiner</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Clean up remote connections
     */</comment>
    <expr_stmt><expr><call><name>pgxc_connections_cleanup</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Clean up parameters if they were set, since plan may be reused
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>paramval_data</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>paramval_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>paramval_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>paramval_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>CloseCombiner</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************
 *
 * Routines to support RemoteSubplan plan node
 *
 **********************************************/</comment>


<comment type="block">/*
 * The routine walks recursively over the plan tree and changes cursor names of
 * RemoteSubplan nodes to make them different from launched from the other
 * datanodes. The routine changes cursor names in place, so caller should
 * take writable copy of the plan tree.
 */</comment>
<function><type><name>void</name></type>
<name>RemoteSubplanMakeUnique</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>unique</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>(List *) plan</argument>)</argument_list></macro>
        <block>{<block_content>
			<expr_stmt><expr><call><name>RemoteSubplanMakeUnique</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>unique</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Transform SharedQueue name
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>RemoteSubplan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
	    <comment type="block">/*
	     * add node information and pid to make it unique
	     */</comment>
        <expr_stmt><expr><operator>(</operator><operator>(</operator><name>RemoteSubplan</name> <operator>*</operator><operator>)</operator><name>plan</name><operator>)</operator><operator>-&gt;</operator><name>unique</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int64</name><operator>)</operator><name>unique</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>|</operator> <name>pid</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Otherwise it is a Plan descendant */</comment>
	<expr_stmt><expr><call><name>RemoteSubplanMakeUnique</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>lefttree</name></expr></argument>, <argument><expr><name>unique</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RemoteSubplanMakeUnique</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>righttree</name></expr></argument>, <argument><expr><name>unique</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Tranform special cases */</comment>
    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_Append</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoteSubplanMakeUnique</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>Append</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>appendplans</name></expr></argument>,
									<argument><expr><name>unique</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_MergeAppend</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoteSubplanMakeUnique</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>MergeAppend</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>mergeplans</name></expr></argument>,
									<argument><expr><name>unique</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_BitmapAnd</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoteSubplanMakeUnique</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>BitmapAnd</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>bitmapplans</name></expr></argument>,
									<argument><expr><name>unique</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_BitmapOr</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoteSubplanMakeUnique</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>BitmapOr</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>bitmapplans</name></expr></argument>,
									<argument><expr><name>unique</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_SubqueryScan</name></expr>:</case>
            <expr_stmt><expr><call><name>RemoteSubplanMakeUnique</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>subplan</name></expr></argument>,
									<argument><expr><name>unique</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>determine_param_types_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>find_params_context</name></name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Param</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>paramno</name> <init>= <expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_EXEC</name> <operator>&amp;&amp;</operator>
                <call><name>bms_is_member</name><argument_list>(<argument><expr><name>paramno</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>defineParams</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RemoteParam</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>rparams</name></name></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><name><name>cur</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>!=</operator> <name>PARAM_EXEC</name> <operator>||</operator> <name><name>cur</name><operator>-&gt;</operator><name>paramid</name></name> <operator>!=</operator> <name>paramno</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>cur</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
            <expr_stmt><expr><name><name>cur</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>defineParams</name></name> <operator>=</operator> <call><name>bms_del_member</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>defineParams</name></name></expr></argument>,
                                                   <argument><expr><name>paramno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>defineParams</name></name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>subplans</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SubPlan</name> <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><call><name>list_nth</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>plan_id</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>determine_param_types</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
        
    <return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>determine_param_types_walker</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<comment type="block">/*
 * Scan expressions in the plan tree to find Param nodes and get data types
 * from them
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>determine_param_types</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,  <parameter><decl><type><name><name>struct</name> <name>find_params_context</name></name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>intersect</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>intersect</name> <operator>=</operator> <call><name>bms_intersect</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>allParam</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>defineParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>intersect</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* the subplan does not depend on params we are interested in */</comment>
        <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>intersect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>intersect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* scan target list */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
                               <argument><expr><name>determine_param_types_walker</name></expr></argument>,
                               <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    <comment type="block">/* scan qual */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>,
                               <argument><expr><name>determine_param_types_walker</name></expr></argument>,
                               <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Check additional node-type-specific fields */</comment>
    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_Result</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>Result</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>resconstantqual</name></expr></argument>,
                                       <argument><expr><name>determine_param_types_walker</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SeqScan</name></expr>:</case>
        <case>case <expr><name>T_SampleScan</name></expr>:</case>
        <case>case <expr><name>T_CteScan</name></expr>:</case>
            <break>break;</break>

        <case>case <expr><name>T_IndexScan</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>IndexScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>indexqual</name></expr></argument>,
                                       <argument><expr><name>determine_param_types_walker</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>indexqual</name></expr></argument>,
                                       <argument><expr><name>determine_param_types_walker</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>BitmapIndexScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>indexqual</name></expr></argument>,
                                       <argument><expr><name>determine_param_types_walker</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>BitmapHeapScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>bitmapqualorig</name></expr></argument>,
                                       <argument><expr><name>determine_param_types_walker</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_TidScan</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>TidScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>tidquals</name></expr></argument>,
                                       <argument><expr><name>determine_param_types_walker</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SubqueryScan</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>determine_param_types</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>subplan</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_FunctionScan</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>FunctionScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>functions</name></expr></argument>,
                                       <argument><expr><name>determine_param_types_walker</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ValuesScan</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>ValuesScan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>values_lists</name></expr></argument>,
                                       <argument><expr><name>determine_param_types_walker</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ModifyTable</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

                <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((ModifyTable *) plan)-&gt;plans</argument>)</argument_list></macro>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>determine_param_types</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
                </block_content>}</block>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_RemoteSubplan</name></expr>:</case>
            <break>break;</break>

        <case>case <expr><name>T_Append</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

                <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((Append *) plan)-&gt;appendplans</argument>)</argument_list></macro>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>determine_param_types</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
                </block_content>}</block>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_MergeAppend</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

                <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((MergeAppend *) plan)-&gt;mergeplans</argument>)</argument_list></macro>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>determine_param_types</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
                </block_content>}</block>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_BitmapAnd</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

                <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((BitmapAnd *) plan)-&gt;bitmapplans</argument>)</argument_list></macro>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>determine_param_types</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
                </block_content>}</block>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_BitmapOr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

                <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((BitmapOr *) plan)-&gt;bitmapplans</argument>)</argument_list></macro>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>determine_param_types</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
                </block_content>}</block>
            </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>T_NestLoop</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>joinqual</name></expr></argument>,
                                       <argument><expr><name>determine_param_types_walker</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_MergeJoin</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>joinqual</name></expr></argument>,
                                       <argument><expr><name>determine_param_types_walker</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>MergeJoin</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>mergeclauses</name></expr></argument>,
                                       <argument><expr><name>determine_param_types_walker</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_HashJoin</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>Join</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>joinqual</name></expr></argument>,
                                       <argument><expr><name>determine_param_types_walker</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>HashJoin</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>hashclauses</name></expr></argument>,
                                       <argument><expr><name>determine_param_types_walker</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_Limit</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>Limit</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>limitOffset</name></expr></argument>,
                                       <argument><expr><name>determine_param_types_walker</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>Limit</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>limitCount</name></expr></argument>,
                                       <argument><expr><name>determine_param_types_walker</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            <break>break;</break>

        <case>case <expr><name>T_RecursiveUnion</name></expr>:</case>
            <break>break;</break>

        <case>case <expr><name>T_LockRows</name></expr>:</case>
            <break>break;</break>

        <case>case <expr><name>T_WindowAgg</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>WindowAgg</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>startOffset</name></expr></argument>,
                                       <argument><expr><name>determine_param_types_walker</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <if_stmt><if>if <condition>(<expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>WindowAgg</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>endOffset</name></expr></argument>,
                                       <argument><expr><name>determine_param_types_walker</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

        <case>case <expr><name>T_Gather</name></expr>:</case>
        <case>case <expr><name>T_Hash</name></expr>:</case>
        <case>case <expr><name>T_Agg</name></expr>:</case>
        <case>case <expr><name>T_Material</name></expr>:</case>
        <case>case <expr><name>T_Sort</name></expr>:</case>
        <case>case <expr><name>T_Unique</name></expr>:</case>
        <case>case <expr><name>T_SetOp</name></expr>:</case>
        <case>case <expr><name>T_Group</name></expr>:</case>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <comment type="block">/* check initplan if exists */</comment>
    <if_stmt><if>if<condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>initPlan</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>plan-&gt;initPlan</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SubPlan</name>  <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if<condition>(<expr><call><name>determine_param_types_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>subplan</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* recurse into subplans */</comment>
    <return>return <expr><call><name>determine_param_types</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call> <operator>||</operator>
            <call><name>determine_param_types</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>RemoteSubplanState</name> <modifier>*</modifier></type>
<name>ExecInitRemoteSubplan</name><parameter_list>(<parameter><decl><type><name>RemoteSubplan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>RemoteStmt</name></type>            <name>rstmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteSubplanState</name> <modifier>*</modifier></type><name>remotestate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResponseCombiner</name>   <modifier>*</modifier></type><name>combiner</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CombineType</name></type>            <name>combineType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>rusage</name></name></type>        <name>start_r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type>        <name>start_t</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Oid</name></type>                 <name>groupid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>                    <name>reloid</name>  <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>log_remotesubplan_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ResetUsageCommon</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start_r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>rstmt</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RemoteStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>remotestate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteSubplanState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>combiner</name> <operator>=</operator> <operator>(</operator><name>ResponseCombiner</name> <operator>*</operator><operator>)</operator> <name>remotestate</name></expr>;</expr_stmt>
    <comment type="block">/*
     * We do not need to combine row counts if we will receive intermediate
     * results or if we won't return row count.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>||</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>combineType</name> <operator>=</operator> <name>COMBINE_TYPE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>remotestate</name><operator>-&gt;</operator><name>execOnAll</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>execOnAll</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>execOnAll</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>combineType</name> <operator>=</operator> <name>COMBINE_TYPE_SUM</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>combineType</name> <operator>=</operator> <name>COMBINE_TYPE_SAME</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <comment type="block">/*
         * If we are updating replicated table we should run plan on all nodes.
         * We are choosing single node only to read
         */</comment>
        <expr_stmt><expr><name><name>remotestate</name><operator>-&gt;</operator><name>execOnAll</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>remotestate</name><operator>-&gt;</operator><name>execNodes</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>InitResponseCombiner</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>combineType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecRemoteSubplan</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>
		
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RemoteInstrKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RemoteInstr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		
		<expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_instr_htbl</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Remote Instrument"</literal></expr></argument>, <argument><expr><literal type="number">8</literal> <operator>*</operator> <name>NumDataNodes</name></expr></argument>,
		                                        <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>remote_parallel_estimated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>request_type</name></name> <operator>=</operator> <name>REQUEST_TYPE_QUERY</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ExecInitResultTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecAssignResultTypeFromTL</name><argument_list>(<argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>remotestate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>g_set_global_snapshot</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_global_snapshot</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>node_count</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            
            <if_stmt><if>if <condition>(<expr><name>node_count</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>need_global_snapshot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>node_count</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>executed_node_list</name> <operator>=</operator> <call><name>list_append_unique_int</name><argument_list>(<argument><expr><name>executed_node_list</name></expr></argument>, <argument><expr><call><name>linitial_int</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>executed_node_list</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>need_global_snapshot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * We optimize execution if we going to send down query to next level
     */</comment>
    <expr_stmt><expr><name><name>remotestate</name><operator>-&gt;</operator><name>local_exec</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>remotestate</name><operator>-&gt;</operator><name>execNodes</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Special case, if subplan is not distributed, like Result, or
             * query against catalog tables only.
             * We are only interested in filtering out the subplan results and
             * get only those we are interested in.
             * XXX we may want to prevent multiple executions in this case
             * either, to achieve this we will set single execNode on planning
             * time and this case would never happen, this code branch could
             * be removed.
             */</comment>
            <expr_stmt><expr><name><name>remotestate</name><operator>-&gt;</operator><name>local_exec</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>remotestate</name><operator>-&gt;</operator><name>execOnAll</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * XXX We should change planner and remove this flag.
             * We want only one node is producing the replicated result set,
             * and planner should choose that node - it is too hard to determine
             * right node at execution time, because it should be guaranteed
             * that all consumers make the same decision.
             * For now always execute replicated plan on local node to save
             * resources.
             */</comment>

            <comment type="block">/*
             * Make sure local node is in execution list
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>list_member_int</name><argument_list>(<argument><expr><name><name>remotestate</name><operator>-&gt;</operator><name>execNodes</name></name></expr></argument>, <argument><expr><name>PGXCNodeId</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>remotestate</name><operator>-&gt;</operator><name>execNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>remotestate</name><operator>-&gt;</operator><name>execNodes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>remotestate</name><operator>-&gt;</operator><name>local_exec</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * To support, we need to connect to some producer, so
                 * each producer should be prepared to serve rows for random
                 * number of consumers. It is hard, because new consumer may
                 * connect after producing is started, on the other hand,
                 * absence of expected consumer is a problem too.
                 */</comment>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Getting replicated results from remote node is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If we are going to execute subplan locally or doing explain initialize
     * the subplan. Otherwise have remote node doing that.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>remotestate</name><operator>-&gt;</operator><name>local_exec</name></name> <operator>||</operator> <operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>remotestate</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>estate</name></expr></argument>,
                                                   <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>distributionNodes</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>         <name>distributionType</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TupleDesc</name></type>     <name>typeInfo</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>typeInfo</name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>distributionKey</name></name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>attr</name> <operator>=</operator> <name><name>typeInfo</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>distributionKey</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>distributionType</name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* Set up locator */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>        
            <macro><name>foreach</name><argument_list>(<argument>table</argument>, <argument>estate-&gt;es_range_table</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>tbl_entry</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>tbl_entry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>reloid</name> <operator>=</operator> <name><name>tbl_entry</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"[ExecInitRemoteSubplan]reloid=%d"</literal></expr></argument>, <argument><expr><name>reloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <expr_stmt><expr><name>groupid</name> <operator>=</operator> <call><name>GetRelGroup</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"[ExecInitRemoteSubplan]groupid=%d"</literal></expr></argument>, <argument><expr><name>groupid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
            <expr_stmt><expr><name><name>remotestate</name><operator>-&gt;</operator><name>locator</name></name> <operator>=</operator> <call><name>createLocator</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>distributionType</name></name></expr></argument>,
                                                 <argument><expr><name>RELATION_ACCESS_INSERT</name></expr></argument>,
                                                 <argument><expr><name>distributionType</name></expr></argument>,
                                                 <argument><expr><name>LOCATOR_LIST_LIST</name></expr></argument>,
                                                 <argument><expr><literal type="number">0</literal></expr></argument>,
                                                 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>distributionNodes</name></name></expr></argument>,
                                                 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>remotestate</name><operator>-&gt;</operator><name>dest_nodes</name></name></expr></argument>,
                                                 <argument><expr><name>false</name></expr></argument>,
                                                 <argument><expr><name>groupid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidAttrNumber</name></expr></argument>,
                                                 <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><name><name>remotestate</name><operator>-&gt;</operator><name>locator</name></name> <operator>=</operator> <call><name>createLocator</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>distributionType</name></name></expr></argument>,
                                                 <argument><expr><name>RELATION_ACCESS_INSERT</name></expr></argument>,
                                                 <argument><expr><name>distributionType</name></expr></argument>,
                                                 <argument><expr><name>LOCATOR_LIST_LIST</name></expr></argument>,
                                                 <argument><expr><literal type="number">0</literal></expr></argument>,
                                                 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>distributionNodes</name></name></expr></argument>,
                                                 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>remotestate</name><operator>-&gt;</operator><name>dest_nodes</name></name></expr></argument>,
                                                 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>remotestate</name><operator>-&gt;</operator><name>locator</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Encode subplan if it will be sent to remote nodes
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>remotestate</name><operator>-&gt;</operator><name>execNodes</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ParamListInfo</name></type> <name>ext_params</name></decl>;</decl_stmt>
        <comment type="block">/* Encode plan if we are going to execute it on other nodes */</comment>
        <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_RemoteStmt</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_NONE</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_DATANODE</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * There are cases when planner can not determine distribution of a
             * subplan, in particular it does not determine distribution of
             * subquery nodes. Such subplans executed from current location
             * (node) and combine all results, like from coordinator nodes.
             * However, if there are multiple locations where distributed
             * executor is running this node, and there are more of
             * RemoteSubplan plan nodes in the subtree there will be a problem -
             * Instances of the inner RemoteSubplan nodes will be using the same
             * SharedQueue, causing error. To avoid this problem we should
             * traverse the subtree and change SharedQueue name to make it
             * unique.
             */</comment>
			<expr_stmt><expr><call><name>RemoteSubplanMakeUnique</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PGXCNodeId</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"RemoteSubplanMakeUnique for LOCATOR_TYPE_NONE unique: %d, cursor: %s"</literal></expr></argument>,
                 <argument><expr><name>PGXCNodeId</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>planTree</name></name> <operator>=</operator> <call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * If datanode launch further execution of a command it should tell
         * it is a SELECT, otherwise secondary data nodes won't return tuples
         * expecting there will be nothing to return.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ModifyTable</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>commandType</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>hasReturning</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>hasReturning</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>resultRelations</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>resultRelations</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>hasReturning</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>resultRelations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>rtable</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>subplans</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>subplans</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>nParamExec</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>nParamExec</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ext_params</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>nParamRemote</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>ext_params</name></expr> ?</condition><then> <expr><name><name>ext_params</name><operator>-&gt;</operator><name>numParams</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>
                <call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>allParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>rstmt</name><operator>.</operator><name>nParamRemote</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>tmpset</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>paramno</name></decl>;</decl_stmt>

            <comment type="block">/* Allocate enough space */</comment>
            <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>remoteparams</name></name> <operator>=</operator> <operator>(</operator><name>RemoteParam</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>rstmt</name><operator>.</operator><name>nParamRemote</name></name> <operator>*</operator>
                                                        <sizeof>sizeof<argument_list>(<argument><expr><name>RemoteParam</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>paramno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ext_params</name></expr>)</condition>
            <block>{<block_content>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ext_params</name><operator>-&gt;</operator><name>numParams</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>&amp;</operator><name><name>ext_params</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <comment type="block">/*
                     * If parameter type is not yet defined but can be defined
                     * do that
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>ext_params</name><operator>-&gt;</operator><name>paramFetch</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call>(<modifier>*</modifier><name><name>ext_params</name><operator>-&gt;</operator><name>paramFetch</name></name>) <argument_list>(<argument><expr><name>ext_params</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="block">/*
                     * If the parameter type is still not defined, assume that
                     * it is unused. But we put a default INT4OID type for such
                     * unused parameters to keep the parameter pushdown code
                     * happy.
                     *
                     * These unused parameters are never accessed during
                     * execution and we will just a null value for these
                     * "dummy" parameters. But including them here ensures that
                     * we send down the parameters in the correct order and at
                     * the position that the datanode needs
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
						<expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>remoteparams</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>.</operator><name>paramused</name> <operator>=</operator>
							<ternary><condition><expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>initPlanParams</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>REMOTE_PARAM_INITPLAN</name></expr> </then><else>: <expr><name>REMOTE_PARAM_SUBPLAN</name></expr></else></ternary></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>remoteparams</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>.</operator><name>paramtype</name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>ptype</name></name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
						<expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>remoteparams</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>.</operator><name>paramused</name> <operator>=</operator> <name>REMOTE_PARAM_UNUSED</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>remoteparams</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>.</operator><name>paramtype</name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>

                    <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>remoteparams</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>.</operator><name>paramkind</name> <operator>=</operator> <name>PARAM_EXTERN</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>remoteparams</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>.</operator><name>paramid</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>paramno</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></for>
                <comment type="block">/* store actual number of parameters */</comment>
                <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>nParamRemote</name></name> <operator>=</operator> <name>paramno</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>allParam</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>defineParams</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>tmpset</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>allParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_first_member</name><argument_list>(<argument><expr><name>tmpset</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prmdata</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>prmdata</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>remoteparams</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>.</operator><name>paramkind</name> <operator>=</operator> <name>PARAM_EXEC</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>remoteparams</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>.</operator><name>paramid</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>remoteparams</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>.</operator><name>paramtype</name> <operator>=</operator> <name><name>prmdata</name><operator>-&gt;</operator><name>ptype</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>remoteparams</name><index>[<expr><name>paramno</name></expr>]</index></name><operator>.</operator><name>paramused</name> <operator>=</operator>
						<ternary><condition><expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>initPlanParams</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>REMOTE_PARAM_INITPLAN</name></expr> </then><else>: <expr><name>REMOTE_PARAM_SUBPLAN</name></expr></else></ternary></expr>;</expr_stmt>
                    <comment type="block">/* Will scan plan tree to find out data type of the param */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>prmdata</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>defineParams</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>defineParams</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>paramno</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></while>
                <comment type="block">/* store actual number of parameters */</comment>
                <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>nParamRemote</name></name> <operator>=</operator> <name>paramno</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>tmpset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>defineParams</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name><name>struct</name> <name>find_params_context</name></name></type> <name>context</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name></type> <name>all_found</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>rparams</name></name> <operator>=</operator> <name><name>rstmt</name><operator>.</operator><name>remoteparams</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>defineParams</name></name> <operator>=</operator> <name>defineParams</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>subplans</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>subplans</name></name></expr>;</expr_stmt>

                    <expr_stmt><expr><name>all_found</name> <operator>=</operator> <call><name>determine_param_types</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>lefttree</name></name></expr></argument>,
                                                      <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/*
                     * Remove not defined params from the list of remote params.
                     * If they are not referenced no need to send them down
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>all_found</name></expr>)</condition>
                    <block>{<block_content>
                        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rstmt</name><operator>.</operator><name>nParamRemote</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name><name>rstmt</name><operator>.</operator><name>remoteparams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>paramkind</name> <operator>==</operator> <name>PARAM_EXEC</name> <operator>&amp;&amp;</operator>
                                    <call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>rstmt</name><operator>.</operator><name>remoteparams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>paramid</name></expr></argument>,
                                                  <argument><expr><name><name>context</name><operator>.</operator><name>defineParams</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <comment type="block">/* Copy last parameter inplace */</comment>
                                <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>nParamRemote</name></name><operator>--</operator></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>rstmt</name><operator>.</operator><name>nParamRemote</name></name></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>remoteparams</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
                                        <name><name>rstmt</name><operator>.</operator><name>remoteparams</name><index>[<expr><name><name>rstmt</name><operator>.</operator><name>nParamRemote</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                                <comment type="block">/* keep current in the same position */</comment>
                                <expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></for>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>defineParams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>remotestate</name><operator>-&gt;</operator><name>nParamRemote</name></name> <operator>=</operator> <name><name>rstmt</name><operator>.</operator><name>nParamRemote</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>remotestate</name><operator>-&gt;</operator><name>remoteparams</name></name> <operator>=</operator> <name><name>rstmt</name><operator>.</operator><name>remoteparams</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>remoteparams</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>rowMarks</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>rowMarks</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>distributionKey</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>distributionKey</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>distributionType</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>distributionType</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>distributionNodes</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>distributionNodes</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>distributionRestrict</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>distributionRestrict</name></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>parallelWorkerSendTuple</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>parallelWorkerSendTuple</name></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>parallelModeNeeded</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>parallelModeNeeded</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>parallelModeNeeded</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>haspart_tobe_modify</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>haspart_tobe_modify</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>haspart_tobe_modify</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>partrelindex</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>partrelindex</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>partpruning</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>partpruning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>haspart_tobe_modify</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>partrelindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>partpruning</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * A try-catch block to ensure that we don't leave behind a stale state
         * if nodeToString fails for whatever reason.
         *
         * XXX We should probably rewrite it someday by either passing a
         * context to nodeToString() or remembering this information somewhere
         * else which gets reset in case of errors. But for now, this seems
         * enough.
         */</comment>
        <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name>set_portable_output</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
            <comment type="block">/* 
             * parseTree and queryString will be only send once while 
             * init the first RemoteSubplan in the whole plan tree
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <call><name>IsConnFromApp</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> 
                <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>parseTree</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                <name><name>estate</name><operator>-&gt;</operator><name>es_remote_subplan_num</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>queryString</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_sourceText</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>parseTree</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>parseTree</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_remote_subplan_num</name></name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name><name>remotestate</name><operator>-&gt;</operator><name>subplanstr</name></name> <operator>=</operator> <call><name>nodeToString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT__</name></cpp:ifdef>
            <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>queryString</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>rstmt</name><operator>.</operator><name>parseTree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog_node_display</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"SendPlanMessage"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rstmt</name></expr></argument>, <argument><expr><name>Debug_pretty_print</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block>
        <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <block>{<block_content>
            <expr_stmt><expr><call><name>set_portable_output</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>set_portable_output</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Connect to remote nodes and send down subplan.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_SUBPLAN</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <expr_stmt><expr><name><name>remotestate</name><operator>-&gt;</operator><name>eflags</name></name> <operator>=</operator> <name>eflags</name></expr>;</expr_stmt>
            <comment type="block">/* In parallel worker, no init, do it until we start to run. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="line">//ExecFinishInitRemoteSubplan(remotestate);</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <comment type="block">/* Not parallel aware, build connections. */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>parallel_aware</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ExecFinishInitRemoteSubplan</name><argument_list>(<argument><expr><name>remotestate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* In session process, if we are under gather, do nothing. */</comment>
                </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>remotestate</name><operator>-&gt;</operator><name>bound</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <comment type="block">/*
     * It does not makes sense to merge sort if there is only one tuple source.
     * By the contract it is already sorted
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>sort</name></name> <operator>&amp;&amp;</operator> <name><name>remotestate</name><operator>-&gt;</operator><name>execOnAll</name></name> <operator>&amp;&amp;</operator>
            <call><name>list_length</name><argument_list>(<argument><expr><name><name>remotestate</name><operator>-&gt;</operator><name>execNodes</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>merge_sort</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_remotesubplan_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ShowUsageCommon</name><argument_list>(<argument><expr><literal type="string">"ExecInitRemoteSubplan"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>remotestate</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>ExecFinishInitRemoteSubplan</name><parameter_list>(<parameter><decl><type><name>RemoteSubplanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ResponseCombiner</name>   <modifier>*</modifier></type><name>combiner</name> <init>= <expr><operator>(</operator><name>ResponseCombiner</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteSubplan</name>         <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>RemoteSubplan</name> <operator>*</operator><operator>)</operator> <name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EState</name>               <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>                   <modifier>*</modifier></type><name>paramtypes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GlobalTransactionId</name></type> <name>gxid</name> <init>= <expr><name>InvalidGlobalTransactionId</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Snapshot</name></type>            <name>snapshot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type>            <name>timestamp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                 <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>                <name>is_read_only</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>                <name><name>cursor</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>finish_init</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Name is required to store plan as a statement
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>unique</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%s_"</literal><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>unique</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* If it is alreaty fully initialized nothing to do */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* local only or explain only execution */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>subplanstr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* 
     * Check if any results are planned to be received here.
     * Otherwise it does not make sense to send out the subplan.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <name><name>plan</name><operator>-&gt;</operator><name>distributionRestrict</name></name> <operator>&amp;&amp;</operator> 
            <operator>!</operator><call><name>list_member_int</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>distributionRestrict</name></name></expr></argument>, <argument><expr><name>PGXCNodeId</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Acquire connections and send down subplan where it will be stored
     * as a prepared statement.
     * That does not require transaction id or snapshot, so does not send them
     * here, postpone till bind.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>execOnAll</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>pgxc_connections</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>pgxc_connections</name> <operator>=</operator> <call><name>get_handles</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>execNodes</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>=</operator> <name><name>pgxc_connections</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name></name> <operator>=</operator> <name><name>pgxc_connections</name><operator>-&gt;</operator><name>datanode_handles</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pgxc_connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name></name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>get_any_handle</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>execNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>gxid</name> <operator>=</operator> <call><name>GetCurrentTransactionIdIfAny</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* extract parameter data types */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nParamRemote</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>paramtypes</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nParamRemote</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nParamRemote</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>paramtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>remoteparams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>paramtype</name></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* send down subplan */</comment>
    <expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>GetCurrentGTMStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* set snapshot as needed */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_set_global_snapshot</name> <operator>&amp;&amp;</operator> <call><name>SetSnapshot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>snapshot</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Datanode should not send down statements that may modify
     * the database. Potgres assumes that all sessions under the same
     * postmaster have different xids. That may cause a locking problem.
     * Shared locks acquired for reading still work fine.
     */</comment>
    <expr_stmt><expr><name>is_read_only</name> <operator>=</operator> <name>IS_PGXC_DATANODE</name> <operator>||</operator>
            <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ModifyTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<comment type="block">/* Set plpgsql transaction begin for all connections */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SetPlpgsqlTransactionBegin</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    for (i = 0; i &lt; combiner-&gt;conn_count; i++)
    {
        PGXCNodeHandle *connection_tmp = combiner-&gt;connections[i];
        if (g_in_plpgsql_exec_fun &amp;&amp; need_begin_txn)
        {
            connection_tmp-&gt;plpgsql_need_begin_txn = true;
            elog(LOG, "[PLPGSQL] ExecFinishInitRemoteSubplan conn nodename:%s backendpid:%d sock:%d need_begin_txn", 
                    connection_tmp-&gt;nodename, connection_tmp-&gt;backend_pid, connection_tmp-&gt;sock);
        }
         if (g_in_plpgsql_exec_fun &amp;&amp; need_begin_sub_txn)
        {
            connection_tmp-&gt;plpgsql_need_begin_sub_txn = true;
            elog(LOG, "[PLPGSQL] ExecFinishInitRemoteSubplan conn nodename:%s backendpid:%d sock:%d need_begin_sub_txn", 
                    connection_tmp-&gt;nodename, connection_tmp-&gt;backend_pid, connection_tmp-&gt;sock);
        }
    }

    if (g_in_plpgsql_exec_fun &amp;&amp; need_begin_txn)
    {
        need_begin_txn =  false;
        elog(LOG, "[PLPGSQL] ExecFinishInitRemoteSubplan need_begin_txn set to false");
    }
    if (g_in_plpgsql_exec_fun &amp;&amp; need_begin_sub_txn)
    {
        need_begin_sub_txn = false;
        elog(LOG, "[PLPGSQL] ExecFinishInitRemoteSubplan need_begin_sub_txn set to false");
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>connection</name> <init>= <expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pgxc_node_begin</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>connection</name></expr></argument>, <argument><expr><name>gxid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>is_read_only</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not begin transaction on data node:%s."</literal></expr></argument>,
							 <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_timestamp</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send command to data nodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>snapshot</name> <operator>&amp;&amp;</operator> <call><name>pgxc_node_send_snapshot</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send snapshot to data nodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_cmd_id</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name><operator>-&gt;</operator><name>curcid</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr> )</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send command ID to data nodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>pgxc_node_send_plan</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>, <argument><expr><literal type="string">"Remote Subplan"</literal></expr></argument>,
							<argument><expr><name><name>node</name><operator>-&gt;</operator><name>subplanstr</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nParamRemote</name></name></expr></argument>, <argument><expr><name>paramtypes</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Plan Message:pid:%d,remote_pid:%d,remote_ip:%s,"</literal>
					  <literal type="string">"remote_port:%d,fd:%d,cursor:%s"</literal></expr></argument>,
				      <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>nodehost</name></name></expr></argument>,
					  <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>nodeport</name></name></expr></argument>, <argument><expr><name><name>connection</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		
		<if_stmt><if>if <condition>(<expr><call><name>pgxc_node_flush</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send subplan to data nodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>append_param_data</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>ptype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pused</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type> <name>n32</name></decl>;</decl_stmt>

    <comment type="block">/* Assume unused parameters to have null values */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pused</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ptype</name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>        <name>typOutput</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>    <name>typIsVarlena</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>    <name>pval</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>pstring</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>        <name>len</name></decl>;</decl_stmt>

        <comment type="block">/* Get info needed to output the value */</comment>
        <expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typOutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIsVarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If we have a toasted datum, forcibly detoast it here to avoid
         * memory leakage inside the type's output routine.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>typIsVarlena</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>pval</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>pval</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* Convert Datum to string */</comment>
        <expr_stmt><expr><name>pstring</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typOutput</name></expr></argument>, <argument><expr><name>pval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* copy data to the buffer */</comment>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>pstring</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>encode_parameters</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nparams</name></decl></parameter>, <parameter><decl><type><name>RemoteParam</name> <modifier>*</modifier></type><name>remoteparams</name></decl></parameter>,
                             <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EState</name>            <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type>    <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16</name></type>             <name>n16</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>             <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprContext</name>       <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>     <name>oldcontext</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ExprContext</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Number of parameter values */</comment>
    <expr_stmt><expr><name>n16</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name>nparams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n16</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Parameter values */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nparams</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RemoteParam</name> <modifier>*</modifier></type><name>rparam</name> <init>= <expr><operator>&amp;</operator><name><name>remoteparams</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>ptype</name> <init>= <expr><name><name>rparam</name><operator>-&gt;</operator><name>paramtype</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>pused</name> <init>= <expr><name><name>rparam</name><operator>-&gt;</operator><name>paramused</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>rparam</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_EXTERN</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>param</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name><operator>-&gt;</operator><name>params</name><index>[<expr><name><name>rparam</name><operator>-&gt;</operator><name>paramid</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>append_param_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>ptype</name></expr></argument>, <argument><expr><name>pused</name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>param</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_param_exec_vals</name><index>[<expr><name><name>rparam</name><operator>-&gt;</operator><name>paramid</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>execPlan</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Parameter not evaluated yet, so go do it */</comment>
                <expr_stmt><expr><call><name>ExecSetParamPlan</name><argument_list>(<argument><expr><operator>(</operator><name>SubPlanState</name> <operator>*</operator><operator>)</operator> <name><name>param</name><operator>-&gt;</operator><name>execPlan</name></name></expr></argument>,
                                 <argument><expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ExprContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* ExecSetParamPlan should have processed this param... */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>execPlan</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>param</name><operator>-&gt;</operator><name>done</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>append_param_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>ptype</name></expr></argument>, <argument><expr><name>pused</name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Take data from the buffer */</comment>
    <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>result</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Encode executor context for EvalPlanQual process including:
 * the number of epqTuples, the ctid and xc_node_id of each tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>encode_epqcontext</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>planstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EState</name> 		   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>planstate</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type> 			<name>n16</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>          <name>n32</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>             <name>ntuples</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_range_table</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>             <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name>	   <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> 	<name>oldcontext</name></decl>;</decl_stmt>
	
	<if_stmt><if>if <condition>(<expr><name><name>planstate</name><operator>-&gt;</operator><name>ps_ExprContext</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>planstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>planstate</name><operator>-&gt;</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* Number of epq tuples */</comment>
	<expr_stmt><expr><name>n16</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name>ntuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n16</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>tid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>           <name>rtidx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>             <name>nodeid</name></decl>;</decl_stmt>
		
		<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTuple</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rtidx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>nodeid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>tid</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_epqTuple</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>t_self</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rtidx</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>nodeid</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_epqTuple</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>t_xc_node_id</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		
		<expr_stmt><expr><name>n16</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name>rtidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n16</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n16</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name><name>tid</name><operator>.</operator><name>ip_blkid</name><operator>.</operator><name>bi_hi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n16</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n16</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name><name>tid</name><operator>.</operator><name>ip_blkid</name><operator>.</operator><name>bi_lo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n16</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n16</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name><name>tid</name><operator>.</operator><name>ip_posid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n16</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	
	<comment type="block">/* Take data from the buffer */</comment>
	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>result</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecRemoteSubplan</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>RemoteSubplanState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>RemoteSubplanState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name> <init>= <expr><operator>(</operator><name>ResponseCombiner</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteSubplan</name>  <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>RemoteSubplan</name> <operator>*</operator><operator>)</operator> <name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EState</name>           <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>resultslot</name> <init>= <expr><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>rusage</name></name></type>    <name>start_r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type>        <name>start_t</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>local_exec</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>finish_init</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_SUBPLAN</name><operator>)</operator><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>execNodes</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ExecFinishInitRemoteSubplan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* 
     * We allow combiner-&gt;conn_count == 0 after node initialization
     * if we figured out that current node won't receive any result
     * because of distributionRestrict is set by planner.
     * But we should distinguish this case from others, when conn_count is 0.
     * That is possible if local execution is chosen or data are buffered 
     * at the coordinator or data are exhausted and node was reset.
     * in last two cases connections are saved to cursor_connections and we
     * can check their presence.  
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>local_exec</name></name> <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> 
            <name><name>combiner</name><operator>-&gt;</operator><name>cursor_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_remotesubplan_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ResetUsageCommon</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start_r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<label><name>primary_mode_phase_two</name>:</label>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>bound</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>fetch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>paramlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>epqctxlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>paramdata</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>epqctxdata</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		
        <comment type="block">/*
         * Conditions when we want to execute query on the primary node first:
         * Coordinator running replicated ModifyTable on multiple nodes
         */</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>primary_mode</name> <init>= <expr><name><name>combiner</name><operator>-&gt;</operator><name>probing_primary</name></name> <operator>||</operator>
                <operator>(</operator><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator>
                 <name><name>combiner</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>==</operator> <name>COMBINE_TYPE_SAME</name> <operator>&amp;&amp;</operator>
                 <call><name>OidIsValid</name><argument_list>(<argument><expr><name>primary_data_node</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                 <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>g_UseDataPump</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>cursor</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>cursor</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>fetch</name> <operator>=</operator> <name>PGXLRemoteFetchSize</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>unique</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%s_"</literal><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>unique</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>cursor</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if<condition>(<expr><name>g_UseDataPump</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* fetch all */</comment>
            <expr_stmt><expr><name>fetch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* get connection's count and handle */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>probing_primary</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>cursor_count</name></name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* initialize */</comment>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_node_count</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_tuples</name></name>     <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_total_time</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_datarows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * Send down all available parameters, if any is used by the plan
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_param_list_info</name></name> <operator>||</operator>
                <operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>allParam</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>paramlen</name> <operator>=</operator> <call><name>encode_parameters</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nParamRemote</name></name></expr></argument>,
                                         <argument><expr><name><name>node</name><operator>-&gt;</operator><name>remoteparams</name></name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>paramdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTuple</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>epqctxlen</name> <operator>=</operator> <call><name>encode_epqcontext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>epqctxdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * The subplan being rescanned, need to restore connections and
         * re-bind the portal
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

            <comment type="block">/*
             * On second phase of primary mode connections are properly set,
             * so do not copy.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>probing_primary</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>cursor_count</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_connections</name></name></expr></argument>,
                            <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>CHECK_OWNERSHIP</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* close previous cursor only on phase 1 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>primary_mode</name> <operator>||</operator> <operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>probing_primary</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>pgxc_node_send_close</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * If we now should probe primary, skip execution on non-primary
                 * nodes
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>primary_mode</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>probing_primary</name></name> <operator>&amp;&amp;</operator>
                        <name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name> <operator>!=</operator> <name>primary_data_node</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <comment type="block">/* rebind */</comment>
                <expr_stmt><expr><call><name>pgxc_node_send_bind</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>,
									<argument><expr><name>paramlen</name></expr></argument>, <argument><expr><name>paramdata</name></expr></argument>, <argument><expr><name>epqctxlen</name></expr></argument>, <argument><expr><name>epqctxdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Bind Message:pid:%d,remote_pid:%d,remote_ip:%s,remote_port:%d,fd:%d,cursor:%s"</literal></expr></argument>,
                              <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodehost</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeport</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* execute */</comment>
                <expr_stmt><expr><call><name>pgxc_node_send_execute</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><name>fetch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* submit */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_flush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send command to data nodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * There could be only one primary node, but can not leave the
                 * loop now, because we need to close cursors.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>primary_mode</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>probing_primary</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>execNodes</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>CommandId</name></type>        <name>cid</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>             <name>i</name></decl>;</decl_stmt>

            <comment type="block">/*
             * There are prepared statement, connections should be already here
             */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>extended_query</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>cid</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name><operator>-&gt;</operator><name>curcid</name></name></expr>;</expr_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>recv_datarows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <expr_stmt><expr><call><name>CHECK_OWNERSHIP</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * If we now should probe primary, skip execution on non-primary
                 * nodes
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>primary_mode</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>probing_primary</name></name> <operator>&amp;&amp;</operator>
                        <name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name> <operator>!=</operator> <name>primary_data_node</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * Update Command Id. Other command may be executed after we
                 * prepare and advanced Command Id. We should use one that
                 * was active at the moment when command started.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_cmd_id</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>cid</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send command ID to data nodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * Resend the snapshot as well since the connection may have
                 * been buffered and use by other commands, with different
                 * snapshot. Set the snapshot back to what it was
                 */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_snapshot</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send snapshot to data nodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* bind */</comment>
				<expr_stmt><expr><call><name>pgxc_node_send_bind</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>paramlen</name></expr></argument>, <argument><expr><name>paramdata</name></expr></argument>,
				                    <argument><expr><name>epqctxlen</name></expr></argument>, <argument><expr><name>epqctxdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Bind Message:pid:%d,remote_pid:%d,remote_ip:%s,remote_port:%d,fd:%d,cursor:%s"</literal></expr></argument>,
                              <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodehost</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeport</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* execute */</comment>
                <expr_stmt><expr><call><name>pgxc_node_send_execute</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>fetch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* submit */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_flush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send command to data nodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * There could be only one primary node, so if we executed
                 * subquery on the phase one of primary mode we can leave the
                 * loop now.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>primary_mode</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>combiner</name><operator>-&gt;</operator><name>probing_primary</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <comment type="block">/*
             * On second phase of primary mode connections are backed up
             * already, so do not copy.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>primary_mode</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>probing_primary</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_count</name></name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_connections</name></name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(
                                <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_connections</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name></name></expr></argument>,
                                <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_count</name></name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_connections</name></name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(
                            <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_connections</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name></name></expr></argument>,
                            <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>merge_sort</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Requests are already made and sorter can fetch tuples to populate
             * sort buffer.
             */</comment>
            <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>tuplesortstate</name></name> <operator>=</operator> <call><name>tuplesort_begin_merge</name><argument_list>(
                                       <argument><expr><name><name>resultslot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>,
                                       <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>sort</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>,
                                       <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>sort</name><operator>-&gt;</operator><name>sortColIdx</name></name></expr></argument>,
                                       <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>sort</name><operator>-&gt;</operator><name>sortOperators</name></name></expr></argument>,
                                       <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>sort</name><operator>-&gt;</operator><name>sortCollations</name></name></expr></argument>,
                                       <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>sort</name><operator>-&gt;</operator><name>nullsFirst</name></name></expr></argument>,
                                       <argument><expr><name>combiner</name></expr></argument>,
                                       <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>primary_mode</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>probing_primary</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>probing_primary</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>bound</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>probing_primary</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>bound</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>tuplesortstate</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>tuplesort_gettupleslot</name><argument_list>(<argument><expr><operator>(</operator><name>Tuplesortstate</name> <operator>*</operator><operator>)</operator> <name><name>combiner</name><operator>-&gt;</operator><name>tuplesortstate</name></name></expr></argument>,
                                   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>resultslot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>log_remotesubplan_stats</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ShowUsageCommon</name><argument_list>(<argument><expr><literal type="string">"ExecRemoteSubplan"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>resultslot</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><call><name>FetchTuple</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>log_remotesubplan_stats</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ShowUsageCommon</name><argument_list>(<argument><expr><literal type="string">"ExecRemoteSubplan"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>slot</name></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>probing_primary</name></name></expr>)</condition><block type="pseudo"><block_content>
            <comment type="block">/* phase1 is successfully completed, run on other nodes */</comment>
            <goto>goto <name>primary_mode_phase_two</name>;</goto></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pgxc_node_report_error</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_remotesubplan_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ShowUsageCommon</name><argument_list>(<argument><expr><literal type="string">"ExecRemoteSubplan"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"FetchTuple: recv_node_count:%d, recv_tuples:%lu, "</literal>
                    <literal type="string">"recv_total_time:%ld, avg_time:%lf."</literal></expr></argument>,
                    <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_node_count</name></name></expr></argument>,<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_tuples</name></name></expr></argument>,
                    <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_total_time</name></name></expr></argument>,
                    <argument><expr><ternary><condition><expr><name><name>combiner</name><operator>-&gt;</operator><name>recv_tuples</name></name></expr> ?</condition><then> <expr><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name><name>combiner</name><operator>-&gt;</operator><name>recv_total_time</name></name><operator>)</operator><operator>/</operator>
                    <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name><name>combiner</name><operator>-&gt;</operator><name>recv_tuples</name></name><operator>)</operator></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>ExecReScanRemoteSubplan</name><parameter_list>(<parameter><decl><type><name>RemoteSubplanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name> <init>= <expr><operator>(</operator><name>ResponseCombiner</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * If we haven't queried remote nodes yet, just return. If outerplan'
     * chgParam is not NULL then it will be re-scanned by ExecProcNode,
     * else - no reason to re-scan it at all.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>bound</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If we execute locally rescan local copy of the plan
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecReScan</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Consume any possible pending input
     */</comment>
    <expr_stmt><expr><call><name>pgxc_connections_cleanup</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* misc cleanup */</comment>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>command_complete_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>description_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Force query is re-bound with new parameters
     */</comment>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>bound</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>EXEC_FLAG_DISCONN</name><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
 * ExecShutdownRemoteSubplan
 * 
 * for instrumentation only, init full planstate tree,
 * then attach recieved remote instrumenation.
 */</comment>
<function><type><name>void</name></type>
<name>ExecShutdownRemoteSubplan</name><parameter_list>(<parameter><decl><type><name>RemoteSubplanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResponseCombiner</name>    <modifier>*</modifier></type><name>combiner</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>combiner</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlanState</name>           <modifier>*</modifier></type><name>ps</name> <init>= <expr><operator>&amp;</operator><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>                <modifier>*</modifier></type><name>plan</name> <init>= <expr><name><name>ps</name><operator>-&gt;</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>              <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>ps</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	
	<comment type="block">/* do nothing if explain only or execute locally */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>local_exec</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"shutdown remote subplan worker %d, plan_node_id %d"</literal></expr></argument>, <argument><expr><name>ParallelWorkerNumber</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>plan_node_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_instrument</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttachRemoteInstrContext</name></type> <name>ctx</name></decl>;</decl_stmt>
		
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ps</name><operator>-&gt;</operator><name>lefttree</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ps</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>EXEC_FLAG_EXPLAIN_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>htab</name></name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>recv_instr_htbl</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>node_idx_List</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RemoteSubplan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>nodeList</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>printed_nodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AttachRemoteInstr</name><argument_list>(<argument><expr><name><name>ps</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecFinishRemoteSubplan</name><parameter_list>(<parameter><decl><type><name>RemoteSubplanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name> <init>= <expr><operator>(</operator><name>ResponseCombiner</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteSubplan</name>    <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>RemoteSubplan</name> <operator>*</operator><operator>)</operator> <name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>dn_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>dn_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>cursor</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_EXPLAIN_ONLY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>bound</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"ExecFinishRemoteSubplan: pid %d not bound, ExecDisconnectRemoteSubplan."</literal></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><call><name>ExecDisconnectRemoteSubplan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>    
        <expr_stmt><expr><name>dn_list</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>NumDataNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>cursor</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>unique</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%s_"</literal><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>unique</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>cursor</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
        
        <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"ExecFinishRemoteSubplan: pid %d cursor %s send signal sigusr2 to end query."</literal></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>conn</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>dn_list</name><index>[<expr><name>dn_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>dn_count</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><call><name>PoolManagerCancelQuery</name><argument_list>(<argument><expr><name>dn_count</name></expr></argument>, 
                                              <argument><expr><name>dn_list</name></expr></argument>, 
                                              <argument><expr><literal type="number">0</literal></expr></argument>,
                                              <argument><expr><name>NULL</name></expr></argument>,
                                              <argument><expr><name>SIGNAL_SIGUSR2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"ExecFinishRemoteSubplan %d with cursor %s failed."</literal></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"ExecFinishRemoteSubplan %d with cursor %s, dn_count %d"</literal></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>dn_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>dn_count</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dn_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>dn_list</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* consume left data in socket */</comment>
        <expr_stmt><expr><call><name>pgxc_connections_cleanup</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecDisconnectRemoteSubplan</name><parameter_list>(<parameter><decl><type><name>RemoteSubplanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name> <init>= <expr><operator>(</operator><name>ResponseCombiner</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteSubplan</name>    <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>RemoteSubplan</name> <operator>*</operator><operator>)</operator> <name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier><modifier>*</modifier></type><name>connections</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>distributionRestrict</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>finish_init</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ExecFinishInitRemoteSubplan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
            PGXCNodeAllHandles *pgxc_connections;
            pgxc_connections = get_handles(node-&gt;execNodes, NIL, false, true);
            combiner-&gt;conn_count = pgxc_connections-&gt;dn_conn_count;
            combiner-&gt;connections = pgxc_connections-&gt;datanode_handles;
            combiner-&gt;current_conn = 0;
            pfree(pgxc_connections);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>extended_query</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type>            <name><name>cursor</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>cursor</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>unique</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%s_"</literal><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>unique</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>cursor</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>conn</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>CHECK_OWNERSHIP</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_disconnect</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>distributionRestrict</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to disconnect from node %d."</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"send disconnect to node %d with cursor %s, remote_pid %d, nconsumers %d."</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>,
						       <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>distributionRestrict</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>bound</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>eflags</name></name> <operator>|=</operator> <name>EXEC_FLAG_DISCONN</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>connections</name> <operator>=</operator> <operator>(</operator><name>PGXCNodeHandle</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>connections</name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name></name></expr></argument>,
            <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</expr_stmt>

        <while>while <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_receive</name><argument_list>(<argument><expr><name>count</name></expr></argument>,
                                  <argument><expr><name>connections</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to disconnect remote subplan"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>handle_response</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_EOF</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_READY</name> <operator>||</operator>
                         <name>res</name> <operator>==</operator> <name>RESPONSE_COMPLETE</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Done, connection is reade for query */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>--</operator><name>count</name> <operator>&gt;</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
                                <name><name>connections</name><index>[<expr><name>count</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_DATAROW</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * If we are finishing slowly running remote subplan while it
                     * is still working (because of Limit, for example) it may
                     * produce one or more tuples between connection cleanup and
                     * handling Close command. One tuple does not cause any problem,
                     * but if it will not be read the next tuple will trigger
                     * assertion failure. So if we got a tuple, just read and
                     * discard it here.
                     */</comment>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>RESPONSE_ERROR</name> <operator>==</operator> <name>res</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>needSync</name></expr>)</condition>
                    <block>{<block_content>                
                        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_sync</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to sync msg to node:%s pid:%d when clean"</literal></expr></argument>, <argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nodename</name></expr></argument>, <argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>backend_pid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                    
                        </block_content>}</block></if></if_stmt>
                        
                        <expr_stmt><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>needSync</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* Ignore other possible responses */</comment>
            </block_content>}</block></while>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Abort the connections, ensure the connections are clean and empty. */</comment>
<function><type><name>void</name></type> <name>pgxc_abort_connections</name><parameter_list>(<parameter><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>all_handles</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives    </comment>
    <decl_stmt><decl><type><name>int</name></type>  <name>ret</name>             <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>i</name>                  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>need_loop_check</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>need_sync</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>read_status</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>all_handles</name></expr>)</condition>
    <block>{<block_content>                
        <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>need_loop_check</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"pgxc_abort_connections %d coordinator to handle"</literal></expr></argument>, <argument><expr><name><name>all_handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>all_handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name><name>all_handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name> <operator>||</operator> <operator>!</operator><call><name>node_ready_for_query</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>pgxc_node_is_data_enqueued</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"pgxc_abort_connections node:%s not ready for query, status:%d"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr>)</condition>
                        <block>{<block_content>
							<expr_stmt><expr><name>read_status</name> <operator>=</operator> <call><name>pgxc_node_flush_read</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>read_status</name> <operator>==</operator> <name>EOF</name> <operator>||</operator> <name>read_status</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
							<block>{<block_content>
								<comment type="block">/* Can not read - no more actions, just discard connection */</comment>
								<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"unexpected EOF on datanode connection."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"unexpected EOF on node:%s pid:%d, read_status:%d, EOF:%d"</literal></expr></argument>,
										<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name>read_status</name></expr></argument>, <argument><expr><name>EOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<return>return;</return>
							</block_content>}</block></if></if_stmt>

                            <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>                
                        <comment type="block">/* Clear any previous error messages */</comment>
                        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"pgxc_abort_connections node:%s ready for query"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if>
                <else>else 
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"pgxc_abort_connections cn node:%s invalid socket %u!"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"pgxc_abort_connections cn node, invalid socket %u!"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></else></if_stmt>
                
            </block_content>}</block></for>
            
            <comment type="block">/*
             * The same for datanode nodes.
             */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"pgxc_abort_connections %d datanode to handle"</literal></expr></argument>, <argument><expr><name><name>all_handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>all_handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name><name>all_handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name> <operator>||</operator> <operator>!</operator><call><name>node_ready_for_query</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>pgxc_node_is_data_enqueued</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"pgxc_abort_connections node:%s not ready for query, status:%d"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>read_status</name> <operator>=</operator> <call><name>pgxc_node_flush_read</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>read_status</name> <operator>==</operator> <name>EOF</name> <operator>||</operator> <name>read_status</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* Can not read - no more actions, just discard connection */</comment>
							<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>add_error_message</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"unexpected EOF on datanode connection."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"unexpected EOF on node:%s pid:%d, read_status:%d, EOF:%d"</literal></expr></argument>,
									<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name>read_status</name></expr></argument>, <argument><expr><name>EOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<return>return;</return>
						</block_content>}</block></if></if_stmt>

                        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>;</expr_stmt>
                                        
                        <comment type="block">/* Clear any previous error messages */</comment>
                        <expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"pgxc_abort_connections node:%s ready for query"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if>
                <else>else 
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"pgxc_abort_connections dn node:%s invalid socket %u!"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"pgxc_abort_connections dn node, invalid socket %u!"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>

            <comment type="block">/* Recheck connection status. */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">" Begin to recheck pgxc_abort_connections %d coordinator handle"</literal></expr></argument>, <argument><expr><name><name>all_handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>all_handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name><name>all_handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name> <operator>||</operator> <operator>!</operator><call><name>node_ready_for_query</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>pgxc_node_is_data_enqueued</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"pgxc_abort_connections recheck node:%s not ready for query, status:%d, sync"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        
						<if_stmt><if>if <condition>(<expr><name>need_sync</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pgxc_node_send_sync</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"pgxc_abort_connections failed to send sync to node %s"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                        
                        <expr_stmt><expr><name>need_loop_check</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>proc_exit_inprogress</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>last_command</name></name> <operator>=</operator> <literal type="char">'Z'</literal></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"pgxc_abort_connections recheck node:%s ready for query"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if>
                <else>else 
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"pgxc_abort_connections cn node:%s invalid socket %u!"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"pgxc_abort_connections cn node, invalid socket %u!"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></else></if_stmt>            
            </block_content>}</block></for>
            
            <comment type="block">/*
             * recheck datanode nodes.
             */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">" Begin to recheck pgxc_abort_connections %d datanode handle"</literal></expr></argument>, <argument><expr><name><name>all_handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>all_handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name><name>all_handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DN_CONNECTION_STATE_IDLE</name> <operator>||</operator> <operator>!</operator><call><name>node_ready_for_query</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>pgxc_node_is_data_enqueued</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"pgxc_abort_connections recheck node:%s not ready for query, status:%d, sync"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        
						<if_stmt><if>if <condition>(<expr><name>need_sync</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pgxc_node_send_sync</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"pgxc_abort_connections failed to send sync to node %s"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>

                        <expr_stmt><expr><name>need_loop_check</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>proc_exit_inprogress</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>DN_CONNECTION_STATE_IDLE</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>last_command</name></name> <operator>=</operator> <literal type="char">'Z'</literal></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"pgxc_abort_connections recheck node:%s ready for query"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if>
                <else>else 
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"pgxc_abort_connections dn node:%s invalid socket %u!"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"pgxc_abort_connections dn node, invalid socket %u!"</literal></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><name>need_sync</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> 
            <comment type="block">/* no need to recheck, break the loop. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_loop_check</name></expr>)</condition>
            <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>
<name>ExecEndRemoteSubplan</name><parameter_list>(<parameter><decl><type><name>RemoteSubplanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int32</name></type>             <name>count</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name> <init>= <expr><operator>(</operator><name>ResponseCombiner</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteSubplan</name>    <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>RemoteSubplan</name> <operator>*</operator><operator>)</operator> <name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>rusage</name></name></type>    <name>start_r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type>        <name>start_t</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_remotesubplan_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ResetUsageCommon</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start_r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><call><name>outerPlanState</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>locator</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>freeLocator</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Consume any possible pending input
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>bound</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pgxc_connections_cleanup</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>    
    
    <comment type="block">/*
     * Update coordinator statistics
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
        
        <comment type="block">/* init node_count with conn_count */</comment>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>node_count</name></name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <switch>switch <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>CMD_INSERT</name></expr>:</case>
                    <comment type="block">/* One statement can insert into only one relation */</comment>
                    <expr_stmt><expr><call><name>pgstat_count_remote_insert</name><argument_list>(
                                <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>ri_RelationDesc</name></expr></argument>,
                                <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
                <case>case <expr><name>CMD_DELETE</name></expr>:</case>
                    <block>{<block_content>
                        <comment type="block">/*
                         * We can not determine here how many row were updated
                         * or delete in each table, so assume same number of
                         * affected row in each table.
                         * If resulting number of rows is 0 because of rounding,
                         * increment each counter at least on 1.
                         */</comment>
                        <decl_stmt><decl><type><name>int</name></type>        <name>i</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>int</name></type>     <name>n</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>bool</name></type>     <name>update</name></decl>;</decl_stmt>

                        <expr_stmt><expr><name>update</name> <operator>=</operator> <operator>(</operator><name><name>estate</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name><operator>)</operator></expr>;</expr_stmt>
                        <expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_processed</name></name> <operator>/</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_num_result_relations</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>Relation</name></type> <name>r</name></decl>;</decl_stmt>
                            <expr_stmt><expr><name>r</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relations</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ri_RelationDesc</name></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>update</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>pgstat_count_remote_update</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                            <else>else<block type="pseudo"><block_content>
                                <expr_stmt><expr><call><name>pgstat_count_remote_delete</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                        </block_content>}</block></for>
                    </block_content>}</block>
                    <break>break;</break>
                <default>default:</default>
                    <comment type="block">/* nothing to count */</comment>
                    <break>break;</break>
            </block_content>}</block></switch>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Close portals. While cursors_connections exist there are open portals
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Restore connections where there are active statements */</comment>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>cursor_count</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>node_count</name></name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_connections</name></name></expr></argument>,
                    <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGXCNodeHandle</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>cursor_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>cursor_connections</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>CHECK_OWNERSHIP</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_close</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to close data node cursor"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <comment type="block">/* The cursor stuff is not needed */</comment>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_connections</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>cursor_connections</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Close statements, even if they never were bound */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>            <name><name>cursor</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>cursor</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>unique</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%s_"</literal><name>INT64_FORMAT</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>unique</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>cursor</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* connection can be null in sort, forget it */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
					<name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>CHECK_OWNERSHIP</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_close</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to close data node statement"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/* Send SYNC and wait for ReadyForQuery */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_sync</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to sync msg to node %s backend_pid:%d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/*
         * Formally connection is not in QUERY state, we set the state to read
         * CloseDone and ReadyForQuery responses. Upon receiving ReadyForQuery
         * state will be changed back to IDLE and conn-&gt;coordinator will be
         * cleared.
         */</comment>
        <expr_stmt><expr><call><name>PGXCNodeSetConnectionState</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>DN_CONNECTION_STATE_CLOSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_receive</name><argument_list>(<argument><expr><name>count</name></expr></argument>,
                              <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to close remote subplan"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>handle_response</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_EOF</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_COMPLETE</name> <operator>&amp;&amp;</operator> <name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>state</name> <operator>==</operator> <name>DN_CONNECTION_STATE_ERROR_FATAL</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* connection is bad, forget it */</comment>
                <if_stmt><if>if <condition>(<expr><operator>--</operator><name>count</name> <operator>&gt;</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
                            <name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>count</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_READY</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Done, connection is reade for query */</comment>
                <if_stmt><if>if <condition>(<expr><operator>--</operator><name>count</name> <operator>&gt;</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
                            <name><name>combiner</name><operator>-&gt;</operator><name>connections</name><index>[<expr><name>count</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>res</name> <operator>==</operator> <name>RESPONSE_DATAROW</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * If we are finishing slowly running remote subplan while it
                 * is still working (because of Limit, for example) it may
                 * produce one or more tuples between connection cleanup and
                 * handling Close command. One tuple does not cause any problem,
                 * but if it will not be read the next tuple will trigger
                 * assertion failure. So if we got a tuple, just read and
                 * discard it here.
                 */</comment>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>currentRow</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* Ignore other possible responses */</comment>
        </block_content>}</block></while>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>ValidateAndCloseCombiner</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>log_remotesubplan_stats</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ShowUsageCommon</name><argument_list>(<argument><expr><literal type="string">"ExecEndRemoteSubplan"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pgxc_node_report_error
 * Throw error from Datanode if any.
 */</comment>
<function><type><name>void</name></type>
<name>pgxc_node_report_error</name><parameter_list>(<parameter><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* If no combiner, nothing to do */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>combiner</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>code</name> <init>= <expr><name><name>combiner</name><operator>-&gt;</operator><name>errorCode</name></name></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifndef>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>combiner</name><operator>-&gt;</operator><name>errorDetail</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>combiner</name><operator>-&gt;</operator><name>errorHint</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><call><name>MAKE_SQLSTATE</name><argument_list>(<argument><expr><name><name>code</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node:%s, backend_pid:%d, %s"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorNode</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>combiner</name><operator>-&gt;</operator><name>errorDetail</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>combiner</name><operator>-&gt;</operator><name>errorHint</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><call><name>MAKE_SQLSTATE</name><argument_list>(<argument><expr><name><name>code</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node:%s, backend_pid:%d, %s"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorNode</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorDetail</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorHint</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>errorDetail</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><call><name>MAKE_SQLSTATE</name><argument_list>(<argument><expr><name><name>code</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node:%s, backend_pid:%d, %s"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorNode</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorDetail</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><call><name>MAKE_SQLSTATE</name><argument_list>(<argument><expr><name><name>code</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"node:%s, backend_pid:%d, %s"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorNode</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>backend_pid</name></name></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorHint</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>combiner</name><operator>-&gt;</operator><name>errorDetail</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>combiner</name><operator>-&gt;</operator><name>errorHint</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><call><name>MAKE_SQLSTATE</name><argument_list>(<argument><expr><name><name>code</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>combiner</name><operator>-&gt;</operator><name>errorDetail</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>combiner</name><operator>-&gt;</operator><name>errorHint</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><call><name>MAKE_SQLSTATE</name><argument_list>(<argument><expr><name><name>code</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorDetail</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorHint</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>errorDetail</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><call><name>MAKE_SQLSTATE</name><argument_list>(<argument><expr><name><name>code</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorDetail</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><call><name>MAKE_SQLSTATE</name><argument_list>(<argument><expr><name><name>code</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>errorHint</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * get_success_nodes:
 * Currently called to print a user-friendly message about
 * which nodes the query failed.
 * Gets all the nodes where no 'E' (error) messages were received; i.e. where the
 * query ran successfully.
 */</comment>
<function><type><specifier>static</specifier> <name>ExecNodes</name> <modifier>*</modifier></type>
<name>get_success_nodes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>node_count</name></decl></parameter>, <parameter><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier><modifier>*</modifier></type><name>handles</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>node_type</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>failednodes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>success_nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>node_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name><name>handles</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nodenum</name> <init>= <expr><call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name><name>handle</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>error</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>success_nodes</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>success_nodes</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name><name>success_nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>success_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><name>nodenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>failednodes</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>failednodes</name></expr></argument>, <argument><expr><literal type="string">"Error message received from nodes:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_PG_REGRESS_</name></cpp:ifndef>
            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>failednodes</name></expr></argument>, <argument><expr><literal type="string">" %s#%d"</literal></expr></argument>,
                <argument><expr><operator>(</operator><ternary><condition><expr><name>node_type</name> <operator>==</operator> <name>PGXC_NODE_COORDINATOR</name></expr> ?</condition><then> <expr><literal type="string">"coordinator"</literal></expr> </then><else>: <expr><literal type="string">"datanode"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
                <argument><expr><name>nodenum</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><name>success_nodes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pgxc_all_success_nodes: Uses get_success_nodes() to collect the
 * user-friendly message from coordinator as well as datanode.
 */</comment>
<function><type><name>void</name></type>
<name>pgxc_all_success_nodes</name><parameter_list>(<parameter><decl><type><name>ExecNodes</name> <modifier>*</modifier><modifier>*</modifier></type><name>d_nodes</name></decl></parameter>, <parameter><decl><type><name>ExecNodes</name> <modifier>*</modifier><modifier>*</modifier></type><name>c_nodes</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>failednodes_msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>connections</name> <init>= <expr><call><name>get_exec_connections</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>EXEC_ON_ALL_NODES</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>failednodes</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>failednodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>d_nodes</name> <operator>=</operator> <call><name>get_success_nodes</name><argument_list>(<argument><expr><name><name>connections</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr></argument>,
                                 <argument><expr><name><name>connections</name><operator>-&gt;</operator><name>datanode_handles</name></name></expr></argument>,
                                 <argument><expr><name>PGXC_NODE_DATANODE</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>failednodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>c_nodes</name> <operator>=</operator> <call><name>get_success_nodes</name><argument_list>(<argument><expr><name><name>connections</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr></argument>,
                                 <argument><expr><name><name>connections</name><operator>-&gt;</operator><name>coord_handles</name></name></expr></argument>,
                                 <argument><expr><name>PGXC_NODE_COORDINATOR</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>failednodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>failednodes</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>failednodes_msg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>failednodes_msg</name> <operator>=</operator> <name><name>failednodes</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * set_dbcleanup_callback:
 * Register a callback function which does some non-critical cleanup tasks
 * on xact success or abort, such as tablespace/database directory cleanup.
 */</comment>
<function><type><name>void</name></type> <name>set_dbcleanup_callback</name><parameter_list>(<parameter><decl><type><name>xact_callback</name></type> <name>function</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>paraminfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>paraminfo_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>fparams</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>fparams</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><name>paraminfo_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>fparams</name></expr></argument>, <argument><expr><name>paraminfo</name></expr></argument>, <argument><expr><name>paraminfo_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>dbcleanup_info</name><operator>.</operator><name>function</name></name> <operator>=</operator> <name>function</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbcleanup_info</name><operator>.</operator><name>fparams</name></name> <operator>=</operator> <name>fparams</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtEOXact_DBCleanup: To be called at post-commit or pre-abort.
 * Calls the cleanup function registered during this transaction, if any.
 */</comment>
<function><type><name>void</name></type> <name>AtEOXact_DBCleanup</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>dbcleanup_info</name><operator>.</operator><name>function</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call>(<modifier>*</modifier><name><name>dbcleanup_info</name><operator>.</operator><name>function</name></name>)<argument_list>(<argument><expr><name>isCommit</name></expr></argument>, <argument><expr><name><name>dbcleanup_info</name><operator>.</operator><name>fparams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Just reset the callbackinfo. We anyway don't want this to be called again,
     * until explicitly set.
     */</comment>
    <expr_stmt><expr><name><name>dbcleanup_info</name><operator>.</operator><name>function</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>dbcleanup_info</name><operator>.</operator><name>fparams</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>dbcleanup_info</name><operator>.</operator><name>fparams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dbcleanup_info</name><operator>.</operator><name>fparams</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetImplicit2PCGID</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>implicit2PC_head</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>localWrite</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>dnCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>coordCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>dnNodeIds</name>       <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>coordNodeIds</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>dnNodeIds</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>TBASE_MAX_DATANODE_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dnNodeIds</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory for dnNodeIds"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>coordNodeIds</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>TBASE_MAX_COORDINATOR_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>coordNodeIds</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory for coordNodeIds"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * Check how many coordinators and datanodes are involved in this
     * transaction.
     * MAX_IMPLICIT_2PC_STR_LEN (5 + 21 + 64 + 1 + 5 + 5)
     */</comment>
    
    <expr_stmt><expr><call><name>pgxc_node_remote_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dnCount</name></expr></argument>, <argument><expr><name>dnNodeIds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>coordCount</name></expr></argument>, <argument><expr><name>coordNodeIds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"%s%u:%s:%c:%d:%d"</literal></expr></argument>,
            <argument><expr><name>implicit2PC_head</name></expr></argument>,
            <argument><expr><call><name>GetTopTransactionId</name><argument_list>()</argument_list></call></expr></argument>,
            <argument><expr><name>PGXCNodeName</name></expr></argument>,
            <argument><expr><ternary><condition><expr><name>localWrite</name></expr> ?</condition><then> <expr><literal type="char">'T'</literal></expr> </then><else>: <expr><literal type="char">'F'</literal></expr></else></ternary></expr></argument>,
            <argument><expr><name>dnCount</name></expr></argument>,
            <argument><expr><name>coordCount</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>localWrite</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    for (i = 0; i &lt; dnCount; i++)
        appendStringInfo(&amp;str, ":%d", dnNodeIds[i]);
    for (i = 0; i &lt; coordCount; i++)
        appendStringInfo(&amp;str, ":%d", coordNodeIds[i]);

    if (localWrite)
        appendStringInfo(&amp;str, ":%d", PGXCNodeIdentifier);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>dnNodeIds</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dnNodeIds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dnNodeIds</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>coordNodeIds</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>coordNodeIds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>coordNodeIds</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name><name>str</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>ExecRemoteSubPlanInitializeDSM</name><parameter_list>(<parameter><decl><type><name>RemoteSubplanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                               <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParallelWorkerStatus</name> <modifier>*</modifier></type><name>worker_status</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>worker_status</name>  <operator>=</operator> <call><name>GetParallelWorkerStatusInfo</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>parallel_status</name></name> <operator>=</operator> <name>worker_status</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecRemoteQueryInitializeDSM</name><parameter_list>(<parameter><decl><type><name>RemoteQueryState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                               <parameter><decl><type><name>ParallelContext</name> <modifier>*</modifier></type><name>pcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParallelWorkerStatus</name> <modifier>*</modifier></type><name>worker_status</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>worker_status</name>  <operator>=</operator> <call><name>GetParallelWorkerStatusInfo</name><argument_list>(<argument><expr><name><name>pcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>parallel_status</name></name> <operator>=</operator> <name>worker_status</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ExecRemoteSubPlanInitDSMWorker</name><parameter_list>(<parameter><decl><type><name>RemoteSubplanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                               <parameter><decl><type><name>ParallelWorkerContext</name> <modifier>*</modifier></type><name>pwcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>                  <name>i</name>                    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>                  <name>length</name>            <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>                  <name>worker_num</name>        <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>                  <name>step</name>                <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>                 <name>begin_node</name>         <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* include */</comment>
    <decl_stmt><decl><type><name>int32</name></type>                 <name>end_node</name>             <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* exclude */</comment>
    <decl_stmt><decl><type><name>ParallelWorkerStatus</name>  <modifier>*</modifier></type><name>worker_status</name>    <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>                     <modifier>*</modifier></type><name>locla_exec_nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>              <modifier>*</modifier></type><name>node_list_item</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>worker_status</name>  <operator>=</operator> <call><name>GetParallelWorkerStatusInfo</name><argument_list>(<argument><expr><name><name>pwcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>worker_num</name> <operator>=</operator> <call><name>ExecGetForWorkerNumber</name><argument_list>(<argument><expr><name>worker_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>parallel_status</name></name> <operator>=</operator> <name>worker_status</name></expr>;</expr_stmt>    
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>execOnAll</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>execNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>locla_exec_nodes</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>execNodes</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>execNodes</name></name>  <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>  

        <if_stmt><if>if <condition>(<expr><name>worker_num</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>DIVIDE_UP</name><argument_list>(<argument><expr><name>length</name></expr></argument>, <argument><expr><name>worker_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* Last worker. */</comment>
        <if_stmt><if>if <condition>(<expr><name>ParallelWorkerNumber</name> <operator>==</operator> <operator>(</operator><name>worker_num</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>begin_node</name> <operator>=</operator> <name>ParallelWorkerNumber</name> <operator>*</operator> <name>step</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>end_node</name>   <operator>=</operator> <name>length</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>begin_node</name> <operator>=</operator> <name>ParallelWorkerNumber</name> <operator>*</operator> <name>step</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>end_node</name>   <operator>=</operator> <name>begin_node</name> <operator>+</operator> <name>step</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* Form the execNodes of our own node. */</comment>
        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>node_list_item</argument>, <argument>locla_exec_nodes</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>    <name>nodeid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>node_list_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>begin_node</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>end_node</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>execNodes</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>execNodes</name></name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>end_node</name></expr>)</condition>
            <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block>
        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>locla_exec_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"only reditribution on all nodes can run in worker"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>    
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>ExecRemoteQueryInitializeDSMWorker</name><parameter_list>(<parameter><decl><type><name>RemoteQueryState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                                   <parameter><decl><type><name>ParallelWorkerContext</name> <modifier>*</modifier></type><name>pwcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>                 <name>worker_num</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelWorkerStatus</name> <modifier>*</modifier></type><name>worker_status</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResponseCombiner</name>     <modifier>*</modifier></type><name>combiner</name>      <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQuery</name>          <modifier>*</modifier></type><name>step</name>          <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>combiner</name>               <operator>=</operator> <operator>(</operator><name>ResponseCombiner</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>step</name>                   <operator>=</operator> <operator>(</operator><name>RemoteQuery</name> <operator>*</operator><operator>)</operator> <name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>worker_status</name>  		  <operator>=</operator> <call><name>GetParallelWorkerStatusInfo</name><argument_list>(<argument><expr><name><name>pwcxt</name><operator>-&gt;</operator><name>toc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>worker_num</name>            <operator>=</operator> <call><name>ExecGetForWorkerNumber</name><argument_list>(<argument><expr><name>worker_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>parallel_status</name></name> <operator>=</operator> <name>worker_status</name></expr>;</expr_stmt>    
    <expr_stmt><expr><name>worker_num</name>              <operator>=</operator> <name>worker_num</name></expr>;</expr_stmt> <comment type="block">/* keep compiler quiet. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>!=</operator> <name>EXEC_ON_DATANODES</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Only datanode remote quern can run in worker"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pgxc_append_param_val:
 * Append the parameter value for the SET clauses of the UPDATE statement.
 * These values are the table attribute values from the dataSlot.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgxc_append_param_val</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>valtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Convert Datum to string */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pstring</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>n32</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>        <name>typOutput</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>    <name>typIsVarlena</name></decl>;</decl_stmt>

    <comment type="block">/* Get info needed to output the value */</comment>
    <expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>valtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typOutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIsVarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * If we have a toasted datum, forcibly detoast it here to avoid
     * memory leakage inside the type's output routine.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>typIsVarlena</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>pstring</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typOutput</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* copy data to the buffer */</comment>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>pstring</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pgxc_append_param_junkval:
 * Append into the data row the parameter whose value cooresponds to the junk
 * attributes in the source slot, namely ctid or node_id.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgxc_append_param_junkval</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attno</name></decl></parameter>,
                          <parameter><decl><type><name>Oid</name></type> <name>valtype</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>isNull</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>slot</name> <operator>&amp;&amp;</operator> <name>attno</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Junk attribute positions are saved by ExecFindJunkAttribute() */</comment>
        <decl_stmt><decl><type><name>Datum</name></type> <name>val</name> <init>= <expr><call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="block">/* shouldn't ever get a null result... */</comment>
        <if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"NULL junk attribute"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>pgxc_append_param_val</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>valtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* handle escape char '''  in source char sequence */</comment>
<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type>
<name>handleEscape</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>source</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>special_case</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name></type> <name>escape</name> <init>= <expr><literal type="char">'\''</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* escape char */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>des</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* when meet escape char, add another escape char */</comment>
    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name><name>source</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>escape</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>des</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>des</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>source</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if<condition>(<expr><name><name>source</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>des</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>des</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'r'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>special_case</name><operator>)</operator> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if<condition>(<expr><name><name>source</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>des</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>des</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'n'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>special_case</name><operator>)</operator> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if<condition>(<expr><name><name>source</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\t'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>des</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>des</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>special_case</name><operator>)</operator> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if<condition>(<expr><name><name>source</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\b'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>des</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>des</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'b'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>special_case</name><operator>)</operator> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if<condition>(<expr><name><name>source</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\f'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>des</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>des</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>special_case</name><operator>)</operator> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if<condition>(<expr><name><name>source</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\v'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>des</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>des</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'v'</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>special_case</name><operator>)</operator> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>des</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>source</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>des</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>des</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetDataRowParams</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>RemoteQueryState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>sourceSlot</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>dataSlot</name></decl></parameter>,
                        <parameter><decl><type><name>JunkFilter</name> <modifier>*</modifier></type><name>ri_junkFilter</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CmdType</name></type>    <name>operation</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type>    <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type>    <name>select_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16</name></type> <name>numparams</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>rqs_num_params</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>         <name>tdesc</name> <init>= <expr><name><name>dataSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>attindex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>numatts</name> <init>= <expr><name><name>tdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name> <init>= <expr><operator>(</operator><name>ResponseCombiner</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQuery</name>    <modifier>*</modifier></type><name>step</name> <init>= <expr><operator>(</operator><name>RemoteQuery</name> <operator>*</operator><operator>)</operator> <name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>            <modifier>*</modifier></type><name>param_types</name> <init>= <expr><name><name>step</name><operator>-&gt;</operator><name>rq_param_types</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>typeOutput</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>typIsVarlena</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>columnValue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>typename</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>special_case</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>cols</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>select_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch<condition>(<expr><name>operation</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>CMD_INSERT</name></expr>:</case>
        <block>{<block_content>
            <comment type="block">/* ensure we have all values */</comment>
            <expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>dataSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <block>{<block_content>
                <decl_stmt><decl><type><name>uint16</name></type> <name>params_nbo</name> <init>= <expr><call><name>htons</name><argument_list>(<argument><expr><name>numparams</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* Network byte order */</comment>
                <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>params_nbo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>params_nbo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            
            <for>for <control>(<init><expr><name>attindex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attindex</name> <operator>&lt;</operator> <name>numatts</name></expr>;</condition> <incr><expr><name>attindex</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>uint32</name></type> <name>n32</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attindex</name> <operator>&lt;</operator> <name>numparams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>dataSlot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>attindex</name></expr>]</index></name> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>param_types</name><index>[<expr><name>attindex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>pgxc_append_param_val</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>dataSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>attindex</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>tdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attindex</name></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></for>

            <if_stmt><if>if <condition>(<expr><name>attindex</name> <operator>!=</operator> <name>numparams</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"INSERT DataRowParams mismatch with dataSlot."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>paramval_data</name></name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>paramval_len</name></name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_onconflict</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>select_buf</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>sql_select_base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>select_buf</name></expr></argument>, <argument><expr><literal type="string">" where "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
                numparams = node-&gt;ss_num_params;

                {
                    uint16 params_nbo = htons(numparams); <comment type="block">/* Network byte order */</comment>
                    appendBinaryStringInfo(&amp;select_buf, (char *) &amp;params_nbo, sizeof(params_nbo));
                }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><name>cols</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>attindex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attindex</name> <operator>&lt;</operator> <name>numatts</name></expr>;</condition> <incr><expr><name>attindex</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><name>special_case</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>attindex</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>conflict_cols</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <continue>continue;</continue></block_content></block></if></if_stmt>
                    
                    <if_stmt><if>if <condition>(<expr><name><name>dataSlot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>attindex</name></expr>]</index></name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if<condition>(<expr><name>cols</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>select_buf</name></expr></argument>, <argument><expr><literal type="string">" and "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><name>att</name> <operator>=</operator> <name><name>tdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attindex</name></expr>]</index></name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>select_buf</name></expr></argument>, <argument><expr><literal type="string">"%s is NULL"</literal></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    
                        <comment type="line">//n32 = htonl(-1);</comment>
                        <comment type="line">//appendBinaryStringInfo(&amp;select_buf, (char *) &amp;n32, 4);</comment>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <if_stmt><if>if<condition>(<expr><name>cols</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>select_buf</name></expr></argument>, <argument><expr><literal type="string">" and "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><name>att</name> <operator>=</operator> <name><name>tdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attindex</name></expr>]</index></name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeOutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIsVarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>           
                        <expr_stmt><expr><name>columnValue</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name>typeOutput</name></expr></argument>, <argument><expr><name><name>dataSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>attindex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    				<expr_stmt><expr><name>typename</name> <operator>=</operator> <call><name>get_typename</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>columnValue</name> <operator>=</operator> <call><name>handleEscape</name><argument_list>(<argument><expr><name>columnValue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>special_case</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if<condition>(<expr><name>special_case</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>select_buf</name></expr></argument>, <argument><expr><literal type="string">"%s = E'%s'::%s"</literal></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>columnValue</name></expr></argument>, <argument><expr><name>typename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                        <else>else<block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>select_buf</name></expr></argument>, <argument><expr><literal type="string">"%s = '%s'::%s"</literal></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>columnValue</name></expr></argument>, <argument><expr><name>typename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                        <comment type="line">//pgxc_append_param_val(&amp;select_buf, dataSlot-&gt;tts_values[attindex], tdesc-&gt;attrs[attindex]-&gt;atttypid);</comment>
                    </block_content>}</block></else></if_stmt>

                    <expr_stmt><expr><name>cols</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></for>

                <if_stmt><if>if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>forUpadte</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>select_buf</name></expr></argument>, <argument><expr><literal type="string">" FOR UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>select_buf</name></expr></argument>, <argument><expr><literal type="string">" FOR NO KEY UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <comment type="line">//node-&gt;ss_paramval_data = select_buf.data;</comment>
                <comment type="line">//node-&gt;ss_paramval_len = select_buf.len;</comment>

                <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>sql_select</name></name> <operator>=</operator> <name><name>select_buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
        <break>break;</break>
        <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
        <block>{<block_content>
            <comment type="block">/* ensure we have all values */</comment>
            <expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>dataSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <block>{<block_content>
                <decl_stmt><decl><type><name>uint16</name></type> <name>params_nbo</name> <init>= <expr><call><name>htons</name><argument_list>(<argument><expr><name>numparams</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* Network byte order */</comment>
                <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>params_nbo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>params_nbo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            
            <for>for <control>(<init><expr><name>attindex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>attindex</name> <operator>&lt;</operator> <name>numatts</name></expr>;</condition> <incr><expr><name>attindex</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>uint32</name></type> <name>n32</name></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attindex</name> <operator>&lt;</operator> <name>numparams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>dataSlot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>attindex</name></expr>]</index></name> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>param_types</name><index>[<expr><name>attindex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>pgxc_append_param_val</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>dataSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>attindex</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>tdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attindex</name></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></for>

            <if_stmt><if>if <condition>(<expr><name>attindex</name> <operator>!=</operator> <name>numparams</name> <operator>-</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"UPDATE DataRowParams mismatch with dataSlot."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>UPSERT_NONE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pgxc_append_param_junkval</name><argument_list>(<argument><expr><name>sourceSlot</name></expr></argument>, <argument><expr><name><name>ri_junkFilter</name><operator>-&gt;</operator><name>jf_junkAttNo</name></name></expr></argument>,
                              <argument><expr><name>TIDOID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pgxc_append_param_junkval</name><argument_list>(<argument><expr><name>sourceSlot</name></expr></argument>, <argument><expr><name><name>ri_junkFilter</name><operator>-&gt;</operator><name>jf_xc_node_id</name></name></expr></argument>,
                                          <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>pgxc_append_param_junkval</name><argument_list>(<argument><expr><name>sourceSlot</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>jf_ctid</name></name></expr></argument>,
                              <argument><expr><name>TIDOID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pgxc_append_param_junkval</name><argument_list>(<argument><expr><name>sourceSlot</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>jf_xc_node_id</name></name></expr></argument>,
                                          <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>paramval_data</name></name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>paramval_len</name></name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
        </block_content>}</block>
        <break>break;</break>
        <case>case <expr><name>CMD_DELETE</name></expr>:</case>
        <block>{<block_content>
            <block>{<block_content>
                <decl_stmt><decl><type><name>uint16</name></type> <name>params_nbo</name> <init>= <expr><call><name>htons</name><argument_list>(<argument><expr><name>numparams</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* Network byte order */</comment>
                <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>params_nbo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>params_nbo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        
            <expr_stmt><expr><call><name>pgxc_append_param_junkval</name><argument_list>(<argument><expr><name>sourceSlot</name></expr></argument>, <argument><expr><name><name>ri_junkFilter</name><operator>-&gt;</operator><name>jf_junkAttNo</name></name></expr></argument>,
                          <argument><expr><name>TIDOID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pgxc_append_param_junkval</name><argument_list>(<argument><expr><name>sourceSlot</name></expr></argument>, <argument><expr><name><name>ri_junkFilter</name><operator>-&gt;</operator><name>jf_xc_node_id</name></name></expr></argument>,
                                      <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>paramval_data</name></name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>paramval_len</name></name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
        </block_content>}</block>
        <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected CmdType in SetDataRowParams."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> 
<name>remember_prepared_node</name><parameter_list>(<parameter><decl><type><name>RemoteQueryState</name> <modifier>*</modifier></type><name>rstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type> <name>wordindex</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name>wordoffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>&gt;</operator> <name>MAX_NODES_NUMBER</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid nodeid:%d is bigger than maximum node number of the cluster"</literal></expr></argument>,<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>wordindex</name>  <operator>=</operator> <name>node</name><operator>/</operator><name>UINT32_BITS_NUM</name></expr>;</expr_stmt>    
    <expr_stmt><expr><name>wordoffset</name> <operator>=</operator> <name>node</name> <operator>%</operator> <name>UINT32_BITS_NUM</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_BIT</name><argument_list>(<argument><expr><name><name>rstate</name><operator>-&gt;</operator><name>dml_prepared_mask</name><index>[<expr><name>wordindex</name></expr>]</index></name></expr></argument>, <argument><expr><name>wordoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> 
<name>is_node_prepared</name><parameter_list>(<parameter><decl><type><name>RemoteQueryState</name> <modifier>*</modifier></type><name>rstate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type> <name>wordindex</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name>wordoffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&gt;=</operator> <name>MAX_NODES_NUMBER</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid nodeid:%d is bigger than maximum node number of the cluster"</literal></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>wordindex</name>  <operator>=</operator> <name>node</name><operator>/</operator><name>UINT32_BITS_NUM</name></expr>;</expr_stmt>    
    <expr_stmt><expr><name>wordoffset</name> <operator>=</operator> <name>node</name> <operator>%</operator> <name>UINT32_BITS_NUM</name></expr>;</expr_stmt>
    <return>return <expr><call><name>BIT_SET</name><argument_list>(<argument><expr><name><name>rstate</name><operator>-&gt;</operator><name>dml_prepared_mask</name><index>[<expr><name>wordindex</name></expr>]</index></name></expr></argument>, <argument><expr><name>wordoffset</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
  *   ExecRemoteDML----execute DML on coordinator
  *   return true if insert/update/delete successfully, else false.
  *
  *   If DML target relation has unshippable triggers, we have to do DML on coordinator.
  *   Construct remote query about DML on plan phase, then adopt parse/bind/execute to
  *   execute the DML with the triggers on coordinator.
  * 
  */</comment>
<function><type><name>bool</name></type>
<name>ExecRemoteDML</name><parameter_list>(<parameter><decl><type><name>ModifyTableState</name> <modifier>*</modifier></type><name>mtstate</name></decl></parameter>, <parameter><decl><type><name>ItemPointer</name></type> <name>tupleid</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>oldtuple</name></decl></parameter>,
              <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>planSlot</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>EPQState</name> <modifier>*</modifier></type><name>epqstate</name></decl></parameter>,
              <parameter><decl><type><name>bool</name></type> <name>canSetTag</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier><modifier>*</modifier></type><name>returning</name></decl></parameter>, <parameter><decl><type><name>UPSERT_ACTION</name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
              <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rel_index</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>CmdType</name></type>    <name>operation</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQueryState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>RemoteQueryState</name> <operator>*</operator><operator>)</operator><name><name>mtstate</name><operator>-&gt;</operator><name>mt_remoterels</name><index>[<expr><name>rel_index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ResponseCombiner</name> <modifier>*</modifier></type><name>combiner</name> <init>= <expr><operator>(</operator><name>ResponseCombiner</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQuery</name>    <modifier>*</modifier></type><name>step</name> <init>= <expr><operator>(</operator><name>RemoteQuery</name> <operator>*</operator><operator>)</operator> <name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>ExprContext</name>    <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>combiner</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprContext</name>    <modifier>*</modifier></type><name>proj_econtext</name> <init>= <expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>pgxc_connections</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GlobalTransactionId</name></type> <name>gxid</name> <init>= <expr><name>InvalidGlobalTransactionId</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Snapshot</name></type>        <name>snapshot</name> <init>= <expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier><modifier>*</modifier></type><name>connections</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>regular_conn_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tupleslot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nodeid</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_INSERT</name> <operator>&amp;&amp;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_onconflict</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>UPSERT_NONE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>UPSERT_SELECT</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>action</name></name> <operator>!=</operator> <name>UPSERT_UPDATE</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Get connections for remote query
         */</comment>
        <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>pgxc_connections</name> <operator>=</operator> <call><name>get_exec_connections</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>step</name><operator>-&gt;</operator><name>exec_nodes</name></name></expr></argument>,
                                                <argument><expr><name><name>step</name><operator>-&gt;</operator><name>exec_type</name></name></expr></argument>,
                                                <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>step</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>==</operator> <name>EXEC_ON_DATANODES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>connections</name> <operator>=</operator> <name><name>pgxc_connections</name><operator>-&gt;</operator><name>datanode_handles</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>regular_conn_count</name> <operator>=</operator> <name><name>pgxc_connections</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>conns</name></name> <operator>=</operator> <name><name>pgxc_connections</name><operator>-&gt;</operator><name>datanode_handles</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>ccount</name></name> <operator>=</operator> <name><name>pgxc_connections</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* reset connection */</comment>
        <expr_stmt><expr><name>connections</name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conns</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>regular_conn_count</name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>ccount</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* get all parameters for execution */</comment>
    <expr_stmt><expr><call><name>SetDataRowParams</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>planSlot</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_junkFilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* need to send commandid to datanode */</comment>
    <expr_stmt><expr><call><name>SetSendCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>regular_conn_count</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>nodeid</name> <operator>=</operator> <call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nodeoid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* need transaction during execution, but only send begin to datanode once */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_node_prepared</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>gxid</name> <operator>=</operator> <call><name>GetCurrentTransactionIdIfAny</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        
		<if_stmt><if>if <condition>(<expr><call><name>pgxc_node_begin</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>gxid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Could not begin transaction on datanode in ExecRemoteDML, nodeid:%d."</literal></expr></argument>,
                         <argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>remember_prepared_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
      * For update/delete and simple insert, we can send SQL statement  to datanode through
      * parse/bind/execute.
      * 
      * UPSERT is a little different, we separate UPSERT into insert, select and update.
      *
      * Step 1, we send select...for update to find the conflicted tuple and lock it; if we
      * succeed, then do the update and finish. Else, it means no conflict tuple now, we can do
      * the insert.
      * 
      * Step 2, if insert succeed, then finish; else insert must conflict with others, this must be 
      * unexepected, but it does happen, goto step 1.
      * We have to repeat step 1 and step 2, until finish.
      */</comment>
    <if_stmt><if>if <condition>(<expr><name>operation</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator> <name>operation</name> <operator>==</operator> <name>CMD_DELETE</name> <operator>||</operator>
        <operator>(</operator><name>operation</name> <operator>==</operator> <name>CMD_INSERT</name> <operator>&amp;&amp;</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_onconflict</name></name> <operator>!=</operator> <name>ONCONFLICT_UPDATE</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgxc_start_command_on_connection</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pgxc_node_remote_abort</name><argument_list>(<argument><expr><name>TXN_TYPE_RollbackTxn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>pgxc_connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to send command to datanode in ExecRemoteDML, nodeid:%d."</literal></expr></argument>,
                        <argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
<label><name>UPSERT</name>:</label>
    <block>{<block_content>
        <comment type="block">/* insert...on conflict do update */</comment>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>paramval_data</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>paramval_data</name></name></expr></init></decl>;</decl_stmt>        
        <decl_stmt><decl><type><name>int</name></type>            <name>paramval_len</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>paramval_len</name></name></expr></init></decl>;</decl_stmt>        
        <decl_stmt><decl><type><name>Oid</name>           <modifier>*</modifier></type><name>rqs_param_types</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>rqs_param_types</name></name></expr></init></decl>;</decl_stmt>    
        <decl_stmt><decl><type><name>int</name></type>            <name>rqs_num_params</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>rqs_num_params</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>sql</name> <init>= <expr><name><name>step</name><operator>-&gt;</operator><name>sql_statement</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>statement</name> <init>= <expr><name><name>step</name><operator>-&gt;</operator><name>statement</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* reset connection */</comment>
        <expr_stmt><expr><name>connections</name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>conns</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>regular_conn_count</name> <operator>=</operator> <name><name>combiner</name><operator>-&gt;</operator><name>ccount</name></name></expr>;</expr_stmt>

        <switch>switch<condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>action</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* select first, try to find conflict tupe */</comment>
            <case>case <expr><name>UPSERT_SELECT</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>paramval_data</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss_paramval_data</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>paramval_len</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss_paramval_len</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>rqs_param_types</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss_param_types</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>rqs_num_params</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss_num_params</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <name><name>step</name><operator>-&gt;</operator><name>sql_select</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>statement</name></name> <operator>=</operator> <name><name>step</name><operator>-&gt;</operator><name>select_cursor</name></name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgxc_start_command_on_connection</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>pgxc_node_remote_abort</name><argument_list>(<argument><expr><name>TXN_TYPE_RollbackTxn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>pgxc_connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to send up_select to datanode in ExecRemoteDML, nodeid:%d."</literal></expr></argument>,
                                <argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>paramval_data</name></name> <operator>=</operator> <name>paramval_data</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>paramval_len</name></name> <operator>=</operator> <name>paramval_len</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>rqs_param_types</name></name> <operator>=</operator> <name>rqs_param_types</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>rqs_num_params</name></name> <operator>=</operator> <name>rqs_num_params</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <name>sql</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>statement</name></name> <operator>=</operator> <name>statement</name></expr>;</expr_stmt>

                <break>break;</break>
            </block_content>}</block>
            <comment type="block">/* no conflict tuple found, try to insert */</comment>
            <case>case <expr><name>UPSERT_INSERT</name></expr>:</case>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pgxc_start_command_on_connection</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>pgxc_node_remote_abort</name><argument_list>(<argument><expr><name>TXN_TYPE_RollbackTxn</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>pgxc_connections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to send up_insert to datanode in ExecRemoteDML, nodeid:%d."</literal></expr></argument>,
                                <argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                                    
                <break>break;</break>
            </block_content>}</block>
            <case>case <expr><name>UPSERT_UPDATE</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>paramval_data</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>su_paramval_data</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>paramval_len</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>su_paramval_len</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>rqs_param_types</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>su_param_types</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>rqs_num_params</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>su_num_params</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <name><name>step</name><operator>-&gt;</operator><name>sql_update</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>statement</name></name> <operator>=</operator> <name><name>step</name><operator>-&gt;</operator><name>update_cursor</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name> <operator>=</operator> <name>CMD_UPDATE</name></expr>;</expr_stmt>
                
                <comment type="block">/* do update */</comment>
                <expr_stmt><expr><name><name>proj_econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name><name>mtstate</name><operator>-&gt;</operator><name>mt_existing</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>proj_econtext</name><operator>-&gt;</operator><name>ecxt_innertuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>proj_econtext</name><operator>-&gt;</operator><name>ecxt_outertuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>ExecQual</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflictSetWhere</name></name></expr></argument>, <argument><expr><name>proj_econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Datum</name></type>        <name>datum</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name></type>        <name>isNull</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>ItemPointer</name></type> <name>conflictTid</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>ExecGetJunkAttribute</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_existing</name></name></expr></argument>,
                                                 <argument><expr><name><name>step</name><operator>-&gt;</operator><name>jf_ctid</name></name></expr></argument>,
                                                 <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* shouldn't ever get a null result... */</comment>
                    <if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ctid is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><name>conflictTid</name> <operator>=</operator> <operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oldtuple</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>oldtuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_existing</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>, 
                                               <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_existing</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, 
                                               <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_existing</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    
                    <comment type="block">/* Project the new tuple version */</comment>
                    <expr_stmt><expr><call><name>ExecProject</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_onConflictSetProj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* Execute UPDATE with projection */</comment>
                    <expr_stmt><expr><operator>*</operator><name>returning</name> <operator>=</operator> <call><name>ExecRemoteUpdate</name><argument_list>(<argument><expr><name>mtstate</name></expr></argument>, <argument><expr><name>conflictTid</name></expr></argument>, <argument><expr><name>oldtuple</name></expr></argument>,
                                            <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_conflproj</name></name></expr></argument>, <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_existing</name></name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name><name>mtstate</name><operator>-&gt;</operator><name>mt_epqstate</name></name></expr></argument>, <argument><expr><name><name>mtstate</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></argument>,
                                            <argument><expr><name>canSetTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>paramval_data</name></name> <operator>=</operator> <name>paramval_data</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>paramval_len</name></name> <operator>=</operator> <name>paramval_len</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>rqs_param_types</name></name> <operator>=</operator> <name>rqs_param_types</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>rqs_num_params</name></name> <operator>=</operator> <name>rqs_num_params</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <name>sql</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>statement</name></name> <operator>=</operator> <name>statement</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>operation</name></name> <operator>=</operator> <name>CMD_INSERT</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>UPSERT_NONE</name></expr>;</expr_stmt>

                <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>UPSERT_UPDATE</name></expr>;</expr_stmt>    

                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected UPSERT action."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></block_content></block></else></if_stmt>

    <comment type="block">/* handle reponse */</comment>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>connections</name></name> <operator>=</operator> <name>connections</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>conn_count</name></name> <operator>=</operator> <name>regular_conn_count</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>current_conn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>combiner</name><operator>-&gt;</operator><name>DML_processed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* 
      * get response from remote datanode while executing DML,
      * we just need to check the affected rows only.
      */</comment>
    <while>while<condition>(<expr><operator>(</operator><name>tupleslot</name> <operator>=</operator> <call><name>FetchTuple</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* we do nothing until we get the commandcomplete response, except for UPSERT case */</comment>
        <expr_stmt><expr><name><name>mtstate</name><operator>-&gt;</operator><name>mt_existing</name></name> <operator>=</operator> <name>tupleslot</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    
    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>errorMessage</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pgxc_node_report_error</name><argument_list>(<argument><expr><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>DML_processed</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>-&gt;</operator><name>DML_processed</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"RemoteDML affects %d rows, more than one row."</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>-&gt;</operator><name>DML_processed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* UPSERT: if select succeed, we can do update directly */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>UPSERT_SELECT</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>UPSERT_UPDATE</name></expr>;</expr_stmt>
            <goto>goto <name>UPSERT</name>;</goto>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>UPSERT_INSERT</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>UPSERT_NONE</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>UPSERT_INSERT</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/* DML succeed */</comment>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* UPSERT: if select failed, we do insert instead */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>UPSERT_SELECT</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>UPSERT_INSERT</name></expr>;</expr_stmt>
            <goto>goto <name>UPSERT</name>;</goto>
        </block_content>}</block></if>
        <comment type="block">/* UPSERT: insert failed, conflict tuple found, re-check the constraints. */</comment>
        <if type="elseif">else if <condition>(<expr><name><name>step</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>UPSERT_INSERT</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>UPSERT_SELECT</name></expr>;</expr_stmt>
            <goto>goto <name>UPSERT</name>;</goto>
        </block_content>}</block></if></if_stmt>
        
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>    <comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>SetCurrentHandlesReadonly</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGXCNodeHandle</name>        <modifier>*</modifier></type><name>conn</name>     <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>handles</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_pgxc_handles_init</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>handles</name> <operator>=</operator> <call><name>get_current_handles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>handles</name><operator>-&gt;</operator><name>dn_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>handles</name><operator>-&gt;</operator><name>datanode_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

        <comment type="block">/* Skip empty slots */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>NO_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>read_only</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

        <comment type="block">/* Skip empty slots */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>==</operator> <name>NO_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>read_only</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>pfree_pgxc_all_handles</name><argument_list>(<argument><expr><name>handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Currently, This function will only be called by CommitSubTranscation.
 * 1. When coordinator, need to send commit_subtxn and clean up connection,
 *       and will not release handle.
 * 2. When datanode, need to send commit transcation and clean up connection,
 *      and will not release handle.
 * 3. When non-subtxn, the parameter of pgxc_node_remote_commit will be 
 *      (TXN_TYPE_CommitTxn , need_release_handle = true)
 */</comment>
<function><type><name>void</name></type>
<name>SubTranscation_PreCommit_Remote</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>temp</name> <init>= <expr><call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
												  <argument><expr><literal type="string">"SubTransaction remote commit context"</literal></expr></argument>,
												  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>old</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Only local coord can send down commit_subtxn when exec plpgsql */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_ORCL_</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>InPlpgsqlFunc</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><call><name>InPlpgsqlFunc</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pgxc_node_remote_commit</name><argument_list>(<argument><expr><name>TXN_TYPE_CommitSubTxn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pgxc_node_remote_commit</name><argument_list>(<argument><expr><name>TXN_TYPE_CommitTxn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Currently, This function will only be called by AbortSubTranscation.
 * 1. When coordinator, need to send rollback_subtxn and clean up connection,
 *       and will not release handle.
 * 2. When datanode, need to send rollback transcation and clean up connection,
 *      and will not release handle.
 * 3. When non-subtxn, the parameter of pgxc_node_remote_abort will be 
 *      (TXN_TYPE_RollbackTxn , need_release_handle = true)
 */</comment>

<function><type><name>void</name></type>
<name>SubTranscation_PreAbort_Remote</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Only local coord can send down commit_subtxn when exec plpgsql */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>InPlpgsqlFunc</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PreAbort_Remote</name><argument_list>(<argument><expr><name>TXN_TYPE_RollbackSubTxn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>IS_PGXC_LOCAL_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PreAbort_Remote</name><argument_list>(<argument><expr><name>TXN_TYPE_CleanConnection</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PreAbort_Remote</name><argument_list>(<argument><expr><name>TXN_TYPE_RollbackTxn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>SetSnapshot</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>state</name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>es_plannedstmt</name></name> <operator>&amp;&amp;</operator> 
        <name><name>state</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>need_snapshot</name></name></expr>)</condition>
    <block>{<block_content> 
        <decl_stmt><decl><type><name>Snapshot</name></type> <name>snap</name></decl>;</decl_stmt>
        
        <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unexpected snapshot"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>need_global_snapshot</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>snap</name> <operator>=</operator> <call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>snap</name> <operator>=</operator> <call><name>GetLocalTransactionSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><name>snap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>es_snapshot</name></name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><name>snap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* snapshot set */</comment>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>need_snapshot</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
