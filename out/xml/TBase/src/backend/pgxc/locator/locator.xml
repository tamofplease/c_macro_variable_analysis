<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/pgxc/locator/locator.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * locator.c
 *        Functions that help manage table location information such as
 * partitioning and replication information.
 *
 *
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 *
 *
 * IDENTIFICATION
 *        $$
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/skey.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/catcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varbit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pgxcship.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/nodemgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/locator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxcnode.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/date.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_key_values.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/shardmap.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Locator details are private
 */</comment>
<struct>struct <name>_Locator</name>
<block>{
    <comment type="block">/*
     * Determine target nodes for value.
     * Resulting nodes are stored to the results array.
     * Function returns number of node references written to the array.
     */</comment>
    <function_decl><type><name>int</name></type>            (<modifier>*</modifier><name>locatefunc</name>) <parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                               <parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>secIsNull</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasprimary</name></decl></parameter>)</parameter_list>;</function_decl>

    <decl_stmt><decl><type><name>Oid</name></type>            <name>dataType</name></decl>;</decl_stmt>         <comment type="block">/* values of that type are passed to locateNodes function */</comment>
    <decl_stmt><decl><type><name>LocatorListType</name></type> <name>listType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>primary</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>groupid</name></decl>;</decl_stmt>        <comment type="block">/* only used by LOCATOR_TYPE_SHARD */</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name>locatorType</name></decl>;</decl_stmt>    <comment type="block">/* locator type */</comment>
    <decl_stmt><decl><type><name>int</name></type>          <name><name>nodeindexMap</name><index>[<expr><name>TBASE_MAX_DATANODE_NUMBER</name></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* map for global node index to local */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type>        <name>need_shardmap_router</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>coldGroupId</name></decl>;</decl_stmt>    <comment type="block">/* cold group oid if exist */</comment>
    <decl_stmt><decl><type><name>AttrNumber</name></type>  <name>secAttrNum</name></decl>;</decl_stmt>     <comment type="block">/* second distribute column's attrNumber */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>secDataType</name></decl>;</decl_stmt>    <comment type="block">/* second distribute column's datatype */</comment>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>relid</name></decl>;</decl_stmt>          
    <decl_stmt><decl><type><name>RelationAccessType</name></type> <name>accessType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name><name>indexMap</name><index>[<expr><name>TBASE_MAX_DATANODE_NUMBER</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* map for global node index to local for cold-hot */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* locator-specific data */</comment>
    <comment type="block">/* XXX: move them into union ? */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>roundRobinNode</name></decl>;</decl_stmt> <comment type="block">/* for LOCATOR_TYPE_RROBIN */</comment>
    <decl_stmt><decl><type><name>LocatorHashFunc</name></type>    <name>hashfunc</name></decl>;</decl_stmt> <comment type="block">/* for LOCATOR_TYPE_HASH */</comment>
    <decl_stmt><decl><type><name>int</name></type>         <name>valuelen</name></decl>;</decl_stmt> <comment type="block">/* 1, 2 or 4 for LOCATOR_TYPE_MODULO */</comment>

    <decl_stmt><decl><type><name>int</name></type>            <name>nodeCount</name></decl>;</decl_stmt> <comment type="block">/* How many nodes are in the map */</comment>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>nodeMap</name></decl>;</decl_stmt> <comment type="block">/* map index to node reference according to listType */</comment>
    <decl_stmt><decl><type><name>void</name>       <modifier>*</modifier></type><name>results</name></decl>;</decl_stmt> <comment type="block">/* array to output results */</comment>
}</block>;</struct>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>Oid</name></type>  <name>opno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>isswap</name></decl>;</decl_stmt>
}</block></struct></type><name>DisQual</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>Oid</name></type>        <name>primary_data_node</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>        <name>num_preferred_data_nodes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Oid</name></type>        <name><name>preferred_data_node</name><index>[<expr><name>MAX_PREFERRED_NODES</name></expr>]</index></name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>modulo_value_len</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dataType</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>locate_static</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                <parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>secIsNull</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasprimary</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>locate_roundrobin</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                       <parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>secIsNull</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                       <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasprimary</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>locate_modulo_random</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                              <parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>secIsNull</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                              <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasprimary</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>locate_hash_insert</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                        <parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>secIsNull</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasprimary</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>locate_hash_select</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                        <parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>secIsNull</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasprimary</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>locate_shard_insert</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                                    <parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>secIsNull</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                    <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasprimary</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>locate_shard_select</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                            <parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>secIsNull</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasprimary</name></decl></parameter>)</parameter_list>;</function_decl>
                   
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>locate_modulo_insert</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                           <parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>secIsNull</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
                           <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasprimary</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>locate_modulo_select</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                            <parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>secIsNull</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasprimary</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type> <name>pgxc_find_distcol_expr</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>,
                       <parameter><decl><type><name>AttrNumber</name></type> <name>attrNum</name></decl></parameter>,
                       <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>)</parameter_list>;</function_decl>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>

<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>pgxc_find_distcol_exprs</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>,
                                     <parameter><decl><type><name>AttrNumber</name></type> <name>attrNum</name></decl></parameter>,
                                    <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>ExecNodes</name> <modifier>*</modifier></type><name>GetRelationTimeStampRangeNodes</name><parameter_list>(<parameter><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rel_loc_info</name></decl></parameter>, 
                                <parameter><decl><type><name>Datum</name></type> <name>valueForDistCol</name></decl></parameter>, 
                                <parameter><decl><type><name>bool</name></type> <name>isValueNull</name></decl></parameter>, 
                                <parameter><decl><type><name>Oid</name></type> <name>typeOfValueForDistCol</name></decl></parameter>,                
                                <parameter><decl><type><name>Oid</name></type> <name>typeOfValueForSecDistCol</name></decl></parameter>,
                                <parameter><decl><type><name>Datum</name></type> <name>minForSecCol</name></decl></parameter>, 
                                <parameter><decl><type><name>Datum</name></type> <name>maxForSecCol</name></decl></parameter>, 
                                <parameter><decl><type><name>bool</name></type>  <name>equalMin</name></decl></parameter>,
                                <parameter><decl><type><name>bool</name></type>  <name>equalMax</name></decl></parameter>,
                                <parameter><decl><type><name>RelationAccessType</name></type> <name>accessType</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsConstAligned</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>reloid</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>constvalue</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>secAttr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>TimeStampRange</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>op</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>DatanodeInGroup</name><parameter_list>(<parameter><decl><type><name>oidvector</name><modifier>*</modifier></type> <name>nodeoids</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>nodeoid</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * GetPreferredReplicationNode
 * Pick any Datanode from given list, however fetch a preferred node first.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetPreferredReplicationNode</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relNodes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nodeid</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>relNodes</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"a list of nodes should have at least one node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <macro><name>foreach</name><argument_list>(<argument>item</argument>, <argument>relNodes</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>cnt_nodes</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name>nodetype</name> <init>= <expr><name>PGXC_NODE_DATANODE</name></expr></init></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>cnt_nodes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
                <condition><expr><name>cnt_nodes</name> <operator>&lt;</operator> <name>num_preferred_data_nodes</name> <operator>&amp;&amp;</operator> <name>nodeid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</condition>
                <incr><expr><name>cnt_nodes</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name><name>preferred_data_node</name><index>[<expr><name>cnt_nodes</name></expr>]</index></name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>nodetype</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
                <expr_stmt><expr><name>nodeid</name> <operator>=</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
        <if_stmt><if>if <condition>(<expr><name>nodeid</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
            <break>break;</break>
    </block_content>}</block></if></if_stmt>
	</block_content>}</block>
    <if_stmt><if>if <condition>(<expr><name>nodeid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
        <return>return <expr><call><name>list_make1_int</name><argument_list>(<argument><expr><call><name>list_nth_int</name><argument_list>(<argument><expr><name>relNodes</name></expr></argument>,
                    <argument><expr><operator>(</operator><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <call><name>random</name><argument_list>()</argument_list></call><operator>)</operator> <operator>%</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>relNodes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

    <return>return <expr><call><name>list_make1_int</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetAnyDataNode
 * Pick any data node from given set, but try a preferred node
 */</comment>
<function><type><name>int</name></type>
<name>GetAnyDataNode</name><parameter_list>(<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nodes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>preferred</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>, <decl><type ref="prev"/><name>nodeid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nmembers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name><name>members</name><index>[<expr><name>NumDataNodes</name></expr>]</index></name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_preferred_data_nodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name>ntype</name> <init>= <expr><name>PGXC_NODE_DATANODE</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>nodeid</name> <operator>=</operator> <call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name><name>preferred_data_node</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ntype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* OK, found one */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
            <expr_stmt><expr><name>preferred</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>preferred</name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

    <comment type="block">/*
     * If no preferred data nodes or they are not in the desired set, pick up
     * from the original set.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>preferred</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><name>preferred</name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Load balance.
     * We can not get item from the set, convert it to array
     */</comment>
    <while>while <condition>(<expr><operator>(</operator><name>nodeid</name> <operator>=</operator> <call><name>bms_first_member</name><argument_list>(<argument><expr><name>preferred</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>members</name><index>[<expr><name>nmembers</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>nodeid</name></expr>;</expr_stmt></block_content></block></while>
    <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>preferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If there is a single member nothing to balance */</comment>
    <if_stmt><if>if <condition>(<expr><name>nmembers</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
        <return>return <expr><name><name>members</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * In general, the set may contain any number of nodes, and if we save
     * previous returned index for load balancing the distribution won't be
     * flat, because small set will probably reset saved value, and lower
     * indexes will be picked up more often.
     * So we just get a random value from 0..nmembers-1.
     */</comment>
    <return>return <expr><name><name>members</name><index>[<expr><operator>(</operator><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <call><name>random</name><argument_list>()</argument_list></call><operator>)</operator> <operator>%</operator> <name>nmembers</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * compute_modulo
 *    Computes modulo of two 64-bit unsigned values.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compute_modulo</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>numerator</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>denominator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>denominator</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>numerator</name> <operator>%</operator> <name>denominator</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetRelationDistColumn - Returns the name of the hash or modulo distribution column
 * First hash distribution is checked
 * Retuens NULL if the table is neither hash nor modulo distributed
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetRelationDistColumn</name><parameter_list>(<parameter><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type> <name>rel_loc_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pColName</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pColName</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>pColName</name> <operator>=</operator> <call><name>GetRelationHashColumn</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>pColName</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><name>pColName</name> <operator>=</operator> <call><name>GetRelationModuloColumn</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <return>return <expr><name>pColName</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>

<comment type="block">/*
 * IsTypeDistributable
 * Returns whether the data type is distributable using a column value.
 */</comment>
<function><type><name>bool</name></type>
<name>IsTypeDistributable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>col_type</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if<condition>(<expr><name>col_type</name> <operator>==</operator> <name>INT8OID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>INT2OID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>OIDOID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>INT4OID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>BOOLOID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>CHAROID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>NAMEOID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>INT2VECTOROID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>TEXTOID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>OIDVECTOROID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>FLOAT4OID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>FLOAT8OID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>ABSTIMEOID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>RELTIMEOID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>CASHOID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>BPCHAROID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>BYTEAOID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>VARCHAROID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>DATEOID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>TIMEOID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>TIMESTAMPOID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>TIMESTAMPTZOID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>INTERVALOID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>TIMETZOID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>NUMERICOID</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_ORCL_</name></cpp:ifdef>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>VARCHAR2OID</name>
    <operator>||</operator> <name>col_type</name> <operator>==</operator> <name>NVARCHAR2OID</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    )</condition>
	<block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Returns whether or not the data type is hash distributable with PG-XC
 * PGXCTODO - expand support for other data types!
 */</comment>
<function><type><name>bool</name></type>
<name>IsTypeHashDistributable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>col_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><call><name>hash_func_ptr</name><argument_list>(<argument><expr><name>col_type</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetRelationHashColumn - return hash column for relation.
 *
 * Returns NULL if the relation is not hash partitioned.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetRelationHashColumn</name><parameter_list>(<parameter><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type> <name>rel_loc_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>column_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>rel_loc_info</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><name>column_str</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>!=</operator> <name>LOCATOR_TYPE_HASH</name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><name>column_str</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>            <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>partAttrName</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>column_str</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>column_str</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>partAttrName</name></name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>column_str</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsDistColumnForRelId - return whether or not column for relation is used for hash or modulo distribution
 *
 */</comment>
<function><type><name>bool</name></type>
<name>IsDistColumnForRelId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>part_col_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rel_loc_info</name></decl>;</decl_stmt>

    <comment type="block">/* if no column is specified, we're done */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>part_col_name</name></expr>)</condition>
	<block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/* if no locator, we're done too */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>rel_loc_info</name> <operator>=</operator> <call><name>GetRelationLocInfo</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/* is the table distributed by column value */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsRelationDistributedByValue</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/* does the column name match the distribution column */</comment>
    <return>return <expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>part_col_name</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>partAttrName</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Returns whether or not the data type is modulo distributable with PG-XC
 * PGXCTODO - expand support for other data types!
 */</comment>
<function><type><name>bool</name></type>
<name>IsTypeModuloDistributable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>col_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><call><name>modulo_value_len</name><argument_list>(<argument><expr><name>col_type</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetRelationModuloColumn - return modulo column for relation.
 *
 * Returns NULL if the relation is not modulo partitioned.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetRelationModuloColumn</name><parameter_list>(<parameter><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type> <name>rel_loc_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>column_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>rel_loc_info</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><name>column_str</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>!=</operator> <name>LOCATOR_TYPE_MODULO</name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><name>column_str</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>    <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>partAttrName</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>column_str</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>column_str</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>partAttrName</name></name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>column_str</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Update the round robin node for the relation
 *
 * PGXCTODO - may not want to bother with locking here, we could track
 * these in the session memory context instead...
 */</comment>
<function><type><name>int</name></type>
<name>GetRoundRobinNode</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>ret_node</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><call><name>IsLocatorReplicated</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name><operator>-&gt;</operator><name>locatorType</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
            <name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_RROBIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ret_node</name> <operator>=</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name><operator>-&gt;</operator><name>roundRobinNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Move round robin indicator to next node */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name><operator>-&gt;</operator><name>roundRobinNode</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name><operator>-&gt;</operator><name>roundRobinNode</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name><operator>-&gt;</operator><name>roundRobinNode</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
    <else>else
	<block>{<block_content>
        <comment type="block">/* reset to first one */</comment>
        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name><operator>-&gt;</operator><name>roundRobinNode</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name><operator>-&gt;</operator><name>rl_nodeList</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ret_node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsTableDistOnPrimary
 *
 * Does the table distribution list include the primary node?
 */</comment>
<function><type><name>bool</name></type>
<name>IsTableDistOnPrimary</name><parameter_list>(<parameter><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rel_loc_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>primary_data_node</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <name>rel_loc_info</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <call><name>list_length</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>rl_nodeList</name></name> <operator>=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

    <macro><name>foreach</name><argument_list>(<argument>item</argument>, <argument>rel_loc_info-&gt;rl_nodeList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name>ntype</name> <init>= <expr><name>PGXC_NODE_DATANODE</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name>primary_data_node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ntype</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
            <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
	</block_content>}</block>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IsLocatorInfoEqual
 * Check equality of given locator information
 */</comment>
<function><type><name>bool</name></type>
<name>IsLocatorInfoEqual</name><parameter_list>(<parameter><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rel_loc_info1</name></decl></parameter>, <parameter><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rel_loc_info2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeList1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nodeList2</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rel_loc_info1</name> <operator>&amp;&amp;</operator> <name>rel_loc_info2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>nodeList1</name> <operator>=</operator> <name><name>rel_loc_info1</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nodeList2</name> <operator>=</operator> <name><name>rel_loc_info2</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr>;</expr_stmt>

    <comment type="block">/* Same relation? */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel_loc_info1</name><operator>-&gt;</operator><name>relid</name></name> <operator>!=</operator> <name><name>rel_loc_info2</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition>
	<block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/* Same locator type? */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel_loc_info1</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>!=</operator> <name><name>rel_loc_info2</name><operator>-&gt;</operator><name>locatorType</name></name></expr>)</condition>
	<block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/* Same attribute number? */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel_loc_info1</name><operator>-&gt;</operator><name>partAttrNum</name></name> <operator>!=</operator> <name><name>rel_loc_info2</name><operator>-&gt;</operator><name>partAttrNum</name></name></expr>)</condition>
	<block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/* Same node list? */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_difference_int</name><argument_list>(<argument><expr><name>nodeList1</name></expr></argument>, <argument><expr><name>nodeList2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name> <operator>||</operator>
        <call><name>list_difference_int</name><argument_list>(<argument><expr><name>nodeList2</name></expr></argument>, <argument><expr><name>nodeList1</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/* Everything is equal */</comment>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ConvertToLocatorType
 *        get locator distribution type
 * We really should just have pgxc_class use disttype instead...
 */</comment>
<function><type><name>char</name></type>
<name>ConvertToLocatorType</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>disttype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name>loctype</name> <init>= <expr><name>LOCATOR_TYPE_NONE</name></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>disttype</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>DISTTYPE_HASH</name></expr>:</case>
            <expr_stmt><expr><name>loctype</name> <operator>=</operator> <name>LOCATOR_TYPE_HASH</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>DISTTYPE_ROUNDROBIN</name></expr>:</case>
            <expr_stmt><expr><name>loctype</name> <operator>=</operator> <name>LOCATOR_TYPE_RROBIN</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>DISTTYPE_REPLICATION</name></expr>:</case>
            <expr_stmt><expr><name>loctype</name> <operator>=</operator> <name>LOCATOR_TYPE_REPLICATED</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>DISTTYPE_MODULO</name></expr>:</case>
            <expr_stmt><expr><name>loctype</name> <operator>=</operator> <name>LOCATOR_TYPE_MODULO</name></expr>;</expr_stmt>
            <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_SHARDING_</name></cpp:ifdef>
        <case>case <expr><name>DISTTYPE_SHARD</name></expr>:</case>
            <expr_stmt><expr><name>loctype</name> <operator>=</operator> <name>LOCATOR_TYPE_SHARD</name></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <default>default:</default>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid distribution type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>loctype</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetLocatorType - Returns the locator type of the table
 *
 */</comment>
<function><type><name>char</name></type>
<name>GetLocatorType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>        <name>ret</name> <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>ret_loc_info</name> <init>= <expr><call><name>GetRelationLocInfo</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>ret_loc_info</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>ret_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Return a list of all Datanodes.
 * We assume all tables use all nodes in the prototype, so just return a list
 * from first one.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetAllDataNodes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>nodeList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>nodeList</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>nodeList</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <return>return <expr><name>nodeList</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a list of all Coordinators
 * This is used to send DDL to all nodes and to clean up pooler connections.
 * Do not put in the list the local Coordinator where this function is launched.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetAllCoordNodes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>nodeList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumCoords</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * Do not put in list the Coordinator we are on,
         * it doesn't make sense to connect to the local Coordinator.
         */</comment>

        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>PGXCNodeId</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
            <expr_stmt><expr><name>nodeList</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>nodeList</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

    <return>return <expr><name>nodeList</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a list of all Coordinators.
 * Including local Coordinator.
 * This is used to clean up pooler connections.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetEntireCoordNodes</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NumCoords</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>nodeList</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>nodeList</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>nodeList</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type> <name>DatanodeInGroup</name><parameter_list>(<parameter><decl><type><name>oidvector</name><modifier>*</modifier></type> <name>nodeoids</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>nodeoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator><name><name>nodeoids</name><operator>-&gt;</operator><name>dim1</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>nodeoids</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>nodeoid</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build locator information associated with the specified relation.
 */</comment>
<function><type><name>void</name></type>
<name>RelationBuildLocator</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>pcrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type>    <name>skey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type>    <name>pcscan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>htup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type>    <name>oldContext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelationLocInfo</name>    <modifier>*</modifier></type><name>relationLocInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pgxc_class</name></type>    <name>pgxc_class</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name>node_in_group</name> <init>=  <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>                <name>curr_nodeoid</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
                <argument><expr><name>Anum_pgxc_class_pcrelid</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pcrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>PgxcClassRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pcscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pcrel</name></expr></argument>, <argument><expr><name>PgxcClassPgxcRelIdIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                <argument><expr><name>SnapshotSelf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>pcscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Assume local relation only */</comment>
        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>pcscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pcrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>pgxc_class</name> <operator>=</operator> <operator>(</operator><name>Form_pgxc_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>relationLocInfo</name> <operator>=</operator> <operator>(</operator><name>RelationLocInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelationLocInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name></name> <operator>=</operator> <name>relationLocInfo</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>=</operator> <name><name>pgxc_class</name><operator>-&gt;</operator><name>pclocatortype</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>partAttrNum</name></name> <operator>=</operator> <name><name>pgxc_class</name><operator>-&gt;</operator><name>pcattnum</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>partAttrName</name></name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>pgxc_class</name><operator>-&gt;</operator><name>pcattnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
    <expr_stmt><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>groupId</name></name> <operator>=</operator> <name><name>pgxc_class</name><operator>-&gt;</operator><name>pgroup</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>coldGroupId</name></name> <operator>=</operator> <name><name>pgxc_class</name><operator>-&gt;</operator><name>pcoldgroup</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>secAttrNum</name></name> <operator>=</operator> <name><name>pgxc_class</name><operator>-&gt;</operator><name>psecondattnum</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>secAttrName</name></name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>pgxc_class</name><operator>-&gt;</operator><name>psecondattnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>rl_nodeList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
    <expr_stmt><expr><call><name>SyncShardMapList</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>curr_nodeoid</name> <operator>=</operator> <call><name>get_pgxc_nodeoid_extend</name><argument_list>(<argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name>PGXCMainClusterName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>curr_nodeoid</name></expr>)</condition>
    <block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no such node:%s on PGXCMainClusterName %s PGXCClustername %s"</literal></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name>PGXCMainClusterName</name></expr></argument>,
		     <argument><expr><name>PGXCClusterName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>node_in_group</name> <operator>=</operator> <call><name>DatanodeInGroup</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pgxc_class</name><operator>-&gt;</operator><name>nodeoids</name></name><operator>)</operator></expr></argument>, <argument><expr><name>curr_nodeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>||</operator> <operator>(</operator><name>IS_PGXC_DATANODE</name> <operator>&amp;&amp;</operator> <name>node_in_group</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int32</name></type>     <name>dn_num</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name>  <modifier>*</modifier></type><name>datanodes</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
            <decl_stmt><decl><type><name>int32</name></type>    <name>nGroup</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name>     <modifier>*</modifier></type><name>groups</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>      <name>i</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>      <name>relationId</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="block">/* major map */</comment>
            <expr_stmt><expr><call><name>GetShardNodes</name><argument_list>(<argument><expr><name><name>pgxc_class</name><operator>-&gt;</operator><name>pgroup</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datanodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dn_num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for<control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>dn_num</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>                            
                <expr_stmt><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>rl_nodeList</name></name> <operator>=</operator> <call><name>list_append_unique_int</name><argument_list>(<argument><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr></argument>, <argument><expr><name><name>datanodes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>datanodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* cold group if exist */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>pgxc_class</name><operator>-&gt;</operator><name>pcoldgroup</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>GetShardNodes</name><argument_list>(<argument><expr><name><name>pgxc_class</name><operator>-&gt;</operator><name>pcoldgroup</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datanodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dn_num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <for>for<control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>dn_num</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>                
						<expr_stmt><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>rl_nodeList</name></name> <operator>=</operator> <call><name>list_append_unique_int</name><argument_list>(<argument><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr></argument>,
						                                                      <argument><expr><name><name>datanodes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>datanodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>relationId</name> <operator>=</operator> <name><name>relationLocInfo</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_CHILD</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>relationId</name> <operator>=</operator> <call><name>RELATION_GET_PARENT</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* secondary group */</comment>
                <expr_stmt><expr><call><name>GetRelationSecondGroup</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>groups</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nGroup</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>GetShardNodes</name><argument_list>(<argument><expr><name><name>groups</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datanodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dn_num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <for>for<control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>dn_num</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>                
						<expr_stmt><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>rl_nodeList</name></name> <operator>=</operator> <call><name>list_append_unique_int</name><argument_list>(<argument><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr></argument>,
						                                                      <argument><expr><name><name>datanodes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>datanodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                
                <if_stmt><if>if <condition>(<expr><name>nGroup</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>pgxc_class</name><operator>-&gt;</operator><name>nodeoids</name><operator>.</operator><name>dim1</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name></type> <name>ntype</name> <init>= <expr><name>PGXC_NODE_DATANODE</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>nid</name> <init>= <expr><call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name><name>pgxc_class</name><operator>-&gt;</operator><name>nodeoids</name><operator>.</operator><name>values</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ntype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>rl_nodeList</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr></argument>, <argument><expr><name>nid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
        </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/*
         * If the locator type is round robin, we set a node to
         * use next time. In addition, if it is replicated,
         * we choose a node to use for balancing reads.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_RROBIN</name>
            <operator>||</operator> <call><name>IsLocatorReplicated</name><argument_list>(<argument><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>locatorType</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>
            <comment type="block">/*
             * pick a random one to start with,
             * since each process will do this independently
             */</comment>
            <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>compute_modulo</name><argument_list>(<argument><expr><call><name>abs</name><argument_list>(<argument><expr><call><name>rand</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>roundRobinNode</name></name> <operator>=</operator> <name><name>relationLocInfo</name><operator>-&gt;</operator><name>rl_nodeList</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt> <comment type="block">/* initialize */</comment>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>offset</name> <operator>&amp;&amp;</operator> <name><name>relationLocInfo</name><operator>-&gt;</operator><name>roundRobinNode</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>roundRobinNode</name></name> <operator>=</operator> <name><name>relationLocInfo</name><operator>-&gt;</operator><name>roundRobinNode</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>pcscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pcrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GetLocatorRelationInfo - Returns the locator information for relation,
 * in a copy of the RelationLocatorInfo struct in relcache
 */</comment>
<function><type><name>RelationLocInfo</name> <modifier>*</modifier></type>
<name>GetRelationLocInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>ret_loc_info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Relation needs to be valid */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_isvalid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name></name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><name>ret_loc_info</name> <operator>=</operator> <call><name>CopyRelationLocInfo</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>ret_loc_info</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the distribution type of relation.
 */</comment>
<function><type><name>char</name></type>
<name>GetRelationLocType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>locinfo</name> <init>= <expr><call><name>GetRelationLocInfo</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>locinfo</name></expr>)</condition>
	<block>{<block_content>
        <return>return <expr><name>LOCATOR_TYPE_NONE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

    <return>return <expr><name><name>locinfo</name><operator>-&gt;</operator><name>locatorType</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy the RelationLocInfo struct
 */</comment>
<function><type><name>RelationLocInfo</name> <modifier>*</modifier></type>
<name>CopyRelationLocInfo</name><parameter_list>(<parameter><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type> <name>src_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>dest_info</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>src_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>dest_info</name> <operator>=</operator> <operator>(</operator><name>RelationLocInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelationLocInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>dest_info</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name><name>src_info</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>=</operator> <name><name>src_info</name><operator>-&gt;</operator><name>locatorType</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest_info</name><operator>-&gt;</operator><name>partAttrNum</name></name> <operator>=</operator> <name><name>src_info</name><operator>-&gt;</operator><name>partAttrNum</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>src_info</name><operator>-&gt;</operator><name>partAttrName</name></name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><name><name>dest_info</name><operator>-&gt;</operator><name>partAttrName</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>src_info</name><operator>-&gt;</operator><name>partAttrName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
    <expr_stmt><expr><name><name>dest_info</name><operator>-&gt;</operator><name>groupId</name></name>     <operator>=</operator> <name><name>src_info</name><operator>-&gt;</operator><name>groupId</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <expr_stmt><expr><name><name>dest_info</name><operator>-&gt;</operator><name>coldGroupId</name></name> <operator>=</operator> <name><name>src_info</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dest_info</name><operator>-&gt;</operator><name>secAttrNum</name></name> <operator>=</operator> <name><name>src_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>src_info</name><operator>-&gt;</operator><name>secAttrName</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>dest_info</name><operator>-&gt;</operator><name>secAttrName</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>src_info</name><operator>-&gt;</operator><name>secAttrName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name><name>src_info</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><name><name>dest_info</name><operator>-&gt;</operator><name>rl_nodeList</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>src_info</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
    <comment type="block">/* Note, for round robin, we use the relcache entry */</comment>

    <return>return <expr><name>dest_info</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Free RelationLocInfo struct
 */</comment>
<function><type><name>void</name></type>
<name>FreeRelationLocInfo</name><parameter_list>(<parameter><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>relationLocInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>relationLocInfo</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>partAttrName</name></name></expr>)</condition>
		<block>{<block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>partAttrName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>secAttrName</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>secAttrName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>relationLocInfo</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>relationLocInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Free the contents of the ExecNodes expression */</comment>
<function><type><name>void</name></type>
<name>FreeExecNodes</name><parameter_list>(<parameter><decl><type><name>ExecNodes</name> <modifier>*</modifier><modifier>*</modifier></type><name>exec_nodes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>tmp_en</name> <init>= <expr><operator>*</operator><name>exec_nodes</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Nothing to do */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp_en</name></expr>)</condition>
	<block>{<block_content>
        <return>return;</return>
	</block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>tmp_en</name><operator>-&gt;</operator><name>primarynodelist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>tmp_en</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tmp_en</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>exec_nodes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>

<comment type="block">/*
 * Determine value length in bytes for specified type for a module locator.
 * Return -1 if module locator is not supported for the type.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>modulo_value_len</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dataType</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <switch>switch <condition>(<expr><name>dataType</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>BOOLOID</name></expr>:</case>
        <case>case <expr><name>CHAROID</name></expr>:</case>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        <case>case <expr><name>INT2OID</name></expr>:</case>
            <return>return <expr><literal type="number">2</literal></expr>;</return>
        <case>case <expr><name>INT4OID</name></expr>:</case>
        <case>case <expr><name>ABSTIMEOID</name></expr>:</case>
        <case>case <expr><name>RELTIMEOID</name></expr>:</case>
        <case>case <expr><name>DATEOID</name></expr>:</case>
            <return>return <expr><literal type="number">4</literal></expr>;</return>
        <case>case <expr><name>INT8OID</name></expr>:</case>
            <return>return <expr><literal type="number">8</literal></expr>;</return>
        <default>default:</default>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>


<function><type><name>LocatorHashFunc</name></type>
<name>hash_func_ptr</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dataType</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <switch>switch <condition>(<expr><name>dataType</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>INT8OID</name></expr>:</case>
        <case>case <expr><name>CASHOID</name></expr>:</case>
            <return>return <expr><name>hashint8</name></expr>;</return>
        <case>case <expr><name>INT2OID</name></expr>:</case>
            <return>return <expr><name>hashint2</name></expr>;</return>
        <case>case <expr><name>OIDOID</name></expr>:</case>
            <return>return <expr><name>hashoid</name></expr>;</return>
        <case>case <expr><name>INT4OID</name></expr>:</case>
        <case>case <expr><name>ABSTIMEOID</name></expr>:</case>
        <case>case <expr><name>RELTIMEOID</name></expr>:</case>
        <case>case <expr><name>DATEOID</name></expr>:</case>
            <return>return <expr><name>hashint4</name></expr>;</return>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <case>case <expr><name>FLOAT4OID</name></expr>:</case>
            <return>return <expr><name>hashfloat4</name></expr>;</return>
        <case>case <expr><name>FLOAT8OID</name></expr>:</case>
            <return>return <expr><name>hashfloat8</name></expr>;</return>
        <case>case <expr><name>JSONBOID</name></expr>:</case>
            <return>return <expr><name>jsonb_hash</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>BOOLOID</name></expr>:</case>
        <case>case <expr><name>CHAROID</name></expr>:</case>
            <return>return <expr><name>hashchar</name></expr>;</return>
        <case>case <expr><name>NAMEOID</name></expr>:</case>
            <return>return <expr><name>hashname</name></expr>;</return>
        <case>case <expr><name>VARCHAROID</name></expr>:</case>
        <case>case <expr><name>TEXTOID</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_PG_ORCL_</name></cpp:ifdef>
        <case>case  <expr><name>VARCHAR2OID</name></expr>:</case>
        <case>case  <expr><name>NVARCHAR2OID</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <return>return <expr><name>hashtext</name></expr>;</return>
        <case>case <expr><name>OIDVECTOROID</name></expr>:</case>
            <return>return <expr><name>hashoidvector</name></expr>;</return>
        <case>case <expr><name>BPCHAROID</name></expr>:</case>
            <return>return <expr><name>hashbpchar</name></expr>;</return>
        <case>case <expr><name>BYTEAOID</name></expr>:</case>
            <return>return <expr><name>hashvarlena</name></expr>;</return>
        <case>case <expr><name>TIMEOID</name></expr>:</case>
            <return>return <expr><name>time_hash</name></expr>;</return>
        <case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
        <case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
            <return>return <expr><name>timestamp_hash</name></expr>;</return>
        <case>case <expr><name>INTERVALOID</name></expr>:</case>
            <return>return <expr><name>interval_hash</name></expr>;</return>
        <case>case <expr><name>TIMETZOID</name></expr>:</case>
            <return>return <expr><name>timetz_hash</name></expr>;</return>
        <case>case <expr><name>NUMERICOID</name></expr>:</case>
            <return>return <expr><name>hash_numeric</name></expr>;</return>
        <case>case <expr><name>UUIDOID</name></expr>:</case>
            <return>return <expr><name>uuid_hash</name></expr>;</return>
		<case>case <expr><name>BITOID</name></expr>:</case>
		<case>case <expr><name>VARBITOID</name></expr>:</case>
			<return>return <expr><name>bithash</name></expr>;</return>
        <default>default:</default>
            <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>

<decl_stmt><decl><type><name>Locator</name> <modifier>*</modifier></type>
<name>createLocator</name><argument_list>(<argument><expr><name>char</name> <name>locatorType</name></expr></argument>, <argument><expr><name>RelationAccessType</name> <name>accessType</name></expr></argument>,
              <argument><expr><name>Oid</name> <name>dataType</name></expr></argument>, <argument><expr><name>LocatorListType</name> <name>listType</name></expr></argument>, <argument><expr><name>int</name> <name>nodeCount</name></expr></argument>,
              <argument><expr><name>void</name> <operator>*</operator><name>nodeList</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><operator>*</operator><name>result</name></expr></argument>, <argument><expr><name>bool</name> <name>primary</name></expr></argument>, <argument><expr><name>Oid</name> <name>groupid</name></expr></argument>,
              <argument><expr><name>Oid</name> <name>coldGroupId</name></expr></argument>, <argument><expr><name>Oid</name> <name>secDataType</name></expr></argument>, <argument><expr><name>AttrNumber</name> <name>secAttrNum</name></expr></argument>,
              <argument><expr><name>Oid</name> <name>relid</name></expr></argument>)</argument_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<name>Locator</name> <modifier>*</modifier>
<name>createLocator</name><argument_list>(<argument><expr><name>char</name> <name>locatorType</name></expr></argument>, <argument><expr><name>RelationAccessType</name> <name>accessType</name></expr></argument>,
              <argument><expr><name>Oid</name> <name>dataType</name></expr></argument>, <argument><expr><name>LocatorListType</name> <name>listType</name></expr></argument>, <argument><expr><name>int</name> <name>nodeCount</name></expr></argument>,
              <argument><expr><name>void</name> <operator>*</operator><name>nodeList</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><operator>*</operator><name>result</name></expr></argument>, <argument><expr><name>bool</name> <name>primary</name></expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>              
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Locator</name>    <modifier>*</modifier></type><name>locator</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name>        <modifier>*</modifier></type><name>nodeMap</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>locator</name> <operator>=</operator> <operator>(</operator><name>Locator</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Locator</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>dataType</name></name> <operator>=</operator> <name>dataType</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>listType</name></name> <operator>=</operator> <name>listType</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>=</operator> <name>nodeCount</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
    <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>groupid</name></name>  <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>=</operator> <name>locatorType</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>coldGroupId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>accessType</name></name> <operator>=</operator> <name>accessType</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>secAttrNum</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>secDataType</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>need_shardmap_router</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>indexMap</name></name></expr></argument>, <argument><expr><literal type="number">0xff</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>TBASE_MAX_DATANODE_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
    <comment type="block">/* Create node map */</comment>
    <switch>switch <condition>(<expr><name>listType</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>LOCATOR_LIST_NONE</name></expr>:</case>
            <comment type="block">/* No map, return indexes */</comment>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_LIST_INT</name></expr>:</case>
            <comment type="block">/* Copy integer array */</comment>
            <expr_stmt><expr><name>nodeMap</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nodeCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>nodeMap</name></expr></argument>, <argument><expr><name>nodeList</name></expr></argument>, <argument><expr><name>nodeCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_LIST_OID</name></expr>:</case>
            <comment type="block">/* Copy array of Oids */</comment>
            <expr_stmt><expr><name>nodeMap</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nodeCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>nodeMap</name></expr></argument>, <argument><expr><name>nodeList</name></expr></argument>, <argument><expr><name>nodeCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_LIST_POINTER</name></expr>:</case>
            <comment type="block">/* Copy array of Oids */</comment>
            <expr_stmt><expr><name>nodeMap</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nodeCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>nodeMap</name></expr></argument>, <argument><expr><name>nodeList</name></expr></argument>, <argument><expr><name>nodeCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_LIST_LIST</name></expr>:</case>
            <comment type="block">/* Create map from list */</comment>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>nodeList</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>IntList</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>intptr</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>nodeMap</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>intptr</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>nodeMap</name></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>l</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>intptr</name><operator>++</operator> <operator>=</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>listType</name></name> <operator>=</operator> <name>LOCATOR_LIST_INT</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>OidList</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>oidptr</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>nodeMap</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>oidptr</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name>nodeMap</name></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>l</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>oidptr</name><operator>++</operator> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>listType</name></name> <operator>=</operator> <name>LOCATOR_LIST_OID</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>voidptr</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>nodeMap</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>voidptr</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>nodeMap</name></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>l</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>voidptr</name><operator>++</operator> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>listType</name></name> <operator>=</operator> <name>LOCATOR_LIST_POINTER</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* can not get here */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>
        </block_content>}</block>
    </block_content>}</block></switch>
    <comment type="block">/*
     * Determine locatefunc, allocate results, set up parameters
     * specific to locator type
     */</comment>
    <switch>switch <condition>(<expr><name>locatorType</name></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
        <case>case <expr><name>LOCATOR_TYPE_SHARD</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>RELATION_ACCESS_INSERT</name> <operator>==</operator> <name>accessType</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>locatefunc</name></name> <operator>=</operator> <name>locate_shard_insert</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeMap</name></name> <operator>=</operator> <name>nodeMap</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>groupid</name></name> <operator>=</operator> <name>groupid</name></expr>;</expr_stmt><empty_stmt>;</empty_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>IS_PGXC_COORDINATOR</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>coldGroupId</name></name> <operator>=</operator> <name>coldGroupId</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>secAttrNum</name></name> <operator>=</operator> <name>secAttrNum</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>secDataType</name></name> <operator>=</operator> <name>secDataType</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name>secAttrNum</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>coldGroupId</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>need_shardmap_router</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>int32</name></type>    <name>nGroup</name></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>Oid</name>     <modifier>*</modifier></type><name>groups</name></decl>;</decl_stmt>
                            
                            <expr_stmt><expr><call><name>GetRelationSecondGroup</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>groups</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><name>nGroup</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>need_shardmap_router</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <switch>switch <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>listType</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>LOCATOR_LIST_NONE</name></expr>:</case>
                    <case>case <expr><name>LOCATOR_LIST_INT</name></expr>:</case>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_OID</name></expr>:</case>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_POINTER</name></expr>:</case>
                        <expr_stmt><expr><call><name>GetGroupNodeIndexMap</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>groupid</name></name></expr></argument>, <argument><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeindexMap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>need_shardmap_router</name></name></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                            <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>rel-&gt;rd_locator_info-&gt;rl_nodeList</argument>)</argument_list></macro>
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>indexMap</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
                            </block_content>}</block>

                            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_LIST</name></expr>:</case>
                        <comment type="block">/* Should never happen */</comment>
                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>locatefunc</name></name> <operator>=</operator> <name>locate_shard_select</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeMap</name></name> <operator>=</operator> <name>nodeMap</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>groupid</name></name> <operator>=</operator> <name>groupid</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>IS_PGXC_COORDINATOR</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>coldGroupId</name></name> <operator>=</operator> <name>coldGroupId</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>secAttrNum</name></name> <operator>=</operator> <name>secAttrNum</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>secDataType</name></name> <operator>=</operator> <name>secDataType</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name>secAttrNum</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>coldGroupId</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>need_shardmap_router</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>int32</name></type>    <name>nGroup</name></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>Oid</name>     <modifier>*</modifier></type><name>groups</name></decl>;</decl_stmt>
                            
                            <expr_stmt><expr><call><name>GetRelationSecondGroup</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>groups</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><name>nGroup</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>need_shardmap_router</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
                <switch>switch <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>listType</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>LOCATOR_LIST_NONE</name></expr>:</case>
                    <case>case <expr><name>LOCATOR_LIST_INT</name></expr>:</case>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_OID</name></expr>:</case>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_POINTER</name></expr>:</case>
                        <expr_stmt><expr><call><name>GetGroupNodeIndexMap</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>groupid</name></name></expr></argument>, <argument><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeindexMap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>need_shardmap_router</name></name></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                            <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                            <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>rel-&gt;rd_locator_info-&gt;rl_nodeList</argument>)</argument_list></macro>
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>indexMap</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
                            </block_content>}</block>

                            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_LIST</name></expr>:</case>
                        <comment type="block">/* Should never happen */</comment>
                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block></else></if_stmt>
            
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
        <case>case <expr><name>LOCATOR_TYPE_REPLICATED</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>accessType</name> <operator>==</operator> <name>RELATION_ACCESS_INSERT</name> <operator>||</operator>
                    <name>accessType</name> <operator>==</operator> <name>RELATION_ACCESS_UPDATE</name> <operator>||</operator>
                    <name>accessType</name> <operator>==</operator> <name>RELATION_ACCESS_READ_FQS</name> <operator>||</operator>
                    <name>accessType</name> <operator>==</operator> <name>RELATION_ACCESS_READ_FOR_UPDATE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>locatefunc</name></name> <operator>=</operator> <name>locate_static</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>nodeMap</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* no map, prepare array with indexes */</comment>
                    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>intptr</name></decl>;</decl_stmt>
                    <expr_stmt><expr><name>nodeMap</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>intptr</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>nodeMap</name></expr>;</expr_stmt>
                    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>locator</name><operator>-&gt;</operator><name>nodeCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                        <expr_stmt><expr><operator>*</operator><name>intptr</name><operator>++</operator> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeMap</name></name> <operator>=</operator> <name>nodeMap</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <name>nodeMap</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* SELECT, use random node.. */</comment>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>locatefunc</name></name> <operator>=</operator> <name>locate_modulo_random</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeMap</name></name> <operator>=</operator> <name>nodeMap</name></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>listType</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>LOCATOR_LIST_NONE</name></expr>:</case>
                    <case>case <expr><name>LOCATOR_LIST_INT</name></expr>:</case>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_OID</name></expr>:</case>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_POINTER</name></expr>:</case>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_LIST</name></expr>:</case>
                        <comment type="block">/* Should never happen */</comment>
                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>roundRobinNode</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_TYPE_RROBIN</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>accessType</name> <operator>==</operator> <name>RELATION_ACCESS_INSERT</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>locatefunc</name></name> <operator>=</operator> <name>locate_roundrobin</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeMap</name></name> <operator>=</operator> <name>nodeMap</name></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>listType</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>LOCATOR_LIST_NONE</name></expr>:</case>
                    <case>case <expr><name>LOCATOR_LIST_INT</name></expr>:</case>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_OID</name></expr>:</case>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_POINTER</name></expr>:</case>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_LIST</name></expr>:</case>
                        <comment type="block">/* Should never happen */</comment>
                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
                <comment type="block">/* randomize choice of the initial node */</comment>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>roundRobinNode</name></name> <operator>=</operator> <operator>(</operator><call><name>abs</name><argument_list>(<argument><expr><call><name>rand</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>%</operator> <name><name>locator</name><operator>-&gt;</operator><name>nodeCount</name></name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>locatefunc</name></name> <operator>=</operator> <name>locate_static</name></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>nodeMap</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* no map, prepare array with indexes */</comment>
                    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>intptr</name></decl>;</decl_stmt>
                    <expr_stmt><expr><name>nodeMap</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>intptr</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>nodeMap</name></expr>;</expr_stmt>
                    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>locator</name><operator>-&gt;</operator><name>nodeCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                        <expr_stmt><expr><operator>*</operator><name>intptr</name><operator>++</operator> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeMap</name></name> <operator>=</operator> <name>nodeMap</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <name>nodeMap</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_TYPE_HASH</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>accessType</name> <operator>==</operator> <name>RELATION_ACCESS_INSERT</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>locatefunc</name></name> <operator>=</operator> <name>locate_hash_insert</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeMap</name></name> <operator>=</operator> <name>nodeMap</name></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>listType</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>LOCATOR_LIST_NONE</name></expr>:</case>
                    <case>case <expr><name>LOCATOR_LIST_INT</name></expr>:</case>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_OID</name></expr>:</case>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_POINTER</name></expr>:</case>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_LIST</name></expr>:</case>
                        <comment type="block">/* Should never happen */</comment>
                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>locatefunc</name></name> <operator>=</operator> <name>locate_hash_select</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeMap</name></name> <operator>=</operator> <name>nodeMap</name></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>listType</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>LOCATOR_LIST_NONE</name></expr>:</case>
                    <case>case <expr><name>LOCATOR_LIST_INT</name></expr>:</case>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_OID</name></expr>:</case>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_POINTER</name></expr>:</case>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_LIST</name></expr>:</case>
                        <comment type="block">/* Should never happen */</comment>
                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>hashfunc</name></name> <operator>=</operator> <call><name>hash_func_ptr</name><argument_list>(<argument><expr><name>dataType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>hashfunc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Error: unsupported data type for HASH locator: %d\n"</literal></expr></argument>,
                                   <argument><expr><name>dataType</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_TYPE_MODULO</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>accessType</name> <operator>==</operator> <name>RELATION_ACCESS_INSERT</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>locatefunc</name></name> <operator>=</operator> <name>locate_modulo_insert</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeMap</name></name> <operator>=</operator> <name>nodeMap</name></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>listType</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>LOCATOR_LIST_NONE</name></expr>:</case>
                    <case>case <expr><name>LOCATOR_LIST_INT</name></expr>:</case>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_OID</name></expr>:</case>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_POINTER</name></expr>:</case>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_LIST</name></expr>:</case>
                        <comment type="block">/* Should never happen */</comment>
                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>locatefunc</name></name> <operator>=</operator> <name>locate_modulo_select</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeMap</name></name> <operator>=</operator> <name>nodeMap</name></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>listType</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>LOCATOR_LIST_NONE</name></expr>:</case>
                    <case>case <expr><name>LOCATOR_LIST_INT</name></expr>:</case>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_OID</name></expr>:</case>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_POINTER</name></expr>:</case>
                        <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_LIST</name></expr>:</case>
                        <comment type="block">/* Should never happen */</comment>
                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name><name>locator</name><operator>-&gt;</operator><name>valuelen</name></name> <operator>=</operator> <call><name>modulo_value_len</name><argument_list>(<argument><expr><name>dataType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>valuelen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Error: unsupported data type for MODULO locator: %d\n"</literal></expr></argument>,
                                   <argument><expr><name>dataType</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Error: no such supported locator type: %c\n"</literal></expr></argument>,
                                   <argument><expr><name>locatorType</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name><name>locator</name><operator>-&gt;</operator><name>results</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <return>return <expr><name>locator</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<function><type><name>void</name></type>
<name>freeLocator</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>locator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>nodeMap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * locator-&gt;nodeMap and locator-&gt;results may point to the same memory,
     * do not free it twice
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name> <operator>!=</operator> <name><name>locator</name><operator>-&gt;</operator><name>nodeMap</name></name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>locator</name><operator>-&gt;</operator><name>results</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Each time return the same predefined results
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>locate_static</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                <parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>secIsNull</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasprimary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* TODO */</comment>
    <if_stmt><if>if <condition>(<expr><name>hasprimary</name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>hasprimary</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
    <return>return <expr><name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Each time return one next node, in round robin manner
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>locate_roundrobin</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                       <parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>secIsNull</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                       <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasprimary</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* TODO */</comment>
    <if_stmt><if>if <condition>(<expr><name>hasprimary</name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>hasprimary</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>self</name><operator>-&gt;</operator><name>roundRobinNode</name></name> <operator>&gt;=</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>roundRobinNode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
    <switch>switch <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>listType</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>LOCATOR_LIST_NONE</name></expr>:</case>
            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>roundRobinNode</name></name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_LIST_INT</name></expr>:</case>
            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator>
                    <operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name><name>self</name><operator>-&gt;</operator><name>roundRobinNode</name></name></expr>]</index></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_LIST_OID</name></expr>:</case>
            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator>
                    <operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name><name>self</name><operator>-&gt;</operator><name>roundRobinNode</name></name></expr>]</index></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_LIST_POINTER</name></expr>:</case>
            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator>
                    <operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name><name>self</name><operator>-&gt;</operator><name>roundRobinNode</name></name></expr>]</index></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_LIST_LIST</name></expr>:</case>
            <comment type="block">/* Should never happen */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Each time return one node, in a random manner
 * This is similar to locate_modulo_select, but that
 * function does not use a random modulo..
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>locate_modulo_random</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                              <parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>secIsNull</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                              <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasprimary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>hasprimary</name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>hasprimary</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>compute_modulo</name><argument_list>(<argument><expr><call><name>abs</name><argument_list>(<argument><expr><call><name>rand</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>listType</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>LOCATOR_LIST_NONE</name></expr>:</case>
            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_LIST_INT</name></expr>:</case>
            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator>
                    <operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name>offset</name></expr>]</index></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_LIST_OID</name></expr>:</case>
            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator>
                    <operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name>offset</name></expr>]</index></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_LIST_POINTER</name></expr>:</case>
            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator>
                    <operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name>offset</name></expr>]</index></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_LIST_LIST</name></expr>:</case>
            <comment type="block">/* Should never happen */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate hash from supplied value and use modulo by nodeCount as an index
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>locate_hash_insert</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                        <parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>secIsNull</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasprimary</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>hasprimary</name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>hasprimary</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>hash32</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>hash32</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>hashfunc</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>compute_modulo</name><argument_list>(<argument><expr><name>hash32</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <switch>switch <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>listType</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>LOCATOR_LIST_NONE</name></expr>:</case>
            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_LIST_INT</name></expr>:</case>
            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name>index</name></expr>]</index></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_LIST_OID</name></expr>:</case>
            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name>index</name></expr>]</index></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_LIST_POINTER</name></expr>:</case>
            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name>index</name></expr>]</index></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_LIST_LIST</name></expr>:</case>
            <comment type="block">/* Should never happen */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>int</name></type> <name>locate_shard_insert</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                                    <parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>secIsNull</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                    <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasprimary</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>global_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>local_index</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>hasprimary</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>hasprimary</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>long</name></type>         <name>hashvalue</name>                    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        
        <expr_stmt><expr><name>global_index</name> <operator>=</operator> <call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>groupid</name></name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>    
        <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>need_shardmap_router</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodelist</name> <init>= <expr><call><name>ShardMapRouter</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>groupid</name></name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
                                            <argument><expr><name><name>self</name><operator>-&gt;</operator><name>dataType</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>secDataType</name></name></expr></argument>,
                                            <argument><expr><name>secIsNull</name></expr></argument>, <argument><expr><name>secValue</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>accessType</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>nodelist</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>global_index</name> <operator>=</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <switch>switch <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>listType</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>LOCATOR_LIST_NONE</name></expr>:</case>
                        <block>{<block_content>
                            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <name>global_index</name></expr>;</expr_stmt>
                        </block_content>}</block>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_INT</name></expr>:</case>
                        <block>{<block_content>
                            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <name>global_index</name></expr>;</expr_stmt>
                        </block_content>}</block>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_OID</name></expr>:</case>
                        <block>{<block_content>
                            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name>global_index</name></expr>]</index></expr>;</expr_stmt>
                        </block_content>}</block>
                        <break>break;</break>
                        
                    <case>case <expr><name>LOCATOR_LIST_POINTER</name></expr>:</case>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>need_shardmap_router</name></name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>local_index</name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>indexMap</name><index>[<expr><name>global_index</name></expr>]</index></name></expr>;</expr_stmt>    

                                <if_stmt><if>if <condition>(<expr><name>local_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not map global_index %d to local"</literal></expr></argument>, <argument><expr><name>global_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <expr_stmt><expr><name>local_index</name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeindexMap</name><index>[<expr><name>global_index</name></expr>]</index></name></expr>;</expr_stmt>    
                            </block_content>}</block></else></if_stmt>
                            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name>local_index</name></expr>]</index></expr>;</expr_stmt>
                        </block_content>}</block>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_LIST</name></expr>:</case>
                        <comment type="block">/* Should never happen */</comment>
                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block>

            <return>return <expr><name>i</name></expr>;</return>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>long</name></type>         <name>hashvalue</name>                    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>hashvalue</name> <operator>=</operator> <call><name>compute_hash</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>dataType</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>LOCATOR_TYPE_SHARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>global_index</name> <operator>=</operator> <call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>groupid</name></name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>    
    
    <switch>switch <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>listType</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>LOCATOR_LIST_NONE</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <name>global_index</name></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_LIST_INT</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <name>global_index</name></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_LIST_OID</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name>global_index</name></expr>]</index></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
            
        <case>case <expr><name>LOCATOR_LIST_POINTER</name></expr>:</case>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>need_shardmap_router</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>local_index</name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>indexMap</name><index>[<expr><name>global_index</name></expr>]</index></name></expr>;</expr_stmt>    

                    <if_stmt><if>if <condition>(<expr><name>local_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not map global_index %d to local"</literal></expr></argument>, <argument><expr><name>global_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>global_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>local_index</name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeindexMap</name><index>[<expr><name>global_index</name></expr>]</index></name></expr>;</expr_stmt>    
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name>local_index</name></expr>]</index></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_LIST_LIST</name></expr>:</case>
            <comment type="block">/* Should never happen */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
    
    <comment type="block">/* set to 1, since will route to only one node. */</comment>
    <return>return <expr><literal type="number">1</literal></expr>;</return>    
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>locate_shard_select</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                            <parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>secIsNull</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasprimary</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>local_index</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>    <name>global_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>hasprimary</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>hasprimary</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>listType</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>LOCATOR_LIST_NONE</name></expr>:</case>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
                <break>break;</break>
            <case>case <expr><name>LOCATOR_LIST_INT</name></expr>:</case>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name></expr></argument>,
                       <argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>LOCATOR_LIST_OID</name></expr>:</case>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name></expr></argument>,
                       <argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>LOCATOR_LIST_POINTER</name></expr>:</case>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name></expr></argument>,
                       <argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>LOCATOR_LIST_LIST</name></expr>:</case>
                <comment type="block">/* Should never happen */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
        <return>return <expr><name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>need_shardmap_router</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>nodelist</name> <init>= <expr><call><name>ShardMapRouter</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>groupid</name></name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
                                            <argument><expr><name><name>self</name><operator>-&gt;</operator><name>dataType</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>secDataType</name></name></expr></argument>,
                                            <argument><expr><name>secIsNull</name></expr></argument>, <argument><expr><name>secValue</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>accessType</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>nodelist</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>global_index</name> <operator>=</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <switch>switch <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>listType</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>LOCATOR_LIST_NONE</name></expr>:</case>
                        <block>{<block_content>
                            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <name>global_index</name></expr>;</expr_stmt>
                        </block_content>}</block>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_INT</name></expr>:</case>
                        <block>{<block_content>
                            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <name>global_index</name></expr>;</expr_stmt>
                        </block_content>}</block>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_OID</name></expr>:</case>
                        <block>{<block_content>
                            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name>global_index</name></expr>]</index></expr>;</expr_stmt>
                        </block_content>}</block>
                        <break>break;</break>
                        
                    <case>case <expr><name>LOCATOR_LIST_POINTER</name></expr>:</case>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>need_shardmap_router</name></name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>local_index</name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>indexMap</name><index>[<expr><name>global_index</name></expr>]</index></name></expr>;</expr_stmt>    
                                
                                <if_stmt><if>if <condition>(<expr><name>local_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not map global_index %d to local"</literal></expr></argument>, <argument><expr><name>global_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <expr_stmt><expr><name>local_index</name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeindexMap</name><index>[<expr><name>global_index</name></expr>]</index></name></expr>;</expr_stmt>    
                            </block_content>}</block></else></if_stmt>
                            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name>local_index</name></expr>]</index></expr>;</expr_stmt>
                        </block_content>}</block>
                        <break>break;</break>
                    <case>case <expr><name>LOCATOR_LIST_LIST</name></expr>:</case>
                        <comment type="block">/* Should never happen */</comment>
                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>
                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block>

            <return>return <expr><name>i</name></expr>;</return>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>long</name></type>         <name>hashvalue</name>                    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>hashvalue</name> <operator>=</operator> <call><name>compute_hash</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>dataType</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>LOCATOR_TYPE_SHARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>global_index</name> <operator>=</operator> <call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>groupid</name></name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>global_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <switch>switch <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>listType</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>LOCATOR_LIST_NONE</name></expr>:</case>
                    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <name>global_index</name></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>LOCATOR_LIST_INT</name></expr>:</case>
                    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <name>global_index</name></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>LOCATOR_LIST_OID</name></expr>:</case>
                    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name>global_index</name></expr>]</index></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>LOCATOR_LIST_POINTER</name></expr>:</case>
                    <expr_stmt><expr><name>local_index</name>        <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeindexMap</name><index>[<expr><name>global_index</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name>local_index</name></expr>]</index></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>LOCATOR_LIST_LIST</name></expr>:</case>
                    <comment type="block">/* Should never happen */</comment>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></switch>

            <comment type="block">/* set to 1, since will route to only one node. */</comment>
            <return>return <expr><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * Calculate hash from supplied value and use modulo by nodeCount as an index
 * if value is NULL assume no hint and return all the nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>locate_hash_select</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                        <parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>secIsNull</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasprimary</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name>hasprimary</name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>hasprimary</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>listType</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>LOCATOR_LIST_NONE</name></expr>:</case>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
                <break>break;</break>
            <case>case <expr><name>LOCATOR_LIST_INT</name></expr>:</case>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name></expr></argument>,
                       <argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>LOCATOR_LIST_OID</name></expr>:</case>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name></expr></argument>,
                       <argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>LOCATOR_LIST_POINTER</name></expr>:</case>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name></expr></argument>,
                       <argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>LOCATOR_LIST_LIST</name></expr>:</case>
                <comment type="block">/* Should never happen */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
        <return>return <expr><name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>hash32</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>          <name>index</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>hash32</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>hashfunc</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>compute_modulo</name><argument_list>(<argument><expr><name>hash32</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>listType</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>LOCATOR_LIST_NONE</name></expr>:</case>
                <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>LOCATOR_LIST_INT</name></expr>:</case>
                <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name>index</name></expr>]</index></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>LOCATOR_LIST_OID</name></expr>:</case>
                <expr_stmt><expr><operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name>index</name></expr>]</index></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>LOCATOR_LIST_POINTER</name></expr>:</case>
                <expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name>index</name></expr>]</index></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>LOCATOR_LIST_LIST</name></expr>:</case>
                <comment type="block">/* Should never happen */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Use modulo of supplied value by nodeCount as an index
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>locate_modulo_insert</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                           <parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>secIsNull</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
                           <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasprimary</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>hasprimary</name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>hasprimary</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>uint64</name></type> <name>val</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>valuelen</name></name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition>
		<block>{<block_content>
            <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <operator>(</operator><call><name>GET_8_BYTES</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>valuelen</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition>
		<block>{<block_content>
            <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <operator>(</operator><call><name>GET_4_BYTES</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>valuelen</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
            <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <operator>(</operator><call><name>GET_2_BYTES</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>valuelen</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
            <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <operator>(</operator><call><name>GET_1_BYTE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
        <else>else
		<block>{<block_content>
            <expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>compute_modulo</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <switch>switch <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>listType</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>LOCATOR_LIST_NONE</name></expr>:</case>
            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_LIST_INT</name></expr>:</case>
            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name>index</name></expr>]</index></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_LIST_OID</name></expr>:</case>
            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name>index</name></expr>]</index></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_LIST_POINTER</name></expr>:</case>
            <expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name>index</name></expr>]</index></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>LOCATOR_LIST_LIST</name></expr>:</case>
            <comment type="block">/* Should never happen */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Use modulo of supplied value by nodeCount as an index
 * if value is NULL assume no hint and return all the nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>locate_modulo_select</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                            <parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>secIsNull</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                            <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasprimary</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name>hasprimary</name></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>hasprimary</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <switch>switch <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>listType</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>LOCATOR_LIST_NONE</name></expr>:</case>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></for>
                <break>break;</break>
            <case>case <expr><name>LOCATOR_LIST_INT</name></expr>:</case>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name></expr></argument>,
                       <argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>LOCATOR_LIST_OID</name></expr>:</case>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name></expr></argument>,
                       <argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>LOCATOR_LIST_POINTER</name></expr>:</case>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>results</name></name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name></expr></argument>,
                       <argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>LOCATOR_LIST_LIST</name></expr>:</case>
                <comment type="block">/* Should never happen */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
        <return>return <expr><name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>uint64</name></type>    <name>val</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>     <name>index</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>valuelen</name></name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition>
		<block>{<block_content>
            <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <operator>(</operator><call><name>GET_8_BYTES</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>valuelen</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition>
		<block>{<block_content>
            <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <operator>(</operator><call><name>GET_4_BYTES</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>valuelen</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
            <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <operator>(</operator><call><name>GET_2_BYTES</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>valuelen</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
            <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <operator>(</operator><call><name>GET_1_BYTE</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
        <else>else
		<block>{<block_content>
            <expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>compute_modulo</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>listType</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>LOCATOR_LIST_NONE</name></expr>:</case>
                <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>LOCATOR_LIST_INT</name></expr>:</case>
                <expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name>index</name></expr>]</index></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>LOCATOR_LIST_OID</name></expr>:</case>
                <expr_stmt><expr><operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name>index</name></expr>]</index></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>LOCATOR_LIST_POINTER</name></expr>:</case>
                <expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>results</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <operator>(</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name><operator>)</operator><index>[<expr><name>index</name></expr>]</index></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>LOCATOR_LIST_LIST</name></expr>:</case>
                <comment type="block">/* Should never happen */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
        <return>return <expr><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>GET_NODES</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                 <parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>secIsNull</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasprimary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <return>return <expr><call>(<modifier>*</modifier><name><name>self</name><operator>-&gt;</operator><name>locatefunc</name></name>) <argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>secValue</name></expr></argument>, <argument><expr><name>secIsNull</name></expr></argument>, <argument><expr><name>hasprimary</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><call>(<modifier>*</modifier><name><name>self</name><operator>-&gt;</operator><name>locatefunc</name></name>) <argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>hasprimary</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>

<function><type><name>char</name></type>
<name>getLocatorDisType</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>self</name><operator>-&gt;</operator><name>locatorType</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>IsDistributedColumn</name><parameter_list>(<parameter><decl><type><name>AttrNumber</name></type> <name>attr</name></decl></parameter>, <parameter><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>relation_loc_info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>relation_loc_info</name> <operator>&amp;&amp;</operator> <call><name>IsLocatorDistributedByValue</name><argument_list>(<argument><expr><name><name>relation_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
       <operator>(</operator><name>attr</name> <operator>==</operator> <name><name>relation_loc_info</name><operator>-&gt;</operator><name>partAttrNum</name></name> <operator>||</operator> <name>attr</name> <operator>==</operator> <name><name>relation_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate the tuple replication times based on replication type and number
 * of target nodes.
 */</comment>
<function><type><name>int</name></type>
<name>calcDistReplications</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>distributionType</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>nodes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nodes</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsLocatorReplicated</name><argument_list>(<argument><expr><name>distributionType</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>IsLocatorNone</name><argument_list>(<argument><expr><name>distributionType</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return  <expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>getLocatorResults</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>self</name><operator>-&gt;</operator><name>results</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name> <modifier>*</modifier></type>
<name>getLocatorNodeMap</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>self</name><operator>-&gt;</operator><name>nodeMap</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>getLocatorNodeCount</name><parameter_list>(<parameter><decl><type><name>Locator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>self</name><operator>-&gt;</operator><name>nodeCount</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * GetRelationNodes
 *
 * Get list of relation nodes
 * If the table is replicated and we are reading, we can just pick one.
 * If the table is partitioned, we apply partitioning column value, if possible.
 *
 * If the relation is partitioned, partValue will be applied if present
 * (indicating a value appears for partitioning column), otherwise it
 * is ignored.
 *
 * preferredNodes is only used when for replicated tables. If set, it will
 * use one of the nodes specified if the table is replicated on it.
 * This helps optimize for avoiding introducing additional nodes into the
 * transaction.
 *
 * The returned List is a copy, so it should be freed when finished.
 */</comment>
<function><type><name>ExecNodes</name> <modifier>*</modifier></type>
<name>GetRelationNodes</name><parameter_list>(<parameter><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rel_loc_info</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>valueForDistCol</name></decl></parameter>,
                <parameter><decl><type><name>bool</name></type> <name>isValueNull</name></decl></parameter>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                <parameter><decl><type><name>Datum</name></type> <name>valueForSecDistCol</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isSecValueNull</name></decl></parameter>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <parameter><decl><type><name>RelationAccessType</name></type> <name>accessType</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ExecNodes</name>    <modifier>*</modifier></type><name>exec_nodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name>            <modifier>*</modifier></type><name>nodenums</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>, <decl><type ref="prev"/><name>count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Locator</name>        <modifier>*</modifier></type><name>locator</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>typeOfValueForDistCol</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Oid</name></type> <name>typeOfValueForSecDistCol</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>rel_loc_info</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>


    <if_stmt><if>if <condition>(<expr><call><name>IsLocatorDistributedByValue</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* A sufficient lock level needs to be taken at a higher level */</comment>
        <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupDesc</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>attr</name> <init>= <expr><name><name>tupDesc</name><operator>-&gt;</operator><name>attrs</name></name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* Get the hash type of relation */</comment>
        <expr_stmt><expr><name>typeOfValueForDistCol</name> <operator>=</operator> <name><name>attr</name><index>[<expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>partAttrNum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>typeOfValueForSecDistCol</name> <operator>=</operator> <name><name>attr</name><index>[<expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>exec_nodes</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>accesstype</name></name> <operator>=</operator> <name>accessType</name></expr>;</expr_stmt>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>  <name>_MIGRATE_</name></cpp:ifdef>
    <expr_stmt><expr><name>locator</name> <operator>=</operator> <call><name>createLocator</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name></expr></argument>,
                            <argument><expr><name>accessType</name></expr></argument>,
                            <argument><expr><name>typeOfValueForDistCol</name></expr></argument>,
                            <argument><expr><name>LOCATOR_LIST_LIST</name></expr></argument>,
                            <argument><expr><literal type="number">0</literal></expr></argument>,
                            <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>rel_loc_info</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr></argument>,
                            <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>nodenums</name></expr></argument>,
                            <argument><expr><name>false</name></expr></argument>,
                            <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>,
                            <argument><expr><name>typeOfValueForSecDistCol</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>,
                            <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

    <expr_stmt><expr><name>locator</name> <operator>=</operator> <call><name>createLocator</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name></expr></argument>,
                            <argument><expr><name>accessType</name></expr></argument>,
                            <argument><expr><name>typeOfValueForDistCol</name></expr></argument>,
                            <argument><expr><name>LOCATOR_LIST_LIST</name></expr></argument>,
                            <argument><expr><literal type="number">0</literal></expr></argument>,
                            <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>rel_loc_info</name><operator>-&gt;</operator><name>rl_nodeList</name></name></expr></argument>,
                            <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>nodenums</name></expr></argument>,
                            <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>GET_NODES</name><argument_list>(<argument><expr><name>locator</name></expr></argument>, <argument><expr><name>valueForDistCol</name></expr></argument>, <argument><expr><name>isValueNull</name></expr></argument>, <argument><expr><name>valueForSecDistCol</name></expr></argument>, <argument><expr><name>isSecValueNull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>GET_NODES</name><argument_list>(<argument><expr><name>locator</name></expr></argument>, <argument><expr><name>valueForDistCol</name></expr></argument>, <argument><expr><name>isValueNull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><name><name>nodenums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><call><name>freeLocator</name><argument_list>(<argument><expr><name>locator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>exec_nodes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetRelationNodesForExplain
 * This is just for explain statement, just pick one datanode.
 * The returned List is a copy, so it should be freed when finished.
 */</comment>
<function><type><name>ExecNodes</name> <modifier>*</modifier></type>
<name>GetRelationNodesForExplain</name><parameter_list>(<parameter><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rel_loc_info</name></decl></parameter>,
				<parameter><decl><type><name>RelationAccessType</name></type> <name>accessType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExecNodes</name>	<modifier>*</modifier></type><name>exec_nodes</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>exec_nodes</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>accesstype</name></name> <operator>=</operator> <name>accessType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>exec_nodes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetRelationNodesByQuals
 * A wrapper around GetRelationNodes to reduce the node list by looking at the
 * quals. varno is assumed to be the varno of reloid inside the quals. No check
 * is made to see if that's correct.
 */</comment>
<function><type><name>ExecNodes</name> <modifier>*</modifier></type>
<name>GetRelationNodesByQuals</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>reloid</name></decl></parameter>, <parameter><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rel_loc_info</name></decl></parameter>,
            <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>, <parameter><decl><type><name>RelationAccessType</name></type> <name>relaccess</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>dis_qual</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>sec_quals</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ONE_SECOND_DATUM</name></cpp:macro> <cpp:value>1000000</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>Expr</name>            <modifier>*</modifier></type><name>distcol_expr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>exec_nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>            <name>distcol_value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name>distcol_isnull</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>int</name></type>             <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>            <modifier>*</modifier></type><name>seccol_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>            <modifier>*</modifier></type><name>seccol_value_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>            <name>seccol_value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name>seccol_isnull</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>                <name>seccol_type</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>             <name>distcol_type</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>                <modifier>*</modifier></type><name>opArray</name>            <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>            <modifier>*</modifier></type><name>isswapArray</name>       <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>disttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>disttypmod</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>dis_qual</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>dis_qual</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>sec_quals</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>sec_quals</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>rel_loc_info</name></expr>)</condition>
	<block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
    <comment type="block">/*
     * If the table distributed by value, check if we can reduce the Datanodes
     * by looking at the qualifiers for this relation
     */</comment>
	<expr_stmt><expr><name>disttype</name> <operator>=</operator> <call><name>get_atttype</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>partAttrNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>disttypmod</name> <operator>=</operator> <call><name>get_atttypmod</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>partAttrNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsRelationDistributedByValue</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>distcol_expr</name> <operator>=</operator> <call><name>pgxc_find_distcol_expr</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>partAttrNum</name></name></expr></argument>,
                                                    <argument><expr><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Remove ArrayCoerceExpr at first */</comment>
		<if_stmt><if>if <condition>(<expr><name>distcol_expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>distcol_expr</name></expr></argument>, <argument><expr><name>ArrayCoerceExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>arrayCoerceExpr</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ArrayCoerceExpr</name></expr></argument>, <argument><expr><name>distcol_expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>arrayCoerceExpr</name><operator>-&gt;</operator><name>arg</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>arrayCoerceExpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
			<expr_stmt><expr><name>distcol_expr</name> <operator>=</operator> <name><name>arrayCoerceExpr</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If the type of expression used to find the Datanode, is not same as
         * the distribution column type, try casting it. This is same as what
         * will happen in case of inserting that type of expression value as the
         * distribution column value.
         */</comment>
		<if_stmt><if>if <condition>(<expr><name>distcol_expr</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>distcol_expr</name></expr></argument>, <argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>distcol_expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
                                                    <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>distcol_expr</name></expr></argument>,
                                                    <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>distcol_expr</name></expr></argument>)</argument_list></call></expr></argument>,
                                                    <argument><expr><name>disttype</name></expr></argument>, <argument><expr><name>disttypmod</name></expr></argument>,
                                                    <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
                                                    <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/*
             * PGXC_FQS_TODO: We should set the bound parameters here, but we don't have
             * PlannerInfo struct and we don't handle them right now.
             * Even if constant expression mutator changes the expression, it will
             * only simplify it, keeping the semantics same
             */</comment>
            <expr_stmt><expr><name>distcol_expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
                                                            <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>distcol_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Oid</name></type>        <name>sectype</name> <init>= <expr><call><name>get_atttype</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name></type>    <name>sectypmod</name> <init>= <expr><call><name>get_atttypmod</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>seccol_list</name> <operator>=</operator> <call><name>pgxc_find_distcol_exprs</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>,
                                                        <argument><expr><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>seccol_list</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name>  <modifier>*</modifier></type><name>qual_cell</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>seccol_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                
                <expr_stmt><expr><name>opArray</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
                <expr_stmt><expr><name>isswapArray</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

                <macro><name>foreach</name><argument_list>(<argument>qual_cell</argument>, <argument>seccol_list</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>DisQual</name> <modifier>*</modifier></type><name>pQual</name> <init>= <expr><operator>(</operator><name>DisQual</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>qual_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name><name>opArray</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pQual</name><operator>-&gt;</operator><name>opno</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>isswapArray</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pQual</name><operator>-&gt;</operator><name>isswap</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name><name>pQual</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
                                            <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>,
                                            <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><name>sectype</name></expr></argument>, <argument><expr><name>sectypmod</name></expr></argument>,
                                            <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
                                            <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
                                            <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>seccol_value_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>seccol_value_list</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block>

                <if_stmt><if>if <condition>(<expr><name>sec_quals</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>sec_quals</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>seccol_list</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>seccol_list</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>distcol_expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>distcol_expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>const_expr</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator><name>distcol_expr</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>distcol_value</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>distcol_isnull</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>constisnull</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>distcol_type</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>consttype</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>dis_qual</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>dis_qual</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>distcol_expr</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <if_stmt><if>if <condition>(<expr><name>seccol_list</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>distcol_isnull</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type> <name>isalign</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>rangeOpCnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>  <modifier>*</modifier></type> <name>cell</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>  <name>equal_min</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>  <name>equal_max</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type> <name>minStamp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type> <name>maxStamp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type> <name>constvalue</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>seccol_value_list</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>sec_distcol_expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>sec_distcol_expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>sec_distcol_expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TimeStampRange</name><argument_list>(<argument><expr><name><name>opArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>const_expr</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator><name>sec_distcol_expr</name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>seccol_value</name>     <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>seccol_isnull</name>    <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>constisnull</name></name></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>seccol_isnull</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>exec_nodes</name> <operator>=</operator> <call><name>GetRelationNodes</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>, 
                                                      <argument><expr><name>distcol_value</name></expr></argument>,
                                                      <argument><expr><name>distcol_isnull</name></expr></argument>, 
                                                      <argument><expr><name>seccol_value</name></expr></argument>,
                                                      <argument><expr><name>seccol_isnull</name></expr></argument>,
                                                      <argument><expr><name>relaccess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><name>exec_nodes</name></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>sec_distcol_expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>sec_distcol_expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>TimeStampRange</name><argument_list>(<argument><expr><name><name>opArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>const_expr</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator><name>sec_distcol_expr</name></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><literal type="number">2062</literal> <operator>==</operator> <name><name>opArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <comment type="block">/* &lt; */</comment>
                    <block>{<block_content>
                        <expr_stmt><expr><name>isalign</name> <operator>=</operator> <call><name>IsConstAligned</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><name><name>isswapArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>constvalue</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>isalign</name></expr>)</condition>
                            <block>{<block_content>
                                <comment type="block">/* const &lt; var -&gt; const + 1 &lt;= var */</comment>
                                <expr_stmt><expr><name>constvalue</name> <operator>=</operator> <name>constvalue</name> <operator>+</operator> <name>ONE_SECOND_DATUM</name></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                            <expr_stmt><expr><name>minStamp</name> <operator>=</operator> <ternary><condition><expr><name>minStamp</name></expr> ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>constvalue</name> <operator>&gt;=</operator> <name>minStamp</name><operator>)</operator></expr> ?</condition><then> <expr><name>minStamp</name></expr> </then><else>: <expr><name>constvalue</name></expr></else></ternary><operator>)</operator></expr> </then><else>: <expr><name>constvalue</name></expr></else></ternary></expr>;</expr_stmt>
                            <expr_stmt><expr><name>seccol_type</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>consttype</name></name></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><name>isalign</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>equal_min</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <expr_stmt><expr><name>equal_min</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><name>constvalue</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>isalign</name></expr>)</condition>
                            <block>{<block_content>
                                <comment type="block">/* var &lt; const -&gt; var &lt;= const -1 */</comment>
                                <expr_stmt><expr><name>constvalue</name> <operator>=</operator> <name>constvalue</name> <operator>-</operator> <name>ONE_SECOND_DATUM</name></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                            
                            <expr_stmt><expr><name>maxStamp</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>constvalue</name> <operator>&gt;=</operator> <name>maxStamp</name><operator>)</operator></expr> ?</condition><then> <expr><name>constvalue</name></expr> </then><else>: <expr><name>maxStamp</name></expr></else></ternary></expr>;</expr_stmt>
                            <expr_stmt><expr><name>seccol_type</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>consttype</name></name></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><name>isalign</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>equal_max</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <expr_stmt><expr><name>equal_max</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><literal type="number">2063</literal> <operator>==</operator> <name><name>opArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <comment type="block">/* &lt;= */</comment>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name><name>isswapArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/* const &lt;= var */</comment>
							<expr_stmt><expr><name>minStamp</name> <operator>=</operator> <ternary><condition><expr><name>minStamp</name></expr> ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>&gt;=</operator> <name>minStamp</name><operator>)</operator></expr> ?</condition><then> <expr><name>minStamp</name></expr>
							                                                            </then><else>: <expr><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></else></ternary><operator>)</operator></expr>
							                    </then><else>: <expr><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></else></ternary></expr>;</expr_stmt>
                            <expr_stmt><expr><name>seccol_type</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>consttype</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>equal_min</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <comment type="block">/* var &lt;= const */</comment>
                            <expr_stmt><expr><name>maxStamp</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>&gt;=</operator> <name>maxStamp</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr> </then><else>: <expr><name>maxStamp</name></expr></else></ternary></expr>;</expr_stmt>
                            <expr_stmt><expr><name>seccol_type</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>consttype</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>equal_max</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if>  
                    <if type="elseif">else if <condition>(<expr><literal type="number">2065</literal> <operator>==</operator> <name><name>opArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <comment type="block">/* &gt;= */</comment>
                    <block>{<block_content>     
                        <if_stmt><if>if <condition>(<expr><name><name>isswapArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/* const &gt;= var */</comment>
                            <expr_stmt><expr><name>maxStamp</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>&gt;=</operator> <name>maxStamp</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr> </then><else>: <expr><name>maxStamp</name></expr></else></ternary></expr>;</expr_stmt>
                            <expr_stmt><expr><name>seccol_type</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>consttype</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>equal_max</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <comment type="block">/* var &gt;= const */</comment>
							<expr_stmt><expr><name>minStamp</name> <operator>=</operator> <ternary><condition><expr><name>minStamp</name></expr> ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>&gt;=</operator> <name>minStamp</name><operator>)</operator></expr> ?</condition><then> <expr><name>minStamp</name></expr>
							                                                            </then><else>: <expr><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></else></ternary><operator>)</operator></expr>
							                    </then><else>: <expr><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></else></ternary></expr>;</expr_stmt>
                            <expr_stmt><expr><name>seccol_type</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>consttype</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>equal_min</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><literal type="number">2064</literal> <operator>==</operator> <name><name>opArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <comment type="block">/* &gt; */</comment>
                    <block>{<block_content>
                        <expr_stmt><expr><name>isalign</name> <operator>=</operator> <call><name>IsConstAligned</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><name><name>isswapArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>constvalue</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>isalign</name></expr>)</condition>
                            <block>{<block_content>
                                <comment type="block">/* const &gt; var -&gt; const -1 &gt;= var */</comment>
                                <expr_stmt><expr><name>constvalue</name> <operator>=</operator> <name>constvalue</name> <operator>-</operator> <name>ONE_SECOND_DATUM</name></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                            <expr_stmt><expr><name>maxStamp</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>constvalue</name> <operator>&gt;=</operator> <name>maxStamp</name><operator>)</operator></expr> ?</condition><then> <expr><name>constvalue</name></expr> </then><else>: <expr><name>maxStamp</name></expr></else></ternary></expr>;</expr_stmt>
                            <expr_stmt><expr><name>seccol_type</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>consttype</name></name></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><name>isalign</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>equal_max</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <expr_stmt><expr><name>equal_max</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><name>constvalue</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>isalign</name></expr>)</condition>
                            <block>{<block_content>
                                <comment type="block">/* var &gt; const -&gt; var  &gt;= const + 1 */</comment>
                                <expr_stmt><expr><name>constvalue</name> <operator>=</operator> <name>constvalue</name> <operator>+</operator> <name>ONE_SECOND_DATUM</name></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                            
                            <expr_stmt><expr><name>minStamp</name> <operator>=</operator> <ternary><condition><expr><name>minStamp</name></expr> ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>constvalue</name> <operator>&gt;=</operator> <name>minStamp</name><operator>)</operator></expr> ?</condition><then> <expr><name>minStamp</name></expr> </then><else>: <expr><name>constvalue</name></expr></else></ternary><operator>)</operator></expr> </then><else>: <expr><name>constvalue</name></expr></else></ternary></expr>;</expr_stmt>
                            <expr_stmt><expr><name>seccol_type</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>consttype</name></name></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><name>isalign</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>equal_min</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <expr_stmt><expr><name>equal_min</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>seccol_type</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    <comment type="block">/* skip range condition */</comment>
                    <expr_stmt><expr><name>rangeOpCnt</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>seccol_value</name>      <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>seccol_isnull</name>    <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block>

            <if_stmt><if>if <condition>(<expr><name>opArray</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>opArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>opArray</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>isswapArray</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>isswapArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>isswapArray</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>rangeOpCnt</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>seccol_value_list</name></expr></argument>)</argument_list></call> <operator>||</operator> 
                <operator>(</operator><name>rangeOpCnt</name> <operator>&amp;&amp;</operator> <name>seccol_isnull</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>exec_nodes</name> <operator>=</operator> <call><name>GetRelationTimeStampRangeNodes</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><name>distcol_value</name></expr></argument>,
                                                            <argument><expr><name>distcol_isnull</name></expr></argument>, <argument><expr><name>distcol_type</name></expr></argument>,
                                                            <argument><expr><name>seccol_type</name></expr></argument>, <argument><expr><name>minStamp</name></expr></argument>, <argument><expr><name>maxStamp</name></expr></argument>, 
                                                            <argument><expr><name>equal_min</name></expr></argument>, <argument><expr><name>equal_max</name></expr></argument>, <argument><expr><name>relaccess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>seccol_value</name>      <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>seccol_isnull</name>    <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>exec_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>exec_nodes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <return>return <expr><name>exec_nodes</name></expr>;</return>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<return>return <expr><call><name>GetRelationNodes</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><name>distcol_value</name></expr></argument>,
		                        <argument><expr><name>distcol_isnull</name></expr></argument>,
		                        <argument><expr><name>seccol_value</name></expr></argument>, <argument><expr><name>seccol_isnull</name></expr></argument>,
		                        <argument><expr><name>relaccess</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<comment type="block">/* Only for shard table without cold hot seperation */</comment>
	<if type="elseif">else if <condition>(<expr><name>distcol_expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>distcol_expr</name></expr></argument>, <argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
	         <name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>==</operator> <name>LOCATOR_TYPE_SHARD</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>seccol_list</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ArrayExpr</name> <modifier>*</modifier></type><name>arrayExpr</name> <init>= <expr><operator>(</operator><name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>distcol_expr</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>success</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>const_expr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>arrayExpr-&gt;elements</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* convert to distribute column type */</comment>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
			                             <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
			                             <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr></argument>,
			                             <argument><expr><name>disttype</name></expr></argument>, <argument><expr><name>disttypmod</name></expr></argument>,
			                             <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
			                             <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
			                              <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>expr</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>success</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>const_expr</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>temp</name> <operator>=</operator> <call><name>GetRelationNodes</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>,
			                        <argument><expr><name><name>const_expr</name><operator>-&gt;</operator><name>constisnull</name></name></expr></argument>,
			                        <argument><expr><name>seccol_value</name></expr></argument>, <argument><expr><name>seccol_isnull</name></expr></argument>,
			                        <argument><expr><name>relaccess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>temp</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>success</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>exec_nodes</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>==</operator> <name><name>temp</name><operator>-&gt;</operator><name>baselocatortype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>list_concat_unique_int</name><argument_list>(<argument><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>,
				                                          <argument><expr><name><name>temp</name><operator>-&gt;</operator><name>nodeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
				<expr_stmt><expr><name>exec_nodes</name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>success</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>exec_nodes</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>distcol_value</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>distcol_isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name> <operator>!=</operator> <name>InvalidAttrNumber</name> <operator>&amp;&amp;</operator> <name>seccol_list</name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name>relaccess</name> <operator>==</operator> <name>RELATION_ACCESS_READ</name> <operator>||</operator> <name>relaccess</name> <operator>==</operator> <name>RELATION_ACCESS_READ_FQS</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int32</name></type>     <name>nGroup</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name>     <modifier>*</modifier></type><name>groups</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name>    <modifier>*</modifier></type><name>newnodelist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type>      <name>relid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>relation_open</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_CHILD</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>RELATION_GET_PARENT</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>GetRelationSecondGroup</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>groups</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* do not have key-value */</comment>
            <if_stmt><if>if <condition>(<expr><name>nGroup</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>oids</name> <init>= <expr><call><name>GetRelationGroupsByQuals</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>seccol_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>oids</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int32</name></type> <name>dn_num</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int32</name> <modifier>*</modifier></type><name>datanodes</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Oid</name></type> <name>groupoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>GetShardNodes</name><argument_list>(<argument><expr><name>groupoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datanodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dn_num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <for>for<control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>dn_num</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>                            
                        <expr_stmt><expr><name>newnodelist</name> <operator>=</operator> <call><name>list_append_unique_int</name><argument_list>(<argument><expr><name>newnodelist</name></expr></argument>, <argument><expr><name><name>datanodes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>datanodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>

                <if_stmt><if>if <condition>(<expr><name>newnodelist</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>exec_nodes</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>accesstype</name></name> <operator>=</operator> <name>relaccess</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <name>newnodelist</name></expr>;</expr_stmt>
                    <return>return <expr><name>exec_nodes</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>exec_nodes</name> <operator>=</operator> <call><name>GetRelationNodes</name><argument_list>(<argument><expr><name>rel_loc_info</name></expr></argument>, <argument><expr><name>distcol_value</name></expr></argument>,
                                                <argument><expr><name>distcol_isnull</name></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                                                <argument><expr><name>seccol_value</name></expr></argument>, <argument><expr><name>seccol_isnull</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                                <argument><expr><name>relaccess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>exec_nodes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetRelationDistribColumn
 * Return hash column name for relation or NULL if relation is not distributed.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetRelationDistribColumn</name><parameter_list>(<parameter><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>locInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* No relation, so simply leave */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>locInfo</name></expr>)</condition>
	<block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/* No distribution column if relation is not distributed with a key */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsRelationDistributedByValue</name><argument_list>(<argument><expr><name>locInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/* Return column name */</comment>
    <return>return <expr><call><name>get_attname</name><argument_list>(<argument><expr><name><name>locInfo</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>locInfo</name><operator>-&gt;</operator><name>partAttrNum</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetRelationSecDistribColumn</name><parameter_list>(<parameter><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>locInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* No relation, so simply leave */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>locInfo</name></expr>)</condition>
	<block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/* No distribution column if relation is not distributed with a key */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsRelationDistributedByValue</name><argument_list>(<argument><expr><name>locInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/* Return column name */</comment>
    <return>return <expr><call><name>get_attname</name><argument_list>(<argument><expr><name><name>locInfo</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>locInfo</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * pgxc_find_distcol_expr
 * Search through the quals provided and find out an expression which will give
 * us value of distribution column if exists in the quals. Say for a table
 * tab1 (val int, val2 int) distributed by hash(val), a query "SELECT * FROM
 * tab1 WHERE val = fn(x, y, z) and val2 = 3", fn(x,y,z) is the expression which
 * decides the distribution column value in the rows qualified by this query.
 * Hence return fn(x, y, z). But for a query "SELECT * FROM tab1 WHERE val =
 * fn(x, y, z) || val2 = 3", there is no expression which decides the values
 * distribution column val can take in the qualified rows. So, in such cases
 * this function returns NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>pgxc_find_distcol_expr</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>,
                       <parameter><decl><type><name>AttrNumber</name></type> <name>attrNum</name></decl></parameter>,
                       <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>lquals</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>qual_cell</name></decl>;</decl_stmt>

    <comment type="block">/* If no quals, no distribution column expression */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>quals</name></expr>)</condition>
	<block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/* Convert the qualification into List if it's not already so */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><name>lquals</name> <operator>=</operator> <call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
    <else>else
	<block>{<block_content>
        <expr_stmt><expr><name>lquals</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator><name>quals</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * For every ANDed expression, check if that expression is of the form
     * &lt;distribution_col&gt; = &lt;expr&gt;. If so return expr.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>qual_cell</argument>, <argument>lquals</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>qual_expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>qual_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>lexpr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>rexpr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var_expr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>distcol_expr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>opno</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>qual_expr</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>op</name> <operator>=</operator> <operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator><name>qual_expr</name></expr>;</expr_stmt>

        <comment type="block">/* If not a binary operator, it can not be '='. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
			<block>{<block_content>
            <continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>lexpr</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rexpr</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>opno</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>opno</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>qual_expr</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>arrayOpExpr</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>qual_expr</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>arrayOpExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>lexpr</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>arrayOpExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rexpr</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>arrayOpExpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>opno</name> <operator>=</operator> <name><name>arrayOpExpr</name><operator>-&gt;</operator><name>opno</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * If either of the operands is a RelabelType, extract the Var in the RelabelType.
         * A RelabelType represents a "dummy" type coercion between two binary compatible datatypes.
         * If we do not handle these then our optimization does not work in case of varchar
         * For example if col is of type varchar and is the dist key then
         * select * from vc_tab where col = 'abcdefghijklmnopqrstuvwxyz';
         * should be shipped to one of the nodes only
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
            <expr_stmt><expr><name>lexpr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name><operator>*</operator><operator>)</operator><name>lexpr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
            <expr_stmt><expr><name>rexpr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name><operator>*</operator><operator>)</operator><name>rexpr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If either of the operands is a Var expression, assume the other
         * one is distribution column expression. If none is Var check next
         * qual.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>var_expr</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name>lexpr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>distcol_expr</name> <operator>=</operator> <name>rexpr</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>var_expr</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name>rexpr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>distcol_expr</name> <operator>=</operator> <name>lexpr</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
		<block>{<block_content>
            <continue>continue;</continue>
		</block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * If Var found is not the distribution column of required relation,
         * check next qual
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>var_expr</name><operator>-&gt;</operator><name>varno</name></name> <operator>!=</operator> <name>varno</name> <operator>||</operator> <name><name>var_expr</name><operator>-&gt;</operator><name>varattno</name></name> <operator>!=</operator> <name>attrNum</name></expr>)</condition>
		<block>{<block_content>
            <continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If the operator is not an assignment operator, check next
         * constraint. An operator is an assignment operator if it's
         * mergejoinable or hashjoinable. Beware that not every assignment
         * operator is mergejoinable or hashjoinable, so we might leave some
		 * opportunity. But then we have to rely on the opname which may not
         * be something we know to be equality operator as well.
         */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_mergejoinable</name><argument_list>(<argument><expr><name>opno</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var_expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		    <operator>!</operator><call><name>op_hashjoinable</name><argument_list>(<argument><expr><name>opno</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var_expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
            <continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

        <comment type="block">/* Found the distribution column expression return it */</comment>
        <return>return <expr><name>distcol_expr</name></expr>;</return>

    </block_content>}</block>
    <comment type="block">/* Exhausted all quals, but no distribution column expression */</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>IsConstAligned</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>reloid</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>constvalue</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>secAttr</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>    <name>isalign</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>   <name>partition_strategy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>fsec_t</name></type>  <name>current_sec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>current_time</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_partition_interval</name></type> <name>routerinfo</name></decl>;</decl_stmt>
        
    <expr_stmt><expr><name>rel</name>        <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>routerinfo</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_partitions_info</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>routerinfo</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>secAttr</name> <operator>==</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partpartkey</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>partition_strategy</name> <operator>=</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_type</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>partition_strategy</name> <operator>==</operator> <name>IntervalType_Month</name> <operator>&amp;&amp;</operator>
                    <name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_int</name></name> <operator>==</operator> <literal type="number">12</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>partition_strategy</name> <operator>=</operator> <name>IntervalType_Year</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><name>constvalue</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_sec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>current_time</name><operator>.</operator><name>tm_hour</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>current_time</name><operator>.</operator><name>tm_min</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>current_time</name><operator>.</operator><name>tm_sec</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>current_sec</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>isalign</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>isalign</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>partition_strategy</name> <operator>==</operator> <name>IntervalType_Month</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>isalign</name> <operator>=</operator> <operator>(</operator><name><name>current_time</name><operator>.</operator><name>tm_mday</name></name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>isalign</name> <operator>&amp;&amp;</operator> <name>partition_strategy</name> <operator>==</operator> <name>IntervalType_Year</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>isalign</name> <operator>=</operator> <operator>(</operator><name><name>current_time</name><operator>.</operator><name>tm_mday</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>current_time</name><operator>.</operator><name>tm_mon</name></name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>isalign</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>TimeStampRange</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name>op</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="number">2062</literal></expr>:</case>
        <case>case <expr><literal type="number">2063</literal></expr>:</case>
        <case>case <expr><literal type="number">2064</literal></expr>:</case>
        <case>case <expr><literal type="number">2065</literal></expr>:</case>
        <block>{<block_content>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block>

        <default>default:</default>
        <block>{<block_content>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block>        
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>pgxc_find_distcol_exprs</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>,
                                     <parameter><decl><type><name>AttrNumber</name></type> <name>attrNum</name></decl></parameter>,
                                    <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>lquals</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>qual_cell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DisQual</name>  <modifier>*</modifier></type><name>pQual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>lresult</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If no quals, no distribution column expression */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>quals</name></expr>)</condition>
	<block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/* Convert the qualification into List if it's not already so */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
        <expr_stmt><expr><name>lquals</name> <operator>=</operator> <call><name>make_ands_implicit</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
    <else>else
	<block>{<block_content>
        <expr_stmt><expr><name>lquals</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator><name>quals</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * For every ANDed expression, check if that expression is of the form
     * &lt;distribution_col&gt; = &lt;expr&gt;. If so return expr.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>qual_cell</argument>, <argument>lquals</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>qual_expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>qual_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>lexpr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>rexpr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var_expr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>distcol_expr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>isswap</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* iterate process nested and */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>and_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>qual_expr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>lresult</name> <operator>=</operator> <call><name>pgxc_find_distcol_exprs</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name>attrNum</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>qual_expr</name><operator>)</operator><operator>-&gt;</operator><name>args</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>lresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>qual_expr</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
            <continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>op</name> <operator>=</operator> <operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator><name>qual_expr</name></expr>;</expr_stmt>
        <comment type="block">/* If not a binary operator, it can not be '='. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
            <continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>lexpr</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rexpr</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If either of the operands is a RelabelType, extract the Var in the RelabelType.
         * A RelabelType represents a "dummy" type coercion between two binary compatible datatypes.
         * If we do not handle these then our optimization does not work in case of varchar
         * For example if col is of type varchar and is the dist key then
         * select * from vc_tab where col = 'abcdefghijklmnopqrstuvwxyz';
         * should be shipped to one of the nodes only
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
            <expr_stmt><expr><name>lexpr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name><operator>*</operator><operator>)</operator><name>lexpr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
            <expr_stmt><expr><name>rexpr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name><operator>*</operator><operator>)</operator><name>rexpr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If either of the operands is a Var expression, assume the other
         * one is distribution column expression. If none is Var check next
         * qual.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>var_expr</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name>lexpr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>distcol_expr</name> <operator>=</operator> <name>rexpr</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>var_expr</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name>rexpr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>distcol_expr</name> <operator>=</operator> <name>lexpr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>isswap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
		<block>{<block_content>
            <continue>continue;</continue>
		</block_content>}</block></else></if_stmt>
        <comment type="block">/*
         * If Var found is not the distribution column of required relation,
         * check next qual
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>var_expr</name><operator>-&gt;</operator><name>varno</name></name> <operator>!=</operator> <name>varno</name> <operator>||</operator> <name><name>var_expr</name><operator>-&gt;</operator><name>varattno</name></name> <operator>!=</operator> <name>attrNum</name></expr>)</condition>
		<block>{<block_content>
            <continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
        <comment type="block">/*
         * If the operator is not an assignment operator, check next
         * constraint. An operator is an assignment operator if it's
         * mergejoinable or hashjoinable. Beware that not every assignment
         * operator is mergejoinable or hashjoinable, so we might leave some
         * oportunity. But then we have to rely on the opname which may not
         * be something we know to be equality operator as well.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_mergejoinable</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>lexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>!</operator><call><name>op_hashjoinable</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>lexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TimeStampRange</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Found the distribution column expression return it */</comment>
        <expr_stmt><expr><name>pQual</name>  <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DisQual</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pQual</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>opno</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pQual</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>distcol_expr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pQual</name><operator>-&gt;</operator><name>isswap</name></name><operator>=</operator> <name>isswap</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>pQual</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>pQual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <comment type="block">/* Exhausted all quals, but no distribution column expression */</comment>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ExecNodes</name> <modifier>*</modifier></type>
<name>GetRelationTimeStampRangeNodes</name><parameter_list>(<parameter><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rel_loc_info</name></decl></parameter>, 
                                <parameter><decl><type><name>Datum</name></type> <name>valueForDistCol</name></decl></parameter>, 
                                <parameter><decl><type><name>bool</name></type> <name>isValueNull</name></decl></parameter>, 
                                <parameter><decl><type><name>Oid</name></type> <name>typeOfValueForDistCol</name></decl></parameter>,                
                                <parameter><decl><type><name>Oid</name></type> <name>typeOfValueForSecDistCol</name></decl></parameter>,
                                <parameter><decl><type><name>Datum</name></type> <name>minForSecCol</name></decl></parameter>, 
                                <parameter><decl><type><name>Datum</name></type> <name>maxForSecCol</name></decl></parameter>,
                                <parameter><decl><type><name>bool</name></type>  <name>equalMin</name></decl></parameter>,
                                <parameter><decl><type><name>bool</name></type>  <name>equalMax</name></decl></parameter>,
                                <parameter><decl><type><name>RelationAccessType</name></type> <name>accessType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExecNodes</name>    <modifier>*</modifier></type><name>exec_nodes</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>rel_loc_info</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

    
    <switch>switch <condition>(<expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>LOCATOR_TYPE_SHARD</name></expr>:</case>
        <block>{<block_content>             
            <expr_stmt><expr><name>exec_nodes</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExecNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>baselocatortype</name></name> <operator>=</operator> <name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>accesstype</name></name> <operator>=</operator> <name>accessType</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>exec_nodes</name><operator>-&gt;</operator><name>nodeList</name></name> <operator>=</operator> <call><name>GetShardMapRangeList</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>, 
                                                        <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>,     
                                                        <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
                                                        <argument><expr><name>typeOfValueForDistCol</name></expr></argument>, 
                                                        <argument><expr><name>valueForDistCol</name></expr></argument>,
                                                        <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>, 
                                                        <argument><expr><name>typeOfValueForSecDistCol</name></expr></argument>,  
                                                        <argument><expr><name>minForSecCol</name></expr></argument>, 
                                                        <argument><expr><name>maxForSecCol</name></expr></argument>,
                                                        <argument><expr><name>equalMin</name></expr></argument>,
                                                        <argument><expr><name>equalMax</name></expr></argument>,
                                                        <argument><expr><name>accessType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>exec_nodes</name></expr>;</return>
        </block_content>}</block>
        <default>default:</default>
            <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>GetRelationGroupsByQuals</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>reloid</name></decl></parameter>, <parameter><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rel_loc_info</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>sec_quals</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>isalign</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rangeOpCnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>  <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>minStamp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>maxStamp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>constvalue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>  <modifier>*</modifier></type><name>qual_cell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>seccol_value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>  <name>seccol_isnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>      <name>seccol_type</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>    <modifier>*</modifier></type><name>opArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>isswapArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>seccol_value_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name>partitionStrategy</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>interval_step</name>            <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type>  <name>start_timestamp</name>          <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_partition_interval</name></type> <name>routerinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>seccol_list</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator><name>sec_quals</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>seccol_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>        <name>sectype</name> <init>= <expr><call><name>get_atttype</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>    <name>sectypmod</name> <init>= <expr><call><name>get_atttypmod</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>opArray</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <expr_stmt><expr><name>isswapArray</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>qual_cell</argument>, <argument>seccol_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>DisQual</name> <modifier>*</modifier></type><name>pQual</name> <init>= <expr><operator>(</operator><name>DisQual</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>qual_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>opArray</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pQual</name><operator>-&gt;</operator><name>opno</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>isswapArray</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>pQual</name><operator>-&gt;</operator><name>isswap</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name><name>pQual</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>,
                                <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>sectype</name></expr></argument>, <argument><expr><name>sectypmod</name></expr></argument>,
                                <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
                                <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>eval_const_expressions</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>seccol_value_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>seccol_value_list</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name>rel</name>          <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>routerinfo</name>     <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_partitions_info</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>routerinfo</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>partitionStrategy</name> <operator>=</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_type</name></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>partitionStrategy</name> <operator>==</operator> <name>IntervalType_Month</name> <operator>&amp;&amp;</operator>
            <name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_int</name></name> <operator>==</operator> <literal type="number">12</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>partitionStrategy</name> <operator>=</operator> <name>IntervalType_Year</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>interval_step</name> <operator>=</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_int</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>start_timestamp</name> <operator>=</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partstartvalue_ts</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>seccol_value_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>sec_distcol_expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>sec_distcol_expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>sec_distcol_expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TimeStampRange</name><argument_list>(<argument><expr><name><name>opArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>const_expr</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator><name>sec_distcol_expr</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>seccol_value</name>     <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>seccol_isnull</name>    <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>constisnull</name></name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>seccol_isnull</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>oids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>IsHotData</name><argument_list>(<argument><expr><name>seccol_value</name></expr></argument>, <argument><expr><name>RELATION_ACCESS_READ</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <return>return <expr><name>oids</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>sec_distcol_expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>sec_distcol_expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>TimeStampRange</name><argument_list>(<argument><expr><name><name>opArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>const_expr</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator><name>sec_distcol_expr</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><literal type="number">2062</literal> <operator>==</operator> <name><name>opArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <comment type="block">/* &lt; */</comment>
            <block>{<block_content>
                <expr_stmt><expr><name>isalign</name> <operator>=</operator> <call><name>IsConstAligned</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>isswapArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>constvalue</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>isalign</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* const &lt; var -&gt; const + 1 &lt;= var */</comment>
                        <expr_stmt><expr><name>constvalue</name> <operator>=</operator> <name>constvalue</name> <operator>+</operator> <name>ONE_SECOND_DATUM</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>minStamp</name> <operator>=</operator> <ternary><condition><expr><name>minStamp</name></expr> ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>constvalue</name> <operator>&gt;=</operator> <name>minStamp</name><operator>)</operator></expr> ?</condition><then> <expr><name>minStamp</name></expr> </then><else>: <expr><name>constvalue</name></expr></else></ternary><operator>)</operator></expr> </then><else>: <expr><name>constvalue</name></expr></else></ternary></expr>;</expr_stmt>
                    <expr_stmt><expr><name>seccol_type</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>consttype</name></name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>constvalue</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>isalign</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* var &lt; const -&gt; var &lt;= const -1 */</comment>
                        <expr_stmt><expr><name>constvalue</name> <operator>=</operator> <name>constvalue</name> <operator>-</operator> <name>ONE_SECOND_DATUM</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    
                    <expr_stmt><expr><name>maxStamp</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>constvalue</name> <operator>&gt;=</operator> <name>maxStamp</name><operator>)</operator></expr> ?</condition><then> <expr><name>constvalue</name></expr> </then><else>: <expr><name>maxStamp</name></expr></else></ternary></expr>;</expr_stmt>
                    <expr_stmt><expr><name>seccol_type</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>consttype</name></name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><literal type="number">2063</literal> <operator>==</operator> <name><name>opArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <comment type="block">/* &lt;= */</comment>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>isswapArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* const &lt;= var */</comment>
					<expr_stmt><expr><name>minStamp</name> <operator>=</operator> <ternary><condition><expr><name>minStamp</name></expr> ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>&gt;=</operator> <name>minStamp</name><operator>)</operator></expr> ?</condition><then> <expr><name>minStamp</name></expr> </then><else>: <expr><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></else></ternary><operator>)</operator></expr>
					                    </then><else>: <expr><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></else></ternary></expr>;</expr_stmt>
                    <expr_stmt><expr><name>seccol_type</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>consttype</name></name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* var &lt;= const */</comment>
                    <expr_stmt><expr><name>maxStamp</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>&gt;=</operator> <name>maxStamp</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr> </then><else>: <expr><name>maxStamp</name></expr></else></ternary></expr>;</expr_stmt>
                    <expr_stmt><expr><name>seccol_type</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>consttype</name></name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>  
            <if type="elseif">else if <condition>(<expr><literal type="number">2065</literal> <operator>==</operator> <name><name>opArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <comment type="block">/* &gt;= */</comment>
            <block>{<block_content>     
                <if_stmt><if>if <condition>(<expr><name><name>isswapArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* const &gt;= var */</comment>
                    <expr_stmt><expr><name>maxStamp</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>&gt;=</operator> <name>maxStamp</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr> </then><else>: <expr><name>maxStamp</name></expr></else></ternary></expr>;</expr_stmt>
                    <expr_stmt><expr><name>seccol_type</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>consttype</name></name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* var &gt;= const */</comment>
					<expr_stmt><expr><name>minStamp</name> <operator>=</operator> <ternary><condition><expr><name>minStamp</name></expr> ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>&gt;=</operator> <name>minStamp</name><operator>)</operator></expr> ?</condition><then> <expr><name>minStamp</name></expr> </then><else>: <expr><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></else></ternary><operator>)</operator></expr>
					                    </then><else>: <expr><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></else></ternary></expr>;</expr_stmt>
                    <expr_stmt><expr><name>seccol_type</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>consttype</name></name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><literal type="number">2064</literal> <operator>==</operator> <name><name>opArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <comment type="block">/* &gt; */</comment>
            <block>{<block_content>
                <expr_stmt><expr><name>isalign</name> <operator>=</operator> <call><name>IsConstAligned</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>isswapArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>constvalue</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>isalign</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* const &gt; var -&gt; const -1 &gt;= var */</comment>
                        <expr_stmt><expr><name>constvalue</name> <operator>=</operator> <name>constvalue</name> <operator>-</operator> <name>ONE_SECOND_DATUM</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><name>maxStamp</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>constvalue</name> <operator>&gt;=</operator> <name>maxStamp</name><operator>)</operator></expr> ?</condition><then> <expr><name>constvalue</name></expr> </then><else>: <expr><name>maxStamp</name></expr></else></ternary></expr>;</expr_stmt>
                    <expr_stmt><expr><name>seccol_type</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>consttype</name></name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name>constvalue</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>isalign</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* var &gt; const -&gt; var  &gt;= const + 1 */</comment>
                        <expr_stmt><expr><name>constvalue</name> <operator>=</operator> <name>constvalue</name> <operator>+</operator> <name>ONE_SECOND_DATUM</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    
                    <expr_stmt><expr><name>minStamp</name> <operator>=</operator> <ternary><condition><expr><name>minStamp</name></expr> ?</condition><then> <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>constvalue</name> <operator>&gt;=</operator> <name>minStamp</name><operator>)</operator></expr> ?</condition><then> <expr><name>minStamp</name></expr> </then><else>: <expr><name>constvalue</name></expr></else></ternary><operator>)</operator></expr> </then><else>: <expr><name>constvalue</name></expr></else></ternary></expr>;</expr_stmt>
                    <expr_stmt><expr><name>seccol_type</name> <operator>=</operator> <name><name>const_expr</name><operator>-&gt;</operator><name>consttype</name></name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>seccol_type</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <comment type="block">/* skip range condition */</comment>
            <expr_stmt><expr><name>rangeOpCnt</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>seccol_value</name>      <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>seccol_isnull</name>    <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <if_stmt><if>if <condition>(<expr><name>opArray</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>opArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>opArray</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>isswapArray</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>isswapArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>isswapArray</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>rangeOpCnt</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>seccol_value_list</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>oids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>minStamp</name> <operator>&amp;&amp;</operator> <name>maxStamp</name></expr>)</condition>
        <block>{<block_content>            
			<if_stmt><if>if <condition>(<expr><call><name>IsHotData</name><argument_list>(<argument><expr><name>minStamp</name></expr></argument>, <argument><expr><name>RELATION_ACCESS_READ</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			    <call><name>IsHotData</name><argument_list>(<argument><expr><name>maxStamp</name></expr></argument>, <argument><expr><name>RELATION_ACCESS_READ</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>    <comment type="block">/* all hot data */</comment>
                <expr_stmt><expr><name>oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                
            </block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>IsHotData</name><argument_list>(<argument><expr><name>minStamp</name></expr></argument>, <argument><expr><name>RELATION_ACCESS_READ</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			         <operator>!</operator><call><name>IsHotData</name><argument_list>(<argument><expr><name>maxStamp</name></expr></argument>, <argument><expr><name>RELATION_ACCESS_READ</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* all cold data */</comment>
                <expr_stmt><expr><name>oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>IsHotData</name><argument_list>(<argument><expr><name>minStamp</name></expr></argument>, <argument><expr><name>RELATION_ACCESS_READ</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			         <call><name>IsHotData</name><argument_list>(<argument><expr><name>maxStamp</name></expr></argument>, <argument><expr><name>RELATION_ACCESS_READ</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* range across cold and hot group */</comment>
                <expr_stmt><expr><name>oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>minStamp</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* timestamp &gt;=, all query in hot node */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>IsHotData</name><argument_list>(<argument><expr><name>minStamp</name></expr></argument>, <argument><expr><name>RELATION_ACCESS_READ</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>maxStamp</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* &lt;= timestamp, both hot and cold need query */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>IsHotData</name><argument_list>(<argument><expr><name>maxStamp</name></expr></argument>, <argument><expr><name>RELATION_ACCESS_READ</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* only cold group */</comment>
                <expr_stmt><expr><name>oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <return>return <expr><name>oids</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>oids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>coldGroupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>oids</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name><modifier>*</modifier></type> <name>g_default_locator_type</name></decl>;</decl_stmt>

<function><type><name>char</name></type> <name>get_default_locator_type</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>g_default_locator_type</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_ALL_TABLE_TYPE</name></cpp:ifdef>
        <return>return <expr><name>LOCATOR_TYPE_HASH</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <return>return <expr><name>LOCATOR_TYPE_SHARD</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>g_default_locator_type</name></expr></argument>, <argument><expr><literal type="string">"shard"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>LOCATOR_TYPE_SHARD</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>g_default_locator_type</name></expr></argument>, <argument><expr><literal type="string">"hash"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>LOCATOR_TYPE_HASH</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>g_default_locator_type</name></expr></argument>, <argument><expr><literal type="string">"replication"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>LOCATOR_TYPE_REPLICATED</name></expr>;</return> 
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown locator type:%s"</literal></expr></argument>, <argument><expr><name>g_default_locator_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* keep compiler slience */</comment>
    <return>return <expr><name>LOCATOR_TYPE_HASH</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>get_default_distype</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>g_default_locator_type</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_ALL_TABLE_TYPE</name></cpp:ifdef>
        <return>return <expr><name>DISTTYPE_HASH</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <return>return <expr><name>DISTTYPE_SHARD</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>g_default_locator_type</name></expr></argument>, <argument><expr><literal type="string">"shard"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>DISTTYPE_SHARD</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>g_default_locator_type</name></expr></argument>, <argument><expr><literal type="string">"hash"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>DISTTYPE_HASH</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>g_default_locator_type</name></expr></argument>, <argument><expr><literal type="string">"replication"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>DISTTYPE_REPLICATION</name></expr>;</return> 
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown locator type:%s"</literal></expr></argument>, <argument><expr><name>g_default_locator_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* keep compiler slience */</comment>
    <return>return <expr><name>DISTTYPE_HASH</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



</unit>
