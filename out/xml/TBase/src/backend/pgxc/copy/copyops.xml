<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/pgxc/copy/copyops.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * copyops.c
 *      Functions related to remote COPY data manipulation and materialization
 *      of data redistribution
 *
 * Copyright (c) 2010-2012 Postgres-XC Development Group
 *
 *
 * IDENTIFICATION
 *      src/backend/pgxc/copy/copyops.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/copyops.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>

<comment type="block">/* NULL print marker */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPYOPS_NULL_PRINT</name></cpp:macro>    <cpp:value>"\\N"</cpp:value></cpp:define>

<comment type="block">/* Some octal operations */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ISOCTAL</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((c) &gt;= '0') &amp;&amp; ((c) &lt;= '7'))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OCTVALUE</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((c) - '0')</cpp:value></cpp:define>
<comment type="block">/* Send text representation of one attribute, with conversion and escaping */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMPSOFAR</name><parameter_list>()</parameter_list></cpp:macro> \
    <cpp:value>do { \
        if (ptr &gt; start) \
            appendBinaryStringInfo(buf, (char *) start, ptr - start); \
    } while (0)</cpp:value></cpp:define>


<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>get_decimal_from_hex</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>hex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>attribute_out_text</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Return decimal value for a hexadecimal digit
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_decimal_from_hex</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>hex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>hex</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>hex</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><call><name>tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>hex</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="char">'a'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Output an attribute to text
 * This takes portions of the code of CopyAttributeOutText
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>attribute_out_text</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>delimc</name> <init>= <expr><name>COPYOPS_DELIMITER</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>need_transcoding</name></decl>, <decl><type ref="prev"/><name>encoding_embeds_ascii</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>file_encoding</name> <init>= <expr><call><name>pg_get_client_encoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>need_transcoding</name> <operator>=</operator> <operator>(</operator><name>file_encoding</name> <operator>!=</operator> <call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call> <operator>||</operator>
                        <call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>encoding_embeds_ascii</name> <operator>=</operator> <call><name>PG_ENCODING_IS_CLIENT_ONLY</name><argument_list>(<argument><expr><name>file_encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>need_transcoding</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>pg_server_to_any</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>file_encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>string</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * We have to grovel through the string searching for control characters
     * and instances of the delimiter character.  In most cases, though, these
     * are infrequent.    To avoid overhead from calling CopySendData once per
     * character, we dump out all characters between escaped characters in a
     * single call.  The loop invariant is that the data from "start" to "ptr"
     * can be sent literally, but hasn't yet been.
     *
     * We can skip pg_encoding_mblen() overhead when encoding is safe, because
     * in valid backend encodings, extra bytes of a multibyte character never
     * look like ASCII.  This loop is sufficiently performance-critical that
     * it's worth making two copies of it to get the IS_HIGHBIT_SET() test out
     * of the normal safe-encoding path.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>encoding_embeds_ascii</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>start</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>ptr</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <literal type="number">0x20</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * \r and \n must be escaped, the others are traditional. We
                 * prefer to dump these using the C-like notation, rather than
                 * a backslash and the literal character, because it makes the
                 * dump file a bit more proof against Microsoftish data
                 * mangling.
                 */</comment>
                <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><literal type="char">'\b'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'b'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'\f'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'\n'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'n'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'\r'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'r'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'\t'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'\v'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'v'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <default>default:</default>
                        <comment type="block">/* All ASCII control chars are length 1 */</comment>
                        <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
                        <continue>continue;</continue>        <comment type="block">/* fall to end of loop */</comment>
                </block_content>}</block></switch>

                <comment type="block">/* if we get here, we need to convert the control char */</comment>
                <expr_stmt><expr><call><name>DUMPSOFAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>start</name> <operator>=</operator> <operator>++</operator><name>ptr</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <name>delimc</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>DUMPSOFAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>start</name> <operator>=</operator> <operator>++</operator><name>ptr</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call><name>pg_encoding_mblen</name><argument_list>(<argument><expr><name>file_encoding</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>start</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>ptr</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <literal type="number">0x20</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * \r and \n must be escaped, the others are traditional. We
                 * prefer to dump these using the C-like notation, rather than
                 * a backslash and the literal character, because it makes the
                 * dump file a bit more proof against Microsoftish data
                 * mangling.
                 */</comment>
                <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><literal type="char">'\b'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'b'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'\f'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'\n'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'n'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'\r'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'r'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'\t'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'\v'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'v'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <default>default:</default>
                        <comment type="block">/* If it's the delimiter, must backslash it */</comment>
                        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>delimc</name></expr>)</condition><block type="pseudo"><block_content>
                            <break>break;</break></block_content></block></if></if_stmt>
                        <comment type="block">/* All ASCII control chars are length 1 */</comment>
                        <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
                        <continue>continue;</continue>        <comment type="block">/* fall to end of loop */</comment>
                </block_content>}</block></switch>
                <comment type="block">/* if we get here, we need to convert the control char */</comment>
                <expr_stmt><expr><call><name>DUMPSOFAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>start</name> <operator>=</operator> <operator>++</operator><name>ptr</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <name>delimc</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>DUMPSOFAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>start</name> <operator>=</operator> <operator>++</operator><name>ptr</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>DUMPSOFAR</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * CopyOps_RawDataToArrayField
 * Convert the raw output of COPY TO to an array of fields.
 * This is a simplified version of CopyReadAttributesText used for data
 * redistribution and storage of tuple data into a tuple store.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type>
<name>CopyOps_RawDataToArrayField</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
        <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>tmpbuf</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name></type>        <name>delimc</name> <init>= <expr><name>COPYOPS_DELIMITER</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>fieldno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>null_print_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>COPYOPS_NULL_PRINT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>origin_ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>output_ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cur_ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>line_end_ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>fields</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>      <modifier>*</modifier><modifier>*</modifier></type><name>raw_fields</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>attr</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Adjust number of fields depending on dropped attributes */</comment>
    <for>for <control>(<init><expr><name>fieldno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>fieldno</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>fieldno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>attr</name><index>[<expr><name>fieldno</name></expr>]</index></name><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>fields</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Then alloc necessary space */</comment>
    <expr_stmt><expr><name>raw_fields</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>fields</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Take a copy of message to manipulate */</comment>
    <expr_stmt><expr><operator>*</operator><name>tmpbuf</name> <operator>=</operator> <name>origin_ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>origin_ptr</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Add clean separator '\0' at the end of message */</comment>
    <expr_stmt><expr><name><name>origin_ptr</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <comment type="block">/* Keep track of original pointer */</comment>
    <expr_stmt><expr><name>output_ptr</name> <operator>=</operator> <name>origin_ptr</name></expr>;</expr_stmt>

    <comment type="block">/* set pointer variables for loop */</comment>
    <expr_stmt><expr><name>cur_ptr</name> <operator>=</operator> <name>message</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>line_end_ptr</name> <operator>=</operator> <name>message</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

    <comment type="block">/* Outer loop iterates over fields */</comment>
    <expr_stmt><expr><name>fieldno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>start_ptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>end_ptr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>input_len</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>found_delim</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>saw_non_ascii</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Make sure there is enough space for the next value */</comment>
        <if_stmt><if>if <condition>(<expr><name>fieldno</name> <operator>&gt;=</operator> <name>fields</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>fields</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>raw_fields</name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>raw_fields</name></expr></argument>, <argument><expr><name>fields</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Remember start of field on output side */</comment>
        <expr_stmt><expr><name>start_ptr</name> <operator>=</operator> <name>cur_ptr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>raw_fields</name><index>[<expr><name>fieldno</name></expr>]</index></name> <operator>=</operator> <name>output_ptr</name></expr>;</expr_stmt>

        <comment type="block">/* Scan data for field */</comment>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type>        <name>c</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>end_ptr</name> <operator>=</operator> <name>cur_ptr</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&gt;=</operator> <name>line_end_ptr</name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>delimc</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>found_delim</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&gt;=</operator> <name>line_end_ptr</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
                <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><literal type="char">'0'</literal></expr>:</case>
                    <case>case <expr><literal type="char">'1'</literal></expr>:</case>
                    <case>case <expr><literal type="char">'2'</literal></expr>:</case>
                    <case>case <expr><literal type="char">'3'</literal></expr>:</case>
                    <case>case <expr><literal type="char">'4'</literal></expr>:</case>
                    <case>case <expr><literal type="char">'5'</literal></expr>:</case>
                    <case>case <expr><literal type="char">'6'</literal></expr>:</case>
                    <case>case <expr><literal type="char">'7'</literal></expr>:</case>
                        <block>{<block_content>
                            <comment type="block">/* handle \013 */</comment>
                            <decl_stmt><decl><type><name>int</name></type>            <name>val</name></decl>;</decl_stmt>

                            <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>OCTVALUE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&lt;</operator> <name>line_end_ptr</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cur_ptr</name></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><call><name>ISOCTAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>
                                    <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <call><name>OCTVALUE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&lt;</operator> <name>line_end_ptr</name></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>cur_ptr</name></expr>;</expr_stmt>
                                        <if_stmt><if>if <condition>(<expr><call><name>ISOCTAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
                                        <block>{<block_content>
                                            <expr_stmt><expr><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>
                                            <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <call><name>OCTVALUE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        </block_content>}</block></if></if_stmt>
                                    </block_content>}</block></if></if_stmt>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block></if></if_stmt>
                            <expr_stmt><expr><name>c</name> <operator>=</operator> <name>val</name> <operator>&amp;</operator> <literal type="number">0377</literal></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name>saw_non_ascii</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                        </block_content>}</block>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'x'</literal></expr>:</case>
                        <comment type="block">/* Handle \x3F */</comment>
                        <if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&lt;</operator> <name>line_end_ptr</name></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>char</name></type>        <name>hexchar</name> <init>= <expr><operator>*</operator><name>cur_ptr</name></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><call><name>isxdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>hexchar</name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <decl_stmt><decl><type><name>int</name></type>            <name>val</name> <init>= <expr><call><name>get_decimal_from_hex</name><argument_list>(<argument><expr><name>hexchar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                                <expr_stmt><expr><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><name>cur_ptr</name> <operator>&lt;</operator> <name>line_end_ptr</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>hexchar</name> <operator>=</operator> <operator>*</operator><name>cur_ptr</name></expr>;</expr_stmt>
                                    <if_stmt><if>if <condition>(<expr><call><name>isxdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>hexchar</name></expr></argument>)</argument_list></call></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><name>cur_ptr</name><operator>++</operator></expr>;</expr_stmt>
                                        <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>+</operator> <call><name>get_decimal_from_hex</name><argument_list>(<argument><expr><name>hexchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>
                                </block_content>}</block></if></if_stmt>
                                <expr_stmt><expr><name>c</name> <operator>=</operator> <name>val</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                                    <expr_stmt><expr><name>saw_non_ascii</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'b'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\b'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'f'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\f'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'n'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'r'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\r'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'t'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\t'</literal></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><literal type="char">'v'</literal></expr>:</case>
                        <expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'\v'</literal></expr>;</expr_stmt>
                        <break>break;</break>

                    <comment type="block">/*
                     * in all other cases, take the char after '\'
                     * literally
                     */</comment>
                </block_content>}</block></switch>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Add c to output string */</comment>
            <expr_stmt><expr><operator>*</operator><name>output_ptr</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Terminate attribute value in output area */</comment>
        <expr_stmt><expr><operator>*</operator><name>output_ptr</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

        <comment type="block">/*
         * If we de-escaped a non-7-bit-ASCII char, make sure we still have
         * valid data for the db encoding. Avoid calling strlen here for the
         * sake of efficiency.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>saw_non_ascii</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>fld</name> <init>= <expr><name><name>raw_fields</name><index>[<expr><name>fieldno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>pg_verifymbstr</name><argument_list>(<argument><expr><name>fld</name></expr></argument>, <argument><expr><name>output_ptr</name> <operator>-</operator> <operator>(</operator><name>fld</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Check whether raw input matched null marker */</comment>
        <expr_stmt><expr><name>input_len</name> <operator>=</operator> <name>end_ptr</name> <operator>-</operator> <name>start_ptr</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>input_len</name> <operator>==</operator> <name>null_print_len</name> <operator>&amp;&amp;</operator>
            <call><name>strncmp</name><argument_list>(<argument><expr><name>start_ptr</name></expr></argument>, <argument><expr><name>COPYOPS_NULL_PRINT</name></expr></argument>, <argument><expr><name>input_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>raw_fields</name><index>[<expr><name>fieldno</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>fieldno</name><operator>++</operator></expr>;</expr_stmt>
        <comment type="block">/* Done if we hit EOL instead of a delim */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_delim</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Clean up state of attribute_buf */</comment>
    <expr_stmt><expr><name>output_ptr</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>output_ptr</name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>raw_fields</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CopyOps_BuildOneRowTo
 * Build one row message to be sent to remote nodes through COPY protocol
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>CopyOps_BuildOneRowTo</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>need_delim</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>out_functions</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>attr</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfo</name></type>    <name>buf</name></decl>;</decl_stmt>

    <comment type="block">/* Get info about the columns we need to process. */</comment>
    <expr_stmt><expr><name>out_functions</name> <operator>=</operator> <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>out_func_oid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isvarlena</name></decl>;</decl_stmt>

        <comment type="block">/* Do not need any information for dropped attributes */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>attr</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>attr</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr></argument>,
                          <argument><expr><operator>&amp;</operator><name>out_func_oid</name></expr></argument>,
                          <argument><expr><operator>&amp;</operator><name>isvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>out_func_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>out_functions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Initialize output buffer */</comment>
    <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>value</name> <init>= <expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name> <init>= <expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Do not need any information for dropped attributes */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>attr</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>need_delim</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>COPYOPS_DELIMITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>need_delim</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Null print value to client */</comment>
            <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\\N"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"\\N"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>OutputFunctionCall</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out_functions</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                        <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>attribute_out_text</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Record length of message */</comment>
    <expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>out_functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>
</unit>
