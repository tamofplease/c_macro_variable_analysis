<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/pgxc/cluster/pause.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pause.c
 *
 *     Cluster Pause/Unpause handling
 *
 * IDENTIFICATION
 *      $$
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<comment type="block">/* globals */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>cluster_lock_held</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>cluster_ex_lock_held</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>HandleClusterPause</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>pause</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>initiator</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessClusterPauseRequest</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>pause</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>ClusterLockInfo</name> <modifier>*</modifier></type><name>ClustLinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * ProcessClusterPauseRequest:
 *
 * Carry out PAUSE/UNPAUSE request on a coordinator node
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessClusterPauseRequest</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>pause</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>action</name> <init>= <expr><ternary><condition><expr><name>pause</name></expr>?</condition><then> <expr><literal type="string">"PAUSE"</literal></expr></then><else>:<expr><literal type="string">"UNPAUSE"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IS_PGXC_COORDINATOR</name> <operator>||</operator> <operator>!</operator><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"The %s CLUSTER message is expected to "</literal>
                        <literal type="string">"arrive at a coordinator from another coordinator"</literal></expr></argument>,
                        <argument><expr><name>action</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Received %s CLUSTER from a coordinator"</literal></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If calling UNPAUSE, ensure that the cluster lock has already been held
     * in exclusive mode
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pause</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cluster_ex_lock_held</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Received an UNPAUSE request when cluster not PAUSED!"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Enable/Disable local queries. We need to release the lock first
     *
     * TODO: Think of some timeout mechanism here, if the locking takes too
     * much time...
     */</comment>
    <expr_stmt><expr><call><name>ReleaseClusterLock</name><argument_list>(<argument><expr><ternary><condition><expr><name>pause</name></expr>?</condition><then> <expr><name>false</name></expr></then><else>:<expr><name>true</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AcquireClusterLock</name><argument_list>(<argument><expr><ternary><condition><expr><name>pause</name></expr>?</condition><then> <expr><name>true</name></expr></then><else>:<expr><name>false</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>pause</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>cluster_ex_lock_held</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>cluster_ex_lock_held</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"%s queries at the coordinator"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>pause</name></expr>?</condition><then> <expr><literal type="string">"Paused"</literal></expr></then><else>:<expr><literal type="string">"Resumed"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * HandleClusterPause:
 *
 * Any errors will be reported via ereport.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>HandleClusterPause</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>pause</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>initiator</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>coord_handles</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>conn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>response</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>action</name> <init>= <expr><ternary><condition><expr><name>pause</name></expr>?</condition><then> <expr><literal type="string">"PAUSE"</literal></expr></then><else>:<expr><literal type="string">"UNPAUSE"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Preparing coordinators for %s CLUSTER"</literal></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>pause</name> <operator>&amp;&amp;</operator> <name>cluster_ex_lock_held</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CLUSTER already PAUSED"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Nothing to do */</comment>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pause</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cluster_ex_lock_held</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Issue PAUSE CLUSTER before calling UNPAUSE"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Nothing to do */</comment>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If we are one of the participating coordinators, just do the action
     * locally and return
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>initiator</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ProcessClusterPauseRequest</name><argument_list>(<argument><expr><name>pause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Send a PAUSE/UNPAUSE CLUSTER message to all the coordinators. We should send an
     * asyncronous request, update the local ClusterLock and then wait for the remote
     * coordinators to respond back
     */</comment>

	<expr_stmt><expr><name>coord_handles</name> <operator>=</operator> <call><name>get_handles</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>, <argument><expr><call><name>GetAllCoordNodes</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>conn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>conn</name> <operator>&lt;</operator> <name><name>coord_handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</condition> <incr><expr><name>conn</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name><name>coord_handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>conn</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_send_query</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><ternary><condition><expr><name>pause</name></expr>?</condition><then> <expr><literal type="string">"PAUSE CLUSTER"</literal></expr> </then><else>: <expr><literal type="string">"UNPAUSE CLUSTER"</literal></expr></else></ternary></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to send %s CLUSTER request to some coordinator nodes"</literal></expr></argument>,<argument><expr><name>action</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Disable/Enable local queries. We need to release the SHARED mode first
     *
     * TODO: Start a timer to cancel the request in case of a timeout
     */</comment>
    <expr_stmt><expr><call><name>ReleaseClusterLock</name><argument_list>(<argument><expr><ternary><condition><expr><name>pause</name></expr>?</condition><then> <expr><name>false</name></expr></then><else>:<expr><name>true</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AcquireClusterLock</name><argument_list>(<argument><expr><ternary><condition><expr><name>pause</name></expr>?</condition><then> <expr><name>true</name></expr></then><else>:<expr><name>false</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>pause</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>cluster_ex_lock_held</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>cluster_ex_lock_held</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>


    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"%s queries at the driving coordinator"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>pause</name></expr>?</condition><then> <expr><literal type="string">"Paused"</literal></expr></then><else>:<expr><literal type="string">"Resumed"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Local queries are paused/enabled. Check status of the remote coordinators
     * now. We need a TRY/CATCH block here, so that if one of the coordinator
     * fails for some reason, we can try best-effort to salvage the situation
     * at others
     *
     * We hope that errors in the earlier loop generally do not occur (out of
     * memory and improper handles..) or we can have a similar TRY/CATCH block
     * there too
     *
     * To repeat: All the salvaging is best effort really...
     */</comment>
    <expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ResponseCombiner</name></type> <name>combiner</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>InitResponseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>, <argument><expr><name><name>coord_handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr></argument>, <argument><expr><name>COMBINE_TYPE_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>conn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>conn</name> <operator>&lt;</operator> <name><name>coord_handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</condition> <incr><expr><name>conn</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>handle</name> <operator>=</operator> <name><name>coord_handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>conn</name></expr>]</index></name></expr>;</expr_stmt>

            <while>while <condition>(<expr><name>true</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>pgxc_node_receive</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>handle</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to receive a response from the remote coordinator node"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>response</name> <operator>=</operator> <call><name>handle_response</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>response</name> <operator>==</operator> <name>RESPONSE_EOF</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><name>response</name> <operator>==</operator> <name>RESPONSE_COMPLETE</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s CLUSTER command failed "</literal>
                                    <literal type="string">"with error %s"</literal></expr></argument>, <argument><expr><name>action</name></expr></argument>, <argument><expr><name><name>handle</name><operator>-&gt;</operator><name>error</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></while>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>.</operator><name>errorMessage</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>code</name> <init>= <expr><name><name>combiner</name><operator>.</operator><name>errorCode</name></name></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>combiner</name><operator>.</operator><name>errorDetail</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><call><name>MAKE_SQLSTATE</name><argument_list>(<argument><expr><name><name>code</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>.</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>.</operator><name>errorDetail</name></name></expr></argument>)</argument_list></call> <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><call><name>MAKE_SQLSTATE</name><argument_list>(<argument><expr><name><name>code</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>code</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>combiner</name><operator>.</operator><name>errorMessage</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>CloseCombiner</name><argument_list>(<argument><expr><operator>&amp;</operator><name>combiner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <block>{<block_content>
        <comment type="block">/*
         * If PAUSE CLUSTER, issue UNPAUSE on the reachable nodes. For failure
         * in cases of UNPAUSE, might need manual intervention at the offending
         * coordinator node (maybe do a pg_cancel_backend() on the backend
         * that's holding the exclusive lock or something..)
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>pause</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                 <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"UNPAUSE CLUSTER command failed on one or more coordinator nodes."</literal>
                        <literal type="string">" Manual intervention may be required!"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                 <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PAUSE CLUSTER command failed on one or more coordinator nodes."</literal>
                        <literal type="string">" Trying to UNPAUSE reachable nodes now"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <for>for <control>(<init><expr><name>conn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>conn</name> <operator>&lt;</operator> <name><name>coord_handles</name><operator>-&gt;</operator><name>co_conn_count</name></name> <operator>&amp;&amp;</operator> <name>pause</name></expr>;</condition> <incr><expr><name>conn</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name><name>coord_handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>conn</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pgxc_node_send_query</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"UNPAUSE CLUSTER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * The incoming data should hopefully be discarded as part of
             * cleanup..
             */</comment>
        </block_content>}</block></for>

        <comment type="block">/* cleanup locally.. */</comment>
        <expr_stmt><expr><call><name>ReleaseClusterLock</name><argument_list>(<argument><expr><ternary><condition><expr><name>pause</name></expr>?</condition><then> <expr><name>true</name></expr></then><else>:<expr><name>false</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AcquireClusterLock</name><argument_list>(<argument><expr><ternary><condition><expr><name>pause</name></expr>?</condition><then> <expr><name>false</name></expr></then><else>:<expr><name>true</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cluster_ex_lock_held</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Successfully completed %s CLUSTER command on "</literal>
                 <literal type="string">"all coordinator nodes"</literal></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>RequestClusterPause</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>pause</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>completionTag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name>action</name> <init>= <expr><ternary><condition><expr><name>pause</name></expr>?</condition><then> <expr><literal type="string">"PAUSE"</literal></expr></then><else>:<expr><literal type="string">"UNPAUSE"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>     <name>initiator</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"%s CLUSTER request received"</literal></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Only a superuser can perform this activity on a cluster */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s CLUSTER command: must be a superuser"</literal></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Ensure that we are a coordinator */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IS_PGXC_COORDINATOR</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s CLUSTER command must be sent to a coordinator"</literal></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Did the command come directly to this coordinator or via another
     * coordinator?
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>initiator</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>HandleClusterPause</name><argument_list>(<argument><expr><name>pause</name></expr></argument>, <argument><expr><name>initiator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>completionTag</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>completionTag</name></expr></argument>, <argument><expr><name>COMPLETION_TAG_BUFSIZE</name></expr></argument>, <argument><expr><literal type="string">"%s CLUSTER"</literal></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * If the backend is shutting down, cleanup the PAUSE cluster lock
 * appropriately. We do this before shutting down shmem, because this needs
 * LWLock and stuff
 */</comment>
<function><type><name>void</name></type>
<name>PGXCCleanClusterLock</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGXCNodeAllHandles</name> <modifier>*</modifier></type><name>coord_handles</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>conn</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>cluster_lock_held</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cluster_ex_lock_held</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ReleaseClusterLock</name> <argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cluster_lock_held</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Do nothing if cluster lock not held */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>cluster_ex_lock_held</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Do nothing if we are not the initiator */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsConnFromCoord</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>coord_handles</name> <operator>=</operator> <call><name>get_handles</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>, <argument><expr><call><name>GetAllCoordNodes</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Try best-effort to UNPAUSE other coordinators now */</comment>
    <for>for <control>(<init><expr><name>conn</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>conn</name> <operator>&lt;</operator> <name><name>coord_handles</name><operator>-&gt;</operator><name>co_conn_count</name></name></expr>;</condition> <incr><expr><name>conn</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PGXCNodeHandle</name> <modifier>*</modifier></type><name>handle</name> <init>= <expr><name><name>coord_handles</name><operator>-&gt;</operator><name>coord_handles</name><index>[<expr><name>conn</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* No error checking here... */</comment>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pgxc_node_send_query</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><literal type="string">"UNPAUSE CLUSTER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Release locally too. We do not want a dangling value in cl_holder_pid! */</comment>
    <expr_stmt><expr><call><name>ReleaseClusterLock</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cluster_ex_lock_held</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Report shared memory space needed by ClusterLockShmemInit */</comment>
<function><type><name>Size</name></type>
<name>ClusterLockShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type>        <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ClusterLockInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Allocate and initialize cluster locking related shared memory */</comment>
<function><type><name>void</name></type>
<name>ClusterLockShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>ClustLinfo</name> <operator>=</operator> <operator>(</operator><name>ClusterLockInfo</name> <operator>*</operator><operator>)</operator>
        <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Cluster Lock Info"</literal></expr></argument>, <argument><expr><call><name>ClusterLockShmemSize</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* First time through, so initialize */</comment>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>ClustLinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>ClusterLockShmemSize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ClustLinfo</name><operator>-&gt;</operator><name>cl_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AcquireClusterLock
 *
 *  Based on the argument passed in, try to update the shared memory
 *  appropriately. In case the conditions cannot be satisfied immediately this
 *  function resorts to a simple sleep. We don't envision PAUSE CLUSTER to
 *  occur that frequently so most of the calls will come out immediately here
 *  without any sleeps at all
 *
 *  We could have used a semaphore to allow the processes to sleep while the
 *  cluster lock is held. But again we are really not worried about performance
 *  and immediate wakeups around PAUSE CLUSTER functionality. Using the sleep
 *  in an infinite loop keeps things simple yet correct
 */</comment>
<function><type><name>void</name></type>
<name>AcquireClusterLock</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>exclusive</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>ClusterLockInfo</name> <modifier>*</modifier></type><name>clinfo</name> <init>= <expr><name>ClustLinfo</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>exclusive</name> <operator>&amp;&amp;</operator> <name>cluster_ex_lock_held</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * In the normal case, none of the backends will ask for exclusive lock, so
     * they will just update the cl_process_count value and exit immediately
     * from the below loop
     */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>wait</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>clinfo</name><operator>-&gt;</operator><name>cl_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>exclusive</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>clinfo</name><operator>-&gt;</operator><name>cl_holder_pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>clinfo</name><operator>-&gt;</operator><name>cl_process_count</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>wait</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else <comment type="block">/* PAUSE CLUSTER handling */</comment>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>clinfo</name><operator>-&gt;</operator><name>cl_holder_pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>clinfo</name><operator>-&gt;</operator><name>cl_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PAUSE CLUSTER already in progress"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * There should be no other process
             * holding the lock including ourself
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>clinfo</name><operator>-&gt;</operator><name>cl_process_count</name></name>  <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>wait</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>clinfo</name><operator>-&gt;</operator><name>cl_holder_pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>clinfo</name><operator>-&gt;</operator><name>cl_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * We use a simple sleep mechanism. If PAUSE CLUSTER has been invoked,
         * we are not worried about immediate performance characteristics..
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>wait</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">100000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content> <comment type="block">/* Got the proper semantic read/write lock.. */</comment>
            <break>break;</break></block_content></block></else></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * ReleaseClusterLock
 *
 *         Update the shared memory appropriately across the release call. We
 *         really do not need the bool argument, but it's there for some
 *         additional sanity checking
 */</comment>
<function><type><name>void</name></type>
<name>ReleaseClusterLock</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>exclusive</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>ClusterLockInfo</name> <modifier>*</modifier></type><name>clinfo</name> <init>= <expr><name>ClustLinfo</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>clinfo</name><operator>-&gt;</operator><name>cl_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>exclusive</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>clinfo</name><operator>-&gt;</operator><name>cl_process_count</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator>
                <name><name>clinfo</name><operator>-&gt;</operator><name>cl_holder_pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>clinfo</name><operator>-&gt;</operator><name>cl_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Inconsistent state while doing UNPAUSE CLUSTER"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Reset the holder pid. Any waiters in AcquireClusterLock will
         * eventually come out of their sleep and notice this new value and
         * move ahead
         */</comment>
        <expr_stmt><expr><name><name>clinfo</name><operator>-&gt;</operator><name>cl_holder_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>clinfo</name><operator>-&gt;</operator><name>cl_holder_pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>clinfo</name><operator>-&gt;</operator><name>cl_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Inconsistent state while releasing CLUSTER lock"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/*
         * Decrement our count. If a PAUSE is waiting inside AcquireClusterLock
         * elsewhere, it will wake out of sleep and do the needful
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>clinfo</name><operator>-&gt;</operator><name>cl_process_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>clinfo</name><operator>-&gt;</operator><name>cl_process_count</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>clinfo</name><operator>-&gt;</operator><name>cl_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
