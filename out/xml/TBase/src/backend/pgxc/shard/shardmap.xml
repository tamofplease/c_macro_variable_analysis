<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/pgxc/shard/shardmap.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/extentmapping.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/s_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lockdefs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/shardmap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxcnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/nodemgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/locator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/bitmapset.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/skey.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sdir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/stratnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_shard_map.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_group.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/groupmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/regproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_key_values.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* 12 month for a year */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLD_HOT_INTERVAL_YEAR</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>

<decl_stmt><decl><type><name>bool</name></type> <name>g_IsExtension</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>enable_cold_hot_router_print</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>trace_extent</name></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>Oid</name></type>     <name>group</name></decl>;</decl_stmt>                    <comment type="block">/* group sharding into */</comment>
    <decl_stmt><decl><type><name>int32</name></type>   <name>shardMaxGlblNdIdx</name></decl>;</decl_stmt>        <comment type="block">/* max global node index */</comment>
    <decl_stmt><decl><type><name>int32</name></type>   <name>shardMapStatus</name></decl>;</decl_stmt>         <comment type="block">/* shard map status */</comment>
    <decl_stmt><decl><type><name>int32</name></type>   <name>shmemNumShardGroups</name></decl>;</decl_stmt>    <comment type="block">/* number of shard groups */</comment>
    <decl_stmt><decl><type><name>int32</name></type>   <name>shmemNumShards</name></decl>;</decl_stmt>            <comment type="block">/* number of shards */</comment>
    <decl_stmt><decl><type><name>int32</name></type>   <name>shmemNumShardNodes</name></decl>;</decl_stmt>        <comment type="block">/* number of nodes in the sharding group*/</comment>

    <decl_stmt><decl><type><name>int32</name></type>   <name><name>shmemshardnodes</name><index>[<expr><name>MAX_GROUP_NODE_NUMBER</name></expr>]</index></name></decl>;</decl_stmt><comment type="block">/* node index of this group, ordered by node name */</comment>
    <decl_stmt><decl><type><name>int32</name></type>   <name><name>shmemNodeMap</name><index>[<expr><name>TBASE_MAX_DATANODE_NUMBER</name></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* map for global node index to group native node index */</comment>
    <decl_stmt><decl><type><name>ShardMapItemDef</name></type> <name><name>shmemshardmap</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* shard map info */</comment>
}</block></struct></type><name>GroupShardInfo</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>uint64</name></type>            <name>group</name></decl>;</decl_stmt>
}</block></struct></type><name>GroupLookupTag</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{    
    <decl_stmt><decl><type><name>GroupLookupTag</name></type> <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>           <name>shardIndex</name></decl>;</decl_stmt>                <comment type="block">/* Associated into  ShardNodeGroupInfo index */</comment>
}</block></struct></type> <name>GroupLookupEnt</name>;</typedef>

<typedef>typedef <type><struct>struct 
<block>{
    <decl_stmt><decl><type><name>bool</name></type>           <name>inited</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>           <name>needLock</name></decl>;</decl_stmt>                      <comment type="block">/* whether we need lock */</comment>
    <decl_stmt><decl><type><name>slock_t</name></type>           <name><name>lock</name><index>[<expr><name>MAX_SHARDING_NODE_GROUP</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* locks to protect used fields */</comment>
    <decl_stmt><decl><type><name>bool</name></type>            <name><name>used</name><index>[<expr><name>MAX_SHARDING_NODE_GROUP</name></expr>]</index></name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>GroupShardInfo</name> <modifier>*</modifier></type><name><name>members</name><index>[<expr><name>MAX_SHARDING_NODE_GROUP</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type><name>ShardNodeGroupInfo</name>;</typedef>

<comment type="block">/* As DN, only one group has shard info. */</comment>
<typedef>typedef <type><struct>struct 
<block>{
    <decl_stmt><decl><type><name>bool</name></type>           <name>inited</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>           <name>needLock</name></decl>;</decl_stmt>                      <comment type="block">/* whether we need lock */</comment>
    <decl_stmt><decl><type><name>slock_t</name></type>           <name>lock</name></decl>;</decl_stmt> <comment type="block">/* locks to protect used fields */</comment>
    <decl_stmt><decl><type><name>bool</name></type>            <name>used</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>GroupShardInfo</name> <modifier>*</modifier></type><name>members</name></decl>;</decl_stmt>
}</block></struct></type><name>ShardNodeGroupInfo_DN</name>;</typedef>

<comment type="block">/*For CN*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ShardNodeGroupInfo</name> <modifier>*</modifier></type><name>g_GroupShardingMgr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name>               <modifier>*</modifier></type><name>g_GroupHashTab</name>     <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*For DN*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ShardNodeGroupInfo_DN</name> <modifier>*</modifier></type><name>g_GroupShardingMgr_DN</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* used for datanodes */</comment>
<decl_stmt><decl><type><name>Bitmapset</name>                      <modifier>*</modifier></type><name>g_DatanodeShardgroupBitmap</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>int32</name></type> <name>nGroups</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>   <name><name>group</name><index>[<expr><name>MAX_SHARDING_NODE_GROUP</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name><name>optype</name><index>[<expr><name>MAX_SHARDING_NODE_GROUP</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type><name>ShardingGroupInfo</name>;</typedef>


<comment type="block">/* Working status for pg_stat_table_shard */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>int</name></type>          <name>currIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShardStat</name></type> <name><name>shardstat</name><index>[<expr><name>SHARD_MAP_GROUP_NUM</name></expr>]</index></name></decl>;</decl_stmt>    
}</block></struct></type> <name>ShardStat_State</name>;</typedef>
<comment type="block">/* used to record sharding group info */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ShardingGroupInfo</name></type> <name>g_UpdateShardingGroupInfo</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><block>{<expr><name>InvalidOid</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*        shard statistic management 
 *
 *  stat all shards' info including:
 *    ntuples_select: number of tuples scanned in each shard
 *    ntuples_insert: number of tuples inserted in each shard
 *    ntuples_update: number of tuples updated in each shard
 *    ntuples_delete: number of tuples deleted in each shard
 *    ntuples: number of tuples in each shard
 *    size: size of all tuples in each shard
 */</comment>

<typedef>typedef <type><struct>struct 
<block>{
    <decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>ntuples_select</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>ntuples_insert</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>ntuples_update</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>ntuples_delete</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>ntuples</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_atomic_uint64</name></type> <name>size</name></decl>;</decl_stmt>
}</block></struct></type> <name>ShardStatistic</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>ShardStatistic</name></type> <name>stat</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_crc32c</name></type>      <name>crc</name></decl>;</decl_stmt>
}</block></struct></type> <name>ShardRecord</name>;</typedef>

<decl_stmt><decl><type><name>ShardStatistic</name> <modifier>*</modifier></type><name>shardStatInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARD_STATISTIC_FILE_PATH</name></cpp:macro> <cpp:value>"pg_stat/shard.stat"</cpp:value></cpp:define>

<comment type="block">/* GUC used for shard statistic */</comment>
<decl_stmt><decl><type><name>bool</name></type>   <name>g_StatShardInfo</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>    <name>g_MaxSessionsPerPool</name> <init>= <expr><literal type="number">250</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>    <name>g_ShardInfoFlushInterval</name> <init>= <expr><literal type="number">60</literal></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>int</name></type>    <name>currIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShardStatistic</name> <modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>
}</block></struct></type> <name>ShmMgr_State</name>;</typedef>

<decl_stmt><decl><type><name>bool</name></type>  <name>show_all_shard_stat</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
<comment type="block">/* lock access info, use on datanode */</comment>
<typedef>typedef <type><struct>struct 
<block>{      
    <decl_stmt><decl><type><name>bool</name></type>    <name>needlock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>    <name>colddata</name></decl>;</decl_stmt>
}</block></struct></type><name>AccessControl</name>;</typedef>

<decl_stmt><decl><type><name>AccessControl</name>  <modifier>*</modifier></type><name>g_AccessCtl</name>    <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACCESS_CONTROL_FILE_NAME</name></cpp:macro>        <cpp:value>"cold_data_node.flag"</cpp:value></cpp:define>

<comment type="block">/* dual tag, used on coordinator */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_DUAL_WRITE_TABLE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct 
<block>{
    <decl_stmt><decl><type><name>Oid</name></type>        <name>relation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>      <name>attr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>      <name>timeoffset</name></decl>;</decl_stmt>
}</block></struct></type><name>DTag</name>;</typedef>
    
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>DTag</name></type>        <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>       <name><name>table</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>char</name></type>       <name><name>column</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>char</name></type>       <name><name>value</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt> 
}</block></struct></type><name>DualWriteRecord</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUAL_WRITE_HASH_SCANF_ELEMENT</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct 
<block>{    
    <decl_stmt><decl><type><name>HTAB</name>     <modifier>*</modifier></type><name>dwhash</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>slock_t</name></type>    <name>lock</name></decl>;</decl_stmt><comment type="block">/* lock to protect the below fields */</comment>
    <decl_stmt><decl><type><name>bool</name></type>    <name>needlock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>   <name>entrynum</name></decl>;</decl_stmt>
}</block></struct></type><name>DualWriteCtl</name>;</typedef>

<decl_stmt><decl><type><name>DualWriteCtl</name>   <modifier>*</modifier></type><name>g_DualWriteCtl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUAL_WRITE_FILE_NAME</name></cpp:macro>        <cpp:value>"dual_write_list.stat"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUAL_WRITE_BACKUP_FILE_NAME</name></cpp:macro> <cpp:value>"dual_write_list.backup"</cpp:value></cpp:define>

<decl_stmt><decl><type><name>bool</name></type> <name>g_EnableKeyValue</name>  <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>g_EnableDualWrite</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>g_TempKeyValueList</name>  <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>g_EnableColdHotVisible</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>Oid</name></type>      <name>table</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NameData</name></type> <name>value</name></decl>;</decl_stmt>        
    <decl_stmt><decl><type><name>Oid</name></type>      <name>hotGroup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>      <name>coldGroup</name></decl>;</decl_stmt>
}</block></struct></type><name>KeyValuePair</name>;</typedef>

<comment type="block">/* 2000-01-01 00:00:00 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>pg_tm</name></name></type> <name>g_keyvalue_base_time</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>,
                                             <expr><literal type="number">0</literal></expr>,
                                             <expr><literal type="number">0</literal></expr>,
                                             <expr><literal type="number">1</literal></expr>,
                                             <expr><literal type="number">1</literal></expr>,      <comment type="block">/* origin 0, not 1 */</comment>
                                             <expr><literal type="number">1990</literal></expr>,    
                                             <expr><literal type="number">1</literal></expr>,
                                             <expr><literal type="number">1</literal></expr>,
                                             <expr><literal type="number">0</literal></expr>,
                                             <expr><literal type="number">0</literal></expr>,
                                             <expr><name>NULL</name></expr>
                                            }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type>  <name>g_keyvalue_base_timestamp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* function declaration */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type>   <name>SyncShardMapList_CN</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>   <name>SyncShardMapList_DN</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>   <name>SyncShardMapList_Node_CN</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>   <name>SyncShardMapList_Node_DN</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>   <name>InsertShardMap_CN</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>map</name></decl></parameter>, <parameter><decl><type><name>Form_pgxc_shard_map</name></type> <name>record</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>   <name>InsertShardMap_DN</name><parameter_list>(<parameter><decl><type><name>Form_pgxc_shard_map</name></type> <name>record</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>   <name>ShardMapInitDone_CN</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>map</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lock</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>   <name>ShardMapInitDone_DN</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_lock</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>cmp_int32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>   <name>GroupShardingTabExist</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lock</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>group_index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type>  <name>AllocShardMap</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>extend</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>groupoid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type>   <name>ShardMapShmemSize_Node_CN</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type>   <name>ShardMapShmemSize_Node_DN</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name><modifier>*</modifier></type>   <name>decide_shardgroups_to_move</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>fromnode</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>shardgroup_num</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>   <name>RemoveShardMapEntry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>   <name>FreshGroupShardMap</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>   <name>BuildDatanodeVisibilityMap</name><parameter_list>(<parameter><decl><type><name>Form_pgxc_shard_map</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>self_oid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GetShardNodes_CN</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier><modifier>*</modifier></type> <name>nodes</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>num_nodes</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isextension</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>GetShardNodes_DN</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier><modifier>*</modifier></type> <name>nodes</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>num_nodes</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isextension</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>Datum</name></type>  <name>pg_stat_table_shard</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>Datum</name></type>  <name>pg_stat_all_shard</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RefreshShardStatistic</name><parameter_list>(<parameter><decl><type><name>ShardStat</name> <modifier>*</modifier></type><name>shardstat</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>pg_set_cold_access</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>pg_clear_cold_access</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>AddDualWriteInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attr</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>gap</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>column</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>long</name></type> <name>compute_keyvalue_hash</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*----------------------------------------------------------
 *
 *        Shard Map In Share Memory
 *
 -----------------------------------------------------------*/</comment>

<function><type><name>void</name></type> <name>InvalidateShmemShardMap</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>iscommit</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int32</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><name><name>g_UpdateShardingGroupInfo</name><operator>.</operator><name>nGroups</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name>iscommit</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* tell others use lock to access shard map */</comment>
                <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>needLock</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                
                <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>g_UpdateShardingGroupInfo</name><operator>.</operator><name>nGroups</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>ShardOpType_create</name> <operator>==</operator> <name><name>g_UpdateShardingGroupInfo</name><operator>.</operator><name>optype</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* refresh shard map of given group. */</comment>
                        <expr_stmt><expr><call><name>FreshGroupShardMap</name><argument_list>(<argument><expr><name><name>g_UpdateShardingGroupInfo</name><operator>.</operator><name>group</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>ShardOpType_drop</name> <operator>==</operator> <name><name>g_UpdateShardingGroupInfo</name><operator>.</operator><name>optype</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>RemoveShardMapEntry</name><argument_list>(<argument><expr><name><name>g_UpdateShardingGroupInfo</name><operator>.</operator><name>group</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>                    
                </block_content>}</block></for>
                <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* reset flag */</comment>
                <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>needLock</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* tell others use lock to access shard map */</comment>
                <expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>needLock</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>                
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>g_UpdateShardingGroupInfo</name><operator>.</operator><name>nGroups</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>ShardOpType_create</name> <operator>==</operator> <name><name>g_UpdateShardingGroupInfo</name><operator>.</operator><name>optype</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* force fresh shard map of DN. SyncShardMapList will take care of lock itself, no need to take lock here. */</comment>
                        <expr_stmt><expr><call><name>SyncShardMapList</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>ShardOpType_drop</name> <operator>==</operator> <name><name>g_UpdateShardingGroupInfo</name><operator>.</operator><name>optype</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>RemoveShardMapEntry</name><argument_list>(<argument><expr><name><name>g_UpdateShardingGroupInfo</name><operator>.</operator><name>group</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>                
                <comment type="block">/* reset flag */</comment>
                <expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>needLock</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        
            <expr_stmt><expr><name><name>g_UpdateShardingGroupInfo</name><operator>.</operator><name>nGroups</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>g_UpdateShardingGroupInfo</name><operator>.</operator><name>nGroups</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>RegisterInvalidShmemShardMap</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>g_UpdateShardingGroupInfo</name><operator>.</operator><name>nGroups</name></name> <operator>&lt;</operator> <name>MAX_SHARDING_NODE_GROUP</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>g_UpdateShardingGroupInfo</name><operator>.</operator><name>group</name><index>[<expr><name><name>g_UpdateShardingGroupInfo</name><operator>.</operator><name>nGroups</name></name></expr>]</index></name>  <operator>=</operator> <name>group</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_UpdateShardingGroupInfo</name><operator>.</operator><name>optype</name><index>[<expr><name><name>g_UpdateShardingGroupInfo</name><operator>.</operator><name>nGroups</name></name></expr>]</index></name> <operator>=</operator> <name>op</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_UpdateShardingGroupInfo</name><operator>.</operator><name>nGroups</name></name><operator>++</operator></expr>;</expr_stmt>        
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many groups created"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// TODO:</comment>
    <comment type="line">//hold_select_shard();</comment>
</block_content>}</block></function>

<comment type="block">/*
 * ShardMapShmem In DN will only has one GroupShardInfo info.
 * Since DN only store its own group shardmap info. 
 */</comment>
<function><type><name>void</name></type> <name>ShardMapShmemInit_CN</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GroupShardInfo</name> <modifier>*</modifier></type><name>groupshard</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HASHCTL</name></type>        <name>info</name></decl>;</decl_stmt>

    <comment type="block">/* init hash table */</comment>
    <expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name>   <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GroupLookupTag</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GroupLookupEnt</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>tag_hash</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>g_GroupHashTab</name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"Group Sharding info look up"</literal></expr></argument>,
                                  <argument><expr><name>MAX_SHARDING_NODE_GROUP</name></expr></argument>, 
                                  <argument><expr><name>MAX_SHARDING_NODE_GROUP</name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
                                  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_GroupHashTab</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid shmem status when creating sharding hash "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>g_GroupShardingMgr</name> <operator>=</operator> <operator>(</operator><name>ShardNodeGroupInfo</name> <operator>*</operator><operator>)</operator><call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Group shard mgr"</literal></expr></argument>,
                                                                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardNodeGroupInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                                                <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid shmem status when creating Group shard mgr "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>inited</name></name>   <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>needLock</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>groupshard</name> <operator>=</operator> <operator>(</operator><name>GroupShardInfo</name> <operator>*</operator><operator>)</operator><call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Group shard major"</literal></expr></argument>,
                                                        <argument><expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GroupShardInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>MAXALIGN64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardMapItemDef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>*</operator> <operator>(</operator><name>SHARD_MAP_GROUP_NUM</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
                                                        <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid shmem status when creating Group shard major "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* init first major group */</comment>
    <expr_stmt><expr><name><name>groupshard</name><operator>-&gt;</operator><name>group</name></name>                 <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>groupshard</name><operator>-&gt;</operator><name>shardMapStatus</name></name>      <operator>=</operator> <name>SHMEM_SHRADMAP_STATUS_UNINITED</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>groupshard</name><operator>-&gt;</operator><name>shmemNumShardGroups</name></name> <operator>=</operator> <name>SHARD_MAP_GROUP_NUM</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>groupshard</name><operator>-&gt;</operator><name>shmemNumShards</name></name>      <operator>=</operator> <name>SHARD_MAP_SHARD_NUM</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>groupshard</name><operator>-&gt;</operator><name>shmemNumShardNodes</name></name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>groupshard</name><operator>-&gt;</operator><name>shmemshardnodes</name></name></expr></argument>, <argument><expr><literal type="number">0X00</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>groupshard</name><operator>-&gt;</operator><name>shmemshardnodes</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>groupshard</name><operator>-&gt;</operator><name>shmemshardmap</name></name></expr></argument>, <argument><expr><literal type="number">0X00</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardMapItemDef</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>SHARD_MAP_GROUP_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>lock</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>used</name><index>[<expr><literal type="number">0</literal></expr>]</index></name>     <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><literal type="number">0</literal></expr>]</index></name>  <operator>=</operator> <name>groupshard</name></expr>;</expr_stmt>

    <comment type="block">/* init extension group */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FIRST_EXTENSION_GROUP</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>LAST_EXTENSION_GROUP</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"Extension group %d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>groupshard</name> <operator>=</operator> <operator>(</operator><name>GroupShardInfo</name> <operator>*</operator><operator>)</operator><call><name>ShmemInitStruct</name><argument_list>(<argument><expr><name>name</name></expr></argument>,
                                                        <argument><expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GroupShardInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>MAXALIGN64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardMapItemDef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>*</operator> <operator>(</operator><name>EXTENSION_SHARD_MAP_GROUP_NUM</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
                                                        <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid shmem status when creating %s "</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/* init first major group */</comment>
        <expr_stmt><expr><name><name>groupshard</name><operator>-&gt;</operator><name>group</name></name>            <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>groupshard</name><operator>-&gt;</operator><name>shardMapStatus</name></name> <operator>=</operator> <name>SHMEM_SHRADMAP_STATUS_UNINITED</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>groupshard</name><operator>-&gt;</operator><name>shmemNumShardGroups</name></name> <operator>=</operator> <name>EXTENSION_SHARD_MAP_GROUP_NUM</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>groupshard</name><operator>-&gt;</operator><name>shmemNumShards</name></name>      <operator>=</operator> <name>EXTENSION_SHARD_MAP_SHARD_NUM</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>groupshard</name><operator>-&gt;</operator><name>shmemNumShardNodes</name></name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>groupshard</name><operator>-&gt;</operator><name>shmemshardnodes</name></name></expr></argument>, <argument><expr><literal type="number">0X00</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>groupshard</name><operator>-&gt;</operator><name>shmemshardnodes</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>groupshard</name><operator>-&gt;</operator><name>shmemshardmap</name></name></expr></argument>, <argument><expr><literal type="number">0X00</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardMapItemDef</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>EXTENSION_SHARD_MAP_GROUP_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>lock</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>used</name><index>[<expr><name>i</name></expr>]</index></name>     <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name>  <operator>=</operator> <name>groupshard</name></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>ShardMapShmemInit_DN</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GroupShardInfo</name> <modifier>*</modifier></type><name>groupshard</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>g_GroupShardingMgr_DN</name> <operator>=</operator> <operator>(</operator><name>ShardNodeGroupInfo_DN</name> <operator>*</operator><operator>)</operator><call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"DN Group shard mgr"</literal></expr></argument>,
                                                                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardNodeGroupInfo_DN</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                                                <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid shmem status when creating Group shard mgr "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>inited</name></name>   <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>needLock</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>groupshard</name> <operator>=</operator> <operator>(</operator><name>GroupShardInfo</name> <operator>*</operator><operator>)</operator><call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Group shard major"</literal></expr></argument>,
                                                        <argument><expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GroupShardInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>MAXALIGN64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardMapItemDef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>*</operator> <operator>(</operator><name>SHARD_MAP_GROUP_NUM</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
                                                        <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid shmem status when creating Group shard major "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* init first major group */</comment>
    <expr_stmt><expr><name><name>groupshard</name><operator>-&gt;</operator><name>group</name></name>                 <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>groupshard</name><operator>-&gt;</operator><name>shardMapStatus</name></name>      <operator>=</operator> <name>SHMEM_SHRADMAP_STATUS_UNINITED</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>groupshard</name><operator>-&gt;</operator><name>shmemNumShardGroups</name></name> <operator>=</operator> <name>SHARD_MAP_GROUP_NUM</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>groupshard</name><operator>-&gt;</operator><name>shmemNumShards</name></name>      <operator>=</operator> <name>SHARD_MAP_SHARD_NUM</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>groupshard</name><operator>-&gt;</operator><name>shmemNumShardNodes</name></name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>groupshard</name><operator>-&gt;</operator><name>shmemshardnodes</name></name></expr></argument>, <argument><expr><literal type="number">0X00</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>groupshard</name><operator>-&gt;</operator><name>shmemshardnodes</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>groupshard</name><operator>-&gt;</operator><name>shmemshardmap</name></name></expr></argument>, <argument><expr><literal type="number">0X00</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardMapItemDef</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>SHARD_MAP_GROUP_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>used</name></name>     <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name></name>  <operator>=</operator> <name>groupshard</name></expr>;</expr_stmt>

    

    <comment type="block">/* DN need to construct g_DatanodeShardgroupBitmap */</comment>
    <expr_stmt><expr><name>g_DatanodeShardgroupBitmap</name> <operator>=</operator> <operator>(</operator><name>Bitmapset</name> <operator>*</operator><operator>)</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Data node bitmap"</literal></expr></argument>,
                                                         <argument><expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><name>SHARD_TABLE_BITMAP_SIZE</name></expr></argument>)</argument_list></call></expr></argument>,
                                                      <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>g_DatanodeShardgroupBitmap</name> <operator>=</operator> <call><name>bms_make</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>g_DatanodeShardgroupBitmap</name></expr></argument>, <argument><expr><name>SHARD_MAP_GROUP_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>    
    
</block_content>}</block></function>


<function><type><name>bool</name></type>   <name>MajorShardAlreadyExist</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>SyncShardMapList</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>used</name><index>[<expr><name>MAJOR_SHARD_NODE_GROUP</name></expr>]</index></name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>used</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return><comment type="block">/* should not reach here */</comment>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>SyncShardMapList</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>(<expr><name>isRestoreMode</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SyncShardMapList_CN</name><argument_list>(<argument><expr><name>force</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SyncShardMapList_DN</name><argument_list>(<argument><expr><name>force</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>SyncShardMapList_CN</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SyncShardMapList_CN should only be called in coordinator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name> <operator>&amp;&amp;</operator> <name><name>g_UpdateShardingGroupInfo</name><operator>.</operator><name>nGroups</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>inited</name></name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* tell others use lock to access shard map */</comment>
    <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>needLock</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

	<comment type="block">/* in case of race conditions */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name> <operator>&amp;&amp;</operator> <name><name>g_UpdateShardingGroupInfo</name><operator>.</operator><name>nGroups</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>inited</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>needLock</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
    
	<expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>inited</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SyncShardMapList_Node_CN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>inited</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/*reset flag*/</comment>
    <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>needLock</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>SyncShardMapList_DN</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsPostmasterEnvironment</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SyncShardMapList_DN should only be called in datanode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name> <operator>&amp;&amp;</operator> <name><name>g_UpdateShardingGroupInfo</name><operator>.</operator><name>nGroups</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>inited</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>used</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"SyncShardMapList_DN GroupShardingMgr is not inited yet."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* tell others use lock to access shard map */</comment>
    <expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>needLock</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* in case of race conditions */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name> <operator>&amp;&amp;</operator> <name><name>g_UpdateShardingGroupInfo</name><operator>.</operator><name>nGroups</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>inited</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>needLock</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>inited</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    
    <expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>inited</name></name> <operator>=</operator> <call><name>SyncShardMapList_Node_DN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/*reset flag*/</comment>
    <expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>needLock</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* read shard map from system table and fill in the share memory */</comment>
<comment type="block">/*
 * On datanode, if pgxc_shard_map tuple's primarycopy is exactly the datanode itself,
 * then this shard is visible, and should be a member of g_DatanodeShardgroupBitmap.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>SyncShardMapList_Node_CN</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type> <name>shard_mgr</name> <init>= <expr><name>INVALID_SHARDMAP_ID</name></expr></init></decl>;</decl_stmt>        
    <decl_stmt><decl><type><name>HeapTuple</name></type>  <name>oldtup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>shardrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pgxc_shard_map</name></type>  <name>pgxc_shard</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pgxc_shard_map</name></type>  <name>firsttup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>    <comment type="block">/* flag for invalid null shardmap. */</comment>
    <decl_stmt><decl><type><name>ScanKeyData</name></type>          <name>skey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type>           <name>sysscan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>              <name>rel</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>HeapScanDesc</name></type>          <name>scan</name></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>HeapTuple</name></type>             <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>                  <name>groupoid</name></decl>;</decl_stmt>
    
    <comment type="block">/* cross check to ensure one node can only be in one node group */</comment>    
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>PgxcGroupRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>        
        <expr_stmt><expr><name>groupoid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>is_group_sharding_inited</name><argument_list>(<argument><expr><name>groupoid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* If the group sharding has not been created. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GroupShardingTabExist</name><argument_list>(<argument><expr><name>groupoid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shard_mgr</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Now to create a new shard mapping mgr */</comment>
                <expr_stmt><expr><name>shard_mgr</name> <operator>=</operator> <call><name>AllocShardMap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>groupoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>INVALID_SHARDMAP_ID</name> <operator>==</operator> <name>shard_mgr</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many sharding group defined"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>            
            
            <comment type="block">/* build sharding table */</comment>
            <expr_stmt><expr><name>firsttup</name>  <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>shardrel</name>  <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>PgxcShardMapRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
                <argument><expr><name>Anum_pgxc_shard_map_nodegroup</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>groupoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><name>sysscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>shardrel</name></expr></argument>,
                                      <argument><expr><name>PgxcShardMapGroupIndexId</name></expr></argument>, 
                                      <argument><expr><name>true</name></expr></argument>,
                                      <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
            
            <while>while<condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>oldtup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sysscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if<condition>(<expr><name>NULL</name> <operator>==</operator> <name>firsttup</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>oldtup</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid status, group:%u has no sharding info"</literal></expr></argument>, <argument><expr><name>groupoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    
                    <expr_stmt><expr><name>firsttup</name> <operator>=</operator> <operator>(</operator><name>Form_pgxc_shard_map</name><operator>)</operator><call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
                </block_content>}</block></if></if_stmt>
                
                <expr_stmt><expr><name>pgxc_shard</name> <operator>=</operator> <operator>(</operator><name>Form_pgxc_shard_map</name><operator>)</operator><call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>InsertShardMap_CN</name><argument_list>(<argument><expr><name>shard_mgr</name></expr></argument>, <argument><expr><name>pgxc_shard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                
            </block_content>}</block></while>
            <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sysscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>shardrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
            <expr_stmt><expr><call><name>ShardMapInitDone_CN</name><argument_list>(<argument><expr><name>shard_mgr</name></expr></argument>, <argument><expr><name>groupoid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>SyncShardMapList_Node_DN</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>        
    <decl_stmt><decl><type><name>HeapTuple</name></type>  <name>oldtup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>shardrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pgxc_shard_map</name></type>  <name>pgxc_shard</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type>          <name>skey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type>           <name>sysscan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>                     <name>curr_groupoid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>                  <name>self_node_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SyncShardMapList_Node_DN should only be called in datanode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>self_node_oid</name> <operator>=</operator> <call><name>get_pgxc_nodeoid_extend</name><argument_list>(<argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name>PGXCMainClusterName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>self_node_oid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"SyncShardMapList_Node_DN failed to get nodeoid, node:%s"</literal></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>curr_groupoid</name> <operator>=</operator> <call><name>GetGroupOidByNode</name><argument_list>(<argument><expr><name>self_node_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>curr_groupoid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"SyncShardMapList_Node_DN failed to get groupoid, node:%s, nodeoid:%d"</literal></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name>self_node_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>			
	
	<if_stmt><if>if <condition>(<expr><call><name>is_group_sharding_inited</name><argument_list>(<argument><expr><name>curr_groupoid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>bms_clear</name><argument_list>(<argument><expr><name>g_DatanodeShardgroupBitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<comment type="block">/* 
		 * If sharding of the group has not been inited, or this sharding map is in use but 
		 * store overdue information, possibly caused by group syncing backend crashing right
		 * before the shmem sync.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>used</name></name> <operator>||</operator> <name>curr_groupoid</name> <operator>!=</operator> <name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>group</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* 
			 * Datanodes can only be in one node group, so we save the effort of
			 * removing entry and skip right into resetting the mgr.
			 */</comment>
			<expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shardMapStatus</name></name> <operator>=</operator> <name>SHMEM_SHRADMAP_STATUS_LOADING</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>group</name></name> <operator>=</operator> <name>curr_groupoid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
			
		<expr_stmt><expr><name>shardrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>PgxcShardMapRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
			<argument><expr><name>Anum_pgxc_shard_map_nodegroup</name></expr></argument>,
			<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
			<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>curr_groupoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>sysscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>shardrel</name></expr></argument>,
								  <argument><expr><name>PgxcShardMapGroupIndexId</name></expr></argument>, 
								  <argument><expr><name>true</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<while>while<condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>oldtup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sysscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>pgxc_shard</name> <operator>=</operator> <operator>(</operator><name>Form_pgxc_shard_map</name><operator>)</operator><call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>InsertShardMap_DN</name><argument_list>(<argument><expr><name>pgxc_shard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* 
			 * If node is DN AND pgxc_shard_map tuple's primary copy is itself,
			 * Add this shardid to bitmap.
			 */</comment>
			<expr_stmt><expr><call><name>BuildDatanodeVisibilityMap</name><argument_list>(<argument><expr><name>pgxc_shard</name></expr></argument>, <argument><expr><name>self_node_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sysscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>shardrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
		<expr_stmt><expr><call><name>ShardMapInitDone_DN</name><argument_list>(<argument><expr><name>curr_groupoid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>					
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"SyncShardMapList_Node_DN group %d is not inited."</literal></expr></argument>, <argument><expr><name>curr_groupoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>bool</name></type> <name>GroupShardingTabExist</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lock</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>group_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>           <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GroupLookupTag</name></type> <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GroupLookupEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>tag</name><operator>.</operator><name>group</name></name> <operator>=</operator>  <name>group</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"GroupShardingTabExist should only be called in coordinator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>lock</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>GroupLookupEnt</name><operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name>g_GroupHashTab</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <if_stmt><if>if <condition>(<expr><name>lock</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>found</name> <operator>&amp;&amp;</operator> <name>group_index</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>group_index</name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator><name><name>ent</name><operator>-&gt;</operator><name>shardIndex</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>InsertShardMap_CN</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>map</name></decl></parameter>, <parameter><decl><type><name>Form_pgxc_shard_map</name></type> <name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"InsertShardMap_CN should only be called in coordinator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>map</name> <operator>!=</operator> <name>INVALID_SHARDMAP_ID</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int32</name></type> <name>nodeindex</name></decl>;</decl_stmt>        
        <if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>shardgroupid</name></name> <operator>&lt;=</operator> <name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>map</name></expr>]</index></name><operator>-&gt;</operator><name>shmemNumShardGroups</name> <operator>&amp;&amp;</operator> <name><name>record</name><operator>-&gt;</operator><name>shardgroupid</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name></type> <name>node_type</name> <init>= <expr><call><name>get_pgxc_nodetype</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>primarycopy</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>nodeindex</name> <operator>=</operator> <call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>primarycopy</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>nodeindex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><literal type="string">"InsertShardMap_CN get node:%u for index failed"</literal></expr></argument>,
					<argument><expr><name><name>record</name><operator>-&gt;</operator><name>primarycopy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>map</name></expr>]</index></name><operator>-&gt;</operator><name><name>shmemshardmap</name><index>[<expr><name><name>record</name><operator>-&gt;</operator><name>shardgroupid</name></name></expr>]</index></name><operator>.</operator><name>primarycopy</name>  <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>primarycopy</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>map</name></expr>]</index></name><operator>-&gt;</operator><name><name>shmemshardmap</name><index>[<expr><name><name>record</name><operator>-&gt;</operator><name>shardgroupid</name></name></expr>]</index></name><operator>.</operator><name>shardgroupid</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>shardgroupid</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>map</name></expr>]</index></name><operator>-&gt;</operator><name><name>shmemshardmap</name><index>[<expr><name><name>record</name><operator>-&gt;</operator><name>shardgroupid</name></name></expr>]</index></name><operator>.</operator><name>nodeindex</name>       <operator>=</operator> <name>nodeindex</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><literal type="string">"invalid pgxc_shard_map record with shardgroupid: %d, map %d "</literal>
				<literal type="string">"and shmemNum: %d"</literal></expr></argument>,
				<argument><expr><name><name>record</name><operator>-&gt;</operator><name>shardgroupid</name></name></expr></argument>, <argument><expr><name>map</name></expr></argument>,
				<argument><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>map</name></expr>]</index></name><operator>-&gt;</operator><name>shmemNumShardGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>        
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>InsertShardMap_DN</name><parameter_list>(<parameter><decl><type><name>Form_pgxc_shard_map</name></type> <name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type> <name>nodeindex</name></decl>;</decl_stmt>        
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"InsertShardMap_DN should only be called in datanode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>shardgroupid</name></name> <operator>&lt;=</operator> <name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemNumShardGroups</name></name> <operator>&amp;&amp;</operator> <name><name>record</name><operator>-&gt;</operator><name>shardgroupid</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name>node_type</name> <init>= <expr><call><name>get_pgxc_nodetype</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>primarycopy</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>nodeindex</name> <operator>=</operator> <call><name>PGXCNodeGetNodeId</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>primarycopy</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nodeindex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><literal type="string">"InsertShardMap_DN get node:%u for index failed"</literal></expr></argument>,
				<argument><expr><name><name>record</name><operator>-&gt;</operator><name>primarycopy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemshardmap</name><index>[<expr><name><name>record</name><operator>-&gt;</operator><name>shardgroupid</name></name></expr>]</index></name><operator>.</operator><name>primarycopy</name>  <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>primarycopy</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemshardmap</name><index>[<expr><name><name>record</name><operator>-&gt;</operator><name>shardgroupid</name></name></expr>]</index></name><operator>.</operator><name>shardgroupid</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>shardgroupid</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemshardmap</name><index>[<expr><name><name>record</name><operator>-&gt;</operator><name>shardgroupid</name></name></expr>]</index></name><operator>.</operator><name>nodeindex</name>     <operator>=</operator> <name>nodeindex</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><literal type="string">"InsertShardMap_DN has invalid pgxc_shard_map record with shardgroupid: "</literal>
			<literal type="string">"%d and shmemNum: %d"</literal></expr></argument>,
			<argument><expr><name><name>record</name><operator>-&gt;</operator><name>shardgroupid</name></name></expr></argument>, <argument><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemNumShardGroups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ShardMapInitDone_CN</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>map</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_lock</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>           <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>           <name>dup</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>          <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>          <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>          <name>nodeindex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>          <name>nodeCnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>           <name>maxNodeIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShardMapItemDef</name></type> <name>item</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GroupLookupEnt</name> <modifier>*</modifier></type><name>ent</name>       <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GroupLookupTag</name></type> <name>tag</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>tag</name><operator>.</operator><name>group</name></name> <operator>=</operator>  <name>group</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ShardMapInitDone_CN should only be called in coordinator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>map</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>map</name> <operator>&gt;=</operator> <name>MAX_SHARDING_NODE_GROUP</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"group index %d is invalid."</literal></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>group</name> <operator>!=</operator> <name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>map</name></expr>]</index></name><operator>-&gt;</operator><name>group</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"groupoid in slot %d oid:%u is not group %d"</literal></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>map</name></expr>]</index></name><operator>-&gt;</operator><name>group</name></expr></argument>, <argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>need_lock</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Add group node to hashmap. */</comment>
    <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>map</name></expr>]</index></name><operator>-&gt;</operator><name>shardMapStatus</name> <operator>=</operator> <name>SHMEM_SHRADMAP_STATUS_USING</name></expr>;</expr_stmt>        
    <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>GroupLookupEnt</name><operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name>g_GroupHashTab</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ent</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Failed to add the hash table entry. */</comment>        
        <comment type="block">/* Release the shard map entry. */</comment>
        <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>lock</name><index>[<expr><name>map</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>used</name><index>[<expr><name>map</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>lock</name><index>[<expr><name>map</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>need_lock</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ShardMapInitDone_CN corrupted shared hash table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>shardIndex</name></name> <operator>=</operator> <name>map</name></expr>;</expr_stmt>    

    <block>{<block_content>
            
        <comment type="block">/* init shard group nodes of the shard map */</comment>
        <expr_stmt><expr><name>nodeCnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>map</name></expr>]</index></name><operator>-&gt;</operator><name>shmemshardnodes</name></expr></argument>, <argument><expr><literal type="number">0Xff</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>map</name></expr>]</index></name><operator>-&gt;</operator><name>shmemshardnodes</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>map</name></expr>]</index></name><operator>-&gt;</operator><name>shmemNumShardGroups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>dup</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>item</name> <operator>=</operator> <name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>map</name></expr>]</index></name><operator>-&gt;</operator><name><name>shmemshardmap</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nodeCnt</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>map</name></expr>]</index></name><operator>-&gt;</operator><name><name>shmemshardnodes</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name><name>item</name><operator>.</operator><name>nodeindex</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>dup</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            
            <comment type="block">/* all node index are in shmemNumShardNodes */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dup</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* store the max global node index. */</comment>
                <expr_stmt><expr><name>maxNodeIndex</name> <operator>=</operator> <ternary><condition><expr><name>maxNodeIndex</name> <operator>&lt;</operator> <name><name>item</name><operator>.</operator><name>nodeindex</name></name></expr> ?</condition><then> <expr><name><name>item</name><operator>.</operator><name>nodeindex</name></name></expr> </then><else>:  <expr><name>maxNodeIndex</name></expr></else></ternary></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>map</name></expr>]</index></name><operator>-&gt;</operator><name><name>shmemshardnodes</name><index>[<expr><name>nodeCnt</name></expr>]</index></name> <operator>=</operator> <name><name>item</name><operator>.</operator><name>nodeindex</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>nodeCnt</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>map</name></expr>]</index></name><operator>-&gt;</operator><name>shmemNumShardNodes</name> <operator>=</operator> <name>nodeCnt</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>map</name></expr>]</index></name><operator>-&gt;</operator><name>shardMaxGlblNdIdx</name>  <operator>=</operator> <name>maxNodeIndex</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt> <comment type="block">/* 1 is enough, just in case*/</comment>

        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>map</name></expr>]</index></name><operator>-&gt;</operator><name>shmemshardnodes</name></expr></argument>, 
                <argument><expr><name>nodeCnt</name></expr></argument>, 
                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>, 
                <argument><expr><name>cmp_int32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/*init all element to invalid big. */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>map</name></expr>]</index></name><operator>-&gt;</operator><name>shmemNodeMap</name></expr></argument>, <argument><expr><literal type="number">0XFF</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>TBASE_MAX_DATANODE_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nodeCnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>nodeindex</name> <operator>=</operator> <name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>map</name></expr>]</index></name><operator>-&gt;</operator><name><name>shmemshardnodes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <comment type="block">/* Store the group native index of the node into the node global map. */</comment>
            <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>map</name></expr>]</index></name><operator>-&gt;</operator><name><name>shmemNodeMap</name><index>[<expr><name>nodeindex</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block>
    <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>map</name></expr>]</index></name><operator>-&gt;</operator><name>shardMapStatus</name> <operator>=</operator> <name>SHMEM_SHRADMAP_STATUS_USING</name></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>need_lock</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>ShardMapInitDone_DN</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>           <name>dup</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		   <name>maxNodeIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>          <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>          <name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>          <name>nodeindex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>          <name>nodeCnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShardMapItemDef</name></type> <name>item</name></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>IS_PGXC_DATANODE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ShardMapInitDone_DN should only be called in datanode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	
	<if_stmt><if>if<condition>(<expr><name>group</name> <operator>!=</operator> <name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>group</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* PANIC here is to reset shmem, although a more elegant way should be provided by ShardMapShmem AM */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"groupoid %d in mgr is not group %d"</literal></expr></argument>, <argument><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>group</name></name></expr></argument>, <argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>need_lock</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* init shard group nodes of the shard map */</comment>
    <expr_stmt><expr><name>nodeCnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemshardnodes</name></name></expr></argument>, <argument><expr><literal type="number">0Xff</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemshardnodes</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemNumShardGroups</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>dup</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>item</name> <operator>=</operator> <name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemshardmap</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nodeCnt</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemshardnodes</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name><name>item</name><operator>.</operator><name>nodeindex</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>dup</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        
        <comment type="block">/* all node index are in shmemNumShardNodes */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dup</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemshardnodes</name><index>[<expr><name>nodeCnt</name></expr>]</index></name> <operator>=</operator> <name><name>item</name><operator>.</operator><name>nodeindex</name></name></expr>;</expr_stmt>
            <comment type="block">/* store the max global node index. */</comment>
            <expr_stmt><expr><name>maxNodeIndex</name> <operator>=</operator> <ternary><condition><expr><name>maxNodeIndex</name> <operator>&lt;</operator> <name><name>item</name><operator>.</operator><name>nodeindex</name></name></expr> ?</condition><then> <expr><name><name>item</name><operator>.</operator><name>nodeindex</name></name></expr> </then><else>:  <expr><name>maxNodeIndex</name></expr></else></ternary></expr>;</expr_stmt>
            <expr_stmt><expr><name>nodeCnt</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    
    <expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemNumShardNodes</name></name> <operator>=</operator> <name>nodeCnt</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shardMaxGlblNdIdx</name></name>  <operator>=</operator> <name>maxNodeIndex</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt> <comment type="block">/* 1 is enough, just in case*/</comment>
    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemshardnodes</name></name></expr></argument>, 
            <argument><expr><name>nodeCnt</name></expr></argument>, 
            <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>, 
            <argument><expr><name>cmp_int32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/*init all element to invalid big. */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemNodeMap</name></name></expr></argument>, <argument><expr><literal type="number">0XFF</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>TBASE_MAX_DATANODE_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nodeCnt</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>nodeindex</name> <operator>=</operator> <name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemshardnodes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <comment type="block">/* Store the group native index of the node into the node global map. */</comment>
        <expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemNodeMap</name><index>[<expr><name>nodeindex</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shardMapStatus</name></name> <operator>=</operator> <name>SHMEM_SHRADMAP_STATUS_USING</name></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>need_lock</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>cmp_int32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i2</name></decl>;</decl_stmt>
    
    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>p1</name> <operator>||</operator> <operator>!</operator><name>p2</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"cmp_int32:args cannot be null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>i1</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator><name>p1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>i2</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator><name>p2</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>i1</name> <operator>==</operator> <name>i2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if<condition>(<expr><name>i1</name> <operator>&lt;</operator> <name>i2</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* Alloc a shard map entry in shared memory. */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type> <name>AllocShardMap</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>extend</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>groupoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name>index</name> <init>= <expr><name>INVALID_SHARDMAP_ID</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"AllocShardMap should only be called in coordinator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>INVALID_SHARDMAP_ID</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>extend</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>lock</name><index>[<expr><name>MAJOR_SHARD_NODE_GROUP</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>used</name><index>[<expr><name>MAJOR_SHARD_NODE_GROUP</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>index</name> <operator>=</operator> <name>MAJOR_SHARD_NODE_GROUP</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>used</name><index>[<expr><name>MAJOR_SHARD_NODE_GROUP</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>MAJOR_SHARD_NODE_GROUP</name></expr>]</index></name><operator>-&gt;</operator><name>group</name> <operator>=</operator> <name>groupoid</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>    
        <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>lock</name><index>[<expr><name>MAJOR_SHARD_NODE_GROUP</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FIRST_EXTENSION_GROUP</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>LAST_EXTENSION_GROUP</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>lock</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>used</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>used</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>group</name> <operator>=</operator> <name>groupoid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>lock</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>lock</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>index</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Size</name></type> <name>ShardMapShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>||</operator> <name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><call><name>ShardMapShmemSize_Node_CN</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><call><name>ShardMapShmemSize_Node_DN</name><argument_list>()</argument_list></call></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type> <name>ShardMapShmemSize_Node_CN</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type> <name>size</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    
    <comment type="block">/* hash table size */</comment>
    <comment type="line">// hash_estimate_size(MAX_SHARDING_NODE_GROUP, sizeof(GroupLookupEnt));</comment>
    
    <comment type="block">/* management info */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardNodeGroupInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* struct self */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GroupShardInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>*</operator> <name>MAX_SHARDING_NODE_GROUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* non extension router info */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardMapItemDef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SHARD_MAP_SHARD_NUM</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* extension router info */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardMapItemDef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>EXTENSION_SHARD_MAP_GROUP_NUM</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>LAST_EXTENSION_GROUP</name> <operator>-</operator> <name>FIRST_EXTENSION_GROUP</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* shardmap bitmap info. Only used in datanode */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><name>SHARD_TABLE_BITMAP_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <comment type="block">/* hash table, here just double the element size, in case of memory corruption */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>MAX_SHARDING_NODE_GROUP</name> <operator>*</operator> <literal type="number">2</literal></expr></argument> , <argument><expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GroupLookupEnt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Size</name></type> <name>ShardMapShmemSize_Node_DN</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type> <name>size</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    
    <comment type="block">/* hash table size */</comment>
    <comment type="line">// hash_estimate_size(MAX_SHARDING_NODE_GROUP, sizeof(GroupLookupEnt));</comment>
    
    <comment type="block">/* management info */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardNodeGroupInfo_DN</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* struct self */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GroupShardInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* non extension router info */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardMapItemDef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SHARD_MAP_SHARD_NUM</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* shardmap bitmap info. Only used in datanode */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><name>SHARD_TABLE_BITMAP_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
List* ShardMapRouter(Oid group, Oid relation, Oid type, Datum dvalue, RelationAccessType accessType)
{    
    long         hashvalue                    = 0;

    <comment type="block">/* not the key value, use common map strategy */</comment>
    hashvalue = compute_hash(type, dvalue, LOCATOR_TYPE_SHARD);

    <comment type="block">/* no second distribute key, trade as hot data*/</comment>
    return list_make1_int(GetNodeIndexByHashValue(group, hashvalue));
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int32</name></type>  <name>GetNodeIndexByHashValue</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives    </comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>shardIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nodeIdx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>           <name>needLock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>           <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GroupLookupTag</name></type> <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GroupLookupEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShardMapItemDef</name> <modifier>*</modifier></type><name>shardgroup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>slot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>IS_PGXC_COORDINATOR</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"[GetNodeIndexByHashValue]group oid can not be invalid."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>needLock</name>  <operator>=</operator> <name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>needLock</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>tag</name><operator>.</operator><name>group</name></name> <operator>=</operator>  <name>group</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>GroupLookupEnt</name><operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name>g_GroupHashTab</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument> , <argument><expr><literal type="string">"no shard group of %u found"</literal></expr></argument>, <argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>shardIndex</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>shardIdx</name>     <operator>=</operator> <call><name>abs</name><argument_list>(<argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call> <operator>%</operator> <operator>(</operator><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>slot</name></expr>]</index></name><operator>-&gt;</operator><name>shmemNumShards</name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>shardgroup</name>   <operator>=</operator> <operator>&amp;</operator><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>slot</name></expr>]</index></name><operator>-&gt;</operator><name><name>shmemshardmap</name><index>[<expr><name>shardIdx</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nodeIdx</name>      <operator>=</operator> <name><name>shardgroup</name><operator>-&gt;</operator><name>nodeindex</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>needLock</name>  <operator>=</operator> <name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>needLock</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>shardIdx</name>     <operator>=</operator> <call><name>abs</name><argument_list>(<argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call> <operator>%</operator> <operator>(</operator><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemNumShards</name></name><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>shardgroup</name>   <operator>=</operator> <operator>&amp;</operator><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemshardmap</name><index>[<expr><name>shardIdx</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nodeIdx</name>      <operator>=</operator> <name><name>shardgroup</name><operator>-&gt;</operator><name>nodeindex</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>nodeIdx</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get node index map of group. */</comment>
<function><type><name>void</name></type>  <name>GetGroupNodeIndexMap</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>           <name>needLock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>           <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GroupLookupTag</name></type> <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GroupLookupEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>slot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"GetGroupNodeIndexMap group oid invalid."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>needLock</name>  <operator>=</operator> <name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>needLock</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>tag</name><operator>.</operator><name>group</name></name> <operator>=</operator>  <name>group</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>GroupLookupEnt</name><operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name>g_GroupHashTab</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument> , <argument><expr><literal type="string">"no shard group of %u found"</literal></expr></argument>, <argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>shardIndex</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>slot</name></expr>]</index></name><operator>-&gt;</operator><name>shmemNodeMap</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>slot</name></expr>]</index></name><operator>-&gt;</operator><name>shardMaxGlblNdIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>group</name> <operator>!=</operator> <name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>group</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"GetGroupNodeIndexMap group oid:%u is not the stored group:%u."</literal></expr></argument>, <argument><expr><name>group</name></expr></argument>, <argument><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>group</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name>needLock</name>  <operator>=</operator> <name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>needLock</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemNodeMap</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shardMaxGlblNdIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>



<function><type><name>void</name></type> <name>GetShardNodes</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier><modifier>*</modifier></type> <name>nodes</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>num_nodes</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isextension</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>GetShardNodes_CN</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>num_nodes</name></expr></argument>, <argument><expr><name>isextension</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>GetShardNodes_DN</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>num_nodes</name></expr></argument>, <argument><expr><name>isextension</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type> <name>GetShardNodes_CN</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier><modifier>*</modifier></type> <name>nodes</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>num_nodes</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isextension</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>           <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>           <name>needLock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>             <name>nNodes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GroupLookupTag</name></type> <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GroupLookupEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>tag</name><operator>.</operator><name>group</name></name> <operator>=</operator>  <name>group</name></expr>;</expr_stmt>        

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"GetShardNodes should only be called in coordinator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    

    <expr_stmt><expr><call><name>SyncShardMapList</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>needLock</name>  <operator>=</operator> <name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>needLock</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>GroupLookupEnt</name><operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name>g_GroupHashTab</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument> , <argument><expr><literal type="string">"corrupted catalog, no shard group of %u found"</literal></expr></argument>, <argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>nNodes</name> <operator>=</operator> <name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name><name>ent</name><operator>-&gt;</operator><name>shardIndex</name></name></expr>]</index></name><operator>-&gt;</operator><name>shmemNumShardNodes</name></expr>;</expr_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>num_nodes</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>num_nodes</name> <operator>=</operator> <name>nNodes</name></expr>;</expr_stmt></block_content></block></if></if_stmt>    
    
    <if_stmt><if>if<condition>(<expr><name>nodes</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>nodes</name> <operator>=</operator> <operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name>nNodes</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>*</operator><name>nodes</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name><name>ent</name><operator>-&gt;</operator><name>shardIndex</name></name></expr>]</index></name><operator>-&gt;</operator><name>shmemshardnodes</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>nNodes</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>isextension</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name><name>ent</name><operator>-&gt;</operator><name>shardIndex</name></name></expr>]</index></name><operator>-&gt;</operator><name>shmemNumShards</name> <operator>==</operator> <name>SHARD_MAP_SHARD_NUM</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>isextension</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if<condition>(<expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name><name>ent</name><operator>-&gt;</operator><name>shardIndex</name></name></expr>]</index></name><operator>-&gt;</operator><name>shmemNumShards</name> <operator>==</operator> <name>EXTENSION_SHARD_MAP_SHARD_NUM</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>isextension</name><operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"shards(%d) of group is invalid "</literal></expr></argument>, <argument><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name><name>ent</name><operator>-&gt;</operator><name>shardIndex</name></name></expr>]</index></name><operator>-&gt;</operator><name>shmemNumShards</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>GetShardNodes_DN</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier><modifier>*</modifier></type> <name>nodes</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>num_nodes</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isextension</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>           <name>needLock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>             <name>nNodes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    


    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"InsertShardMap_DN should only be called in datanode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    

    <expr_stmt><expr><call><name>SyncShardMapList</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>needLock</name>  <operator>=</operator> <name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>needLock</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>used</name></name> <operator>||</operator> <name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>group</name></name> <operator>!=</operator> <name>group</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument> , <argument><expr><literal type="string">"[GetShardNodes_DN]corrupted catalog, no shard group of %u found"</literal></expr></argument>, <argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>nNodes</name> <operator>=</operator> <name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemNumShardNodes</name></name></expr>;</expr_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>num_nodes</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>num_nodes</name> <operator>=</operator> <name>nNodes</name></expr>;</expr_stmt></block_content></block></if></if_stmt>    
    
    <if_stmt><if>if<condition>(<expr><name>nodes</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>nodes</name> <operator>=</operator> <operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><name>nNodes</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>*</operator><name>nodes</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><operator>(</operator><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemshardnodes</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>nNodes</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>isextension</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemNumShards</name></name> <operator>==</operator> <name>SHARD_MAP_SHARD_NUM</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>isextension</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if<condition>(<expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemNumShards</name></name> <operator>==</operator> <name>EXTENSION_SHARD_MAP_SHARD_NUM</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>*</operator><name>isextension</name><operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"shards(%d) of group is invalid "</literal></expr></argument>, <argument><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shmemNumShards</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>needLock</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>PrepareMoveData</name><parameter_list>(<parameter><decl><type><name>MoveDataStmt</name><modifier>*</modifier></type> <name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Oid</name></type>       <name>group_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name>        <modifier>*</modifier></type><name>dnoids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>ndns</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Value</name> <modifier>*</modifier></type><name>fromvalue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Value</name> <modifier>*</modifier></type><name>tovalue</name></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>fromvalue</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>from_node</name><operator>-&gt;</operator><name>val</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>tovalue</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>to_node</name><operator>-&gt;</operator><name>val</name></name><operator>)</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>fromvalue</name></expr></argument>,<argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>fromid</name></name> <operator>=</operator> <call><name>get_pgxc_nodeoid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>fromvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>fromid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"datanode[%s] is not exist"</literal></expr></argument>,<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>fromvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>fromvalue</name></expr></argument>,<argument><expr><name>Integer</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>fromid</name></name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><name>fromvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"PgxcMoveData error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>tovalue</name></expr></argument>,<argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>toid</name></name> <operator>=</operator> <call><name>get_pgxc_nodeoid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>tovalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>toid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"datanode[%s] is not exist"</literal></expr></argument>,<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>tovalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>tovalue</name></expr></argument>,<argument><expr><name>Integer</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>toid</name></name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><name>tovalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"PgxcMoveData error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    
    <expr_stmt><expr><name>group_oid</name> <operator>=</operator> <call><name>get_pgxc_groupoid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>group</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>group_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"group with name:%s not found"</literal></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>group</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* check if the group contains this two datanodes */</comment>
    <expr_stmt><expr><name>ndns</name> <operator>=</operator> <call><name>get_pgxc_groupmembers</name><argument_list>(<argument><expr><name>group_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dnoids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>ndns</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"group %s dose not contain datanode %s or datanode %s"</literal></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>group</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>fromvalue</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>tovalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>fromid</name></name> <operator>==</operator> <name><name>dnoids</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"group %s dose not contain datanode %s"</literal></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>group</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>fromvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ndns</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>toid</name></name><operator>==</operator> <name><name>dnoids</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"group %s dose not contain datanode %s"</literal></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>group</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>tovalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//GetShardNodes(group_oid, NULL, NULL, &amp;stmt-&gt;isextension);</comment>
    <expr_stmt><expr><call><name>SyncShardMapList</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>MOVE_DATA_STRATEGY_SHARD</name></expr>:</case>
            <block>{<block_content>
                <comment type="line">//elog(ERROR,"shard-based data moving is not supported in coordinator.");</comment>
                <decl_stmt><decl><type><name>ListCell</name>     <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>A_Const</name>     <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Value</name>        <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>shard</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>shard_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>num_shard</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>shards</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if<condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>shards</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"shard list must be assigned"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>arr_shard</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>num_shard</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <macro><name>foreach</name><argument_list>(<argument>lc</argument>,<argument>stmt-&gt;shards</argument>)</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>A_Const</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>val</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>con</name><operator>-&gt;</operator><name>val</name></name><operator>)</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name>shard</name> <operator>=</operator> <call><name>intVal</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if<condition>(<expr><name>shard</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"%d shard is invalid, shard to move must be greater than or equal with zero"</literal></expr></argument>, <argument><expr><name>shard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>arr_shard</name><index>[<expr><name>shard_idx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>shard</name></expr>;</expr_stmt>
                </block_content>}</block>

                <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>arr_shard</name></name></expr></argument>, 
                        <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>num_shard</name></name></expr></argument>, 
                        <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>, 
                        <argument><expr><name>cmp_int32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>split_point</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>MOVE_DATA_STRATEGY_NODE</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>arr_shard</name></name> <operator>=</operator> <call><name>decide_shardgroups_to_move</name><argument_list>(<argument><expr><name>group_oid</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>fromid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stmt</name><operator>-&gt;</operator><name>num_shard</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>split_point</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>arr_shard</name><index>[<expr><name><name>stmt</name><operator>-&gt;</operator><name>num_shard</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                <if_stmt><if>if<condition>(<expr><call><name>NodeHasShard</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>toid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"shard must be moved to a new node which is ready for data but no shard"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case  <expr><name>MOVE_DATA_STRATEGY_AT</name></expr>:</case>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Move Strategy MOVE_DATA_STRATEGY_AT is not supported in coordinator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid Move Stratety %d"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>dnoids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name><modifier>*</modifier></type> 
<name>decide_shardgroups_to_move</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>fromnode</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>shardgroup_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>shardmapRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pgxc_shard_map</name></type> <name>pgxc_shard</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type> <name>tuplist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>shardgroups</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tuplist</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>shardmapRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>PgxcShardMapRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><name>Anum_pgxc_shard_map_nodegroup</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                    <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
                    <argument><expr><name>Anum_pgxc_shard_map_primarycopy</name></expr></argument>,
                    <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                    <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>fromnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>shardmapRel</name></expr></argument>,
                                <argument><expr><name>PgxcShardMapGroupIndexId</name></expr></argument>,<argument><expr><name>true</name></expr></argument>,
                                <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><literal type="number">2</literal></expr></argument>,
                                <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while<condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>pgxc_shard</name> <operator>=</operator> <operator>(</operator><name>Form_pgxc_shard_map</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tuplist</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>tuplist</name></expr></argument>,<argument><expr><name><name>pgxc_shard</name><operator>-&gt;</operator><name>shardgroupid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if<condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>tuplist</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"datanode[%d] has no shardgroup to be moved"</literal></expr></argument>,<argument><expr><name>fromnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>tuplist</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"datanode[%d] has only one shardgroup, it cannot be splited"</literal></expr></argument>,<argument><expr><name>fromnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>shardgroup_num</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>tuplist</name></expr></argument>)</argument_list></call><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>shardgroups</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>shardgroup_num</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>shardgroup_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>shardgroupid</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>shardgroupid</name> <operator>=</operator> <call><name>list_nth_int</name><argument_list>(<argument><expr><name>tuplist</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>shardgroups</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>shardgroupid</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>shardmapRel</name></expr></argument>,<argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>tuplist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>shardgroups</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>PgxcMoveData_Node</name><parameter_list>(<parameter><decl><type><name>MoveDataStmt</name><modifier>*</modifier></type> <name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>    
    <decl_stmt><decl><type><name>Oid</name></type> <name>group_oid</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>group_oid</name> <operator>=</operator> <call><name>get_pgxc_groupoid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>group</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>group_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"group with name:%s not found"</literal></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>group</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>UpdateRelationShardMap</name><argument_list>(<argument><expr><name>group_oid</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>fromid</name></name></expr></argument>,<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>toid</name></name></expr></argument>,<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>num_shard</name></name></expr></argument>,<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>arr_shard</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Diff from CN, DN should truncate all non-shard tables in to-node when split one dn to two.
 */</comment>
<function><type><name>void</name></type> <name>PgxcMoveData_DN</name><parameter_list>(<parameter><decl><type><name>MoveDataStmt</name><modifier>*</modifier></type> <name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives    </comment>
    <comment type="line">//Value *fromvalue;</comment>
    <decl_stmt><decl><type><name>Value</name> <modifier>*</modifier></type><name>tovalue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>    <name>isFrom</name></decl>;</decl_stmt>

    <comment type="line">//fromvalue = &amp;(stmt-&gt;from_node-&gt;val);</comment>
    <expr_stmt><expr><name>tovalue</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>to_node</name><operator>-&gt;</operator><name>val</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>isFrom</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/* Only tonode and strategy equals to MOVE_DATA_STRATEGY_AT should truncate all non-shard tables */</comment>
    <if_stmt><if>if<condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>tovalue</name></expr></argument>,<argument><expr><name>String</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>tovalue</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>isFrom</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[PgxcMoveData_DN]Nove data tonode:%s not datanode itself:%s, "</literal>
                  <literal type="string">"no need to truncate all non-shard tables."</literal></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>tovalue</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></else></if_stmt>


    <switch>switch<condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>MOVE_DATA_STRATEGY_SHARD</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"[PgxcMoveData_DN]When using strategy MOVE_DATA_STRATEGY_SHARD, no need to"</literal>
                         <literal type="string">" truncate all non-shard tables."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
         <case>case <expr><name>MOVE_DATA_STRATEGY_AT</name></expr>:</case>
            <block>{<block_content>
                <if_stmt><if>if<condition>(<expr><operator>!</operator><name>isFrom</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type> <name>relnames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type> <name>nsnames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type> <name>relrvs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                    <comment type="block">/* get rel list except shard table */</comment>
                    <expr_stmt><expr><call><name>GetNotShardRelations</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nsnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    
                    <if_stmt><if>if<condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>relnames</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>relcell</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>nscell</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type> <name>rv</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>char</name>     <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name>nsname</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>TruncateStmt</name> <modifier>*</modifier></type> <name>stmt</name> <init>= <expr><operator>(</operator><name>TruncateStmt</name><operator>*</operator><operator>)</operator><call><name>makeNode</name><argument_list>(<argument><expr><name>TruncateStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name> <operator>=</operator> <name>DROP_CASCADE</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>restart_seqs</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                        <macro><name>forboth</name><argument_list>(<argument>relcell</argument>, <argument>relnames</argument>, <argument>nscell</argument>, <argument>nsnames</argument>)</argument_list></macro>
                        <block>{<block_content>
                            <expr_stmt><expr><name>relname</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>relcell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>nsname</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>nscell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name>nsname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"truncate relation %s because of moving data in new datanode"</literal></expr></argument>,<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>relrvs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>relrvs</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>

                        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relations</name></name> <operator>=</operator> <name>relrvs</name></expr>;</expr_stmt>        
                        <expr_stmt><expr><call><name>ExecuteTruncate</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>relnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>nsnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>relrvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>MOVE_DATA_STRATEGY_NODE</name></expr>:</case>
            <comment type="line">//elog(ERROR, "Move Strategy MOVE_DATA_STRATEGY_NODE is not supported in data node");</comment>
            <block>{<block_content>
                <if_stmt><if>if<condition>(<expr><operator>!</operator><name>isFrom</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type> <name>relnames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type> <name>nsnames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type> <name>relrvs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                    <comment type="block">/* get rel list except shard table */</comment>
                    <expr_stmt><expr><call><name>GetNotShardRelations</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nsnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    
                    <if_stmt><if>if<condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>relnames</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>relcell</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>nscell</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type> <name>rv</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>char</name>     <modifier>*</modifier></type><name>relname</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>char</name>    <modifier>*</modifier></type><name>nsname</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>TruncateStmt</name> <modifier>*</modifier></type> <name>stmt</name> <init>= <expr><operator>(</operator><name>TruncateStmt</name><operator>*</operator><operator>)</operator><call><name>makeNode</name><argument_list>(<argument><expr><name>TruncateStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>behavior</name></name> <operator>=</operator> <name>DROP_CASCADE</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>restart_seqs</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                        <macro><name>forboth</name><argument_list>(<argument>relcell</argument>, <argument>relnames</argument>, <argument>nscell</argument>, <argument>nsnames</argument>)</argument_list></macro>
                        <block>{<block_content>
                            <expr_stmt><expr><name>relname</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>relcell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>nsname</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>nscell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name>nsname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"truncate relation %s because of moving data in new datanode"</literal></expr></argument>,<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>relrvs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>relrvs</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block>

                        <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relations</name></name> <operator>=</operator> <name>relrvs</name></expr>;</expr_stmt>        
                        <expr_stmt><expr><call><name>ExecuteTruncate</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>relnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>nsnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>relrvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid Move Strategy %d"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>UpdateReplicaRelNodes</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>newnodeid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>oldtup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pgxc_class</name></type> <name>pgxc_class</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>old_oid_array</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name><name>new_oid_array</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name><name>new_num</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>new_oid_array</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>new_num</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>int</name></type> <name>old_num</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>newnodeid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"add invalid node oid to relation nodes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>PgxcClassRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>oldtup</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>,<argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <while>while<condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>pgxc_class</name> <operator>=</operator> <operator>(</operator><name>Form_pgxc_class</name><operator>)</operator><call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>pgxc_class</name><operator>-&gt;</operator><name>pclocatortype</name></name> <operator>!=</operator> <name>LOCATOR_TYPE_REPLICATED</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>oldtup</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>,<argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>old_num</name> <operator>=</operator> <call><name>get_pgxc_classnodes</name><argument_list>(<argument><expr><name><name>pgxc_class</name><operator>-&gt;</operator><name>pcrelid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old_oid_array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><call><name>oidarray_contian_oid</name><argument_list>(<argument><expr><name>old_oid_array</name></expr></argument>, <argument><expr><name>old_num</name></expr></argument>, <argument><expr><name>newnodeid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>oldtup</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>,<argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
        <expr_stmt><expr><name><name>new_oid_array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>add_node_list</name><argument_list>(<argument><expr><name>old_oid_array</name></expr></argument>, <argument><expr><name>old_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newnodeid</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>new_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* Sort once again the newly-created array of node Oids to maintain consistency */</comment>
        <expr_stmt><expr><name><name>new_oid_array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>SortRelationDistributionNodes</name><argument_list>(<argument><expr><name><name>new_oid_array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>new_num</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>new_oid_array</name> <operator>=</operator> <call><name>add_node_list</name><argument_list>(<argument><expr><name>old_oid_array</name></expr></argument>, <argument><expr><name>old_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newnodeid</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* Sort once again the newly-created array of node Oids to maintain consistency */</comment>
        <expr_stmt><expr><name>new_oid_array</name> <operator>=</operator> <call><name>SortRelationDistributionNodes</name><argument_list>(<argument><expr><name>new_oid_array</name></expr></argument>, <argument><expr><name>new_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Update pgxc_class entry */</comment>
        <expr_stmt><expr><call><name>PgxcClassAlter</name><argument_list>(<argument><expr><name><name>pgxc_class</name><operator>-&gt;</operator><name>pcrelid</name></name></expr></argument>,
                   <argument><expr><literal type="char">'\0'</literal></expr></argument>,
                   <argument><expr><literal type="number">0</literal></expr></argument>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
                   <argument><expr><literal type="number">0</literal></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                   <argument><expr><literal type="number">0</literal></expr></argument>,
                   <argument><expr><literal type="number">0</literal></expr></argument>,
                   <argument><expr><name>new_num</name></expr></argument>,
                   <argument><expr><name>new_oid_array</name></expr></argument>,
                   <argument><expr><name>PGXC_CLASS_ALTER_NODES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>oldtup</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>,<argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    
    <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * fresh shard map in share memory.
 * groupoid can be InvalidOid when this function called in datanode
*/</comment>
<function><type><name>void</name></type> <name>ForceRefreshShardMap</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>groupoid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>    
        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
        <block>{<block_content>
			<expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>inited</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SyncShardMapList_Node_CN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>inited</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
        <block>{<block_content>    
			<expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>inited</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>inited</name></name> <operator>=</operator> <call><name>SyncShardMapList_Node_DN</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
        <comment type="block">/*
         * Invalidate the relcache after refresh shard map in shmem,
         * because Relation-&gt;rd_locator_info changed.
         */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateRelcacheAll</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * upper level has taken care of the locks
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>RemoveShardMapEntry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>           <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>          <name>map</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GroupLookupTag</name></type> <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GroupLookupEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>tag</name><operator>.</operator><name>group</name></name> <operator>=</operator>  <name>group</name></expr>;</expr_stmt>    

    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>GroupLookupEnt</name><operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name>g_GroupHashTab</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ent</name></expr>)</condition>
        <block>{<block_content>            
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>map</name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>shardIndex</name></name></expr>;</expr_stmt>    

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hash_search</name><argument_list>(<argument><expr><name>g_GroupHashTab</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hash table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>lock</name><index>[<expr><name>map</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>used</name><index>[<expr><name>map</name></expr>]</index></name>          <operator>=</operator>  <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>map</name></expr>]</index></name><operator>-&gt;</operator><name>group</name> <operator>=</operator>  <name>InvalidOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g_GroupShardingMgr</name><operator>-&gt;</operator><name>lock</name><index>[<expr><name>map</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>group</name></name> <operator>==</operator> <name>group</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>used</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>group</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>bms_clear</name><argument_list>(<argument><expr><name>g_DatanodeShardgroupBitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* sync shard map list of a group */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>FreshGroupShardMap</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>  <name>newcreate</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>  <name>oldtup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>shardrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pgxc_shard_map</name></type>  <name>pgxc_shard</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name>shard_mgr</name> <init>= <expr><name>INVALID_SHARDMAP_ID</name></expr></init></decl>;</decl_stmt>        
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name>skey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>   <name>self_node_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* 
     * In datanode, one can only see the shardmap belongs to single group,
     * so it's ok to clear the g_DatanodeShardgroupBitmap here.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>bms_clear</name><argument_list>(<argument><expr><name>g_DatanodeShardgroupBitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>self_node_oid</name> <operator>=</operator> <call><name>get_pgxc_nodeoid_extend</name><argument_list>(<argument><expr><name>PGXCNodeName</name></expr></argument>, <argument><expr><name>PGXCMainClusterName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* build sharding table */</comment>
    <expr_stmt><expr><name>shardrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>PgxcShardMapRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
        <argument><expr><name>Anum_pgxc_shard_map_nodegroup</name></expr></argument>,
        <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
        <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>shardrel</name></expr></argument>,
                              <argument><expr><name>PgxcShardMapGroupIndexId</name></expr></argument>, 
                              <argument><expr><name>true</name></expr></argument>,
                              <argument><expr><name>SnapshotSelf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* no such tuples exist, so remove the existing map entry */</comment>
    <expr_stmt><expr><name>oldtup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>RemoveShardMapEntry</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <while>while<condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>pgxc_shard</name> <operator>=</operator> <operator>(</operator><name>Form_pgxc_shard_map</name><operator>)</operator><call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>INVALID_SHARDMAP_ID</name> <operator>==</operator> <name>shard_mgr</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* If the group sharding has not been created */</comment>
                <expr_stmt><expr><name>newcreate</name> <operator>=</operator> <operator>!</operator><call><name>GroupShardingTabExist</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shard_mgr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>newcreate</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* here, we try to get a new shard mapping mgr */</comment>
                    <expr_stmt><expr><name>shard_mgr</name> <operator>=</operator> <call><name>AllocShardMap</name><argument_list>(<argument><expr><name><name>pgxc_shard</name><operator>-&gt;</operator><name>extended</name></name></expr></argument>, <argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>INVALID_SHARDMAP_ID</name> <operator>==</operator> <name>shard_mgr</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many sharding group defined"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>InsertShardMap_CN</name><argument_list>(<argument><expr><name>shard_mgr</name></expr></argument>, <argument><expr><name>pgxc_shard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>shard_mgr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/*set to 0, shows oldtup is valid*/</comment>
            <expr_stmt><expr><call><name>InsertShardMap_DN</name><argument_list>(<argument><expr><name>pgxc_shard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        </block_content>}</block></if></if_stmt>
        
                            
        <expr_stmt><expr><name>oldtup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>BuildDatanodeVisibilityMap</name><argument_list>(<argument><expr><name>pgxc_shard</name></expr></argument>, <argument><expr><name>self_node_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>shardrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name>INVALID_SHARDMAP_ID</name> <operator>!=</operator> <name>shard_mgr</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ShardMapInitDone_CN</name><argument_list>(<argument><expr><name>shard_mgr</name></expr></argument>, <argument><expr><name>group</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name>INVALID_SHARDMAP_ID</name> <operator>!=</operator> <name>shard_mgr</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ShardMapInitDone_DN</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>    
</block_content>}</block></function>

<comment type="block">/*
 * It's caller's responsibilty to ensure g_DatanodeShardgroupBitmap is cleared.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>BuildDatanodeVisibilityMap</name><parameter_list>(<parameter><decl><type><name>Form_pgxc_shard_map</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>self_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><name><name>tuple</name><operator>-&gt;</operator><name>primarycopy</name></name> <operator>==</operator> <name>self_oid</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>g_DatanodeShardgroupBitmap</name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>shardgroupid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>tmp</name> <operator>!=</operator> <name>g_DatanodeShardgroupBitmap</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"build shard group bitmap failed. new bitmap maybe not in share memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"shardid %d belongs to datanode:%s"</literal></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>shardgroupid</name></name></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"shardid %d belongs to datanode whose oid:%d, NOT datanode itself:%s"</literal></expr></argument>, 
                 <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>shardgroupid</name></name></expr></argument>, <argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>primarycopy</name></name></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>Bitmapset</name> <modifier>*</modifier></type> 
<name>CopyShardGroups_DN</name><parameter_list>(<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type> <name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>SyncShardMapList</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <comment type="block">/* Only one group exists in  */</comment>
    <if_stmt><if>if<condition>(<expr><name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shardMapStatus</name></name> <operator>!=</operator> <name>SHMEM_SHRADMAP_STATUS_USING</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>g_DatanodeShardgroupBitmap</name></expr></argument>, <argument><expr><name>SHARD_TABLE_BITMAP_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
    <return>return <expr><name>dest</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>GetGroupSize</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
 * Get ShardId in datanode
 */</comment>
<function><type><name>int32</name></type> <name>EvaluateShardId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isNull</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>dvalue</name></decl></parameter>, 
                           <parameter><decl><type><name>Oid</name></type> <name>secType</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isSecNull</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>    
    <decl_stmt><decl><type><name>long</name></type>        <name>hashvalue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>table</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>sechashvalue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>     <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>        <name>typlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>typbyval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>typalign</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>typdelim</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>typioparam</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>typiofunc</name></decl>;</decl_stmt>
    
    <comment type="block">/* primary distribute key or secondary distribute key is NULL */</comment>
    <if_stmt><if>if <condition>(<expr><name>isNull</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NullShardId</name></expr>;</return>
    </block_content>}</block></if></if_stmt>    

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_CHILD</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>RELATION_GET_PARENT</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>table</name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,<argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_EnableKeyValue</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* not the key value, use common map strategy */</comment>
        <expr_stmt><expr><name>hashvalue</name> <operator>=</operator> <call><name>compute_hash</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>dvalue</name></expr></argument>, <argument><expr><name>LOCATOR_TYPE_SHARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <return>return  <expr><call><name>abs</name><argument_list>(<argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call> <operator>%</operator> <name>MAX_SHARDS</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* check whether the value is key value */</comment>
    <expr_stmt><expr><call><name>get_type_io_data</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>IOFunc_output</name></expr></argument>,
                     <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>,
                     <argument><expr><operator>&amp;</operator><name>typalign</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typdelim</name></expr></argument>,
                     <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typiofunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typiofunc</name></expr></argument>, <argument><expr><name>dvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsKeyValues</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>InTempKeyValueList</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>        
        <comment type="block">/* not the key value, use common map strategy */</comment>
        <expr_stmt><expr><name>hashvalue</name> <operator>=</operator> <call><name>compute_hash</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>dvalue</name></expr></argument>, <argument><expr><name>LOCATOR_TYPE_SHARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return  <expr><call><name>abs</name><argument_list>(<argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call> <operator>%</operator> <name>MAX_SHARDS</name></expr>;</return><empty_stmt>;</empty_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* secondary sharding map */</comment>
    <expr_stmt><expr><name>hashvalue</name> <operator>=</operator> <call><name>compute_hash</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>dvalue</name></expr></argument>, <argument><expr><name>LOCATOR_TYPE_SHARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>isSecNull</name></expr>)</condition>
    <block>{<block_content>        
        <expr_stmt><expr><name>sechashvalue</name> <operator>=</operator> <call><name>compute_keyvalue_hash</name><argument_list>(<argument><expr><name>secType</name></expr></argument>, <argument><expr><name>secValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>sechashvalue</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><call><name>abs</name><argument_list>(<argument><expr><name>hashvalue</name> <operator>+</operator> <name>sechashvalue</name></expr></argument>)</argument_list></call> <operator>%</operator> <name>MAX_SHARDS</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>TruncateShard</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>reloid</name></decl></parameter>, <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pausetime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExtentID</name></type> <name>eid</name> <init>= <expr><name>InvalidExtentID</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>    <name>tuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>        <name>toastoid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>toastoid</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>RelationHasExtent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"only sharded table can be truncated by shard."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * step 1: add shard barrier
     */</comment>
    <expr_stmt><expr><call><name>AddShardBarrier</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,<argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * step 2: do checkpoint, make sure dirty page of this shard flushed to storage. 
     */</comment>
    <expr_stmt><expr><call><name>RequestCheckpoint</name><argument_list>(<argument><expr><name>CHECKPOINT_IMMEDIATE</name> <operator>|</operator> <name>CHECKPOINT_FORCE</name> <operator>|</operator> <name>CHECKPOINT_WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * step 3: start remove index items and recycle storage space
     */</comment>
    <expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>eid</name> <operator>=</operator> <call><name>RelOidGetShardScanHead</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <while>while<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>deleted_tuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * delete this extent's tuples and their index entries
         */</comment>
        <expr_stmt><expr><call><name>truncate_extent_tuples</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, 
                                <argument><expr><name>eid</name> <operator>*</operator> <name>PAGES_PER_EXTENTS</name></expr></argument>, 
                                <argument><expr><operator>(</operator><name>eid</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>PAGES_PER_EXTENTS</name></expr></argument>, 
                                <argument><expr><name>false</name></expr></argument>, 
                                <argument><expr><operator>&amp;</operator><name>deleted_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tuples</name> <operator>+=</operator> <name>deleted_tuples</name></expr>;</expr_stmt>

        <comment type="block">/*
         * end transaction 
         */</comment>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * start another transaction
         */</comment>
        <expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>RelationOpenSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DISABLE_FALLOCATE</name></cpp:ifndef>
        <expr_stmt><expr><call><name>log_smgrdealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>SMGR_DEALLOC_FREESTORAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>smgrdealloc</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>eid</name> <operator>*</operator> <name>PAGES_PER_EXTENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]Dealloc:[rel:%d/%d/%d]"</literal>
                        <literal type="string">"[eid:%d, flags=FREESTORAGE]"</literal></expr></argument>,
                        <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                        <argument><expr><name>eid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>log_smgrdealloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><name>eid</name></expr></argument>, <argument><expr><name>SMGR_DEALLOC_REINIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>reinit_extent_pages</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>trace_extent</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[trace extent]Dealloc:[rel:%d/%d/%d]"</literal>
                        <literal type="string">"[eid:%d, flags=REINIT_PAGE]"</literal></expr></argument>,
                        <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>dbNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>spcNode</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name><operator>.</operator><name>relNode</name></name></expr></argument>,
                        <argument><expr><name>eid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>        
        <comment type="block">/* 
         * detach extent
         */</comment>
        <expr_stmt><expr><call><name>FreeExtent</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>eid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>eid</name> <operator>=</operator> <call><name>RelOidGetShardScanHead</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><call><name>ExtentIdIsValid</name><argument_list>(<argument><expr><name>eid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>pausetime</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>pausetime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * step 4: invalidate buf page.
     */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DISABLE_FALLOCATE</name></cpp:ifndef>
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <expr_stmt><expr><call><name>DropRelfileNodeShardBuffers</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * step 5: release barrier
     */</comment>
    <expr_stmt><expr><call><name>RemoveShardBarrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if<condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>toastoid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>TruncateShard</name><argument_list>(<argument><expr><name>toastoid</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>pausetime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <return>return <expr><name>tuples</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>StatShardRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>ShardStat</name> <modifier>*</modifier></type><name>shardstat</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>shardnumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>        <name>shardid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>     <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BufferAccessStrategy</name></type> <name>bstrategy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Snapshot</name></type>    <name>snapshot</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>LOCATOR_TYPE_SHARD</name> <operator>==</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name><operator>-&gt;</operator><name>locatorType</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>scan</name>  <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,<argument><expr><name>snapshot</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
            
            <comment type="block">/* set proper strategy */</comment>
            <expr_stmt><expr><name>bstrategy</name> <operator>=</operator> <call><name>GetAccessStrategy</name><argument_list>(<argument><expr><name>BAS_BULKREAD_STAT_SHARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_strategy</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>FreeAccessStrategy</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_strategy</name></name> <operator>=</operator> <name>bstrategy</name></expr>;</expr_stmt>            
            <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>,<argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
            <while>while<condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>shardid</name> <operator>=</operator> <call><name>HeapTupleGetShardId</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>shardid</name> <operator>&gt;=</operator> <name>shardnumber</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid shard id:%d of shard tuple in relation:%u"</literal></expr></argument>, <argument><expr><name>shardid</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name><name>shardstat</name><index>[<expr><name>shardid</name></expr>]</index></name><operator>.</operator><name>shard</name> <operator>=</operator> <name>shardid</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>shardstat</name><index>[<expr><name>shardid</name></expr>]</index></name><operator>.</operator><name>count</name> <operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>shardstat</name><index>[<expr><name>shardid</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>+=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <expr_stmt><expr><name>tuple</name>   <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>,<argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>

            <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>StatShardAllRelations</name><parameter_list>(<parameter><decl><type><name>ShardStat</name> <modifier>*</modifier></type><name>shardstat</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>shardnumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type>              <name>relid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>         <name>classRel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>         <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapScanDesc</name></type>     <name>relScan</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>classRel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>relScan</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * Here we only process main tables, skip other kind relations
     */</comment>
    <while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>relScan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classForm</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        
        <if_stmt><if>if <condition>(<expr><name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
            <name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>StatShardRelation</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>shardstat</name></expr></argument>, <argument><expr><name>shardnumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>relScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>pg_stat_table_shard</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>COLUMN_NUM</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

    <decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShardStat_State</name> <modifier>*</modifier></type><name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name>            <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>    <name>nsp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>    <name>rel</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>   <modifier>*</modifier></type><name>relInfoList</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>   <modifier>*</modifier></type><name>search_path</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>text</name>   <modifier>*</modifier></type><name>tbl</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
        
        <comment type="block">/* get table oid */</comment>
        <expr_stmt><expr><name>tbl</name> <operator>=</operator> <operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tbl</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no table specified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>relInfoList</name> <operator>=</operator> <call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>relInfoList</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="number">1</literal></expr>:</case>
            <block>{<block_content>
                <comment type="block">/* only relation */</comment>
                <expr_stmt><expr><name>search_path</name> <operator>=</operator> <call><name>fetch_search_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>search_path</argument>)</argument_list></macro>
                <block>{<block_content>
                    <expr_stmt><expr><name>nsp</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nsp</name></expr></argument>)</argument_list></call></expr>)</condition>            
                    <block>{<block_content>
                        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>relInfoList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block>                        
                <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>search_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
            <case>case <expr><literal type="number">2</literal></expr>:</case>
            <block>{<block_content>
                <comment type="block">/* schema.relation */</comment>                    
                <expr_stmt><expr><name>nsp</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>relInfoList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
                <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name>relInfoList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
            <case>case <expr><literal type="number">3</literal></expr>:</case>
            <block>{<block_content>
                <comment type="block">/* database.schema.relation */</comment>                            
                <expr_stmt><expr><name>nsp</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name>relInfoList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lthird</name><argument_list>(<argument><expr><name>relInfoList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

            <default>default:</default>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table %s not exist"</literal></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>

        </block_content>}</block></switch>
        <comment type="block">/* free name list */</comment>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>relInfoList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table %s not exist"</literal></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/* create a function context for cross-call persistence */</comment>
        <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Switch to memory context appropriate for multiple function calls
         */</comment>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* build tupdesc for result tuples */</comment>
        <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>COLUMN_NUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"shardid"</literal></expr></argument>,
                           <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"tuplecount"</literal></expr></argument>,
                           <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>status</name> <operator>=</operator> <operator>(</operator><name>ShardStat_State</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardStat_State</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>status</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    
        
        <expr_stmt><expr><call><name>StatShardRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>status</name><operator>-&gt;</operator><name>shardstat</name></name></expr></argument>, <argument><expr><name>SHARD_MAP_GROUP_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>status</name>  <operator>=</operator> <operator>(</operator><name>ShardStat_State</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>
    
    <while>while <condition>(<expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>&lt;</operator> <name>SHARD_MAP_SHARD_NUM</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>
        
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>status</name><operator>-&gt;</operator><name>shardstat</name><index>[<expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name><operator>.</operator><name>count</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/*
         * Form tuple with appropriate data.
         */</comment>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>,  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>status</name><operator>-&gt;</operator><name>shardstat</name><index>[<expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name><operator>.</operator><name>shard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>status</name><operator>-&gt;</operator><name>shardstat</name><index>[<expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name><operator>.</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>Datum</name></type>
<name>pg_stat_all_shard</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>COLUMN_NUM</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

    <decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShardStat_State</name> <modifier>*</modifier></type><name>status</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>        
        <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
        

        <comment type="block">/* create a function context for cross-call persistence */</comment>
        <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Switch to memory context appropriate for multiple function calls
         */</comment>
        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* build tupdesc for result tuples */</comment>
        <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>COLUMN_NUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"shardid"</literal></expr></argument>,
                           <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"tuplecount"</literal></expr></argument>,
                           <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>status</name> <operator>=</operator> <operator>(</operator><name>ShardStat_State</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardStat_State</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>status</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    
        
        <expr_stmt><expr><call><name>StatShardAllRelations</name><argument_list>(<argument><expr><name><name>status</name><operator>-&gt;</operator><name>shardstat</name></name></expr></argument>, <argument><expr><name>SHARD_MAP_GROUP_NUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

        <expr_stmt><expr><call><name>RefreshShardStatistic</name><argument_list>(<argument><expr><name><name>status</name><operator>-&gt;</operator><name>shardstat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>status</name>  <operator>=</operator> <operator>(</operator><name>ShardStat_State</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>
    
    <while>while <condition>(<expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>&lt;</operator> <name>SHARD_MAP_SHARD_NUM</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>COLUMN_NUM</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>
        
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>status</name><operator>-&gt;</operator><name>shardstat</name><index>[<expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name><operator>.</operator><name>count</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/*
         * Form tuple with appropriate data.
         */</comment>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>,  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>status</name><operator>-&gt;</operator><name>shardstat</name><index>[<expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name><operator>.</operator><name>shard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>status</name><operator>-&gt;</operator><name>shardstat</name><index>[<expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name><operator>.</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUAL_WRITE_FMT</name></cpp:macro> <cpp:value>"%u,%d,%d,%s,%s,%s\n"</cpp:value></cpp:define>

<function><type><name>Datum</name></type>
<name>pg_begin_table_dual_write</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int16</name></type>        <name>typlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>gap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>partitionStrategy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>typbyval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>bexist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>typalign</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>typdelim</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>typioparam</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>typiofunc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>dvalue</name></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>Oid</name></type>    <name>nsp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>    <name>rel</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>    <name>type</name></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>AttrNumber</name></type> <name>attribute</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>List</name>   <modifier>*</modifier></type><name>relInfoList</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>   <modifier>*</modifier></type><name>search_path</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name>         <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>   <modifier>*</modifier></type><name>tbl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>   <modifier>*</modifier></type><name>column</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>columnstr</name></decl>;</decl_stmt>     
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>valuestr</name></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>Relation</name></type>                 <name>relation</name>      <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_partition_interval</name></type> <name>routerinfo</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>FILE</name>                     <modifier>*</modifier></type><name>fp</name>          <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>char</name></type>             <name><name>returnstr</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[table_dual_write]can only called on coordinator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* get table oid */</comment>
    <expr_stmt><expr><name>tbl</name> <operator>=</operator> <operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tbl</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[table_dual_write]no table specified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>relInfoList</name> <operator>=</operator> <call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>relInfoList</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="number">1</literal></expr>:</case>
        <block>{<block_content>
            <comment type="block">/* only relation */</comment>
            <expr_stmt><expr><name>search_path</name> <operator>=</operator> <call><name>fetch_search_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>search_path</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>nsp</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nsp</name></expr></argument>)</argument_list></call></expr>)</condition>            
                <block>{<block_content>
                    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>relInfoList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>                        
            <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>search_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><literal type="number">2</literal></expr>:</case>
        <block>{<block_content>
            <comment type="block">/* schema.relation */</comment>                    
            <expr_stmt><expr><name>nsp</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>relInfoList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
            <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name>relInfoList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><literal type="number">3</literal></expr>:</case>
        <block>{<block_content>
            <comment type="block">/* database.schema.relation */</comment>    
            <expr_stmt><expr><name>nsp</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name>relInfoList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lthird</name><argument_list>(<argument><expr><name>relInfoList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>

        <default>default:</default>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[table_dual_write]table '%s' not exist"</literal></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

    </block_content>}</block></switch>

    <comment type="block">/* free name list */</comment>    
    <expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>relInfoList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[table_dual_write]table '%s' not exist"</literal></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* handle column */</comment>
    <expr_stmt><expr><name>column</name> <operator>=</operator> <operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>column</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[table_dual_write]we need column info"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>columnstr</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>attribute</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>columnstr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>InvalidAttrNumber</name> <operator>==</operator> <name>attribute</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                  <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[table_dual_write]no such column:%s"</literal></expr></argument>, <argument><expr><name>columnstr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
        
    <expr_stmt><expr><name>relation</name>     <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>routerinfo</name>     <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_partitions_info</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>routerinfo</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partpartkey</name></name> <operator>!=</operator> <name>attribute</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                  <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[table_dual_write]dual write attribute must be the partitioned key"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
              <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[table_dual_write]only partitioned table can set dual write"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name>partitionStrategy</name> <operator>=</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_type</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>partitionStrategy</name> <operator>==</operator> <name>IntervalType_Month</name> <operator>&amp;&amp;</operator>
        <name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_int</name></name> <operator>==</operator> <literal type="number">12</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>partitionStrategy</name> <operator>=</operator> <name>IntervalType_Year</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* handle value info */</comment>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[table_dual_write]no table specified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>valuestr</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>type</name>     <operator>=</operator> <call><name>get_atttype</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>get_type_io_data</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>IOFunc_input</name></expr></argument>,
                     <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>,
                     <argument><expr><operator>&amp;</operator><name>typalign</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typdelim</name></expr></argument>,
                     <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typiofunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dvalue</name> <operator>=</operator> <call><name>OidInputFunctionCall</name><argument_list>(<argument><expr><name>typiofunc</name></expr></argument>, <argument><expr><name>valuestr</name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>gap</name> <operator>=</operator> <call><name>get_timestamptz_gap</name><argument_list>(<argument><expr><name>dvalue</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* here, parameter check has done, we have record data onto disk now */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>DualWriteLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>needlock</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> <comment type="block">/* tell others to use lock */</comment>
    
    <comment type="block">/* record dual write info into disk */</comment>    
    <expr_stmt><expr><name>bexist</name> <operator>=</operator> <call><name>AddDualWriteInfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attribute</name></expr></argument>, <argument><expr><name>gap</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>columnstr</name></expr></argument>, <argument><expr><name>valuestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    <if_stmt><if>if <condition>(<expr><name>bexist</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* already exist, no need to flush file */</comment>
        <expr_stmt><expr><name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>needlock</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DualWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>returnstr</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"success"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>returnstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>returnstr</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>,<argument><expr><name>DUAL_WRITE_FMT</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attribute</name></expr></argument>, <argument><expr><name>gap</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>columnstr</name></expr></argument>, <argument><expr><name>valuestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* sync info into file */</comment>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>stat</name><argument_list>(<argument><expr><name>DUAL_WRITE_FILE_NAME</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* use major file */</comment>
        <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>DUAL_WRITE_FILE_NAME</name></expr></argument>, <argument><expr><literal type="string">"a+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[table_dual_write]could not open file \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name>DUAL_WRITE_FILE_NAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>returnstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[table_dual_write]could not write file \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name>DUAL_WRITE_FILE_NAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>    
    <if type="elseif">else if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>stat</name><argument_list>(<argument><expr><name>DUAL_WRITE_BACKUP_FILE_NAME</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* use backup file */</comment>
        <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>DUAL_WRITE_BACKUP_FILE_NAME</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[table_dual_write]could not open file \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name>DUAL_WRITE_BACKUP_FILE_NAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>returnstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[table_dual_write]could not write file \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name>DUAL_WRITE_BACKUP_FILE_NAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* rename backup file to current file */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>DUAL_WRITE_BACKUP_FILE_NAME</name></expr></argument>, <argument><expr><name>DUAL_WRITE_FILE_NAME</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[table_dual_write]could not rename file \"%s\" to \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name>DUAL_WRITE_BACKUP_FILE_NAME</name></expr></argument>, <argument><expr><name>DUAL_WRITE_FILE_NAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* use major file */</comment>
        <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>DUAL_WRITE_FILE_NAME</name></expr></argument>, <argument><expr><literal type="string">"w+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[table_dual_write]could not open file \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name>DUAL_WRITE_FILE_NAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>returnstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[table_dual_write]could not write file \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name>DUAL_WRITE_FILE_NAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>    
    <expr_stmt><expr><name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>needlock</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt><comment type="block">/* tell others to release lock */</comment>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DualWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* print dual write log */</comment>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[table_dual_write]set begin dual write:%s"</literal></expr></argument>, <argument><expr><name>returnstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>returnstr</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"success"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>returnstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
}</block></struct></type><name>DualWriteStatInfo</name>;</typedef>

<comment type="block">/*
 * check valid dual info
 */</comment>
<function><type><specifier>static</specifier> 
<name>bool</name></type> <name>ValidDualWriteInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>  <name>removed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DualWriteRecord</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>         <name>rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>dwhash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <while>while <condition>(<expr><operator>(</operator><operator>(</operator><name>ent</name> <operator>=</operator> <operator>(</operator><name>DualWriteRecord</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>rel</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>ent</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>dwhash</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>ent</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>entrynum</name></name><operator>--</operator></expr>;</expr_stmt>    
            <expr_stmt><expr><name>removed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>removed</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>DumpDualWriteInfo</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>needlock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DualWriteRecord</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>needlock</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>DualWriteLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>dwhash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>ent</name> <operator>=</operator> <operator>(</operator><name>DualWriteRecord</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>DUAL_WRITE_FMT</name></expr></argument>, <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>relation</name></name></expr></argument>, <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>attr</name></name></expr></argument>, <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>timeoffset</name></name></expr></argument>, <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>table</name></name></expr></argument>, <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>column</name></name></expr></argument>, <argument><expr><name><name>ent</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    
    <if_stmt><if>if <condition>(<expr><name>needlock</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DualWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add dual write info
 */</comment>
<function><type><specifier>static</specifier> 
<name>bool</name></type> <name>RemoveDualWriteInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attr</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type> <name>gap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DTag</name></type>  <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>partitionStrategy</name>        <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>                  <name>rel</name>            <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_partition_interval</name></type> <name>routerinfo</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
    
    <comment type="block">/* get partition stragegy first */</comment>
    <expr_stmt><expr><name>rel</name>          <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>routerinfo</name>   <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_partitions_info</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>routerinfo</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>attr</name> <operator>==</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partpartkey</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>partitionStrategy</name> <operator>=</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_type</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>partitionStrategy</name> <operator>==</operator> <name>IntervalType_Month</name> <operator>&amp;&amp;</operator>
                <name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_int</name></name> <operator>==</operator> <literal type="number">12</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>partitionStrategy</name> <operator>=</operator> <name>IntervalType_Year</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>gap</name>             <operator>=</operator> <call><name>get_timestamptz_gap</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tag</name><operator>.</operator><name>relation</name></name>     <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tag</name><operator>.</operator><name>attr</name></name>         <operator>=</operator> <name>attr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tag</name><operator>.</operator><name>timeoffset</name></name>  <operator>=</operator> <name>gap</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>dwhash</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>     
    <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>entrynum</name></name><operator>--</operator></expr>;</expr_stmt>    
        <if_stmt><if>if <condition>(<expr><name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>entrynum</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>entrynum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_stat_dual_write</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ATTR_NUM</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>FuncCallContext</name>     <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DualWriteStatInfo</name>    <modifier>*</modifier></type><name>qInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DualWriteRecord</name>     <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can only called on coordinator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>        
        <decl_stmt><decl><type><name>bool</name></type>          <name>bremove</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleDesc</name></type>      <name>tupdesc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>FILE</name>          <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>DualWriteLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bremove</name> <operator>=</operator> <call><name>ValidDualWriteInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DualWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>bremove</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* remove dual write info from disk */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>DUAL_WRITE_FILE_NAME</name></expr></argument>, <argument><expr><name>DUAL_WRITE_BACKUP_FILE_NAME</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rename file \"%s\" to \"%s\": %m"</literal></expr></argument>,
                                 <argument><expr><name>DUAL_WRITE_FILE_NAME</name></expr></argument>, <argument><expr><name>DUAL_WRITE_BACKUP_FILE_NAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <comment type="block">/* no backup file either, create new file */</comment>
            <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>DUAL_WRITE_FILE_NAME</name></expr></argument>, <argument><expr><literal type="string">"w+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>,
                                <argument><expr><name>DUAL_WRITE_FILE_NAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>DumpDualWriteInfo</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write file \"%s\": %m"</literal></expr></argument>,
                                <argument><expr><name>DUAL_WRITE_FILE_NAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* remove backup file */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>DUAL_WRITE_BACKUP_FILE_NAME</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not unlink file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>DUAL_WRITE_BACKUP_FILE_NAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        
        
        <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>ATTR_NUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"relation"</literal></expr></argument>,
                           <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"attribute"</literal></expr></argument>,
                           <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>,
                           <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DualWriteStatInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>qInfo</name> <operator>=</operator> <operator>(</operator><name>DualWriteStatInfo</name><operator>*</operator><operator>)</operator><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>DualWriteLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>qInfo</name><operator>-&gt;</operator><name>status</name></name></expr></argument>, <argument><expr><name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>dwhash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>


    <comment type="block">/* stuff done on every call of the function */</comment>
    <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>qInfo</name> <operator>=</operator> <operator>(</operator><name>DualWriteStatInfo</name><operator>*</operator><operator>)</operator><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt> 
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>ent</name> <operator>=</operator> <operator>(</operator><name>DualWriteRecord</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>qInfo</name><operator>-&gt;</operator><name>status</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* for each row */</comment>
        <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>ATTR_NUM</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>ATTR_NUM</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>        

        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>ent</name><operator>-&gt;</operator><name>table</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>ent</name><operator>-&gt;</operator><name>column</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>ent</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* nothing left */</comment>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DualWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_stop_table_dual_write</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int16</name></type>        <name>typlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>typbyval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>bexist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>typalign</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>typdelim</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>typioparam</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>typiofunc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>dvalue</name></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>Oid</name></type>    <name>nsp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>    <name>rel</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>AttrNumber</name></type> <name>attribute</name></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>List</name>   <modifier>*</modifier></type><name>relInfoList</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>   <modifier>*</modifier></type><name>search_path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>   <modifier>*</modifier></type><name>tbl</name>    <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>   <modifier>*</modifier></type><name>column</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name>   <modifier>*</modifier></type><name>value</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>table</name>      <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>columnstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>valuestr</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>Relation</name></type>                 <name>relation</name>      <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_partition_interval</name></type> <name>routerinfo</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>fp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>char</name></type>    <name><name>returnstr</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[table_dual_write]can only called on coordinator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* get table oid */</comment>
    <expr_stmt><expr><name>tbl</name> <operator>=</operator> <operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>tbl</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[table_dual_write]no table specified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>tbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>relInfoList</name> <operator>=</operator> <call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>relInfoList</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="number">1</literal></expr>:</case>
        <block>{<block_content>
            <comment type="block">/* only relation */</comment>
            <expr_stmt><expr><name>search_path</name> <operator>=</operator> <call><name>fetch_search_path</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>search_path</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>nsp</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nsp</name></expr></argument>)</argument_list></call></expr>)</condition>            
                <block>{<block_content>
                    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>relInfoList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>                        
            <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>search_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><literal type="number">2</literal></expr>:</case>
        <block>{<block_content>
            <comment type="block">/* schema.relation */</comment>                    
            <expr_stmt><expr><name>nsp</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>relInfoList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
            <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name>relInfoList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><literal type="number">3</literal></expr>:</case>
        <block>{<block_content>
            <comment type="block">/* database.schema.relation */</comment>
            <expr_stmt><expr><name>nsp</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name>relInfoList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lthird</name><argument_list>(<argument><expr><name>relInfoList</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>

        <default>default:</default>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[table_dual_write]table '%s' not exist"</literal></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

    </block_content>}</block></switch>
    <comment type="block">/* free name list */</comment>    
    <expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>relInfoList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[table_dual_write]table '%s' not exist"</literal></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>    
    
    <comment type="block">/* handle column */</comment>
    <expr_stmt><expr><name>column</name> <operator>=</operator> <operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>column</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[table_dual_write]we need column info"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>columnstr</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>attribute</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>columnstr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>InvalidAttrNumber</name> <operator>==</operator> <name>attribute</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                  <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[table_dual_write]no such column:%s"</literal></expr></argument>, <argument><expr><name>columnstr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
        
    <expr_stmt><expr><name>relation</name>     <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>routerinfo</name>     <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_partitions_info</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>routerinfo</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partpartkey</name></name> <operator>!=</operator> <name>attribute</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                  <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[table_dual_write]dual write attribute must be the partitioned key"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
              <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[table_dual_write]only partitioned table can set dual write"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* handle value info */</comment>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>text</name><operator>*</operator><operator>)</operator><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"[table_dual_write]no table specified"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>valuestr</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>get_atttype</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>get_type_io_data</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>IOFunc_input</name></expr></argument>,
                     <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>,
                     <argument><expr><operator>&amp;</operator><name>typalign</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typdelim</name></expr></argument>,
                     <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typiofunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dvalue</name> <operator>=</operator> <call><name>OidInputFunctionCall</name><argument_list>(<argument><expr><name>typiofunc</name></expr></argument>, <argument><expr><name>valuestr</name></expr></argument>, <argument><expr><name>typioparam</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* remove dual write info from share memory */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>DualWriteLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bexist</name>    <operator>=</operator> <call><name>RemoveDualWriteInfo</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attribute</name></expr></argument>, <argument><expr><name>dvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>bexist</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* no such element, return now */</comment>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DualWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>returnstr</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"success"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>returnstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* remove dual write info from disk */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>DUAL_WRITE_FILE_NAME</name></expr></argument>, <argument><expr><name>DUAL_WRITE_BACKUP_FILE_NAME</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[table_dual_write]could not rename file \"%s\" to \"%s\": %m"</literal></expr></argument>,
                         <argument><expr><name>DUAL_WRITE_FILE_NAME</name></expr></argument>, <argument><expr><name>DUAL_WRITE_BACKUP_FILE_NAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* no backup file either, create new file */</comment>
    <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>DUAL_WRITE_FILE_NAME</name></expr></argument>, <argument><expr><literal type="string">"w+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[table_dual_write]could not open file \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>DUAL_WRITE_FILE_NAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>DumpDualWriteInfo</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[table_dual_write]could not write file \"%s\": %m"</literal></expr></argument>,
                        <argument><expr><name>DUAL_WRITE_FILE_NAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* remove backup file */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>DUAL_WRITE_BACKUP_FILE_NAME</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"[table_dual_write]could not unlink file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>DUAL_WRITE_BACKUP_FILE_NAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DualWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>returnstr</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"success"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[table_dual_write]set dual write stop for table:%s column:%s value:%s"</literal></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>columnstr</name></expr></argument>, <argument><expr><name>valuestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>returnstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>  
<name>pg_set_node_cold_access</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>pg_set_cold_access</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>Datum</name></type>  
<name>pg_clear_node_cold_access</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>pg_clear_cold_access</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>int32</name></type>                <name>index</name></decl>;</decl_stmt>
}</block></struct></type><name>AccessControlStatInfo</name>;</typedef>

<function><type><name>Datum</name></type>  
<name>pg_stat_node_access</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACCESS_CONTROL_ATTR_NUM</name></cpp:macro>  <cpp:value>1</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>FuncCallContext</name>         <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AccessControlStatInfo</name>    <modifier>*</modifier></type><name>qInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>                <name>tuple</name></decl>;</decl_stmt>        

    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>ACCESS_CONTROL_ATTR_NUM</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>ACCESS_CONTROL_ATTR_NUM</name></expr>]</index></name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can only called on datanode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>ACCESS_CONTROL_ATTR_NUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"access"</literal></expr></argument>,
                           <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AccessControlStatInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>qInfo</name> <operator>=</operator> <operator>(</operator><name>AccessControlStatInfo</name><operator>*</operator><operator>)</operator><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>g_AccessCtl</name><operator>-&gt;</operator><name>needlock</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ColdAccessLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* stuff done on every call of the function */</comment>
    <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>qInfo</name> <operator>=</operator> <operator>(</operator><name>AccessControlStatInfo</name><operator>*</operator><operator>)</operator><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt> 
    <if_stmt><if>if <condition>(<expr><name><name>qInfo</name><operator>-&gt;</operator><name>index</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><ternary><condition><expr><name><name>g_AccessCtl</name><operator>-&gt;</operator><name>colddata</name></name></expr> ?</condition><then> <expr><literal type="string">"cold"</literal></expr> </then><else>: <expr><literal type="string">"hot"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qInfo</name><operator>-&gt;</operator><name>index</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>     
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* nothing left */</comment>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ColdAccessLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>    
</block_content>}</block></function>


<comment type="block">/*
 * Estimate space needed for shard statistic hashtable 
 */</comment>
<function><type><name>Size</name></type>
<name>ShardStatisticShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type> <name>space</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nelems</name> <init>= <expr><name>MAX_SHARDS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>npools</name> <init>= <expr><operator>(</operator><name>MaxBackends</name> <operator>/</operator> <name>g_MaxSessionsPerPool</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type> <name>pool_size</name> <init>= <expr><call><name>mul_size</name><argument_list>(<argument><expr><name>nelems</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardStatistic</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>space</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><name>npools</name></expr></argument>, <argument><expr><name>pool_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return <expr><name>space</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize shard statistic info in shared memory
 */</comment>
<function><type><name>void</name></type>
<name>ShardStatisticShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nelems</name> <init>= <expr><name>MAX_SHARDS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>npools</name> <init>= <expr><operator>(</operator><name>MaxBackends</name> <operator>/</operator> <name>g_MaxSessionsPerPool</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type> <name>pool_size</name> <init>= <expr><call><name>mul_size</name><argument_list>(<argument><expr><name>nelems</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardStatistic</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    
    <expr_stmt><expr><name>shardStatInfo</name> <operator>=</operator> <operator>(</operator><name>ShardStatistic</name> <operator>*</operator><operator>)</operator>
        <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Shard Statistic Info"</literal></expr></argument>,
                        <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>npools</name></expr></argument>, <argument><expr><name>pool_size</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>max_elems</name> <init>= <expr><name>nelems</name> <operator>*</operator> <name>npools</name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_elems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shardStatInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ntuples_select</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shardStatInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ntuples_insert</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shardStatInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ntuples_update</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shardStatInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ntuples_delete</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shardStatInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ntuples</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shardStatInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * update shard statistic info by each backend which do select/insert/update/delete.
 */</comment>
<function><type><name>void</name></type>
<name>UpdateShardStatistic</name><parameter_list>(<parameter><decl><type><name>CmdType</name></type> <name>cmd</name></decl></parameter>, <parameter><decl><type><name>ShardID</name></type> <name>sid</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>new_size</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>old_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nelems</name> <init>= <expr><name>MAX_SHARDS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>npools</name> <init>= <expr><operator>(</operator><name>MaxBackends</name> <operator>/</operator> <name>g_MaxSessionsPerPool</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShardIDIsValid</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><name><name>MyProc</name><operator>-&gt;</operator><name>pgprocno</name></name> <operator>%</operator> <name>npools</name><operator>)</operator> <operator>*</operator> <name>nelems</name> <operator>+</operator> <name>sid</name></expr>;</expr_stmt>
    
    <switch>switch<condition>(<expr><name>cmd</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>CMD_SELECT</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shardStatInfo</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>ntuples_select</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shardStatInfo</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>ntuples_update</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>new_size</name> <operator>&gt;</operator> <name>old_size</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int64</name></type> <name>size</name> <init>= <expr><name>new_size</name> <operator>-</operator> <name>old_size</name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shardStatInfo</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>new_size</name> <operator>&lt;</operator> <name>old_size</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int64</name></type> <name>size</name> <init>= <expr><name>old_size</name> <operator>-</operator> <name>new_size</name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>pg_atomic_fetch_sub_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shardStatInfo</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>CMD_INSERT</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shardStatInfo</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>ntuples_insert</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shardStatInfo</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>ntuples</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shardStatInfo</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>, <argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <case>case <expr><name>CMD_DELETE</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shardStatInfo</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>ntuples_delete</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>pg_atomic_fetch_sub_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shardStatInfo</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>ntuples</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>pg_atomic_fetch_sub_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shardStatInfo</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>, <argument><expr><name>old_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Unsupported CmdType %d in UpdateShardStatistic"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitShardStatistic</name><parameter_list>(<parameter><decl><type><name>ShardStatistic</name> <modifier>*</modifier></type><name>stat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stat</name><operator>-&gt;</operator><name>ntuples</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stat</name><operator>-&gt;</operator><name>ntuples_delete</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stat</name><operator>-&gt;</operator><name>ntuples_update</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stat</name><operator>-&gt;</operator><name>ntuples_insert</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stat</name><operator>-&gt;</operator><name>ntuples_select</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>stat</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* fetch from shard statistic from source, add to dest */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FetchAddShardStatistic</name><parameter_list>(<parameter><decl><type><name>ShardStatistic</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>ShardStatistic</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>ntuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dest</name><operator>-&gt;</operator><name>ntuples</name></name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>ntuples_delete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dest</name><operator>-&gt;</operator><name>ntuples_delete</name></name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>ntuples_update</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dest</name><operator>-&gt;</operator><name>ntuples_update</name></name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>ntuples_insert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dest</name><operator>-&gt;</operator><name>ntuples_insert</name></name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>ntuples_select</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dest</name><operator>-&gt;</operator><name>ntuples_select</name></name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dest</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/* write shard statistic info into file */</comment>
<function><type><name>void</name></type>
<name>FlushShardStatistic</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>      <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name>      <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name>     <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nelems</name> <init>= <expr><name>MAX_SHARDS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>npools</name> <init>= <expr><operator>(</operator><name>MaxBackends</name> <operator>/</operator> <name>g_MaxSessionsPerPool</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>size</name>   <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardRecord</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nelems</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>ShardRecord</name></type> <name><name>rec</name><index>[<expr><name>MAX_SHARDS</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* init all shard records */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>InitShardStatistic</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rec</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name><name>rec</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* merge shard statistic */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>npools</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><name>i</name> <operator>*</operator> <name>nelems</name> <operator>+</operator> <name>j</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>FetchAddShardStatistic</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rec</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>stat</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>shardStatInfo</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <comment type="block">/* calculate crc for each record */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name><name>rec</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>crc</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>rec</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>stat</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardStatistic</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name><name>rec</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* write record into file */</comment>
    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>SHARD_STATISTIC_FILE_PATH</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_TRUNC</name> <operator>|</operator> <name>O_CREAT</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>size</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>RecoverShardStatistic</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>      <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name>     <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nelems</name> <init>= <expr><name>MAX_SHARDS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>size</name>   <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardRecord</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nelems</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShardRecord</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>ShardRecord</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><call><name>access</name><argument_list>(<argument><expr><name>SHARD_STATISTIC_FILE_PATH</name></expr></argument>, <argument><expr><name>F_OK</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>SHARD_STATISTIC_FILE_PATH</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>, <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not open file \"%s\""</literal></expr></argument>, <argument><expr><name>SHARD_STATISTIC_FILE_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>end</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>size</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"failed to read file \"%s\""</literal></expr></argument>, <argument><expr><name>SHARD_STATISTIC_FILE_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>end</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>pg_crc32c</name></type> <name>crc</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>rec</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>stat</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardStatistic</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>crc</name> <operator>==</operator> <name><name>rec</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>crc</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>FetchAddShardStatistic</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shardStatInfo</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rec</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>stat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"shard %d statistic info CRC-ERROR"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

<label><name>end</name>:</label>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>RefreshShardStatistic</name><parameter_list>(<parameter><decl><type><name>ShardStat</name> <modifier>*</modifier></type><name>shardstat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nelems</name> <init>= <expr><name>MAX_SHARDS</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>shardstat</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>shardstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shardStatInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ntuples</name></expr></argument>, <argument><expr><name><name>shardstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>pg_atomic_fetch_add_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shardStatInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>, <argument><expr><name><name>shardstat</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>ResetShardStatistic</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nelems</name> <init>= <expr><name>MAX_SHARDS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>npools</name> <init>= <expr><operator>(</operator><name>MaxBackends</name> <operator>/</operator> <name>g_MaxSessionsPerPool</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>npools</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><name>j</name> <operator>*</operator> <name>nelems</name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shardStatInfo</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>ntuples</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pg_atomic_init_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shardStatInfo</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* display shard statistic info */</comment>
<function><type><name>Datum</name></type>  
<name>tbase_shard_statistic</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NCOLUMNS</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>FuncCallContext</name>     <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShmMgr_State</name>    <modifier>*</modifier></type><name>status</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ShardStatistic</name> <modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nelems</name> <init>= <expr><name>MAX_SHARDS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>npools</name> <init>= <expr><operator>(</operator><name>MaxBackends</name> <operator>/</operator> <name>g_MaxSessionsPerPool</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>size</name>   <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShardStatistic</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nelems</name></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>        
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleDesc</name></type>      <name>tupdesc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        
        <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>NCOLUMNS</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"group_name"</literal></expr></argument>,
                           <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"node_name"</literal></expr></argument>,
                           <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"shard_id"</literal></expr></argument>,
                           <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"ntups_select"</literal></expr></argument>,
                           <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"ntups_insert"</literal></expr></argument>,
                           <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"ntups_update"</literal></expr></argument>,
                           <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"ntups_delete"</literal></expr></argument>,
                           <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>,
                           <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">9</literal></expr></argument>, <argument><expr><literal type="string">"ntups"</literal></expr></argument>,
                           <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>status</name> <operator>=</operator> <operator>(</operator><name>ShmMgr_State</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShmMgr_State</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>status</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>rec</name> <operator>=</operator> <operator>(</operator><name>ShardStatistic</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>InitShardStatistic</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>npools</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>show_all_shard_stat</name> <operator>||</operator> <name>IS_PGXC_COORDINATOR</name> <operator>||</operator>
                   <operator>!</operator><name>g_DatanodeShardgroupBitmap</name> <operator>||</operator>
                   <name><name>g_GroupShardingMgr_DN</name><operator>-&gt;</operator><name>members</name><operator>-&gt;</operator><name>shardMapStatus</name></name> <operator>!=</operator> <name>SHMEM_SHRADMAP_STATUS_USING</name> <operator>||</operator>
                   <call><name>bms_is_member</name><argument_list>(<argument><expr><name>j</name></expr></argument>, <argument><expr><name>g_DatanodeShardgroupBitmap</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                                   
                    <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><name>i</name> <operator>*</operator> <name>nelems</name> <operator>+</operator> <name>j</name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>FetchAddShardStatistic</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rec</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>shardStatInfo</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ShardMapLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>rec</name></name> <operator>=</operator> <name>rec</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>


    <comment type="block">/* stuff done on every call of the function */</comment>
    <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>status</name>  <operator>=</operator> <operator>(</operator><name>ShmMgr_State</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rec</name> <operator>=</operator> <name><name>status</name><operator>-&gt;</operator><name>rec</name></name></expr>;</expr_stmt>
    
    <while>while <condition>(<expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name> <operator>&lt;</operator> <name>nelems</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>NCOLUMNS</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>NCOLUMNS</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name></type>        <name>result</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>group_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>,  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>group_name</name> <operator>=</operator> <call><name>GetMyGroupName</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>group_name</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>group_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rec</name><index>[<expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name><operator>.</operator><name>ntuples_select</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rec</name><index>[<expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name><operator>.</operator><name>ntuples_insert</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rec</name><index>[<expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name><operator>.</operator><name>ntuples_update</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rec</name><index>[<expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name><operator>.</operator><name>ntuples_delete</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rec</name><index>[<expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><call><name>pg_atomic_read_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rec</name><index>[<expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name></expr>]</index></name><operator>.</operator><name>ntuples</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>status</name><operator>-&gt;</operator><name>currIdx</name></name><operator>++</operator></expr>;</expr_stmt>

        <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    
    <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>LoadAccessControlInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>    
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>stat</name><argument_list>(<argument><expr><name>ACCESS_CONTROL_FILE_NAME</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>g_AccessCtl</name><operator>-&gt;</operator><name>colddata</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add dual write info
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> 
<name>AddDualWriteInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attr</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>gap</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>column</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>  <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DTag</name></type>  <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DualWriteRecord</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>    

    <expr_stmt><expr><name><name>tag</name><operator>.</operator><name>relation</name></name>     <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tag</name><operator>.</operator><name>attr</name></name>         <operator>=</operator> <name>attr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tag</name><operator>.</operator><name>timeoffset</name></name>  <operator>=</operator> <name>gap</name></expr>;</expr_stmt>    
    
    <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>DualWriteRecord</name><operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>dwhash</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ent</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"corrupted shared hash table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>table</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>column</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>entrynum</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Only called when startup, no lock needed
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>LoadDualWriteInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives    </comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>relOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>columnidx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>gapptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>columnstr</name></decl>;</decl_stmt>   
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>valuestr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>fp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>char</name></type>       <name><name>buffer</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <comment type="block">/* try major file */</comment>    
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>stat</name><argument_list>(<argument><expr><name>DUAL_WRITE_FILE_NAME</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* use major file */</comment>
        <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>DUAL_WRITE_FILE_NAME</name></expr></argument>, <argument><expr><literal type="string">"r+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name>DUAL_WRITE_FILE_NAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>        
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>stat</name><argument_list>(<argument><expr><name>DUAL_WRITE_BACKUP_FILE_NAME</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* use backup file */</comment>
        <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>DUAL_WRITE_BACKUP_FILE_NAME</name></expr></argument>, <argument><expr><literal type="string">"r+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name>DUAL_WRITE_BACKUP_FILE_NAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>    

    <if_stmt><if>if <condition>(<expr><name>fp</name></expr>)</condition>
    <block>{<block_content>
        <while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>,  <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>p</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
            
            <expr_stmt><expr><name>relOid</name>    <operator>=</operator> <name>p</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>columnidx</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>columnstr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>gapptr</name>    <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>valuestr</name>  <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>table</name>     <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            
            <comment type="block">/* split string */</comment>
            <while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><literal type="char">','</literal> <operator>==</operator> <operator>*</operator><name>p</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>columnidx</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>columnidx</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>                    
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>gapptr</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>gapptr</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>                    
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>table</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>table</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>                    
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>columnstr</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>columnstr</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>                    
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>valuestr</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>valuestr</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>    
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt> 
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><literal type="char">'\n'</literal> <operator>==</operator> <operator>*</operator><name>p</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt> 
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></while>
            <expr_stmt><expr><call><name>AddDualWriteInfo</name><argument_list>(<argument><expr><operator>(</operator><name>Oid</name><operator>)</operator><call><name>atoi</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator><call><name>atoi</name><argument_list>(<argument><expr><name>columnidx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int32</name><operator>)</operator><call><name>atoi</name><argument_list>(<argument><expr><name>gapptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>columnstr</name></expr></argument>, <argument><expr><name>valuestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>Size</name></type> <name>DualWriteTableSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>MAX_DUAL_WRITE_TABLE</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DualWriteRecord</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DualWriteCtl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>    
    <if type="elseif">else if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AccessControl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>DualWriteCtlInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>(<expr><name>IS_PGXC_COORDINATOR</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>         <name>found</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HASHCTL</name></type>        <name>info</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>g_DualWriteCtl</name> <operator>=</operator> <operator>(</operator><name>DualWriteCtl</name> <operator>*</operator><operator>)</operator><call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Dual write control"</literal></expr></argument>,
                                                                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DualWriteCtl</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                                                <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid shmem status when dual write control "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>dwhash</name></name>   <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>needlock</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>entrynum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/* init dual write hash table */</comment>
        <expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name>   <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DTag</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DualWriteRecord</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>info</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>tag_hash</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>dwhash</name></name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"dual write hash table"</literal></expr></argument>,
                                      <argument><expr><name>MAX_DUAL_WRITE_TABLE</name></expr></argument>, 
                                      <argument><expr><name>MAX_DUAL_WRITE_TABLE</name></expr></argument>,
                                      <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
                                      <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>dwhash</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid shmem status when creating dual write hash table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>    
        <expr_stmt><expr><call><name>LoadDualWriteInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>g_AccessCtl</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type>         <name>found</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>g_AccessCtl</name> <operator>=</operator> <operator>(</operator><name>AccessControl</name> <operator>*</operator><operator>)</operator><call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"access control"</literal></expr></argument>,
                                                        <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AccessControl</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                                        <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid shmem status when create access control"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>        
         
        <expr_stmt><expr><call><name>LoadAccessControlInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>g_DualWriteCtl</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return node access status, true : cold , false : hot
 */</comment>
<function><type><name>bool</name></type> <name>pg_get_node_access</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><ternary><condition><expr><name><name>g_AccessCtl</name><operator>-&gt;</operator><name>colddata</name></name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>pg_set_cold_access</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>char</name></type>   <name><name>returnstr</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name>   <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can only called on datanode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>    
    
    <comment type="block">/* remove dual write info from share memory */</comment>
    <expr_stmt><expr><name><name>g_AccessCtl</name><operator>-&gt;</operator><name>needlock</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ColdAccessLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>stat</name><argument_list>(<argument><expr><name>ACCESS_CONTROL_FILE_NAME</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        
    </block_content>}</block></if>    
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>ACCESS_CONTROL_FILE_NAME</name></expr></argument>, <argument><expr><literal type="string">"w+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>,
                            <argument><expr><name>ACCESS_CONTROL_FILE_NAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>        
        <expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><name><name>g_AccessCtl</name><operator>-&gt;</operator><name>colddata</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ColdAccessLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name><name>g_AccessCtl</name><operator>-&gt;</operator><name>needlock</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt><comment type="block">/* tell others to release lock */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>returnstr</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"success"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>returnstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>pg_clear_cold_access</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>   <name><name>returnstr</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>    

	<if_stmt><if>if<condition>(<expr><operator>!</operator><name>IS_PGXC_DATANODE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can only called on datanode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>	
    
    <comment type="block">/* remove dual write info from share memory */</comment>
    <expr_stmt><expr><name><name>g_AccessCtl</name><operator>-&gt;</operator><name>needlock</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ColdAccessLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* remove backup file */</comment>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>stat</name><argument_list>(<argument><expr><name>ACCESS_CONTROL_FILE_NAME</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>ACCESS_CONTROL_FILE_NAME</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not unlink file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>ACCESS_CONTROL_FILE_NAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>g_AccessCtl</name><operator>-&gt;</operator><name>colddata</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ColdAccessLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>g_AccessCtl</name><operator>-&gt;</operator><name>needlock</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt><comment type="block">/* tell others to release lock */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>returnstr</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"success"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>returnstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Need dual write or not
 */</comment>
<function><type><name>bool</name></type> <name>NeedDualWrite</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attr</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>  <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>  <name>needlock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name>gap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DTag</name></type>  <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>partitionStrategy</name>        <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>                  <name>rel</name>            <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_partition_interval</name></type> <name>routerinfo</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>needlock</name> <operator>=</operator> <name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>needlock</name></name></expr>;</expr_stmt>

    <comment type="line">//LogDualWriteInfo(needlock);</comment>
    
    <comment type="block">/*no one is trying to add dual write logical */</comment>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>entrynum</name></name> <operator>&amp;&amp;</operator> <name>false</name> <operator>==</operator> <name>needlock</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get partition stragegy first */</comment>
    <expr_stmt><expr><name>rel</name>          <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>routerinfo</name>   <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_partitions_info</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>routerinfo</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>attr</name> <operator>==</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partpartkey</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>partitionStrategy</name> <operator>=</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_type</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>partitionStrategy</name> <operator>==</operator> <name>IntervalType_Month</name> <operator>&amp;&amp;</operator>
                <name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_int</name></name> <operator>==</operator> <literal type="number">12</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>partitionStrategy</name> <operator>=</operator> <name>IntervalType_Year</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
    
    <expr_stmt><expr><name>gap</name>             <operator>=</operator> <call><name>get_timestamptz_gap</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tag</name><operator>.</operator><name>relation</name></name>     <operator>=</operator> <name>relation</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tag</name><operator>.</operator><name>attr</name></name>         <operator>=</operator> <name>attr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tag</name><operator>.</operator><name>timeoffset</name></name>  <operator>=</operator> <name>gap</name></expr>;</expr_stmt>
    
    
    <if_stmt><if>if <condition>(<expr><name>needlock</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>DualWriteLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>dwhash</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <if_stmt><if>if <condition>(<expr><name>needlock</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DualWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check value whether temp key value
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>IsTempKeyValue</name><parameter_list>(<parameter><decl><type><name>KeyValuePair</name><modifier>*</modifier></type> <name>p_KeyValuePair</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>hotGroup</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>coldGroup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>p_KeyValuePair</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>p_KeyValuePair</name><operator>-&gt;</operator><name>table</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>p_KeyValuePair</name><operator>-&gt;</operator><name>table</name></name> <operator>==</operator> <name>relation</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>p_KeyValuePair</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>hotGroup</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>hotGroup</name>  <operator>=</operator> <name><name>p_KeyValuePair</name><operator>-&gt;</operator><name>hotGroup</name></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>coldGroup</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>coldGroup</name> <operator>=</operator> <name><name>p_KeyValuePair</name><operator>-&gt;</operator><name>coldGroup</name></name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check value in temp key value list
 */</comment>
<function><type><name>bool</name></type> <name>InTempKeyValueList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>hotGroup</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>coldGroup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>KeyValuePair</name> <modifier>*</modifier></type><name>p_KeyValuePair</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>NIL</name> <operator>!=</operator> <name>g_TempKeyValueList</name></expr>)</condition>
    <block>{<block_content>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>g_TempKeyValueList</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><name>p_KeyValuePair</name> <operator>=</operator> <operator>(</operator><name>KeyValuePair</name><operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><call><name>IsTempKeyValue</name><argument_list>(<argument><expr><name>p_KeyValuePair</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>hotGroup</name></expr></argument>, <argument><expr><name>coldGroup</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>
    
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get group's oid by group name.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type> <name>GetGroupOidByName</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>groupname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>groupname</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>get_pgxc_groupoid</name><argument_list>(<argument><expr><name>groupname</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get table's oid by table name.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type> <name>GetTableOidByName</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>schema_tblname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>schema</name><index>[<expr><name>STRINGLENGTH</name></expr>]</index></name>      <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>tablename</name><index>[<expr><name>STRINGLENGTH</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>  <name>schema_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>  <name>table_oid</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>schema_tblname</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>InvalidOid</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>schema_tblname</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>schema_tblname</name></expr></argument>, <argument><expr><name>tmp</name> <operator>-</operator> <name>schema_tblname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tablename</name></expr></argument>, <argument><expr><name>tmp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>schema_tblname</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><name>tmp</name> <operator>-</operator> <name>schema_tblname</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* get table schema */</comment>
    <expr_stmt><expr><name>schema_oid</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>schema_oid</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_SCHEMA</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"schema \"%s\" does not exist."</literal></expr></argument>, <argument><expr><name>schema</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* get table name */</comment>

    <expr_stmt><expr><name>table_oid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name>tablename</name></expr></argument>, <argument><expr><name>schema_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>table_oid</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" does not exist."</literal></expr></argument>, <argument><expr><name>tablename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <return>return <expr><name>table_oid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * extract tblNames, value, hotGroupName, coldGroupName from user's input string.
 * string: public.test1,public.test2,public.test3,public.test4 5 gp0 gp1
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>ExtractPara</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_tblNames</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>valueLength</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>hotGroupName</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>coldGroupName</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>STRINGLENGTH</name></expr>]</index></name>   <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type> <name>cnt</name>                    <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p_str</name>                 <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>mid</name>                   <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name>                   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tmp2</name>                <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>singleTableName</name>        <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type> <name>length</name>                    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type> <name>continuousSpaceCount</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type> <name>headSpaceCount</name>            <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_cxt</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>str</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* tmp points to the first non-space character in str */</comment>
    <expr_stmt><expr><name>tmp2</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>tmp2</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>headSpaceCount</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>tmp2</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    
    <expr_stmt><expr><name>old_cxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/*erase last spaces*/</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>tmp2</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>headSpaceCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>&amp;</operator><name><name>buffer</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>headSpaceCount</name></expr>]</index></name></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>tmp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>tmp</name><operator>--</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p_str</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>p_str</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* first tablename to [last-1] tablename*/</comment>
    <while>while <condition>(<expr><operator>(</operator><name>mid</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p_str</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>*</operator><operator>(</operator><name>mid</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>mid</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <name>mid</name> <operator>-</operator> <name>p_str</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>singleTableName</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name>length</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>singleTableName</name></expr></argument>, <argument><expr><name>p_str</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>p_tblNames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>p_tblNames</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>singleTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>p_str</name> <operator>=</operator> <name>tmp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>*</operator><name>p_str</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>p_str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></while>

    <while>while <condition>(<expr><operator>(</operator><name>mid</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p_str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>continuousSpaceCount</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>*</operator><operator>(</operator><name>mid</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>mid</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><name>length</name> <operator>=</operator> <name>mid</name> <operator>-</operator> <name>p_str</name></expr>;</expr_stmt>
        <comment type="block">/* position of last tablename */</comment>
        <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>==</operator> <name>cnt</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>singleTableName</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name>length</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>singleTableName</name></expr></argument>, <argument><expr><name>p_str</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>p_tblNames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>p_tblNames</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>singleTableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* position of value */</comment>
        <if type="elseif">else if <condition>(<expr><literal type="number">2</literal> <operator>==</operator> <name>cnt</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>p_str</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>valueLength</name> <operator>=</operator> <name>length</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* position of hotgroupname */</comment>
        <if type="elseif">else if <condition>(<expr><literal type="number">3</literal> <operator>==</operator> <name>cnt</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>hotGroupName</name></expr></argument>, <argument><expr><name>p_str</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>p_str</name> <operator>=</operator> <name>tmp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>*</operator><name>p_str</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>p_str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></while>

    <comment type="block">/* 
     *validate user input by check space count.
     *in normal case, total continuous space count between strings will be 3.
     */</comment>
    <if_stmt><if>if <condition>(<expr><literal type="number">3</literal> <operator>!=</operator> <name>continuousSpaceCount</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WARNING</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid input. Correct format: set temp_key_value='schmea.tbl,schema2.tbl2 value hotgp coldgp'"</literal></expr></argument> )</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* position of coldgroupname */</comment>
    <expr_stmt><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>*</operator><name>p_str</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>coldGroupName</name><index>[<expr><name>cnt</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>p_str</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>p_str</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set temp Key value as g_TempKeyValueList's member
 */</comment>
<function><type><name>void</name></type> <name>SetTempKeyValueList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>List</name>      <modifier>*</modifier></type><name>tblNames</name>                      <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>  <modifier>*</modifier></type><name>lc</name>                          <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>      <name><name>value</name><index>[<expr><name>STRINGLENGTH</name></expr>]</index></name>           <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type>       <name>valueLength</name>                  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>      <name><name>hotGroupName</name><index>[<expr><name>STRINGLENGTH</name></expr>]</index></name>  <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>      <name><name>coldGroupName</name><index>[<expr><name>STRINGLENGTH</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>       <name>hotGroupOid</name>                 <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>          <name>coldGroupOid</name>                <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>KeyValuePair</name> <modifier>*</modifier></type><name>p_KeyValuePair</name>          <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_cxt</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>old_cxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* set more than once will cover last set operation.*/</comment>
    <if_stmt><if>if <condition>(<expr><name>g_TempKeyValueList</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>g_TempKeyValueList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>g_TempKeyValueList</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/*
     * str format: schemaA.tbl1,schemaB.tbl2 value hotgroupname coldgroupname
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ExtractPara</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tblNames</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valueLength</name></expr></argument>, <argument><expr><name>hotGroupName</name></expr></argument>, <argument><expr><name>coldGroupName</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>IS_PGXC_DATANODE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>hotGroupOid</name>  <operator>=</operator> <call><name>GetGroupOidByName</name><argument_list>(<argument><expr><name>hotGroupName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>coldGroupOid</name> <operator>=</operator> <call><name>GetGroupOidByName</name><argument_list>(<argument><expr><name>coldGroupName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/*validate hotGroupOid and coldGroupOid*/</comment>
            <if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>hotGroupOid</name> <operator>||</operator> <name>InvalidOid</name> <operator>==</operator> <name>coldGroupOid</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>hotGroupOid</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hot group \"%s\" does not exist"</literal></expr></argument>, 
                             <argument><expr><name>hotGroupName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>coldGroupOid</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cold group \"%s\" does not exist"</literal></expr></argument>, 
                             <argument><expr><name>coldGroupName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name>g_TempKeyValueList</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
                <return>return ;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
                
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tblNames</argument>)</argument_list></macro>
        <block>{<block_content>
            <comment type="block">/*set single key value*/</comment>
            <expr_stmt><expr><name>p_KeyValuePair</name> <operator>=</operator> <operator>(</operator><name>KeyValuePair</name><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>KeyValuePair</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><name><name>p_KeyValuePair</name><operator>-&gt;</operator><name>table</name></name>       <operator>=</operator> <call><name>GetTableOidByName</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p_KeyValuePair</name><operator>-&gt;</operator><name>value</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>valueLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
            <expr_stmt><expr><name><name>p_KeyValuePair</name><operator>-&gt;</operator><name>hotGroup</name></name>  <operator>=</operator> <name>hotGroupOid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>p_KeyValuePair</name><operator>-&gt;</operator><name>coldGroup</name></name> <operator>=</operator> <name>coldGroupOid</name></expr>;</expr_stmt>
            <comment type="block">/*add to list*/</comment>
            <expr_stmt><expr><name>g_TempKeyValueList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>g_TempKeyValueList</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator><name>p_KeyValuePair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*free talNames itself*/</comment>
    <if_stmt><if>if <condition>(<expr><name>tblNames</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>tblNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return ;</return>
</block_content>}</block></function>

<comment type="block">/* We use second offset as key value offset */</comment>
<function><type><name>long</name></type> <name>get_keyvalue_offset</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>endtime</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>long</name></type> <name>secs</name>      <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>microsecs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>g_keyvalue_base_timestamp</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>tm2timestamp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_keyvalue_base_time</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>g_keyvalue_base_timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transfer timestamp failed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><name>g_keyvalue_base_timestamp</name></expr></argument>, <argument><expr><name>endtime</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>microsecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>secs</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>==</operator> <name>microsecs</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid timestamp value when get second offset, timestamp value must be after 2000-01:01-00:00:00"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>secs</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type> 
<name>compute_keyvalue_hash</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>PARTITION_KEY_IS_TIMESTAMP</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><call><name>get_keyvalue_offset</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <return>return <expr><call><name>compute_hash</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>LOCATOR_TYPE_SHARD</name></expr></argument>)</argument_list></call></expr>;</return>    
    </block_content>}</block></else></if_stmt>    
</block_content>}</block></function>

<comment type="block">/*
 * get hot gap by partition interval type
 */</comment>
<function><type><name>int32</name></type> <name>GetHotDataGap</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>interval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>gap</name></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name>interval</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>IntervalType_Month</name></expr>:</case>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>g_ManualHotDataGapWithMonths</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>gap</name> <operator>=</operator> <call><name>date_diff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_ManualHotDataTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <return>return <expr><name>gap</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            
            <return>return  <expr><name>g_ColdDataThreashold</name> <operator>/</operator> <literal type="number">30</literal></expr>;</return>
        </block_content>}</block>
        
        <case>case <expr><name>IntervalType_Day</name></expr>:</case>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>g_ManualHotDataGapWithDays</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>gap</name> <operator>=</operator> <call><name>date_diff_indays</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_ManualHotDataTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <return>return <expr><name>gap</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if></if_stmt>
            
            <return>return  <expr><name>g_ColdDataThreashold</name></expr>;</return>
        </block_content>}</block>

        <default>default:</default>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"partition interval %d not support hot and cold seperation"</literal></expr></argument>, <argument><expr><name>interval</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block>
    </block_content>}</block></switch>   
</block_content>}</block></function>

<comment type="block">/* 
    if temp_cold_date guc option is available, new mod needs to be checked whether treating as cold date.
    reture true, this data would be treated as cold data, else as hot data.
*/</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>IsTempColdData</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>RelationAccessType</name></type> <name>access</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>interval</name></decl></parameter>,
                                <parameter><decl><type><name>int</name></type> <name>step</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>startValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>RELATION_ACCESS_INSERT</name> <operator>==</operator> <name>access</name> <operator>||</operator> <name>RELATION_ACCESS_UPDATE</name> <operator>==</operator> <name>access</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><literal type="char">'\0'</literal> <operator>!=</operator> <name><name>g_TempColdDate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>is_sec_meet_temp_cold_date</name><argument_list>(<argument><expr><name>secValue</name></expr></argument>, <argument><expr><name>interval</name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><name>startValue</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* return this is one cold data */</comment>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Get invalid data when temp_cold_date(%d-%d-%d) is set"</literal></expr></argument>,
            <argument><expr><name><name>g_TempColdDataTime</name><operator>.</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>g_TempColdDataTime</name><operator>.</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>g_TempColdDataTime</name><operator>.</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Data is hot or not
 */</comment>
<function><type><name>bool</name></type> <name>IsHotData</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>RelationAccessType</name></type> <name>access</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>interval</name></decl></parameter>,
                  <parameter><decl><type><name>int</name></type> <name>step</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>startValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Timestamp</name></type> <name>hotDataTime</name></decl>;</decl_stmt>    
    
	<if_stmt><if>if <condition>(<expr><name>enable_cold_hot_router_print</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"IsHotData Check value "</literal><name>INT64_FORMAT</name><literal type="string">" access %d interval %d step %d "</literal><name>INT64_FORMAT</name></expr></argument>,
		     <argument><expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>secValue</name></expr></argument>)</argument_list></call></expr></argument>,
		     <argument><expr><name>access</name></expr></argument>, <argument><expr><name>interval</name></expr></argument>, <argument><expr><name>step</name></expr></argument>,
		     <argument><expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>startValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


    <comment type="block">/* trade temp cold data as cold data. checking is needed if data would satisfy temp_cold_date guc option */</comment>
    <if_stmt><if>if <condition>(<expr><name>true</name> <operator>==</operator> <call><name>IsTempColdData</name><argument_list>(<argument><expr><name>secValue</name></expr></argument>, <argument><expr><name>access</name></expr></argument>, <argument><expr><name>interval</name></expr></argument>, <argument><expr><name>step</name></expr></argument>, <argument><expr><name>startValue</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
    	<if_stmt><if>if <condition>(<expr><name>enable_cold_hot_router_print</name></expr>)</condition>
	    <block>{<block_content>
		    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Return from TempColdData Value: %s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>g_TempColdDate</name></expr> ?</condition><then> <expr><name>g_TempColdDate</name></expr> </then><else>: <expr><literal type="string">"(null)"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    </block_content>}</block></if></if_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    gap = get_timestamptz_diff(secValue, interval);

    return gap &lt; GetHotDataGap(interval);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><call><name>tm2timestamp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_ManualHotDataTime</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hotDataTime</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>enable_cold_hot_router_print</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"IsHotData Check hotDateTime "</literal><name>INT64_FORMAT</name>
				<literal type="string">" Manual hot data time "</literal>
				<literal type="string">"{ tm_sec:%d tm_min:%d tm_hour:%d tm_mday:%d tm_mon:%d tm_year:%d tm_wday:%d tm_yday:%d"</literal>
				<literal type="string">"  tm_isdst:%d tm_gmtoff:%ld tm_zone:%s } ret: %d"</literal></expr></argument>,
             <argument><expr><operator>(</operator><name>int64</name><operator>)</operator><name>hotDataTime</name></expr></argument>,
			 <argument><expr><name><name>g_ManualHotDataTime</name><operator>.</operator><name>tm_sec</name></name></expr></argument>,
			 <argument><expr><name><name>g_ManualHotDataTime</name><operator>.</operator><name>tm_min</name></name></expr></argument>,
			 <argument><expr><name><name>g_ManualHotDataTime</name><operator>.</operator><name>tm_hour</name></name></expr></argument>,
			 <argument><expr><name><name>g_ManualHotDataTime</name><operator>.</operator><name>tm_mday</name></name></expr></argument>,
			 <argument><expr><name><name>g_ManualHotDataTime</name><operator>.</operator><name>tm_mon</name></name></expr></argument>,
			 <argument><expr><name><name>g_ManualHotDataTime</name><operator>.</operator><name>tm_year</name></name></expr></argument>,
			 <argument><expr><name><name>g_ManualHotDataTime</name><operator>.</operator><name>tm_wday</name></name></expr></argument>,
			 <argument><expr><name><name>g_ManualHotDataTime</name><operator>.</operator><name>tm_yday</name></name></expr></argument>,
			 <argument><expr><name><name>g_ManualHotDataTime</name><operator>.</operator><name>tm_isdst</name></name></expr></argument>,
			 <argument><expr><name><name>g_ManualHotDataTime</name><operator>.</operator><name>tm_gmtoff</name></name></expr></argument>,
			 <argument><expr><name><name>g_ManualHotDataTime</name><operator>.</operator><name>tm_zone</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><operator>(</operator><name>Timestamp</name><operator>)</operator><name>secValue</name> <operator>&gt;=</operator> <name>hotDataTime</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <return>return <expr><operator>(</operator><operator>(</operator><name>Timestamp</name><operator>)</operator><name>secValue</name> <operator>&gt;=</operator> <name>hotDataTime</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>List</name><modifier>*</modifier></type> <name>ShardMapRouter</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>coldgroup</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>dvalue</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>secAttr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>secType</name></decl></parameter>, 
                    <parameter><decl><type><name>bool</name></type> <name>isSecNull</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>secValue</name></decl></parameter>, <parameter><decl><type><name>RelationAccessType</name></type> <name>accessType</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives    </comment>
    <decl_stmt><decl><type><name>int16</name></type>        <name>typlen</name>                      <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>typbyval</name>                  <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>bdualwrite</name>                  <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>typalign</name>                  <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>typdelim</name>                  <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>Oid</name></type>         <name>typioparam</name>                  <init>= <expr><name>InvalidOid</name></expr></init></decl> ;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>typiofunc</name>                  <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>keyValueGroup</name>              <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>secColdGroup</name>              <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>hashvalue</name>                  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>sechashvalue</name>              <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>i</name>                          <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>value</name>                      <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>timestr</name>     <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>        <modifier>*</modifier></type><name>list</name>                      <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>dn_num</name>                      <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name>        <modifier>*</modifier></type><name>datanodes</name>                  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>int32</name></type>         <name>partitionStrategy</name>          <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>interval_step</name>            <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type>  <name>start_timestamp</name>          <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>                 <name>rel</name>          <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_partition_interval</name></type> <name>routerinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>    
	<decl_stmt><decl><type><name>bool</name></type>         <name>router_log_print</name>         <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_CHILD</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>RELATION_GET_PARENT</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>router_log_print</name> <operator>=</operator> <operator>(</operator><name>enable_cold_hot_router_print</name> <operator>&amp;&amp;</operator> <name>accessType</name> <operator>==</operator> <name>RELATION_ACCESS_INSERT</name> <operator>&amp;&amp;</operator>
						<operator>(</operator><call><name>RELATION_IS_INTERVAL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>RELATION_IS_CHILD</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>g_EnableKeyValue</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* check whether the value is key value */</comment>
        <expr_stmt><expr><call><name>get_type_io_data</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>IOFunc_output</name></expr></argument>,
                         <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>,
                         <argument><expr><operator>&amp;</operator><name>typalign</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typdelim</name></expr></argument>,
                         <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typiofunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typiofunc</name></expr></argument>, <argument><expr><name>dvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>g_EnableDualWrite</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isSecNull</name> <operator>&amp;&amp;</operator> <call><name>PARTITION_KEY_IS_TIMESTAMP</name><argument_list>(<argument><expr><name>secType</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>secAttr</name> <operator>!=</operator> <name>InvalidAttrNumber</name> <operator>&amp;&amp;</operator> 
            <name>accessType</name> <operator>!=</operator> <name>RELATION_ACCESS_READ</name> <operator>&amp;&amp;</operator> <name>accessType</name> <operator>!=</operator> <name>RELATION_ACCESS_READ_FQS</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>bdualwrite</name> <operator>=</operator> <call><name>NeedDualWrite</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>secAttr</name></expr></argument>, <argument><expr><name>secValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>bdualwrite</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"distribute key:%s timestamp:%s need dual write"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><call><name>timestamptz_to_str</name><argument_list>(<argument><expr><operator>(</operator><name>TimestampTz</name><operator>)</operator> <name>secValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>bdualwrite</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
	<if_stmt><if>if <condition>(<expr><name>router_log_print</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Group %d coldgroup %d relation %d secAttr %d isSecNull %d dualwrite %d"</literal></expr></argument>,
		     <argument><expr><name>group</name></expr></argument>, <argument><expr><name>coldgroup</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>secAttr</name></expr></argument>, <argument><expr><name>isSecNull</name></expr></argument>, <argument><expr><name>bdualwrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
    
    <comment type="block">/* get partition stragegy first */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isSecNull</name> <operator>&amp;&amp;</operator> <name>secAttr</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>rel</name>          <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>routerinfo</name>     <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_partitions_info</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>routerinfo</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>secAttr</name> <operator>==</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partpartkey</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>partitionStrategy</name> <operator>=</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_type</name></name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>partitionStrategy</name> <operator>==</operator> <name>IntervalType_Month</name> <operator>&amp;&amp;</operator>
					<name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_int</name></name> <operator>==</operator> <name>COLD_HOT_INTERVAL_YEAR</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>partitionStrategy</name> <operator>=</operator> <name>IntervalType_Year</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>interval_step</name> <operator>=</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_int</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>start_timestamp</name> <operator>=</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partstartvalue_ts</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>router_log_print</name></expr>)</condition>
			<block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"has routerinfo %d"</literal></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>router_log_print</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"no routerinfo %d"</literal></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>g_EnableKeyValue</name></expr>)</condition>
    <block>{<block_content>    
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>InTempKeyValueList</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keyValueGroup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>secColdGroup</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>keyValueGroup</name> <operator>=</operator> <call><name>GetKeyValuesGroup</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>secColdGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>keyValueGroup</name></expr>)</condition>
    <block>{<block_content>        
        <comment type="block">/* not the key value, use common map strategy */</comment>
        <expr_stmt><expr><name>hashvalue</name> <operator>=</operator> <call><name>compute_hash</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>dvalue</name></expr></argument>, <argument><expr><name>LOCATOR_TYPE_SHARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* no second distribute key, trade as hot data*/</comment>
        <if_stmt><if>if <condition>(<expr><name>InvalidAttrNumber</name> <operator>==</operator> <name>secAttr</name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><call><name>list_make1_int</name><argument_list>(<argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/* we have exact second distribute key */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isSecNull</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>bdualwrite</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* has cold data strategy */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>coldgroup</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* hot data, only timestamp field can be divided into hot and cold data */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>PARTITION_KEY_IS_TIMESTAMP</name><argument_list>(<argument><expr><name>secType</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsHotData</name><argument_list>(<argument><expr><name>secValue</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <return>return <expr><call><name>list_make1_int</name><argument_list>(<argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="block">/* cold data */</comment>
                        <return>return <expr><call><name>list_make1_int</name><argument_list>(<argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>coldgroup</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
                    </block_content>}</block></else></if_stmt>
                    
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* only timestamp field can be divided into hot and cold data */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>PARTITION_KEY_IS_TIMESTAMP</name><argument_list>(<argument><expr><name>secType</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsHotData</name><argument_list>(<argument><expr><name>secValue</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* for first distribute column */</comment>
                        <expr_stmt><expr><call><name>get_type_io_data</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>IOFunc_output</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>typalign</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typdelim</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typiofunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typiofunc</name></expr></argument>, <argument><expr><name>dvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/* for timestamp */</comment>
                        <expr_stmt><expr><call><name>get_type_io_data</name><argument_list>(<argument><expr><name>TIMESTAMPOID</name></expr></argument>, <argument><expr><name>IOFunc_output</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>typalign</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typdelim</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typiofunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        
                        <expr_stmt><expr><name>timestr</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typiofunc</name></expr></argument>,    <argument><expr><name>secValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"distribute key:%s timestamp:%s is cold data, but table has no cold group"</literal></expr></argument>, 
                            <argument><expr><name>value</name></expr></argument>, <argument><expr><name>timestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <return>return <expr><call><name>list_make1_int</name><argument_list>(<argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* need dual write, read access route to hot group */</comment>
                <if_stmt><if>if <condition>(<expr><name>RELATION_ACCESS_READ</name> <operator>==</operator> <name>accessType</name> <operator>||</operator>
                    <name>RELATION_ACCESS_READ_FQS</name> <operator>==</operator> <name>accessType</name></expr>)</condition>
                <block>{<block_content>
                    <return>return <expr><call><name>list_make1_int</name><argument_list>(<argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* if meet temp_cold_date guc option, modifications are only send to cold nodes */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>PARTITION_KEY_IS_TIMESTAMP</name><argument_list>(<argument><expr><name>secType</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>true</name> <operator>==</operator> <call><name>IsTempColdData</name><argument_list>(<argument><expr><name>secValue</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>coldgroup</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>coldgroup</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <return>return <expr><name>list</name></expr>;</return>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"NO cold datanode to send when temp_cold_date(%d-%d-%d) is set"</literal></expr></argument>,
                            <argument><expr><name><name>g_TempColdDataTime</name><operator>.</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>g_TempColdDataTime</name><operator>.</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>g_TempColdDataTime</name><operator>.</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    
                    <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>coldgroup</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>coldgroup</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>                    
                    <return>return <expr><name>list</name></expr>;</return>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* now we have send query to hot and cold group the same time */</comment>
            <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
            <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>coldgroup</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>coldgroup</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name>list</name></expr>;</return>
        </block_content>}</block></else></if_stmt>        
    </block_content>}</block></if></if_stmt>    

    <comment type="block">/* no second distribute key, trade as hot data*/</comment>
    <if_stmt><if>if <condition>(<expr><name>InvalidAttrNumber</name> <operator>==</operator> <name>secAttr</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>hashvalue</name>     <operator>=</operator> <call><name>compute_hash</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>dvalue</name></expr></argument>, <argument><expr><name>LOCATOR_TYPE_SHARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        <return>return <expr><call><name>list_make1_int</name><argument_list>(<argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>keyValueGroup</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* second key is NULL, we need use special route stragegy */</comment>
    <if_stmt><if>if <condition>(<expr><name>isSecNull</name></expr>)</condition>
    <block>{<block_content>        
        <if_stmt><if>if <condition>(<expr><name>RELATION_ACCESS_INSERT</name> <operator>==</operator> <name>accessType</name></expr>)</condition>
        <block>{<block_content>
            
            <comment type="block">/* hot data*/</comment>        
            <expr_stmt><expr><call><name>GetShardNodes</name><argument_list>(<argument><expr><name>keyValueGroup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datanodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dn_num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* route to the first node in group */</comment>
            <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name><name>datanodes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>datanodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
        
            <comment type="block">/* route to all nodes in group */</comment>
            <expr_stmt><expr><call><name>GetShardNodes</name><argument_list>(<argument><expr><name>keyValueGroup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datanodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dn_num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dn_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>                    
                <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>datanodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>datanodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

            <comment type="block">/* got cold group */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>secColdGroup</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>GetShardNodes</name><argument_list>(<argument><expr><name>secColdGroup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>datanodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dn_num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dn_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>                    
                    <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>datanodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>datanodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>list</name></expr>;</return>            
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* secondary sharding map */</comment>
    <expr_stmt><expr><name>hashvalue</name>     <operator>=</operator> <call><name>compute_hash</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>dvalue</name></expr></argument>, <argument><expr><name>LOCATOR_TYPE_SHARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <expr_stmt><expr><name>sechashvalue</name> <operator>=</operator> <call><name>compute_keyvalue_hash</name><argument_list>(<argument><expr><name>secType</name></expr></argument>, <argument><expr><name>secValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* no dual write, normal access strategy */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>bdualwrite</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>secColdGroup</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* hot data, only timestamp field can be divided into hot and cold data */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>PARTITION_KEY_IS_TIMESTAMP</name><argument_list>(<argument><expr><name>secType</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsHotData</name><argument_list>(<argument><expr><name>secValue</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><call><name>list_make1_int</name><argument_list>(<argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>keyValueGroup</name></expr></argument>, <argument><expr><name>hashvalue</name> <operator>+</operator> <name>sechashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <return>return <expr><call><name>list_make1_int</name><argument_list>(<argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>secColdGroup</name></expr></argument>, <argument><expr><name>hashvalue</name> <operator>+</operator> <name>sechashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsHotData</name><argument_list>(<argument><expr><name>secValue</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* for first distribute column */</comment>
                <expr_stmt><expr><call><name>get_type_io_data</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>IOFunc_output</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>typalign</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typdelim</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typiofunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typiofunc</name></expr></argument>, <argument><expr><name>dvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* for timestamp */</comment>
                <expr_stmt><expr><call><name>get_type_io_data</name><argument_list>(<argument><expr><name>TIMESTAMPOID</name></expr></argument>, <argument><expr><name>IOFunc_output</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>typalign</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typdelim</name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typiofunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <expr_stmt><expr><name>timestr</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typiofunc</name></expr></argument>,    <argument><expr><name>secValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"key value distribute key:%s timestamp:%s is cold data, but table has no cold group"</literal></expr></argument>, 
                    <argument><expr><name>value</name></expr></argument>, <argument><expr><name>timestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><call><name>list_make1_int</name><argument_list>(<argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>keyValueGroup</name></expr></argument>, <argument><expr><name>hashvalue</name> <operator>+</operator> <name>sechashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>RELATION_ACCESS_READ</name> <operator>==</operator> <name>accessType</name> <operator>||</operator>
            <name>RELATION_ACCESS_READ_FQS</name> <operator>==</operator> <name>accessType</name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><call><name>list_make1_int</name><argument_list>(<argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>keyValueGroup</name></expr></argument>, <argument><expr><name>hashvalue</name> <operator>+</operator> <name>sechashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>keyValueGroup</name></expr></argument>, <argument><expr><name>hashvalue</name> <operator>+</operator> <name>sechashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
            <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>secColdGroup</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>secColdGroup</name></expr></argument>, <argument><expr><name>hashvalue</name> <operator>+</operator> <name>sechashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name>list</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prune hot data when creating scan plan
 */</comment>
<function><type><name>void</name></type> <name>PruneHotData</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>children</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int32</name></type>  <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>  <name>indexnow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>  <name>indexspecial</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>   <name>lock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>   <name>skip_first</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>   <name>skip_temp_first</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>tmnow</name></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>tmspecial</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>                 <name>rel</name>          <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_partition_interval</name></type> <name>routerinfo</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>RelationLocInfo</name>          <modifier>*</modifier></type><name>rd_locator_info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>rel</name>             <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>routerinfo</name>        <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_partitions_info</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rd_locator_info</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_locator_info</name></name></expr>;</expr_stmt>

    <comment type="block">/* we only prune tables with two distribution attributes */</comment>
    <if_stmt><if>if <condition>(<expr><name>InvalidAttrNumber</name> <operator>==</operator> <name><name>rd_locator_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    
    <if_stmt><if>if <condition>(<expr><name>routerinfo</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>lock</name> <operator>=</operator> <name><name>g_AccessCtl</name><operator>-&gt;</operator><name>needlock</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>lock</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ColdAccessLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>        
        
        <if_stmt><if>if<condition>(<expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_type</name></name> <operator>!=</operator> <name>IntervalType_Day</name> 
            <operator>&amp;&amp;</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_type</name></name> <operator>!=</operator> <name>IntervalType_Month</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>tm2timestamp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_ManualHotDataTime</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmnow</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <comment type="line">//tmnow     = GetCurrentTimestamp();    </comment>
        <comment type="block">/* here we use the MAX_NUM_PARTITIONS to get actual offset of the partition */</comment>
        <expr_stmt><expr><name>indexnow</name> <operator>=</operator> <call><name>GetPartitionIndex</name><argument_list>(<argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partstartvalue_ts</name></name></expr></argument>,
                                     <argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_int</name></name></expr></argument>,
                                     <argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_type</name></name></expr></argument>,
                                     <argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partnparts</name></name></expr></argument>,
                                     <argument><expr><name>tmnow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <if_stmt><if>if <condition>(<expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_type</name></name> <operator>==</operator> <name>IntervalType_Day</name> <operator>&amp;&amp;</operator>
            <name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_int</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>fsec_t</name></type> <name>current_sec</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>start_time</name></decl>;</decl_stmt>

            <comment type="block">/* timestamp convert to posix struct */</comment>
            <if_stmt><if>if<condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partstartvalue_ts</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_sec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>skip_first</name> <operator>=</operator> <call><name>is_first_day_from_start</name><argument_list>(<argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_int</name></name></expr></argument>, <argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>g_ManualHotDataTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><literal type="char">'\0'</literal> <operator>!=</operator> <name><name>g_TempHotDate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>skip_temp_first</name> <operator>=</operator> <call><name>is_first_day_from_start</name><argument_list>(<argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_int</name></name></expr></argument>, <argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>g_TempHotDataTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><literal type="char">'\0'</literal> <operator>!=</operator> <name><name>g_TempHotDate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>tm2timestamp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_TempHotDataTime</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmspecial</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><name>indexspecial</name> <operator>=</operator> <call><name>GetPartitionIndex</name><argument_list>(<argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partstartvalue_ts</name></name></expr></argument>,
                                     <argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_int</name></name></expr></argument>,
                                     <argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_type</name></name></expr></argument>,
                                     <argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partnparts</name></name></expr></argument>,
                                     <argument><expr><name>tmspecial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        
        <if_stmt><if>if <condition>(<expr><name>indexnow</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>g_AccessCtl</name><operator>-&gt;</operator><name>colddata</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><literal type="char">'\0'</literal> <operator>==</operator> <name><name>g_TempHotDate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
                <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
                    <comment type="block">/* all data is hot data */</comment>
                    hot_gap = GetHotDataGap(interval);
                    if (indexnow &lt; hot_gap)
                    {
                        <comment type="block">/* clear all tables */</comment>
                        bms_clear(children);
                    }
                    else 
                    {
                        <comment type="block">/* remove hot tables */</comment>
                        for (i = (indexnow - hot_gap + 1); i &lt;= indexnow; i++)
                        {
                            bms_del_member(children, i);
                        }
                    }    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <comment type="block">/* remove hot tables */</comment>
                    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>indexnow</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partnparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>    
                        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>indexnow</name> <operator>&amp;&amp;</operator> <name>skip_first</name></expr>)</condition>
                        <block>{<block_content>
                            <continue>continue;</continue>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><call><name>bms_del_member</name><argument_list>(<argument><expr><name>children</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
                    <comment type="block">/* if we set temp_hot_data, keep only the specified gap on cold datanode */</comment>
                    for (i = 0; i &lt;= indexnow; i++)
                    {
                        if (i != indexspecial)
                        {
                            bms_del_member(children, i);
                        }
                    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <comment type="block">/* remove hot tables */</comment>
                    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>indexspecial</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partnparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>indexspecial</name> <operator>&amp;&amp;</operator> <name>skip_temp_first</name></expr>)</condition>
                        <block>{<block_content>
                            <continue>continue;</continue>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><call><name>bms_del_member</name><argument_list>(<argument><expr><name>children</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>    
                <if_stmt><if>if <condition>(<expr><literal type="char">'\0'</literal> <operator>==</operator> <name><name>g_TempHotDate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
                <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
                    <comment type="block">/* hot nodes */</comment>
                    hot_gap = GetHotDataGap(interval);
                    if (indexnow &lt; hot_gap)
                    {
                        <comment type="block">/* all data is hot*/</comment>                    
                    }
                    else if (indexnow &gt; hot_gap)
                    {
                        <comment type="block">/* remove cold tables */</comment>
                        for (i = 0; i &lt;= (indexnow - hot_gap); i++)
                        {
                            bms_del_member(children, i);
                        }
                    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <comment type="block">/* remove cold tables */</comment>
                    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>indexnow</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>bms_del_member</name><argument_list>(<argument><expr><name>children</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
                    <comment type="block">/* if we set temp_hot_data, keep only the specified gap on hot datanode */</comment>
                    for (i = 0; i &lt;= indexnow; i++)
                    {
                        if (i != indexspecial)
                        {
                            bms_del_member(children, i);
                        }
                    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <comment type="block">/* remove cold tables */</comment>
                    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>indexspecial</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>bms_del_member</name><argument_list>(<argument><expr><name>children</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>lock</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ColdAccessLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>        
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ScanNeedExecute</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>  <name>indexnow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>  <name>indexspecial</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>tmnow</name></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>bool</name></type>   <name>lock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>   <name>skip_first</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>   <name>skip_temp_first</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>tmspecial</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_partition_interval</name></type> <name>routerinfo</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>RelationLocInfo</name>           <modifier>*</modifier></type><name>rd_locator_info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        
    <if_stmt><if>if <condition>(<expr><name>rel</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_DATANODE</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_CHILD</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>    
            <decl_stmt><decl><type><name>Oid</name></type> <name>parent_oid</name> <init>= <expr><call><name>RELATION_GET_PARENT</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Relation</name></type> <name>parent_rel</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>parent_oid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>child_index</name> <init>= <expr><call><name>RelationGetChildIndex</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            
            <expr_stmt><expr><name>routerinfo</name>        <operator>=</operator> <name><name>parent_rel</name><operator>-&gt;</operator><name>rd_partitions_info</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rd_locator_info</name> <operator>=</operator> <name><name>parent_rel</name><operator>-&gt;</operator><name>rd_locator_info</name></name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>rd_locator_info</name> <operator>&amp;&amp;</operator> <call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name><name>rd_locator_info</name><operator>-&gt;</operator><name>secAttrNum</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>child_index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>routerinfo</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>lock</name> <operator>=</operator> <name><name>g_AccessCtl</name><operator>-&gt;</operator><name>needlock</name></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>lock</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ColdAccessLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>    
                    
                    <if_stmt><if>if<condition>(<expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_type</name></name> <operator>==</operator> <name>IntervalType_Day</name> <operator>||</operator>
                       <name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_type</name></name> <operator>==</operator> <name>IntervalType_Month</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><call><name>tm2timestamp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_ManualHotDataTime</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmnow</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
        
                        <expr_stmt><expr><name>indexnow</name> <operator>=</operator> <call><name>GetPartitionIndex</name><argument_list>(<argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partstartvalue_ts</name></name></expr></argument>,
                                                     <argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_int</name></name></expr></argument>,
                                                     <argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_type</name></name></expr></argument>,
                                                     <argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partnparts</name></name></expr></argument>,
                                                     <argument><expr><name>tmnow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><literal type="char">'\0'</literal> <operator>!=</operator> <name><name>g_TempHotDate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><call><name>tm2timestamp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g_TempHotDataTime</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmspecial</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                            
                            <expr_stmt><expr><name>indexspecial</name> <operator>=</operator> <call><name>GetPartitionIndex</name><argument_list>(<argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partstartvalue_ts</name></name></expr></argument>,
                                                     <argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_int</name></name></expr></argument>,
                                                     <argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_type</name></name></expr></argument>,
                                                     <argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partnparts</name></name></expr></argument>,
                                                     <argument><expr><name>tmspecial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>

                        <if_stmt><if>if <condition>(<expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_type</name></name> <operator>==</operator> <name>IntervalType_Day</name> <operator>&amp;&amp;</operator>
                            <name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_int</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>fsec_t</name></type> <name>current_sec</name></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>start_time</name></decl>;</decl_stmt>

                            <comment type="block">/* timestamp convert to posix struct */</comment>
                            <if_stmt><if>if<condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partstartvalue_ts</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_sec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>

                            <expr_stmt><expr><name>skip_first</name> <operator>=</operator> <call><name>is_first_day_from_start</name><argument_list>(<argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_int</name></name></expr></argument>, <argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>g_ManualHotDataTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><literal type="char">'\0'</literal> <operator>!=</operator> <name><name>g_TempHotDate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>skip_temp_first</name> <operator>=</operator> <call><name>is_first_day_from_start</name><argument_list>(<argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_int</name></name></expr></argument>, <argument><expr><name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_time</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>g_TempHotDataTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>

                        <if_stmt><if>if <condition>(<expr><name>indexnow</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if <condition>(<expr><name><name>g_AccessCtl</name><operator>-&gt;</operator><name>colddata</name></name></expr>)</condition>
                            <block>{<block_content>
                                <if_stmt><if>if <condition>(<expr><literal type="char">'\0'</literal> <operator>==</operator> <name><name>g_TempHotDate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
                                <block>{<block_content>
                                    <if_stmt><if>if <condition>(<expr><name>child_index</name> <operator>&gt;=</operator> <name>indexnow</name> <operator>&amp;&amp;</operator> <name>child_index</name> <operator>&lt;</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partnparts</name></name></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                                        <if_stmt><if>if <condition>(<expr><name>child_index</name> <operator>==</operator> <name>indexnow</name> <operator>&amp;&amp;</operator> <name>skip_first</name></expr>)</condition>
                                        <block>{<block_content>
                                            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                                        </block_content>}</block></if></if_stmt>
                                    </block_content>}</block></if></if_stmt>
                                </block_content>}</block></if>
                                <else>else
                                <block>{<block_content>
                                    <if_stmt><if>if <condition>(<expr><name>child_index</name> <operator>&gt;=</operator> <name>indexspecial</name> <operator>&amp;&amp;</operator> <name>child_index</name> <operator>&lt;</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partnparts</name></name></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                                        <if_stmt><if>if <condition>(<expr><name>child_index</name> <operator>==</operator> <name>indexspecial</name> <operator>&amp;&amp;</operator> <name>skip_temp_first</name></expr>)</condition>
                                        <block>{<block_content>
                                            <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                                        </block_content>}</block></if></if_stmt>
                                    </block_content>}</block></if></if_stmt>
                                </block_content>}</block></else></if_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>    
                                <if_stmt><if>if <condition>(<expr><literal type="char">'\0'</literal> <operator>==</operator> <name><name>g_TempHotDate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
                                <block>{<block_content>
                                    <if_stmt><if>if <condition>(<expr><name>child_index</name> <operator>&lt;</operator> <name>indexnow</name></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>
                                </block_content>}</block></if>
                                <else>else
                                <block>{<block_content>
                                    <if_stmt><if>if <condition>(<expr><name>child_index</name> <operator>&lt;</operator> <name>indexspecial</name></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>
                                </block_content>}</block></else></if_stmt>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name>lock</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ColdAccessLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>    
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>parent_rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> 
<name>RangeNeedDualWrite</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attr</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>minValue</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>maxValue</name></decl></parameter>,
                           <parameter><decl><type><name>bool</name></type> <name>equalMin</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>equalMax</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>  <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>  <name>needlock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name>minGap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name>MaxGap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>partitionStrategy</name>        <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>                  <name>rel</name>            <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_partition_interval</name></type> <name>routerinfo</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>scan_status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DualWriteRecord</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>needlock</name> <operator>=</operator> <name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>needlock</name></name></expr>;</expr_stmt>
    
    <comment type="block">/*no one is trying to add dual write logical */</comment>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>entrynum</name></name> <operator>&amp;&amp;</operator> <name>false</name> <operator>==</operator> <name>needlock</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get partition stragegy first */</comment>
    <expr_stmt><expr><name>rel</name>          <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>routerinfo</name>   <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_partitions_info</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>routerinfo</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>attr</name> <operator>==</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partpartkey</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>partitionStrategy</name> <operator>=</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_type</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>partitionStrategy</name> <operator>==</operator> <name>IntervalType_Month</name> <operator>&amp;&amp;</operator>
                <name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_int</name></name> <operator>==</operator> <literal type="number">12</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>partitionStrategy</name> <operator>=</operator> <name>IntervalType_Year</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>minValue</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>minGap</name> <operator>=</operator> <call><name>get_timestamptz_gap</name><argument_list>(<argument><expr><name>minValue</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>maxValue</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>MaxGap</name> <operator>=</operator> <call><name>get_timestamptz_gap</name><argument_list>(<argument><expr><name>maxValue</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>, <argument><expr><name><name>g_DualWriteCtl</name><operator>-&gt;</operator><name>dwhash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>needlock</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>DualWriteLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>item</name> <operator>=</operator> <operator>(</operator><name>DualWriteRecord</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>minValue</name> <operator>&amp;&amp;</operator> <name>maxValue</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>minGap</name> <operator>&lt;=</operator> <name><name>item</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>timeoffset</name></name> <operator>&amp;&amp;</operator>
                <name>MaxGap</name> <operator>&gt;=</operator> <name><name>item</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>timeoffset</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>minValue</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>minGap</name> <operator>&lt;=</operator> <name><name>item</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>timeoffset</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>maxValue</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>MaxGap</name> <operator>&gt;=</operator> <name><name>item</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>timeoffset</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
        <block>{<block_content>
             <expr_stmt><expr><call><name>hash_seq_term</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>    

    <if_stmt><if>if <condition>(<expr><name>needlock</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DualWriteLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>List</name><modifier>*</modifier></type> <name>GetShardMapRangeList</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>coldgroup</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>dvalue</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>secAttr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>secType</name></decl></parameter>, 
                    <parameter><decl><type><name>Datum</name></type> <name>minValue</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>maxValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>equalMin</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>equalMax</name></decl></parameter>, <parameter><decl><type><name>RelationAccessType</name></type> <name>accessType</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives    </comment>
    <decl_stmt><decl><type><name>int16</name></type>         <name>typlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>         <name>typbyval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>         <name>typalign</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>         <name>typdelim</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>          <name>typioparam</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>          <name>typiofunc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>          <name>keyValueGroup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>          <name>keyValueColdGroup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>         <name>hashvalue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>         <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>         <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>         <modifier>*</modifier></type><name>list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>int</name></type>           <name>hot_num</name>          <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>           <name>cold_num</name>          <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name>         <modifier>*</modifier></type><name>hot_data_nodes</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name>         <modifier>*</modifier></type><name>cold_data_nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>         <name>partitionStrategy</name>          <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>                 <name>rel</name>          <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>interval_step</name>            <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type>  <name>start_timestamp</name>          <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_partition_interval</name></type> <name>routerinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>    
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PARTITION_KEY_IS_TIMESTAMP</name><argument_list>(<argument><expr><name>secType</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>    

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_CHILD</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>RELATION_GET_PARENT</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <comment type="block">/* get partition stragegy first */</comment>
    <if_stmt><if>if <condition>(<expr><name>secAttr</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>rel</name>          <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>routerinfo</name>     <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_partitions_info</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>routerinfo</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>secAttr</name> <operator>==</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partpartkey</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>partitionStrategy</name> <operator>=</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_type</name></name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>partitionStrategy</name> <operator>==</operator> <name>IntervalType_Month</name> <operator>&amp;&amp;</operator>
                    <name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_int</name></name> <operator>==</operator> <literal type="number">12</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>partitionStrategy</name> <operator>=</operator> <name>IntervalType_Year</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name>interval_step</name> <operator>=</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partinterval_int</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>start_timestamp</name> <operator>=</operator> <name><name>routerinfo</name><operator>-&gt;</operator><name>partstartvalue_ts</name></name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></else></if_stmt>

    
    <comment type="block">/* check whether the value is key value */</comment>
    <expr_stmt><expr><call><name>get_type_io_data</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>IOFunc_output</name></expr></argument>,
                     <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>,
                     <argument><expr><operator>&amp;</operator><name>typalign</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typdelim</name></expr></argument>,
                     <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typiofunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typiofunc</name></expr></argument>, <argument><expr><name>dvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
    
    <expr_stmt><expr><name>keyValueGroup</name> <operator>=</operator> <call><name>GetKeyValuesGroup</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><name>relation</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>keyValueColdGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>g_EnableDualWrite</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>PARTITION_KEY_IS_TIMESTAMP</name><argument_list>(<argument><expr><name>secType</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>accessType</name> <operator>==</operator> <name>RELATION_ACCESS_UPDATE</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>RangeNeedDualWrite</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>secAttr</name></expr></argument>, <argument><expr><name>minValue</name></expr></argument>, <argument><expr><name>maxValue</name></expr></argument>, <argument><expr><name>equalMin</name></expr></argument>, <argument><expr><name>equalMax</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>keyValueGroup</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>hashvalue</name> <operator>=</operator> <call><name>compute_hash</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>dvalue</name></expr></argument>, <argument><expr><name>LOCATOR_TYPE_SHARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

                    <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>coldgroup</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>coldgroup</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>GetShardNodes</name><argument_list>(<argument><expr><name>keyValueGroup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hot_data_nodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hot_num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>hot_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>                    
                        <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>hot_data_nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hot_data_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>hot_data_nodes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>    

                    <comment type="block">/* all cold */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>keyValueColdGroup</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>GetShardNodes</name><argument_list>(<argument><expr><name>keyValueColdGroup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cold_data_nodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cold_num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cold_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>                    
                            <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>cold_data_nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></for>
                        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cold_data_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>cold_data_nodes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></else></if_stmt>

                <return>return <expr><name>list</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>==</operator> <name>keyValueGroup</name></expr>)</condition>
    <block>{<block_content>    
        <comment type="block">/* no cold data stragey */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>coldgroup</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/* not the key value, use common map strategy */</comment>
        <expr_stmt><expr><name>hashvalue</name> <operator>=</operator> <call><name>compute_hash</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>dvalue</name></expr></argument>, <argument><expr><name>LOCATOR_TYPE_SHARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        
        <comment type="block">/* range value, both cold and hot group */</comment>
        <if_stmt><if>if <condition>(<expr><name>minValue</name> <operator>&amp;&amp;</operator> <name>maxValue</name></expr>)</condition>
        <block>{<block_content>            
            <if_stmt><if>if <condition>(<expr><call><name>IsHotData</name><argument_list>(<argument><expr><name>minValue</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsHotData</name><argument_list>(<argument><expr><name>maxValue</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>                <comment type="block">/* all hot data */</comment>
                <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>                                    
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>IsHotData</name><argument_list>(<argument><expr><name>minValue</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsHotData</name><argument_list>(<argument><expr><name>maxValue</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* all cold data */</comment>
                <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>coldgroup</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if<condition>(<expr><operator>!</operator><call><name>IsHotData</name><argument_list>(<argument><expr><name>minValue</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsHotData</name><argument_list>(<argument><expr><name>maxValue</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* range across cold and hot group */</comment>
                <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>coldgroup</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>                
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name>list</name></expr>;</return>    
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>minValue</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* timestamp &gt;=, all query in hot node */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>IsHotData</name><argument_list>(<argument><expr><name>minValue</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>coldgroup</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
            </block_content>}</block></else></if_stmt>
            <return>return <expr><name>list</name></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>maxValue</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* &lt;= timestamp, both hot and cold need query */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>IsHotData</name><argument_list>(<argument><expr><name>maxValue</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>                
                <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>coldgroup</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* only cold group */</comment>
                <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><call><name>GetNodeIndexByHashValue</name><argument_list>(<argument><expr><name>coldgroup</name></expr></argument>, <argument><expr><name>hashvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <return>return <expr><name>list</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>            

    <comment type="block">/* no cold group */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>keyValueColdGroup</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* secondary sharding map */</comment>
    <expr_stmt><expr><name>hashvalue</name> <operator>=</operator> <call><name>compute_hash</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>dvalue</name></expr></argument>, <argument><expr><name>LOCATOR_TYPE_SHARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    <if_stmt><if>if <condition>(<expr><name>minValue</name> <operator>&amp;&amp;</operator> <name>maxValue</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IsHotData</name><argument_list>(<argument><expr><name>minValue</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsHotData</name><argument_list>(<argument><expr><name>maxValue</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>    
            <comment type="block">/* all hot */</comment>    
            <expr_stmt><expr><call><name>GetShardNodes</name><argument_list>(<argument><expr><name>keyValueGroup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hot_data_nodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hot_num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>hot_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>                    
                <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>hot_data_nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hot_data_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>hot_data_nodes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>                                
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>IsHotData</name><argument_list>(<argument><expr><name>minValue</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsHotData</name><argument_list>(<argument><expr><name>maxValue</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* all cold */</comment>
            <expr_stmt><expr><call><name>GetShardNodes</name><argument_list>(<argument><expr><name>keyValueColdGroup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cold_data_nodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cold_num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cold_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>                    
                <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>cold_data_nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cold_data_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cold_data_nodes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if<condition>(<expr><operator>!</operator><call><name>IsHotData</name><argument_list>(<argument><expr><name>minValue</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsHotData</name><argument_list>(<argument><expr><name>maxValue</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* range across cold and hot group */</comment>
            <comment type="block">/* all hot */</comment>    
            <expr_stmt><expr><call><name>GetShardNodes</name><argument_list>(<argument><expr><name>keyValueGroup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hot_data_nodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hot_num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>hot_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>                    
                <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>hot_data_nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hot_data_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>hot_data_nodes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>    

            <comment type="block">/* all cold */</comment>
            <expr_stmt><expr><call><name>GetShardNodes</name><argument_list>(<argument><expr><name>keyValueColdGroup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cold_data_nodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cold_num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cold_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>                    
                <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>cold_data_nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cold_data_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cold_data_nodes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>list</name></expr>;</return>    
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>minValue</name></expr>)</condition>
    <block>{<block_content>        
        <if_stmt><if>if <condition>(<expr><call><name>IsHotData</name><argument_list>(<argument><expr><name>minValue</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* all hot */</comment>    
            <expr_stmt><expr><call><name>GetShardNodes</name><argument_list>(<argument><expr><name>keyValueGroup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hot_data_nodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hot_num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>hot_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>                    
                <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>hot_data_nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hot_data_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>hot_data_nodes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* all nodes */</comment>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>    
    <if type="elseif">else if <condition>(<expr><name>maxValue</name></expr>)</condition>
    <block>{<block_content>        
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsHotData</name><argument_list>(<argument><expr><name>maxValue</name></expr></argument>, <argument><expr><name>accessType</name></expr></argument>, <argument><expr><name>partitionStrategy</name></expr></argument>, <argument><expr><name>interval_step</name></expr></argument>, <argument><expr><name>start_timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* all cold */</comment>
            <expr_stmt><expr><call><name>GetShardNodes</name><argument_list>(<argument><expr><name>keyValueColdGroup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cold_data_nodes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cold_num</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cold_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>                    
                <expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>cold_data_nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cold_data_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>cold_data_nodes</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* all nodes */</comment>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
