<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/pgxc/plan/planner.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * planner.c
 *
 *      Functions for generating a PGXC style plan.
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group
 * Portions Copyright (c) 2010-2012 Postgres-XC Development Group
 *
 *
 * IDENTIFICATION
 *      $$
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits_fn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/prepare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/locator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/nodemgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/portal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/numeric.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/date.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>contains_temp_tables</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type><name>pgxc_FQS_planner</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>,
                                     <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RemoteQuery</name> <modifier>*</modifier></type><name>pgxc_FQS_create_remote_plan</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
                                                <parameter><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>exec_nodes</name></decl></parameter>,
                                                <parameter><decl><type><name>bool</name></type> <name>is_exec_direct</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CombineType</name></type> <name>get_plan_combine_type</name><parameter_list>(<parameter><decl><type><name>CmdType</name></type> <name>commandType</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>baselocatortype</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
<comment type="block">/*
 * AddRemoteQueryNode
 *
 * Add a Remote Query node to launch on Datanodes.
 * This can only be done for a query a Top Level to avoid
 * duplicated queries on Datanodes.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>AddRemoteQueryNode</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmts</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>, <parameter><decl><type><name>RemoteQueryExecType</name></type> <name>remoteExecType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>stmts</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If node is appplied on EXEC_ON_NONE, simply return the list unchanged */</comment>
    <if_stmt><if>if <condition>(<expr><name>remoteExecType</name> <operator>==</operator> <name>EXEC_ON_NONE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Only a remote Coordinator is allowed to send a query to backend nodes */</comment>
    <if_stmt><if>if <condition>(<expr><name>remoteExecType</name> <operator>==</operator> <name>EXEC_ON_CURRENT</name> <operator>||</operator>
            <operator>(</operator><name>IS_PGXC_LOCAL_COORDINATOR</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>step</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>=</operator> <name>COMBINE_TYPE_SAME</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>queryString</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>step</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>remoteExecType</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * pgxc_direct_planner
 * The routine tries to see if the statement can be completely evaluated on the
 * datanodes. In such cases coordinator is not needed to evaluate the statement,
 * and just acts as a proxy. A statement can be completely shipped to the remote
 * node if every row of the result can be evaluated on a single datanode.
 * For example:
 *
 * Only EXECUTE DIRECT statements are sent directly as of now
 */</comment>
<function><type><name>PlannedStmt</name> <modifier>*</modifier></type>
<name>pgxc_direct_planner</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>query_step</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* build the PlannedStmt result */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Try and set what we can */</comment>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>commandType</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr>;</expr_stmt>

    <comment type="block">/* EXECUTE DIRECT statements have their RemoteQuery node already built when analyzing */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name>
        <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>RemoteQuery</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>!=</operator> <name>EXEC_DIRECT_NONE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>query_step</name> <operator>=</operator> <name>stmt</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>query_step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Optimize multi-node handling */</comment>
    <expr_stmt><expr><name><name>query_step</name><operator>-&gt;</operator><name>read_only</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>planTree</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>query_step</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>query_step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if at least one temporary table is in use
 * in query (and its subqueries)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contains_temp_tables</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>item</argument>, <argument>rtable</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>IsTempTable</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name> <operator>&amp;&amp;</operator>
                 <call><name>contains_temp_tables</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_plan_combine_type - determine combine type
 *
 * COMBINE_TYPE_SAME - for replicated updates
 * COMBINE_TYPE_SUM - for hash and round robin updates
 * COMBINE_TYPE_NONE - for operations where row_count is not applicable
 *
 * return NULL if it is not safe to be done in a single step.
 */</comment>
<function><type><specifier>static</specifier> <name>CombineType</name></type>
<name>get_plan_combine_type</name><parameter_list>(<parameter><decl><type><name>CmdType</name></type> <name>commandType</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>baselocatortype</name></decl></parameter>)</parameter_list>
<block>{<block_content>

    <switch>switch <condition>(<expr><name>commandType</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>CMD_INSERT</name></expr>:</case>
        <case>case <expr><name>CMD_UPDATE</name></expr>:</case>
        <case>case <expr><name>CMD_DELETE</name></expr>:</case>
            <return>return <expr><ternary><condition><expr><name>baselocatortype</name> <operator>==</operator> <name>LOCATOR_TYPE_REPLICATED</name></expr> ?</condition><then>
                    <expr><name>COMBINE_TYPE_SAME</name></expr> </then><else>: <expr><name>COMBINE_TYPE_SUM</name></expr></else></ternary></expr>;</return>

        <default>default:</default>
            <return>return <expr><name>COMBINE_TYPE_NONE</name></expr>;</return>
    </block_content>}</block></switch>
    <comment type="block">/* quiet compiler warning */</comment>
    <return>return <expr><name>COMBINE_TYPE_NONE</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Build up a QueryPlan to execute on.
 *
 * This functions tries to find out whether
 * 1. The statement can be shipped to the Datanode and Coordinator is needed
 *    only as a proxy - in which case, it creates a single node plan.
 * 2. The statement can be evaluated on the Coordinator completely - thus no
 *    query shipping is involved and standard_planner() is invoked to plan the
 *    statement
 * 3. The statement needs Coordinator as well as Datanode for evaluation -
 *    again we use standard_planner() to plan the statement.
 *
 * The plan generated in either of the above cases is returned.
 */</comment>
<function><type><name>PlannedStmt</name> <modifier>*</modifier></type>
<name>pgxc_planner</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <comment type="block">/* see if can ship the query completely */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pgxc_FQS_planner</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* we need Coordinator for evaluation, invoke standard planner */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>standard_planner</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>cursorOptions</name></expr></argument>, <argument><expr><name>boundParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pgxc_FQS_planner
 * The routine tries to see if the statement can be completely evaluated on the
 * Datanodes. In such cases Coordinator is not needed to evaluate the statement,
 * and just acts as a proxy. A statement can be completely shipped to the remote
 * node if every row of the result can be evaluated on a single Datanode.
 * For example:
 *
 * 1. SELECT * FROM tab1; where tab1 is a distributed table - Every row of the
 * result set can be evaluated at a single Datanode. Hence this statement is
 * completely shippable even though many Datanodes are involved in evaluating
 * complete result set. In such case Coordinator will be able to gather rows
 * arisign from individual Datanodes and proxy the result to the client.
 *
 * 2. SELECT count(*) FROM tab1; where tab1 is a distributed table - there is
 * only one row in the result but it needs input from all the Datanodes. Hence
 * this is not completely shippable.
 *
 * 3. SELECT count(*) FROM tab1; where tab1 is replicated table - since result
 * can be obtained from a single Datanode, this is a completely shippable
 * statement.
 *
 * fqs in the name of function is acronym for fast query shipping.
 */</comment>
<function><type><specifier>static</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type>
<name>pgxc_FQS_planner</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursorOptions</name></decl></parameter>, <parameter><decl><type><name>ParamListInfo</name></type> <name>boundParams</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>PlannedStmt</name>        <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PlannerGlobal</name>    <modifier>*</modifier></type><name>glob</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PlannerInfo</name>        <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExecNodes</name>        <modifier>*</modifier></type><name>exec_nodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name>            <modifier>*</modifier></type><name>top_plan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>            <modifier>*</modifier></type><name>tlist</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name>groupOids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Try by-passing standard planner, if fast query shipping is enabled */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>enable_fast_query_shipping</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Do not FQS cursor statements that require backward scrolling */</comment>
    <if_stmt><if>if <condition>(<expr><name>cursorOptions</name> <operator>&amp;</operator> <name>CURSOR_OPT_SCROLL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Do not FQS EXEC DIRECT statements */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><operator>(</operator><name>RemoteQuery</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>!=</operator> <name>EXEC_DIRECT_NONE</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If the query can not be or need not be shipped to the Datanodes, don't
     * create any plan here. standard_planner() will take care of it.
     */</comment>
    <expr_stmt><expr><name>exec_nodes</name> <operator>=</operator> <call><name>pgxc_is_query_shippable</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>exec_nodes</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>glob</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerGlobal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>boundParams</name></name> <operator>=</operator> <name>boundParams</name></expr>;</expr_stmt>
    <comment type="block">/* Create a PlannerInfo data structure, usually it is done for a subquery */</comment>
    <expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name> <operator>=</operator> <name>query</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name> <operator>=</operator> <name>glob</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>query_level</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>planner_cxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>preprocess_rowmarks</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>preprocess_targetlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We decided to ship the query to the Datanode/s, create a RemoteQuery node
     * for the same.
     */</comment>
    <expr_stmt><expr><name>top_plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><call><name>pgxc_FQS_create_remote_plan</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>exec_nodes</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>top_plan</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
    <comment type="block">/*
     * Just before creating the PlannedStmt, do some final cleanup
     * We need to save plan dependencies, so that dropping objects will
     * invalidate the cached plan if it depends on those objects. Table
     * dependencies are available in glob-&gt;relationOids and all other
     * dependencies are in glob-&gt;invalItems. These fields can be retrieved
     * through set_plan_references().
     */</comment>
    <expr_stmt><expr><name>top_plan</name> <operator>=</operator> <call><name>set_plan_references</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>top_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* build the PlannedStmt result */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Try and set what we can, rest must have been zeroed out by makeNode() */</comment>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>commandType</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>canSetTag</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</expr_stmt>

    <comment type="block">/* Set result relations */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>resultRelations</name></name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>planTree</name></name> <operator>=</operator> <name>top_plan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>queryId</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>queryId</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>relationOids</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>relationOids</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>invalItems</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>invalItems</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>rowMarks</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>finalrowmarks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>hasReturning</name></name> <operator>=</operator> <operator>(</operator><name><name>query</name><operator>-&gt;</operator><name>returningList</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RemoteQuery</name> <modifier>*</modifier></type>
<name>pgxc_FQS_create_remote_plan</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>ExecNodes</name> <modifier>*</modifier></type><name>exec_nodes</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_exec_direct</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>query_step</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name>    <modifier>*</modifier></type><name>dummy_rte</name></decl>;</decl_stmt>

    <comment type="block">/* EXECUTE DIRECT statements have their RemoteQuery node already built when analyzing */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_exec_direct</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>, <argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>query_step</name> <operator>=</operator> <operator>(</operator><name>RemoteQuery</name> <operator>*</operator><operator>)</operator><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>query_step</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RemoteQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>query_step</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>=</operator> <name>COMBINE_TYPE_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>query_step</name><operator>-&gt;</operator><name>exec_type</name></name> <operator>=</operator> <name>EXEC_ON_DATANODES</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>query_step</name><operator>-&gt;</operator><name>exec_direct_type</name></name> <operator>=</operator> <name>EXEC_DIRECT_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>query_step</name><operator>-&gt;</operator><name>exec_nodes</name></name> <operator>=</operator> <name>exec_nodes</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>query_step</name><operator>-&gt;</operator><name>exec_nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Deparse query tree to get step query. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>query_step</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * We always finalise aggregates on datanodes for FQS.
         * Use the expressions for ORDER BY or GROUP BY clauses.
         */</comment>
        <expr_stmt><expr><call><name>deparse_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>query_step</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query_step</name><operator>-&gt;</operator><name>exec_nodes</name></name> <operator>&amp;&amp;</operator>
		<name><name>query_step</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>need_rewrite</name></name> <operator>&amp;&amp;</operator>
		<name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>query_step</name><operator>-&gt;</operator><name>forDeparse</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <comment type="block">/* Optimize multi-node handling */</comment>
    <expr_stmt><expr><name><name>query_step</name><operator>-&gt;</operator><name>read_only</name></name> <operator>=</operator> <operator>(</operator><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>hasForUpdate</name></name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query_step</name><operator>-&gt;</operator><name>has_row_marks</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>hasForUpdate</name></name></expr>;</expr_stmt>

    <comment type="block">/* Check if temporary tables are in use in query */</comment>
    <comment type="block">/* PGXC_FQS_TODO: scanning the rtable again for the queries should not be
     * needed. We should be able to find out if the query has a temporary object
     * while finding nodes for the objects. But there is no way we can convey
     * that information here. Till such a connection is available, this is it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>contains_temp_tables</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>query_step</name><operator>-&gt;</operator><name>is_temp</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We need to evaluate some expressions like the ExecNodes-&gt;en_expr at
     * Coordinator, prepare those for evaluation. Ideally we should call
     * preprocess_expression, but it needs PlannerInfo structure for the same
     */</comment>
    <expr_stmt><expr><call><name>fix_opfuncids</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>query_step</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>en_expr</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * PGXCTODO
     * When Postgres runs insert into t (a) values (1); against table
     * defined as create table t (a int, b int); the plan is looking
     * like insert into t (a,b) values (1,null);
     * Later executor is verifying plan, to make sure table has not
     * been altered since plan has been created and comparing table
     * definition with plan target list and output error if they do
     * not match.
     * I could not find better way to generate targetList for pgxc plan
     * then call standard planner and take targetList from the plan
     * generated by Postgres.
     */</comment>
    <expr_stmt><expr><name><name>query_step</name><operator>-&gt;</operator><name>combine_type</name></name> <operator>=</operator> <call><name>get_plan_combine_type</name><argument_list>(
                <argument><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>, <argument><expr><name><name>query_step</name><operator>-&gt;</operator><name>exec_nodes</name><operator>-&gt;</operator><name>baselocatortype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create a dummy RTE for the remote query being created. Append the dummy
     * range table entry to the range table. Note that this modifies the master
     * copy the caller passed us, otherwise e.g EXPLAIN VERBOSE will fail to
     * find the rte the Vars built below refer to. Also create the tuple
     * descriptor for the result of this query from the base_tlist (targetlist
     * we used to generate the remote node query).
     */</comment>
    <expr_stmt><expr><name>dummy_rte</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dummy_rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_REMOTE_DUMMY</name></expr>;</expr_stmt>
    <comment type="block">/* Use a dummy relname... */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_exec_direct</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>dummy_rte</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <literal type="string">"__EXECUTE_DIRECT__"</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>dummy_rte</name><operator>-&gt;</operator><name>relname</name></name>       <operator>=</operator> <literal type="string">"__REMOTE_FQS_QUERY__"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><name><name>dummy_rte</name><operator>-&gt;</operator><name>eref</name></name>           <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"__REMOTE_FQS_QUERY__"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Rest will be zeroed out in makeNode() */</comment>

    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>dummy_rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query_step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name>     <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query_step</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query_step</name><operator>-&gt;</operator><name>base_tlist</name></name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr>;</expr_stmt>

    <return>return <expr><name>query_step</name></expr>;</return>
</block_content>}</block></function>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>make_dummy_remote_rte</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>, <parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>dummy_rte</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>dummy_rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_REMOTE_DUMMY</name></expr>;</expr_stmt>

    <comment type="block">/* use a dummy relname... */</comment>
    <expr_stmt><expr><name><name>dummy_rte</name><operator>-&gt;</operator><name>relname</name></name>         <operator>=</operator> <name>relname</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dummy_rte</name><operator>-&gt;</operator><name>eref</name></name>             <operator>=</operator> <name>alias</name></expr>;</expr_stmt>

    <return>return <expr><name>dummy_rte</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pgxc_make_param
 *
 * Helper function to make a parameter
 */</comment>
<function><type><specifier>static</specifier> <name>Param</name> <modifier>*</modifier></type>
<name>pgxc_make_param</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>param_num</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>param_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Param</name>    <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Parameter values are supplied from outside the plan */</comment>
    <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_EXTERN</name></expr>;</expr_stmt>
    <comment type="block">/* Parameters are numbered from 1 to n */</comment>
    <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <name>param_num</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <name>param_type</name></expr>;</expr_stmt>
    <comment type="block">/* The following members are not required for deparsing */</comment>
    <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramtypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramcollid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <return>return <expr><name>param</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * pgxc_add_param_as_tle
 *
 * Helper function to add a parameter to the target list of the query
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgxc_add_param_as_tle</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>param_num</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>param_type</name></decl></parameter>,
                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>resname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Param</name>        <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TargetEntry</name>    <modifier>*</modifier></type><name>res_tle</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>pgxc_make_param</name><argument_list>(<argument><expr><name>param_num</name></expr></argument>, <argument><expr><name>param_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res_tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>param</name></expr></argument>, <argument><expr><name>param_num</name></expr></argument>, <argument><expr><name>resname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>res_tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pgxc_dml_add_qual_to_query
 *
 * This function adds a qual of the form sys_col_name = $? to a query
 * It is required while adding quals like ctid = $2 or xc_node_id = $3 to DMLs
 *
 * Parameters Description
 * query         : The qual will be added to this query
 * param_num     : The parameter number to use while adding the qual
 * sys_col_attno : Which system column to use for LHS of the = operator
 *               : SelfItemPointerAttributeNumber for ctid
 *               : XC_NodeIdAttributeNumber for xc_node_id
 * varno         : Index of this system column's relation in range table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgxc_dml_add_qual_to_query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>param_num</name></decl></parameter>,
                            <parameter><decl><type><name>AttrNumber</name></type> <name>sys_col_attno</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>param_type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>explicit_cast</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Var</name>            <modifier>*</modifier></type><name>lhs_var</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name>        <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Param</name>        <modifier>*</modifier></type><name>rhs_param</name></decl>;</decl_stmt>

    <comment type="block">/* Make a parameter expr for RHS of the = operator */</comment>
    <expr_stmt><expr><name>rhs_param</name> <operator>=</operator> <call><name>pgxc_make_param</name><argument_list>(<argument><expr><name>param_num</name></expr></argument>, <argument><expr><name>param_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rhs_param</name><operator>-&gt;</operator><name>explicit_cast</name></name> <operator>=</operator> <name>explicit_cast</name></expr>;</expr_stmt>

    <comment type="block">/* Make a system column ref expr for LHS of the = operator */</comment>
    <expr_stmt><expr><name>lhs_var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>varno</name></expr></argument>, <argument><expr><name>sys_col_attno</name></expr></argument>, <argument><expr><name>param_type</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make the new qual sys_column_name = $? */</comment>
    <expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>make_op</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>lhs_var</name></expr></argument>,
                                    <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>rhs_param</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Add the qual to the qual list */</comment>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>lappend</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator><name><name>query</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>,
                                        <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pgxc_rqplan_build_statement
 * Given a RemoteQuery plan generate the SQL statement from Query structure
 * inside it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgxc_rqplan_build_statement</name><parameter_list>(<parameter><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>rqplan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfo</name></type> <name>sql</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>deparse_query</name><argument_list>(<argument><expr><name><name>rqplan</name><operator>-&gt;</operator><name>remote_query</name></name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_finalise_aggs</name></name></expr></argument>,
                    <argument><expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_sortgroup_colno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>rqplan</name><operator>-&gt;</operator><name>sql_statement</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>rqplan</name><operator>-&gt;</operator><name>sql_statement</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>sql_statement</name></name> <operator>=</operator> <name><name>sql</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
    <return>return;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/*
 * pgxc_find_unique_index finds either primary key or unique index
 * defined for the passed relation.
 * Returns the number of columns in the primary key or unique index
 * ZERO means no primary key or unique index is defined.
 * The column attributes of the primary key or unique index are returned
 * in the passed indexed_col_numbers.
 * The function allocates space for indexed_col_numbers, the caller is
 * supposed to free it after use.
 */</comment>
static int
pgxc_find_unique_index(Oid relid, int16 **indexed_col_numbers)
{
    HeapTuple        indexTuple = NULL;
    HeapTuple        indexUnique = NULL;
    Form_pg_index    indexStruct;
    ListCell        *item;
    int                i;

    <comment type="block">/* Get necessary information about relation */</comment>
    Relation rel = relation_open(relid, AccessShareLock);

    foreach(item, RelationGetIndexList(rel))
    {
        Oid            indexoid = lfirst_oid(item);

        indexTuple = SearchSysCache1(INDEXRELID,
                                    ObjectIdGetDatum(indexoid));
        if (!HeapTupleIsValid(indexTuple))
            elog(ERROR, "cache lookup failed for index %u", indexoid);

        indexStruct = (Form_pg_index) GETSTRUCT(indexTuple);

        if (indexStruct-&gt;indisprimary)
        {
            indexUnique = indexTuple;
            ReleaseSysCache(indexTuple);
            break;
        }

        <comment type="block">/* In case we do not have a primary key, use a unique index */</comment>
        if (indexStruct-&gt;indisunique)
        {
            indexUnique = indexTuple;
        }

        ReleaseSysCache(indexTuple);
    }
    relation_close(rel, AccessShareLock);

    if (!indexUnique)
        return 0;

    indexStruct = (Form_pg_index) GETSTRUCT(indexUnique);

    *indexed_col_numbers = palloc0(indexStruct-&gt;indnatts * sizeof(int16));

    <comment type="block">/*
     * Now get the list of PK attributes from the indkey definition (we
     * assume a primary key cannot have expressional elements)
     */</comment>
    for (i = 0; i &lt; indexStruct-&gt;indnatts; i++)
    {
        (*indexed_col_numbers)[i] = indexStruct-&gt;indkey.values[i];
    }
    return indexStruct-&gt;indnatts;
}

<comment type="block">/*
 * is_pk_being_changed determines whether the query is changing primary key
 * or unique index.
 * The attributes of the primary key / unique index and their count is
 * passed to the function along with the query
 * Returns true if the query is changing the primary key / unique index
 * The function takes care of the fact that just having the primary key
 * in set caluse does not mean that it is being changed unless the RHS
 * is different that the LHS of the set caluse i.e. set pk = pk
 * is taken as no change to the column
 */</comment>
static bool
is_pk_being_changed(const Query *query, int16 *indexed_col_numbers, int count)
{<comment type="line">// #lizard forgives</comment>
    ListCell *lc;
    int i;

    if (query == NULL || query-&gt;rtable == NULL || indexed_col_numbers == NULL)
        return false;

    if (query-&gt;commandType != CMD_UPDATE)
        return false;

    for (i = 0; i &lt; count; i++)
    {
        foreach(lc, query-&gt;targetList)
        {
            TargetEntry *tle = (TargetEntry *) lfirst(lc);

            <comment type="block">/* Nothing to do for a junk entry */</comment>
            if (tle-&gt;resjunk)
                continue;

            <comment type="block">/*
             * The TargetEntry::resno is the same as the attribute number
             * of the column being updated, if the attribute number of the
             * column being updated and the attribute of the primary key of
             * the table is same means this set clause entry is updating the
             * primary key column of the target table.
             */</comment>
            if (indexed_col_numbers[i] == tle-&gt;resno)
            {
                Var *v;
                <comment type="block">/*
                 * Although the set caluse contains pk column, but if it is
                 * not being modified, we can use pk for updating the row
                 */</comment>
                if (!IsA(tle-&gt;expr, Var))
                    return true;

                v = (Var *)tle-&gt;expr;
                if (v-&gt;varno == query-&gt;resultRelation &amp;&amp;
                    v-&gt;varattno == tle-&gt;resno)
                {
                    return false;
                }
                else
                {
                    return true;
                }
            }
        }
    }
    return false;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
 * pgxc_add_returning_list
 *
 * This function adds RETURNING var list to the passed remote query node
 * It first pulls all vars from the returning list.
 * It then iterates over all the vars and picks all belonging
 * to the remote relation. The refined vars list is then copied in plan target
 * list as well as base_tlist of remote query.
 *
 * Parameters:
 * rq             : The remote query node to whom the returning
 *                  list is to be added
 * ret_list       : The returning list
 * rel_index      : The index of the concerned relation in RTE list
 */</comment>
<function><type><name>void</name></type>
<name>pgxc_add_returning_list</name><parameter_list>(<parameter><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>rq</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>ret_list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rel_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>        <modifier>*</modifier></type><name>shipableReturningList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>        <modifier>*</modifier></type><name>varlist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* Do we have to add a returning clause or not? */</comment>
    <if_stmt><if>if <condition>(<expr><name>ret_list</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Returning lists cannot contain aggregates and
     * we are not supporting place holders for now
     */</comment>
    <expr_stmt><expr><name>varlist</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>ret_list</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * For every entry in the returning list if the entry belongs to the
     * same table as the one whose index is passed then add it to the
     * shippable returning list
     */</comment>
    <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>varlist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>rel_index</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>shipableReturningList</name> <operator>=</operator> <call><name>add_to_flat_tlist</name><argument_list>(<argument><expr><name>shipableReturningList</name></expr></argument>,
                                                        <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * If the user query had RETURNING clause and here we find that
     * none of the items in the returning list are shippable
     * we intend to send RETURNING NULL to the datanodes
     * Otherwise no rows will be returned from the datanodes
     * and no rows will be projected to the upper nodes in the
     * execution tree.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>shipableReturningList</name> <operator>==</operator> <name>NIL</name> <operator>||</operator>
        <call><name>list_length</name><argument_list>(<argument><expr><name>shipableReturningList</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
        <call><name>list_length</name><argument_list>(<argument><expr><name>ret_list</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>null_const</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>makeNullConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>shipableReturningList</name> <operator>=</operator> <call><name>add_to_flat_tlist</name><argument_list>(<argument><expr><name>shipableReturningList</name></expr></argument>,
                                                <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>null_const</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Copy the refined var list in plan target list as well as
     * base_tlist of the remote query node
     */</comment>
    <expr_stmt><expr><name><name>rq</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>shipableReturningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rq</name><operator>-&gt;</operator><name>base_tlist</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>shipableReturningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
  * pgxc_build_upsert_statement
  *
  *  Construct subquery statement for UPSERT executed on coordinator with unshippable triggers.
  *  We separate UPSERT into SELECT, INSERT and UPDATE, INSERT has already been generated
  *  before, now we have to build the SELECT and UPDATE statement.
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pgxc_build_upsert_statement</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>CmdType</name></type> <name>cmdtype</name></decl></parameter>,
                                    <parameter><decl><type><name>Index</name></type> <name>resultRelationIndex</name></decl></parameter>, <parameter><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>rqplan</name></decl></parameter>,
                                    <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sourceTargetList</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query_to_deparse</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name>    <modifier>*</modifier></type><name>res_rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>    <name>col_att</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>keyCols</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>updatedCols</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfo</name></type> <name>sql_select</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfo</name></type> <name>sql_update</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>relation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>natts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>attnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Var</name>         <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TargetEntry</name>    <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attrname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblRef</name>        <modifier>*</modifier></type><name>target_table_ref</name></decl>;</decl_stmt>

    <comment type="block">/* First construct a reference to an entry in the query's rangetable */</comment>
    <expr_stmt><expr><name>target_table_ref</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* RangeTblRef::rtindex will be the same as indicated by the caller */</comment>
    <expr_stmt><expr><name><name>target_table_ref</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name>resultRelationIndex</name></expr>;</expr_stmt>
    
    <comment type="block">/* init query structure */</comment>
    <expr_stmt><expr><name>query_to_deparse</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>,
                                                   <argument><expr><name>target_table_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>res_rel</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>resultRelationIndex</name></expr></argument>, <argument><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* construct select statement */</comment>
    <expr_stmt><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>ss_param_types</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>sourceTargetList</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* construct select targetlist and whereclause */</comment>
    <macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>sourceTargetList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name> <name>type</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt> 
        <decl_stmt><decl><type><name>TargetEntry</name>    <modifier>*</modifier></type><name>select_tle</name></decl>;</decl_stmt>
        
        <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>col_att</name><operator>++</operator></expr>;</expr_stmt>
        
        <comment type="block">/*
         * Make sure the entry in the source target list belongs to the
         * target table of the DML
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resorigtbl</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>tle</name><operator>-&gt;</operator><name>resorigtbl</name></name> <operator>!=</operator> <name><name>res_rel</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <comment type="block">/* Make sure the column has not been dropped */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>get_rte_attribute_is_dropped</name><argument_list>(<argument><expr><name>res_rel</name></expr></argument>, <argument><expr><name>col_att</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_param_types</name><index>[<expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_num_params</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
            <continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVarFromTargetEntry</name><argument_list>(<argument><expr><name>resultRelationIndex</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>select_tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
                                      <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>,
                                     <argument><expr><call><name>get_attname</name><argument_list>(<argument><expr><name><name>res_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varoattno</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>select_tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* keep param type */</comment>
        <comment type="line">//rqplan-&gt;ss_param_types[rqplan-&gt;ss_num_params++] = type;</comment>
        
        <comment type="block">/*
         * Create the param to be used for where caluse (a = $1 and b = $2 ...)
         * and add it to the quals
         */</comment>
        <comment type="line">//pgxc_dml_add_qual_to_query(query_to_deparse, rqplan-&gt;ss_num_params,</comment>
        <comment type="line">//                           col_att, resultRelationIndex, type, true);</comment>
    </block_content>}</block>

    <comment type="block">/* make 'and' whereclause */</comment>
    <comment type="line">//query_to_deparse-&gt;jointree-&gt;quals = (Node *)make_andclause(</comment>
    <comment type="line">//                            (List *)query_to_deparse-&gt;jointree-&gt;quals);</comment>

    <comment type="block">/* put ctid and xc_node_id into targetlist */</comment>
    <expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>resultRelationIndex</name></expr></argument>,
                  <argument><expr><name>XC_NodeIdAttributeNumber</name></expr></argument>,
                  <argument><expr><name>INT4OID</name></expr></argument>,
                  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                  <argument><expr><name>InvalidOid</name></expr></argument>,
                  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>attrname</name> <operator>=</operator> <literal type="string">"xc_node_id"</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>jf_xc_node_id</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
                          <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                          <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>attrname</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>resultRelationIndex</name></expr></argument>,
                  <argument><expr><name>SelfItemPointerAttributeNumber</name></expr></argument>,
                  <argument><expr><name>TIDOID</name></expr></argument>,
                  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                  <argument><expr><name>InvalidOid</name></expr></argument>,
                  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>attrname</name> <operator>=</operator> <literal type="string">"ctid"</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>jf_ctid</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt><empty_stmt>;</empty_stmt>

    <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
                          <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                          <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>attrname</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>deparse_query</name><argument_list>(<argument><expr><name>query_to_deparse</name></expr></argument>, <argument><expr><name>sql_select</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_finalise_aggs</name></name></expr></argument>,
                    <argument><expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_sortgroup_colno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* add lock tuple for select */</comment>
    <comment type="block">/*
     * Compute lock mode to use.  If columns that are part of the key have not
     * been modified, then we can use a weaker lock, allowing for better
     * concurrency.
     */</comment>
    <expr_stmt><expr><name>updatedCols</name> <operator>=</operator> <name><name>res_rel</name><operator>-&gt;</operator><name>updatedCols</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>res_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>keyCols</name> <operator>=</operator> <call><name>RelationGetIndexAttrBitmap</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
                                         <argument><expr><name>INDEX_ATTR_BITMAP_KEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>keyCols</name></expr></argument>, <argument><expr><name>updatedCols</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>forUpadte</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <comment type="line">//appendStringInfoString(sql_select, " FOR UPDATE");</comment>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>forUpadte</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <comment type="line">//appendStringInfoString(sql_select, " FOR NO KEY UPDATE");</comment>
    
    <if_stmt><if>if <condition>(<expr><name><name>rqplan</name><operator>-&gt;</operator><name>sql_select_base</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>rqplan</name><operator>-&gt;</operator><name>sql_select_base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>sql_select_base</name></name> <operator>=</operator> <name><name>sql_select</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>

    
    <comment type="block">/* construct update statement */</comment>
    <expr_stmt><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>=</operator> <name>resultRelationIndex</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UPDATE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>natts</name> <operator>=</operator> <call><name>get_relnatts</name><argument_list>(<argument><expr><name><name>res_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* natts + 1(xc_node_id) + 1(ctid) */</comment>
	<expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>su_param_types</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>natts</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* Make sure the column has not been dropped */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>get_rte_attribute_is_dropped</name><argument_list>(<argument><expr><name>res_rel</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_param_types</name><index>[<expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_num_params</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
            <continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>get_atttype</name><argument_list>(<argument><expr><name><name>res_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pgxc_add_param_as_tle</name><argument_list>(<argument><expr><name>query_to_deparse</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
                            <argument><expr><name>type</name></expr></argument>,
                            <argument><expr><call><name>get_attname</name><argument_list>(<argument><expr><name><name>res_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* keep param type */</comment>
        <expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>su_param_types</name><index>[<expr><name><name>rqplan</name><operator>-&gt;</operator><name>su_num_params</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>pgxc_dml_add_qual_to_query</name><argument_list>(<argument><expr><name>query_to_deparse</name></expr></argument>, <argument><expr><name><name>rqplan</name><operator>-&gt;</operator><name>su_num_params</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                <argument><expr><name>SelfItemPointerAttributeNumber</name></expr></argument>, <argument><expr><name>resultRelationIndex</name></expr></argument>, <argument><expr><name>TIDOID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>su_param_types</name><index>[<expr><name><name>rqplan</name><operator>-&gt;</operator><name>su_num_params</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>TIDOID</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pgxc_dml_add_qual_to_query</name><argument_list>(<argument><expr><name>query_to_deparse</name></expr></argument>, <argument><expr><name><name>rqplan</name><operator>-&gt;</operator><name>su_num_params</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                    <argument><expr><name>XC_NodeIdAttributeNumber</name></expr></argument>, <argument><expr><name>resultRelationIndex</name></expr></argument>, <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>su_param_types</name><index>[<expr><name><name>rqplan</name><operator>-&gt;</operator><name>su_num_params</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt>

    <comment type="block">/* make 'and' whereclause */</comment>
    <expr_stmt><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>make_andclause</name><argument_list>(
                                <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator><name><name>query_to_deparse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* pgxc_add_returning_list copied returning list in base_tlist */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rqplan</name><operator>-&gt;</operator><name>base_tlist</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>returningList</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>rqplan</name><operator>-&gt;</operator><name>base_tlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>deparse_query</name><argument_list>(<argument><expr><name>query_to_deparse</name></expr></argument>, <argument><expr><name>sql_update</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_finalise_aggs</name></name></expr></argument>,
                <argument><expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_sortgroup_colno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>rqplan</name><operator>-&gt;</operator><name>sql_update</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>rqplan</name><operator>-&gt;</operator><name>sql_update</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>sql_update</name></name> <operator>=</operator> <name><name>sql_update</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>conflict_cols</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>conflict_cols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pgxc_build_dml_statement
 *
 * Construct a Query structure for the query to be fired on the datanodes
 * and deparse it. Fields not set remain memzero'ed as set by makeNode.
 * Following is a description of all members of Query structure
 * when used for deparsing of non FQSed DMLs in XC.
 *
 * querySource        : Can be set to QSRC_ORIGINAL i.e. 0
 * queryId            : Not used in deparsing, can be 0
 * canSetTag        : Not used in deparsing, can be false
 * utilityStmt        : A DML is not a utility statement, keep it NULL
 * resultRelation    : Index of the target relation will be sent by the caller
 * hasAggs            : Our DML won't contain any aggregates in tlist, so false
 * hasWindowFuncs    : Our DML won't contain any window funcs in tlist, so false
 * hasSubLinks        : RemoteQuery does not support subquery, so false
 * hasDistinctOn    : Our DML wont contain any DISTINCT clause, so false
 * hasRecursive        : WITH RECURSIVE wont be specified in our DML, so false
 * hasModifyingCTE    : Our DML will not be in WITH, so false
 * hasForUpdate        : FOR UPDATE/SHARE can be there but not untill we support it
 * cteList            : WITH list will be NULL in our case
 * rtable            : We can set the rtable as being the same as the original query
 * jointree            : In XC we plan non FQSed DML's in such a maner that the
 *                    : DML's to be sent to the datanodes do not contain joins,
 *                    : so the join tree will not contain any thing in fromlist,
 *                    : It will however contain quals and the number of quals
 *                    : will always be fixed to two in case of UPDATE/DELETE &amp;
 *                    : zero in case of an INSERT. The quals will be of the
 *                    : form ctid = $4 or xc_node_id = $5
 * targetList        : For DELETEs it will be NULL
 *                    : For INSERTs it will be a list of params. The number of
 *                    :             params will be the same as the number of
 *                    :             enteries in the source data plan target list
 *                    :             The targetList specifies the VALUES caluse
 *                    :             e.g. INSERT INTO TAB VALUES ($1, $2, ...)
 *                    : For UPDATEs it will be a list of parameters, the number
 *                    :             of parameters will be the same as the number
 *                    :             entries in the original query, however the
 *                    :             parameter numbers will be the one where
 *                    :             the target entry of the original query occurs
 *                    :             in the source data plan target list
 *                    :             The targetList specified the SET clause
 *                    :             e.g. UPDATE tab SET c1 = $3, c2 = $5 ....
 * returningList    : will be provided by pgxc_add_returning_list
 * groupClause        : Our DML won't contin any so NULL.
 * havingQual        : Our DML won't contin any so NULL.
 * windowClause        : Our DML won't contin any so NULL.
 * distinctClause    : Our DML won't contin any so NULL.
 * sortClause        : Our DML won't contin any so NULL.
 * limitOffset        : Our DML won't contin any so NULL.
 * limitCount        : Our DML won't contin any so NULL.
 * rowMarks            : Will be NULL for now, may be used when we provide support
 *                    : for WHERE CURRENT OF.
 * setOperations    : Our DML won't contin any so NULL.
 * constraintDeps    : Our DML won't contin any so NULL.
 * sql_statement    : Original query is not required for deparsing
 * is_local            : Not required for deparsing, keep 0
 * has_to_save_cmd_id    : Not required for deparsing, keep 0
 */</comment>
<function><type><name>void</name></type>
<name>pgxc_build_dml_statement</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>CmdType</name></type> <name>cmdtype</name></decl></parameter>,
                        <parameter><decl><type><name>Index</name></type> <name>resultRelationIndex</name></decl></parameter>, <parameter><decl><type><name>RemoteQuery</name> <modifier>*</modifier></type><name>rqplan</name></decl></parameter>,
                        <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sourceTargetList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>interval</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Query</name>            <modifier>*</modifier></type><name>query_to_deparse</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblRef</name>        <modifier>*</modifier></type><name>target_table_ref</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name>    <modifier>*</modifier></type><name>res_rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>        <modifier>*</modifier></type><name>elt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name>ctid_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name>node_id_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>col_att</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name>                <name>ctid_param_num</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>        <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>            <name>can_use_pk_for_rep_change</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name>            <modifier>*</modifier></type><name>indexed_col_numbers</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    int                index_col_count = 0;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Make sure we are dealing with DMLs */</comment>
    <if_stmt><if>if <condition>(<expr><name>cmdtype</name> <operator>!=</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator>
        <name>cmdtype</name> <operator>!=</operator> <name>CMD_INSERT</name> <operator>&amp;&amp;</operator>
        <name>cmdtype</name> <operator>!=</operator> <name>CMD_DELETE</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_num_params</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>ss_num_params</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>su_num_params</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* First construct a reference to an entry in the query's rangetable */</comment>
    <expr_stmt><expr><name>target_table_ref</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* RangeTblRef::rtindex will be the same as indicated by the caller */</comment>
    <expr_stmt><expr><name><name>target_table_ref</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name>resultRelationIndex</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>query_to_deparse</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>cmdtype</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>=</operator> <name>resultRelationIndex</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>hasUnshippableTriggers</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <comment type="block">/*
     * While copying the range table to the query to deparse make sure we do
     * not copy RTE's of type RTE_JOIN because set_deparse_for_query
     * function expects that each RTE_JOIN is accompanied by a JoinExpr in
     * Query's jointree, which is not true in case of XC's DML planning.
     * We therefore fill the RTE's of type RTE_JOIN with dummy RTE entries.
     * If each RTE of type RTE_JOIN is not accompanied by a corresponding
     * JoinExpr in Query's jointree then set_deparse_for_query crashes
     * when trying to set_join_column_names, because set_using_names did not
     * call identify_join_columns to put valid values in
     * deparse_columns::leftrti &amp; deparse_columns::rightrti
     * Instead of putting a check in set_join_column_names to return in case
     * of invalid values in leftrti or rightrti, it is preferable to change
     * code here and skip RTE's of type RTE_JOIN while copying
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;parse-&gt;rtable</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RangeTblEntry</name>    <modifier>*</modifier></type><name>dummy_rte</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name>            <modifier>*</modifier></type><name>rte_name</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>rte_name</name> <operator>=</operator> <literal type="string">"_DUMMY_RTE_"</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>dummy_rte</name> <operator>=</operator> <call><name>make_dummy_remote_rte</name><argument_list>(<argument><expr><name>rte_name</name></expr></argument>,
                                    <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"_DUMMY_RTE_"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>dummy_rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name>res_rel</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>resultRelationIndex</name></expr></argument>, <argument><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>res_rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* This RTE should appear in FROM clause of the SQL statement constructed */</comment>
    <expr_stmt><expr><name><name>res_rel</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    can_use_pk_for_rep_change = (cmdtype == CMD_UPDATE || cmdtype == CMD_DELETE) &amp;&amp;
                IsRelationReplicated(GetRelationLocInfo(res_rel-&gt;relid));

    if (can_use_pk_for_rep_change)
    {
        index_col_count = pgxc_find_unique_index(res_rel-&gt;relid,
                                                &amp;indexed_col_numbers);
        if (index_col_count &lt;= 0)
            can_use_pk_for_rep_change = false;

        if (can_use_pk_for_rep_change)
        {
            if (is_pk_being_changed(root-&gt;parse, indexed_col_numbers,
                                    index_col_count))
            {
                can_use_pk_for_rep_change = false;
            }
        }
    }

    rqplan-&gt;rq_use_pk_for_rep_change = can_use_pk_for_rep_change;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * Prepare a param list for INSERT queries
     * While doing so note the position of ctid, xc_node_id in source data
     * plan's target list provided by the caller.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>cmdtype</name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_param_types</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>sourceTargetList</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <macro><name>foreach</name><argument_list>(<argument>elt</argument>, <argument>sourceTargetList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type> <name>type</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name>    <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>elt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>col_att</name><operator>++</operator></expr>;</expr_stmt>

        <comment type="block">/* The position of ctid/xc_node_id is not required for INSERT */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>can_use_pk_for_rep_change</name> <operator>&amp;&amp;</operator> <name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name>cmdtype</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator> <name>cmdtype</name> <operator>==</operator> <name>CMD_DELETE</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>resultRelationIndex</name> <operator>||</operator> <name>interval</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>XC_NodeIdAttributeNumber</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>node_id_found</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Duplicate node_ids not expected in source target list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>node_id_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>SelfItemPointerAttributeNumber</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>ctid_found</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Duplicate ctids not expected in source target list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><name>ctid_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

            </block_content>}</block></if></if_stmt>

            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Make sure the entry in the source target list belongs to the
         * target table of the DML
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resorigtbl</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>tle</name><operator>-&gt;</operator><name>resorigtbl</name></name> <operator>!=</operator> <name><name>res_rel</name><operator>-&gt;</operator><name>relid</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>cmdtype</name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Make sure the column has not been dropped */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>get_rte_attribute_is_dropped</name><argument_list>(<argument><expr><name>res_rel</name></expr></argument>, <argument><expr><name>col_att</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_param_types</name><index>[<expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_num_params</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                <continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Create the param to be used for VALUES caluse ($1, $2 ...)
             * and add it to the query target list
             */</comment>
            <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pgxc_add_param_as_tle</name><argument_list>(<argument><expr><name>query_to_deparse</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>,
                                    <argument><expr><name>type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* keep param type */</comment>
            <expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_param_types</name><index>[<expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_num_params</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <if_stmt><if>if<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>onConflict</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>onConflict</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>onConflict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * In XC we will update *all* the table attributes to reduce code
     * complexity in finding the columns being updated, it works whether
     * we have before row triggers defined on the table or not.
     * The code complexity arises for the case of a table with child tables,
     * where columns are added to parent using ALTER TABLE. The attribute
     * number of the added column is different in parnet and child table.
     * In this case we first have to use TargetEntry::resno to find the name
     * of the column being updated in parent table, and then find the attribute
     * number of that particular column in the child. This makes code complex.
     * In comaprison if we choose to update all the columns of the table
     * irrespective of the columns being updated, the code becomes simple
     * and easy to read.
     * Performance comparison between the two approaches (updating all columns
     * and updating only the columns that were in the target list) shows that
     * both the approaches give similar TPS in hour long runs of DBT1.
     * In XC UPDATE will look like :
     * UPDATE ... SET att1 = $1, att1 = $2, .... attn = $n WHERE ctid = $(n+1)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>cmdtype</name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type>         <name>type</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>natts</name> <init>= <expr><call><name>get_relnatts</name><argument_list>(<argument><expr><name><name>res_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>attnum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>         <name>appendix</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* count origin attrs and ctid, nodeid */</comment>
		<expr_stmt><expr><name>appendix</name> <operator>+=</operator> <ternary><condition><expr><name>node_id_found</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>appendix</name> <operator>+=</operator> <ternary><condition><expr><name>ctid_found</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_param_types</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>natts</name> <operator>+</operator> <name>appendix</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="block">/* Make sure the column has not been dropped */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>get_rte_attribute_is_dropped</name><argument_list>(<argument><expr><name>res_rel</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_param_types</name><index>[<expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_num_params</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                <continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>get_atttype</name><argument_list>(<argument><expr><name><name>res_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pgxc_add_param_as_tle</name><argument_list>(<argument><expr><name>query_to_deparse</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>,
                                <argument><expr><name>type</name></expr></argument>,
                                <argument><expr><call><name>get_attname</name><argument_list>(<argument><expr><name><name>res_rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* keep param type */</comment>
            <expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_param_types</name><index>[<expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_num_params</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/*
         * The data row generated for BIND has all required values, plus NULL
         * values for attributes that are not SET. The first n parameters are
         * the n table attributes, followed by ctid and optionally node_id. So
         * we know that the ctid has to be n + 1.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>can_use_pk_for_rep_change</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>ctid_param_num</name> <operator>=</operator> <name>natts</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>cmdtype</name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>can_use_pk_for_rep_change</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Since there is no data to update, the first param is going to be
             * ctid.
             */</comment>
            <expr_stmt><expr><name>ctid_param_num</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Add quals like ctid = $4 AND xc_node_id = $6 to the UPDATE/DELETE query */</comment>
    <if_stmt><if>if <condition>(<expr><name>cmdtype</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator> <name>cmdtype</name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If it is not replicated, we can use CTID, otherwise we need
         * to use a defined primary key
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>can_use_pk_for_rep_change</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ctid_found</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Source data plan's target list does not contain ctid colum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* delete just need ctid and xc_node_id */</comment>
            <if_stmt><if>if <condition>(<expr><name>cmdtype</name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_param_types</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/*
             * Beware, the ordering of ctid and node_id is important ! ctid should
             * be followed by node_id, not vice-versa, so as to be consistent with
             * the data row to be generated while binding the parameters for the
             * update statement.
             */</comment>
            <expr_stmt><expr><call><name>pgxc_dml_add_qual_to_query</name><argument_list>(<argument><expr><name>query_to_deparse</name></expr></argument>, <argument><expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_num_params</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                            <argument><expr><name>SelfItemPointerAttributeNumber</name></expr></argument>, <argument><expr><name>resultRelationIndex</name></expr></argument>, <argument><expr><name>TIDOID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_param_types</name><index>[<expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_num_params</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>TIDOID</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>node_id_found</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pgxc_dml_add_qual_to_query</name><argument_list>(<argument><expr><name>query_to_deparse</name></expr></argument>, <argument><expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_num_params</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
                                <argument><expr><name>XC_NodeIdAttributeNumber</name></expr></argument>, <argument><expr><name>resultRelationIndex</name></expr></argument>, <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_param_types</name><index>[<expr><name><name>rqplan</name><operator>-&gt;</operator><name>rq_num_params</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
        else
        {
            <comment type="block">/*
             * Add all the columns of the primary key or unique index
             * in the where clause of update / delete on the replicated table
             */</comment>
            int i;
            for (i = 0; i &lt; index_col_count; i++)
            {
                int            pkattno = indexed_col_numbers[i];

                col_att = 0;
                foreach(elt, sourceTargetList)
                {
                    TargetEntry    *tle = lfirst(elt);
                    Var *v;
            
                    col_att++;
            
                    v = (Var *)tle-&gt;expr;
        
                    if (v-&gt;varno == resultRelationIndex &amp;&amp;
                        v-&gt;varattno == pkattno)
                    {
                        break;
                    }
                }

                pgxc_dml_add_qual_to_query(query_to_deparse, col_att,
                            pkattno, resultRelationIndex, INT4OID, false);
            }
        }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>make_andclause</name><argument_list>(
                        <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator><name><name>query_to_deparse</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>indexed_col_numbers</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>indexed_col_numbers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* pgxc_add_returning_list copied returning list in base_tlist */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rqplan</name><operator>-&gt;</operator><name>base_tlist</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>query_to_deparse</name><operator>-&gt;</operator><name>returningList</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>rqplan</name><operator>-&gt;</operator><name>base_tlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>rqplan</name><operator>-&gt;</operator><name>remote_query</name></name> <operator>=</operator> <name>query_to_deparse</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pgxc_rqplan_build_statement</name><argument_list>(<argument><expr><name>rqplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
      * At last, we have to check if it is insert... on conflict do update.
      * If so, we need to generate select and update statement for coordinator
      * to exec UPSERT.
      */</comment>
    <if_stmt><if>if <condition>(<expr><name>cmdtype</name> <operator>==</operator> <name>CMD_INSERT</name> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>onConflict</name></name> <operator>&amp;&amp;</operator>
        <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pgxc_build_upsert_statement</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>cmdtype</name></expr></argument>, <argument><expr><name>resultRelationIndex</name></expr></argument>, 
                                    <argument><expr><name>rqplan</name></expr></argument>, <argument><expr><name>sourceTargetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pgxc_set_en_expr
 * Try to find the expression of distribution column to calculate node at plan execution
 */</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type>
<name>pgxc_set_en_expr</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tableoid</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>resultRelationIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTuple</name></type> <name>tp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>partAttrTup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Var</name>    <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RelationLocInfo</name> <modifier>*</modifier></type><name>rel_loc_info</name></decl>;</decl_stmt>

    <comment type="block">/* Get location info of the target table */</comment>
    <expr_stmt><expr><name>rel_loc_info</name> <operator>=</operator> <call><name>GetRelationLocInfo</name><argument_list>(<argument><expr><name>tableoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rel_loc_info</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
         <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * For hash/modulo distributed tables, the target node must be selected
     * at the execution time based on the partition column value.
     *
     * For round robin distributed tables, tuples must be divided equally
     * between the nodes.
     *
     * For replicated tables, tuple must be inserted in all the Datanodes
     *
     * XXX Need further testing for replicated and round-robin tables
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>!=</operator> <name>LOCATOR_TYPE_HASH</name> <operator>&amp;&amp;</operator>
        <name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>!=</operator> <name>LOCATOR_TYPE_MODULO</name>
        <operator>&amp;&amp;</operator> <name><name>rel_loc_info</name><operator>-&gt;</operator><name>locatorType</name></name> <operator>!=</operator> <name>LOCATOR_TYPE_SHARD</name></expr>
        )</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
                        <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>tableoid</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>partAttrNum</name></name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>partAttrTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create a Var for the distribution column and set it for
     * execution time evaluation of target node. ExecEvalVar() picks
     * up values from ecxt_scantuple if Var does not refer either OUTER
     * or INNER varno. We utilize that mechanism to pick up values from
     * the tuple returned by the current plan node
     */</comment>
    <expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>resultRelationIndex</name></expr></argument>,
                  <argument><expr><name><name>rel_loc_info</name><operator>-&gt;</operator><name>partAttrNum</name></name></expr></argument>,
                  <argument><expr><name><name>partAttrTup</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
                  <argument><expr><name><name>partAttrTup</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
                  <argument><expr><name><name>partAttrTup</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
                  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
Expr *
pgxc_set_sec_en_expr(Oid tableoid, Index resultRelationIndex)
{
    HeapTuple tp;
    Form_pg_attribute partAttrTup;
    Var    *var;
    RelationLocInfo *rel_loc_info;

    <comment type="block">/* Do not have distribute column now */</comment>
    return NULL;

    <comment type="block">/* Get location info of the target table */</comment>
    rel_loc_info = GetRelationLocInfo(tableoid);
    if (rel_loc_info == NULL)
         return NULL;

    <comment type="block">/*
     * For hash/modulo distributed tables, the target node must be selected
     * at the execution time based on the partition column value.
     *
     * For round robin distributed tables, tuples must be divided equally
     * between the nodes.
     *
     * For replicated tables, tuple must be inserted in all the Datanodes
     *
     * XXX Need further testing for replicated and round-robin tables
     */</comment>
    if (rel_loc_info-&gt;locatorType != LOCATOR_TYPE_HASH &amp;&amp;
        rel_loc_info-&gt;locatorType != LOCATOR_TYPE_MODULO
        &amp;&amp; rel_loc_info-&gt;locatorType != LOCATOR_TYPE_SHARD
        )
        return NULL;

    if (InvalidAttrNumber == rel_loc_info-&gt;secAttrNum)
    {
        return NULL;
    }
    tp = SearchSysCache(ATTNUM,
                        ObjectIdGetDatum(tableoid),
                        Int16GetDatum(rel_loc_info-&gt;secAttrNum),
                        0, 0);
    partAttrTup = (Form_pg_attribute) GETSTRUCT(tp);

    <comment type="block">/*
     * Create a Var for the distribution column and set it for
     * execution time evaluation of target node. ExecEvalVar() picks
     * up values from ecxt_scantuple if Var does not refer either OUTER
     * or INNER varno. We utilize that mechanism to pick up values from
     * the tuple returned by the current plan node
     */</comment>
    var = makeVar(resultRelationIndex,
                  rel_loc_info-&gt;secAttrNum,
                  partAttrTup-&gt;atttypid,
                  partAttrTup-&gt;atttypmod,
                  partAttrTup-&gt;attcollation,
                  0);
    ReleaseSysCache(tp);

    return (Expr *) var;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
