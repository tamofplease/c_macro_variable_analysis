<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/pgxc/nodemgr/nodemgr.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodemgr.c
 *      Routines to support manipulation of the pgxc_node catalog
 *      Support concerns CREATE/ALTER/DROP on NODE object.
 *
 * Copyright (c) 2010-2012 Postgres-XC Development Group
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/locator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/nodemgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/groupmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_shard_map.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>bool</name></type> <name>enable_multi_cluster</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>enable_multi_cluster_print</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * How many times should we try to find a unique indetifier
 * in case hash of the node name comes out to be duplicate
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_TRIES_FOR_NID</name></cpp:macro>    <cpp:value>200</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>generate_node_id</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>node_name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>count_coords_datanodes</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_coord</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_dns</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type>  <name>PgxcCheckNodeValid</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>clustername</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>  <name>ValidateCreateGtmNode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>  <name>ValidateAlterGtmNode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * GUC parameters.
 * Shared memory block can not be resized dynamically, so we should have some
 * limits set at startup time to calculate amount of shared memory to store
 * node table. Nodes can be added to running cluster until that limit is reached
 * if cluster needs grow beyond the configuration value should be changed and
 * cluster restarted.
 */</comment>
<comment type="block">/* Global number of nodes. Point to a shared memory block */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name>       <modifier>*</modifier></type><name>shmemNumCoords</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name>       <modifier>*</modifier></type><name>shmemNumDataNodes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name>       <modifier>*</modifier></type><name>shmemNumSlaveDataNodes</name></decl>;</decl_stmt>

<comment type="block">/* Shared memory tables of node definitions */</comment>
<decl_stmt><decl><type><name>NodeDefinition</name> <modifier>*</modifier></type><name>coDefs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NodeDefinition</name> <modifier>*</modifier></type><name>dnDefs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NodeDefinition</name> <modifier>*</modifier></type><name>sdnDefs</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>PGXCNodeHost</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>g_TbasePlane</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* HashTable key: nodeoid  value: position of coDefs/dnDefs */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>g_NodeDefHashTab</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>Oid</name></type>            <name>nodeoid</name></decl>;</decl_stmt>
}</block></struct></type> <name>NodeDefLookupTag</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{    
    <decl_stmt><decl><type><name>NodeDefLookupTag</name></type>  <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>                 <name>nodeDefIndex</name></decl>;</decl_stmt>    <comment type="block">/* Associated into  coDefs or dnDefs index */</comment>
}</block></struct></type> <name>NodeDefLookupEnt</name>;</typedef>



<comment type="block">/*
 * NodeTablesInit
 *    Initializes shared memory tables of Coordinators and Datanodes.
 */</comment>
<function><type><name>void</name></type>
<name>NodeTablesShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Initialize the table of Coordinators: first sizeof(int) bytes are to
     * store actual number of Coordinators, remaining data in the structure is
     * array of NodeDefinition that can contain up to TBASE_MAX_COORDINATOR_NUMBER entries.
     * That is a bit weird and probably it would be better have these in
     * separate structures, but I am unsure about cost of having shmem structure
     * containing just single integer.
     */</comment>
    <expr_stmt><expr><name>shmemNumCoords</name> <operator>=</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Coordinator Table"</literal></expr></argument>,
                                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
                                    <sizeof>sizeof<argument_list>(<argument><expr><name>NodeDefinition</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>TBASE_MAX_COORDINATOR_NUMBER</name></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Have coDefs pointing right behind shmemNumCoords */</comment>
    <expr_stmt><expr><name>coDefs</name> <operator>=</operator> <operator>(</operator><name>NodeDefinition</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>shmemNumCoords</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Mark it empty upon creation */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>shmemNumCoords</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <comment type="block">/* Mark nodeishealthy true at init time for all */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TBASE_MAX_COORDINATOR_NUMBER</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>coDefs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeishealthy</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Same for Datanodes */</comment>
    <expr_stmt><expr><name>shmemNumDataNodes</name> <operator>=</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Datanode Table"</literal></expr></argument>,
                                   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
                                       <sizeof>sizeof<argument_list>(<argument><expr><name>NodeDefinition</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>TBASE_MAX_DATANODE_NUMBER</name></expr></argument>,
                                   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Have dnDefs pointing right behind shmemNumDataNodes */</comment>
    <expr_stmt><expr><name>dnDefs</name> <operator>=</operator> <operator>(</operator><name>NodeDefinition</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>shmemNumDataNodes</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Mark it empty upon creation */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>shmemNumDataNodes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <comment type="block">/* Mark nodeishealthy true at init time for all */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TBASE_MAX_DATANODE_NUMBER</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>dnDefs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeishealthy</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>

    
    <comment type="block">/* Same for Datanodes */</comment>
    <expr_stmt><expr><name>shmemNumSlaveDataNodes</name> <operator>=</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Slave Datanode Table"</literal></expr></argument>,
                                   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
                                       <sizeof>sizeof<argument_list>(<argument><expr><name>NodeDefinition</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>TBASE_MAX_DATANODE_NUMBER</name></expr></argument>,
                                   <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Have dnDefs pointing right behind shmemNumSlaveDataNodes */</comment>
    <expr_stmt><expr><name>sdnDefs</name> <operator>=</operator> <operator>(</operator><name>NodeDefinition</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>shmemNumSlaveDataNodes</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* Mark it empty upon creation */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>shmemNumSlaveDataNodes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <comment type="block">/* Mark nodeishealthy true at init time for all */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>TBASE_MAX_DATANODE_NUMBER</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>sdnDefs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeishealthy</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><name>PGXCNodeHost</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"PGXC Node Host"</literal></expr></argument>,
                                            <argument><expr><name>NAMEDATALEN</name></expr></argument>,
                                           <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>PGXCNodeHost</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>g_TbasePlane</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"TBase Plane"</literal></expr></argument>,
											<argument><expr><name>NAMEDATALEN</name></expr></argument>,
								            <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>g_TbasePlane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>NodeDefHashTabShmemInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>NodeDefHashTabShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASHCTL</name></type>        <name>info</name></decl>;</decl_stmt>
    
    <comment type="block">/* Init hash table for nodeoid to dnDefs/coDefs lookup */</comment>
    <expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name>   <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NodeDefLookupTag</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NodeDefLookupEnt</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info</name><operator>.</operator><name>hash</name></name>        <operator>=</operator> <name>tag_hash</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>g_NodeDefHashTab</name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"NodeDef info look up"</literal></expr></argument>,
                                  <argument><expr><name>TBASE_MAX_COORDINATOR_NUMBER</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>TBASE_MAX_DATANODE_NUMBER</name></expr></argument>, 
                                  <argument><expr><name>TBASE_MAX_COORDINATOR_NUMBER</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <name>TBASE_MAX_DATANODE_NUMBER</name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
                                  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator> <name>HASH_FIXED_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_NodeDefHashTab</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid shmem status when creating node def hash "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * NodeHashTableShmemSize
 *    Get the size of Node Definition hash table
 */</comment>
<function><type><name>Size</name></type> 
<name>NodeHashTableShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type> <name>size</name></decl>;</decl_stmt>

    <comment type="block">/* hash table, here just double the element size, in case of memory corruption */</comment>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><operator>(</operator><name>TBASE_MAX_DATANODE_NUMBER</name><operator>+</operator><name>TBASE_MAX_COORDINATOR_NUMBER</name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr></argument> , <argument><expr><call><name>MAXALIGN64</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NodeDefLookupEnt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * NodeTablesShmemSize
 *    Get the size of shared memory dedicated to node definitions
 */</comment>
<function><type><name>Size</name></type>
<name>NodeTablesShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type> <name>co_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type> <name>dn_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type> <name>dn_slave_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type> <name>total_size</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>co_size</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NodeDefinition</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>TBASE_MAX_COORDINATOR_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>co_size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>co_size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dn_size</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NodeDefinition</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>TBASE_MAX_DATANODE_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dn_size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>dn_size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dn_slave_size</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NodeDefinition</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>TBASE_MAX_DATANODE_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dn_slave_size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>dn_slave_size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>total_size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>co_size</name></expr></argument>, <argument><expr><name>dn_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>total_size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>total_size</name></expr></argument>, <argument><expr><name>dn_slave_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>total_size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>total_size</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>total_size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>total_size</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>total_size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check list of options and return things filled.
 * This includes check on option values.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_node_options</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>node_name</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>node_host</name></decl></parameter>,
            <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>node_port</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>node_type</name></decl></parameter>,
            <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_primary</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_preferred</name></decl></parameter>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            ,<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>node_group</name></decl></parameter>,
            <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>node_cluster_name</name></decl></parameter>,
            <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>alter</name></decl></parameter>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            )</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>    
    <decl_stmt><decl><type><name>bool</name></type>        <name>set_node_primary_option</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>set_node_host_option</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>set_node_port_option</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>options</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"No options specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Filter options */</comment>
    <macro><name>foreach</name><argument_list>(<argument>option</argument>, <argument>options</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"port"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>node_port</name> <operator>=</operator> <call><name>defGetTypeLength</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>            
            <expr_stmt><expr><name>set_node_host_option</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>node_port</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <operator>*</operator><name>node_port</name></expr></argument> &gt;</argument_list></name> <literal type="number">65535</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"port value is out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"host"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>node_host</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>            
            <expr_stmt><expr><name>set_node_port_option</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type_loc</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>type_loc</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type_loc</name></expr></argument>, <argument><expr><literal type="string">"coordinator"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                <call><name>strcmp</name><argument_list>(<argument><expr><name>type_loc</name></expr></argument>, <argument><expr><literal type="string">"datanode"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal>     <operator>&amp;&amp;</operator>
                <call><name>strcmp</name><argument_list>(<argument><expr><name>type_loc</name></expr></argument>, <argument><expr><literal type="string">"gtm"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type value is incorrect, specify 'coordinator or 'datanode' or 'gtm'"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type_loc</name></expr></argument>, <argument><expr><literal type="string">"coordinator"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>node_type</name> <operator>=</operator> <name>PGXC_NODE_COORDINATOR</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type_loc</name></expr></argument>, <argument><expr><literal type="string">"datanode"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>node_type</name> <operator>=</operator> <name>PGXC_NODE_DATANODE</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>type_loc</name></expr></argument>, <argument><expr><literal type="string">"gtm"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>node_type</name> <operator>=</operator> <name>PGXC_NODE_GTM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"primary"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>is_primary</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>            
            <expr_stmt><expr><name>set_node_primary_option</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"preferred"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>is_preferred</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"group"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>node_group</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"cluster"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>node_cluster_name</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"alter"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>alter</name> <operator>=</operator> <call><name>defGetBoolean</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"incorrect option: %s"</literal></expr></argument>, <argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>

    <comment type="block">/* A primary node has to be a Datanode or Gtm */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>is_primary</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>node_type</name> <operator>!=</operator> <name>PGXC_NODE_DATANODE</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>node_type</name> <operator>!=</operator> <name>PGXC_NODE_GTM</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC node %s: cannot be a primary node, it has to be a Datanode or GTM"</literal></expr></argument>,
                        <argument><expr><name>node_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* A preferred node has to be a Datanode */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>is_preferred</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>node_type</name> <operator>!=</operator> <name>PGXC_NODE_DATANODE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC node %s: cannot be a preferred node, it has to be a Datanode"</literal></expr></argument>,
                        <argument><expr><name>node_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Node type check */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>node_type</name> <operator>==</operator> <name>PGXC_NODE_NONE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC node %s: Node type not specified"</literal></expr></argument>,
                        <argument><expr><name>node_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XCP</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>node_type</name> <operator>==</operator> <name>PGXC_NODE_DATANODE</name> <operator>&amp;&amp;</operator> <name>NumDataNodes</name> <operator>&gt;=</operator> <name>TBASE_MAX_DATANODE_NUMBER</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Too many datanodes, current value of max_datanodes is %d"</literal></expr></argument>,
                        <argument><expr><name>TBASE_MAX_DATANODE_NUMBER</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>PGXC_NODE_GTM</name> <operator>==</operator> <operator>*</operator><name>node_type</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Currently only accept master gtm, so set to  */</comment>
        <if_stmt><if>if <condition>(<expr><name>set_node_primary_option</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>false</name> <operator>==</operator> <operator>*</operator><name>is_primary</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC node %s: only master gtm accepted"</literal></expr></argument>,
                        <argument><expr><name>node_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* set gtm as primary by default */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>set_node_primary_option</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>is_primary</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <operator>*</operator><name>node_host</name> <operator>||</operator> <literal type="number">0</literal> <operator>==</operator> <operator>*</operator><name>node_port</name> <operator>||</operator> <operator>!</operator><name>set_node_host_option</name> <operator>||</operator> <operator>!</operator><name>set_node_port_option</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC node %s: host, port should be specified"</literal></expr></argument>,
                        <argument><expr><name>node_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <operator>*</operator><name>node_group</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC node %s: gtm should not specify group"</literal></expr></argument>,
                        <argument><expr><name>node_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_node_cluster_name</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>node_cluster_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>options</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"No options specified"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Filter options */</comment>
    <macro><name>foreach</name><argument_list>(<argument>option</argument>, <argument>options</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"cluster"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>node_cluster_name</name> <operator>=</operator> <call><name>defGetString</name><argument_list>(<argument><expr><name>defel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * generate_node_id
 *
 * Given a node name compute its hash to generate the identifier
 * If the hash comes out to be duplicate , try some other values
 * Give up after a few tries
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>generate_node_id</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>node_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>node_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>inc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Compute node identifier by computing hash of node name */</comment>
    <expr_stmt><expr><name>node_id</name> <operator>=</operator> <call><name>hash_any</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>node_name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check if the hash is near the overflow limit, then we will
     * decrement it , otherwise we will increment
     */</comment>
    <expr_stmt><expr><name>inc</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><name>node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <name>UINT_MAX</name> <operator>-</operator> <name>MAX_TRIES_FOR_NID</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>inc</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Check if the identifier is clashing with an existing one,
     * and if it is try some other
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_TRIES_FOR_NID</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PGXCNODEIDENTIFIER</name></expr></argument>, <argument><expr><name>node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>tup</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><name>node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>inc</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>node_id</name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * This has really few chances to happen, but inform backend that node
     * has not been registered correctly in this case.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>MAX_TRIES_FOR_NID</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Please choose different node name."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Name \"%s\" produces a duplicate identifier node_name"</literal></expr></argument>,
                           <argument><expr><name>node_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>node_id</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *  cmp_nodes
 *
 *  Compare the Oids of two XC nodes
 *  to sort them in ascending order by their names
 * --------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_nodes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type> <name>n1</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator><name>p1</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>n2</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator><name>p2</name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>get_pgxc_nodename</name><argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Count the number of coordinators and datanodes configured so far.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>count_coords_datanodes</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_coord</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_dns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>coordCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>dnCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>   <name>tuple</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>SnapshotSelf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pgxc_node</name></type>  <name>nodeForm</name> <init>= <expr><operator>(</operator><name>Form_pgxc_node</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Take definition for given node type */</comment>
        <switch>switch <condition>(<expr><name><name>nodeForm</name><operator>-&gt;</operator><name>node_type</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>PGXC_NODE_COORDINATOR</name></expr>:</case>
                <expr_stmt><expr><name>coordCount</name><operator>++</operator></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>PGXC_NODE_DATANODE</name></expr>:</case>
                <expr_stmt><expr><name>dnCount</name><operator>++</operator></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>num_coord</name> <operator>=</operator> <name>coordCount</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>num_dns</name> <operator>=</operator> <name>dnCount</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Whether node changes happened
 */</comment>
<function><type><name>bool</name></type>
<name>PrimaryNodeNumberChanged</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><operator>*</operator><name>shmemNumCoords</name> <operator>+</operator> <operator>*</operator><name>shmemNumDataNodes</name> <operator>!=</operator> <name>NumCoords</name> <operator>+</operator> <name>NumDataNodes</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PgxcNodeListAndCount
 *
 * Update node definitions in the shared memory tables from the catalog
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PgxcNodeListAndCount</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>   <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NodeDefinition</name> <modifier>*</modifier></type><name>nodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>    <name>numNodes</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>    
    <decl_stmt><decl><type><name>int</name></type> <name>loop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NodeDefLookupTag</name></type> <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NodeDefLookupEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>    

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>numNodes</name> <operator>=</operator> <operator>*</operator><name>shmemNumCoords</name> <operator>+</operator> <operator>*</operator><name>shmemNumDataNodes</name> <operator>+</operator> <operator>*</operator><name>shmemNumSlaveDataNodes</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>shmemNumCoords</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>shmemNumDataNodes</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>shmemNumSlaveDataNodes</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Save the existing health status values because nodes
     * might get added or deleted here. We will save
     * nodeoid, status. No need to differentiate between
     * coords and datanodes since oids will be unique anyways
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>numNodes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>nodes</name> <operator>=</operator> <operator>(</operator><name>NodeDefinition</name><operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>numNodes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NodeDefinition</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* XXX It's possible to call memcpy with */</comment>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>shmemNumCoords</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>coDefs</name></expr></argument>, <argument><expr><operator>*</operator><name>shmemNumCoords</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NodeDefinition</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>shmemNumDataNodes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>nodes</name> <operator>+</operator> <operator>*</operator><name>shmemNumCoords</name></expr></argument>, <argument><expr><name>dnDefs</name></expr></argument>,
                   <argument><expr><operator>*</operator><name>shmemNumDataNodes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NodeDefinition</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>shmemNumSlaveDataNodes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>nodes</name> <operator>+</operator> <operator>*</operator><name>shmemNumCoords</name> <operator>+</operator> <operator>*</operator><name>shmemNumDataNodes</name></expr></argument>, <argument><expr><name>sdnDefs</name></expr></argument>,
               <argument><expr><operator>*</operator><name>shmemNumSlaveDataNodes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>NodeDefinition</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>shmemNumCoords</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>shmemNumDataNodes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>shmemNumSlaveDataNodes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Node information initialization is made in one scan:
     * 1) Scan pgxc_node catalog to find the number of nodes for
     *    each node type and make proper allocations
     * 2) Then extract the node Oid
     * 3) Complete primary/preferred node information
     */</comment>
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>PgxcNodeRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>SnapshotSelf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pgxc_node</name></type>  <name>nodeForm</name> <init>= <expr><operator>(</operator><name>Form_pgxc_node</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>NodeDefinition</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if<condition>(<expr><name>enable_multi_cluster</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodeForm</name><operator>-&gt;</operator><name>node_cluster_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PGXCClusterName</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if <condition>(<expr><name>PGXC_NODE_GTM</name> <operator>==</operator> <name><name>nodeForm</name><operator>-&gt;</operator><name>node_type</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>
        
        <comment type="block">/* Take definition for given node type */</comment>
        <switch>switch <condition>(<expr><name><name>nodeForm</name><operator>-&gt;</operator><name>node_type</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>PGXC_NODE_COORDINATOR</name></expr>:</case>
                <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>&amp;</operator><name><name>coDefs</name><index>[<expr><operator>(</operator><operator>*</operator><name>shmemNumCoords</name><operator>)</operator><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>PGXC_NODE_DATANODE</name></expr>:</case>
                <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>&amp;</operator><name><name>dnDefs</name><index>[<expr><operator>(</operator><operator>*</operator><name>shmemNumDataNodes</name><operator>)</operator><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>PGXC_NODE_SLAVEDATANODE</name></expr>:</case>
            <default>default:</default>
                <comment type="block">/*
                 * compile warning for node uninitialized, we hope nodetype were in PGXC_NODE enum.
                 */</comment>
                <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>&amp;</operator><name><name>sdnDefs</name><index>[<expr><operator>(</operator><operator>*</operator><name>shmemNumSlaveDataNodes</name><operator>)</operator><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name><name>PGXCNodeHost</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name>IsUnderPostmaster</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><call><name>get_local_address</name><argument_list>(<argument><expr><name>MyProcPort</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>ip</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><literal type="string">"localhost"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><literal type="string">"127.0.0.1"</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>PGXCNodeHost</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>ip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* Populate the definition */</comment>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nodeoid</name></name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>nodename</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nodeForm</name><operator>-&gt;</operator><name>node_name</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>nodehost</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nodeForm</name><operator>-&gt;</operator><name>node_host</name></name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nodeport</name></name> <operator>=</operator> <name><name>nodeForm</name><operator>-&gt;</operator><name>node_port</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nodeisprimary</name></name> <operator>=</operator> <name><name>nodeForm</name><operator>-&gt;</operator><name>nodeis_primary</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nodeispreferred</name></name> <operator>=</operator> <name><name>nodeForm</name><operator>-&gt;</operator><name>nodeis_preferred</name></name></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>enable_multi_cluster_print</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"nodename %s nodehost %s nodeport %d Oid %d"</literal></expr></argument>, 
                    <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nodename</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nodehost</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nodeport</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nodeoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/*
         * Copy over the health status from above for nodes that
         * existed before and after the refresh. If we do not find
         * entry for a nodeoid, we mark it as healthy
         */</comment>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nodeishealthy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeoid</name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>nodeoid</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nodeishealthy</name></name> <operator>=</operator> <name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeishealthy</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Done pgxc_nodes scan: %d coordinators and %d datanodes and %d slavedatanodes"</literal></expr></argument>,
            <argument><expr><operator>*</operator><name>shmemNumCoords</name></expr></argument>, <argument><expr><operator>*</operator><name>shmemNumDataNodes</name></expr></argument>, <argument><expr><operator>*</operator><name>shmemNumSlaveDataNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>numNodes</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Finally sort the lists */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>shmemNumCoords</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>coDefs</name></expr></argument>, <argument><expr><operator>*</operator><name>shmemNumCoords</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NodeDefinition</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cmp_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>shmemNumDataNodes</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>dnDefs</name></expr></argument>, <argument><expr><operator>*</operator><name>shmemNumDataNodes</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NodeDefinition</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cmp_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>shmemNumSlaveDataNodes</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>sdnDefs</name></expr></argument>, <argument><expr><operator>*</operator><name>shmemNumSlaveDataNodes</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NodeDefinition</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cmp_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
	<comment type="block">/* set plane type */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>g_TbasePlane</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>PGXCClusterName</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>PGXCClusterName</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>g_TbasePlane</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>PGXCClusterName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>plane_changed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>PGXCClusterName</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>g_TbasePlane</name></expr></argument>, <argument><expr><name>PGXCClusterName</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>plane_changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* reset hashtab */</comment>
		<if_stmt><if>if <condition>(<expr><name>plane_changed</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>scan_status</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>NodeDefLookupEnt</name>  <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>, <argument><expr><name>g_NodeDefHashTab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>(</operator><name>item</name> <operator>=</operator> <operator>(</operator><name>NodeDefLookupEnt</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>g_NodeDefHashTab</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>,
								<argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"node definition hash table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></while>

			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>g_TbasePlane</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>PGXCClusterName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
    <comment type="block">/* Add to hash table */</comment>
    <for>for <control>(<init><expr><name>loop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>loop</name> <operator>&lt;</operator> <operator>*</operator><name>shmemNumCoords</name></expr>;</condition> <incr><expr><name>loop</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>tag</name><operator>.</operator><name>nodeoid</name></name> <operator>=</operator> <name><name>coDefs</name><index>[<expr><name>loop</name></expr>]</index></name><operator>.</operator><name>nodeoid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>NodeDefLookupEnt</name><operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name>g_NodeDefHashTab</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ent</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"corrupted node definition hash table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>nodeDefIndex</name></name> <operator>=</operator> <name>loop</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><expr><name>loop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>loop</name> <operator>&lt;</operator> <operator>*</operator><name>shmemNumDataNodes</name></expr>;</condition> <incr><expr><name>loop</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>tag</name><operator>.</operator><name>nodeoid</name></name> <operator>=</operator> <name><name>dnDefs</name><index>[<expr><name>loop</name></expr>]</index></name><operator>.</operator><name>nodeoid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>NodeDefLookupEnt</name><operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name>g_NodeDefHashTab</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ent</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"corrupted node definition hash table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>nodeDefIndex</name></name> <operator>=</operator> <name>loop</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    
    <for>for <control>(<init><expr><name>loop</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>loop</name> <operator>&lt;</operator> <operator>*</operator><name>shmemNumSlaveDataNodes</name></expr>;</condition> <incr><expr><name>loop</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>tag</name><operator>.</operator><name>nodeoid</name></name> <operator>=</operator> <name><name>sdnDefs</name><index>[<expr><name>loop</name></expr>]</index></name><operator>.</operator><name>nodeoid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>NodeDefLookupEnt</name><operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name>g_NodeDefHashTab</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ent</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"corrupted node definition hash table"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>nodeDefIndex</name></name> <operator>=</operator> <name>loop</name></expr>;</expr_stmt>
    </block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PgxcNodeListAndCountWrapTransaction
 *
 * Update node definitions in the shared memory tables from the catalog wrap the transaction
 */</comment>
<function><type><name>void</name></type>
<name>PgxcNodeListAndCountWrapTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>need_abort</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTransactionOrTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>need_abort</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PgxcNodeListAndCount</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>need_abort</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AbortCurrentTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PgxcNodeGetIds
 *
 * List into palloc'ed arrays Oids of Coordinators and Datanodes currently
 * presented in the node table, as well as number of Coordinators and Datanodes.
 * Any parameter may be NULL if caller is not interested in receiving
 * appropriate results. Preferred and primary node information can be updated
 * in session if requested.
 */</comment>
<function><type><name>void</name></type>
<name>PgxcNodeGetOidsExtend</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>coOids</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>dnOids</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>sdnOids</name></decl></parameter>,
                <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_coords</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_dns</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_sdns</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>update_preferred</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Get OIDs from table: %d coordinators and %d datanodes"</literal></expr></argument>,
            <argument><expr><operator>*</operator><name>shmemNumCoords</name></expr></argument>, <argument><expr><operator>*</operator><name>shmemNumDataNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>num_coords</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>num_coords</name> <operator>=</operator> <operator>*</operator><name>shmemNumCoords</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>num_dns</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>num_dns</name> <operator>=</operator> <operator>*</operator><name>shmemNumDataNodes</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>num_sdns</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>num_sdns</name> <operator>=</operator> <operator>*</operator><name>shmemNumSlaveDataNodes</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>coOids</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><operator>*</operator><name>coOids</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>*</operator><name>shmemNumCoords</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>shmemNumCoords</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>coOids</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <name><name>coDefs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeoid</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"i %d coOid %d"</literal></expr></argument>,<argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>coOids</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>dnOids</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><operator>*</operator><name>dnOids</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>*</operator><name>shmemNumDataNodes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>shmemNumDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>dnOids</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <name><name>dnDefs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeoid</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"i %d dnOid %d"</literal></expr></argument>,<argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>dnOids</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    
    <if_stmt><if>if <condition>(<expr><name>sdnOids</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><operator>*</operator><name>sdnOids</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>*</operator><name>shmemNumSlaveDataNodes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>shmemNumSlaveDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>sdnOids</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <name><name>sdnDefs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeoid</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"i %d sdnOid %d"</literal></expr></argument>,<argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><operator>*</operator><name>sdnOids</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Update also preferred and primary node informations if requested */</comment>
    <if_stmt><if>if <condition>(<expr><name>update_preferred</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <comment type="block">/* Initialize primary and preferred node information */</comment>
        <expr_stmt><expr><name>primary_data_node</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>num_preferred_data_nodes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>shmemNumDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>dnDefs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeisprimary</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>primary_data_node</name> <operator>=</operator> <name><name>dnDefs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeoid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>dnDefs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeispreferred</name> <operator>&amp;&amp;</operator> <name>num_preferred_data_nodes</name> <operator>&lt;</operator> <name>MAX_PREFERRED_NODES</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>preferred_data_node</name><index>[<expr><name>num_preferred_data_nodes</name></expr>]</index></name> <operator>=</operator> <name><name>dnDefs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeoid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>num_preferred_data_nodes</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PgxcNodeGetHealthMap
 *
 * List into palloc'ed arrays Oids of Coordinators and Datanodes currently
 * presented in the node table, as well as number of Coordinators and Datanodes.
 * Any parameter may be NULL if caller is not interested in receiving
 * appropriate results for either the Coordinators or Datanodes.
 */</comment>
<function><type><name>void</name></type>
<name>PgxcNodeGetHealthMapExtend</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>coOids</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>dnOids</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sdnOids</name></decl></parameter>,
                <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_coords</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_dns</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_sdns</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>coHealthMap</name></decl></parameter>,
                <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>dnHealthMap</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>sdnHealthMap</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Get HealthMap from table: %d coordinators and %d datanodes"</literal></expr></argument>,
            <argument><expr><operator>*</operator><name>shmemNumCoords</name></expr></argument>, <argument><expr><operator>*</operator><name>shmemNumDataNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>num_coords</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>num_coords</name> <operator>=</operator> <operator>*</operator><name>shmemNumCoords</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>num_dns</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>num_dns</name> <operator>=</operator> <operator>*</operator><name>shmemNumDataNodes</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>num_sdns</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>num_sdns</name> <operator>=</operator> <operator>*</operator><name>shmemNumSlaveDataNodes</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>coOids</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>shmemNumCoords</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>coOids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>coDefs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeoid</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>coHealthMap</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>coHealthMap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>coDefs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeishealthy</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>dnOids</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>shmemNumDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>dnOids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>dnDefs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeoid</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>dnHealthMap</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>dnHealthMap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>dnDefs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeishealthy</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    
    <if_stmt><if>if <condition>(<expr><name>sdnOids</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>shmemNumSlaveDataNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>sdnOids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>sdnDefs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeoid</name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>sdnHealthMap</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>sdnHealthMap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>sdnDefs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeishealthy</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Consult the shared memory NodeDefinition structures and
 * fetch the nodeishealthy value and return it back
 *
 * We will probably need a similar function for coordinators
 * in the future..
 */</comment>
<function><type><name>void</name></type>
<name>PgxcNodeDnListHealth</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nodeList</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>healthmap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Get healthmap from datanodeList"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>nodeList</name> <operator>||</operator> <operator>!</operator><call><name>list_length</name><argument_list>(<argument><expr><name>nodeList</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"NIL or empty nodeList passed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>nodeList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>node</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>node</name> <operator>&gt;=</operator> <operator>*</operator><name>shmemNumDataNodes</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC health status not found for datanode with oid (%d)"</literal></expr></argument>,
                         <argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>healthmap</name><index>[<expr><name>index</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>dnDefs</name><index>[<expr><name>node</name></expr>]</index></name><operator>.</operator><name>nodeishealthy</name></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find node definition in the shared memory node table.
 * The structure is a copy palloc'ed in current memory context.
 */</comment>
<function><type><name>NodeDefinition</name> <modifier>*</modifier></type>
<name>PgxcNodeGetDefinition</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>NodeDefinition</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>             <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NodeDefLookupTag</name></type> <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NodeDefLookupEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name><name>tag</name><operator>.</operator><name>nodeoid</name></name> <operator>=</operator>   <name>node</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>NodeDefLookupEnt</name><operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name>g_NodeDefHashTab</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <if_stmt><if>if<condition>(<expr><name>found</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>dnDefs</name><index>[<expr><name><name>ent</name><operator>-&gt;</operator><name>nodeDefIndex</name></name></expr>]</index></name><operator>.</operator><name>nodeoid</name> <operator>==</operator> <name>node</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>NodeDefinition</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NodeDefinition</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>dnDefs</name> <operator>+</operator> <name><name>ent</name><operator>-&gt;</operator><name>nodeDefIndex</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NodeDefinition</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <return>return <expr><name>result</name></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>coDefs</name><index>[<expr><name><name>ent</name><operator>-&gt;</operator><name>nodeDefIndex</name></name></expr>]</index></name><operator>.</operator><name>nodeoid</name> <operator>==</operator> <name>node</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>NodeDefinition</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NodeDefinition</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>coDefs</name> <operator>+</operator> <name><name>ent</name><operator>-&gt;</operator><name>nodeDefIndex</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NodeDefinition</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <return>return <expr><name>result</name></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>sdnDefs</name><index>[<expr><name><name>ent</name><operator>-&gt;</operator><name>nodeDefIndex</name></name></expr>]</index></name><operator>.</operator><name>nodeoid</name> <operator>==</operator> <name>node</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>NodeDefinition</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NodeDefinition</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>sdnDefs</name> <operator>+</operator> <name><name>ent</name><operator>-&gt;</operator><name>nodeDefIndex</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NodeDefinition</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <return>return <expr><name>result</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
            
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* not found, return NULL */</comment>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Update health status of a node in the shared memory node table.
 *
 * We could try to optimize this by checking if the ishealthy value
 * is already the same as the passed in one.. but if the cluster is
 * impaired, dunno how much such optimizations are worth. So keeping
 * it simple for now
 */</comment>
<function><type><name>bool</name></type>
<name>PgxcNodeUpdateHealth</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>             <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NodeDefLookupTag</name></type> <name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>NodeDefLookupEnt</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name><name>tag</name><operator>.</operator><name>nodeoid</name></name> <operator>=</operator>   <name>node</name></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>NodeDefLookupEnt</name><operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name>g_NodeDefHashTab</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <if_stmt><if>if<condition>(<expr><name>found</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>dnDefs</name><index>[<expr><name><name>ent</name><operator>-&gt;</operator><name>nodeDefIndex</name></name></expr>]</index></name><operator>.</operator><name>nodeoid</name> <operator>==</operator> <name>node</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>dnDefs</name><index>[<expr><name><name>ent</name><operator>-&gt;</operator><name>nodeDefIndex</name></name></expr>]</index></name><operator>.</operator><name>nodeishealthy</name> <operator>=</operator> <name>status</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>coDefs</name><index>[<expr><name><name>ent</name><operator>-&gt;</operator><name>nodeDefIndex</name></name></expr>]</index></name><operator>.</operator><name>nodeoid</name> <operator>==</operator> <name>node</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>coDefs</name><index>[<expr><name><name>ent</name><operator>-&gt;</operator><name>nodeDefIndex</name></name></expr>]</index></name><operator>.</operator><name>nodeishealthy</name> <operator>=</operator> <name>status</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>sdnDefs</name><index>[<expr><name><name>ent</name><operator>-&gt;</operator><name>nodeDefIndex</name></name></expr>]</index></name><operator>.</operator><name>nodeoid</name> <operator>==</operator> <name>node</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>sdnDefs</name><index>[<expr><name><name>ent</name><operator>-&gt;</operator><name>nodeDefIndex</name></name></expr>]</index></name><operator>.</operator><name>nodeishealthy</name> <operator>=</operator> <name>status</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
            
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* not found, return false */</comment>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PgxcNodeCreate
 *
 * Add a PGXC node
 */</comment>
<function><type><name>void</name></type>
<name>PgxcNodeCreate</name><parameter_list>(<parameter><decl><type><name>CreateNodeStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>pgxcnodesrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>htup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>nulls</name><index>[<expr><name>Natts_pgxc_node</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>values</name><index>[<expr><name>Natts_pgxc_node</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>node_name</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>node_name</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>i</name></decl>;</decl_stmt>
    <comment type="block">/* Options with default values */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>node_host</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>node_type</name> <init>= <expr><name>PGXC_NODE_NONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>node_port</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_primary</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_preferred</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>node_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>coordCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>dnCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>nodeOid</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>char</name>           <modifier>*</modifier></type><name>node_group</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>groupoid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>node_cluster_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>alter</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    

    <comment type="block">/* Only a DB administrator can add nodes */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to create cluster nodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* 
     * Support create node format like this: 
     * create gtm node gtm1 with (host='xxx.xxx.xxx.xxx',port=2999);
     * type='gtm' can be ignored.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>PGXC_NODE_GTM</name> <operator>==</operator> <name><name>stmt</name><operator>-&gt;</operator><name>node_type</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>node_type</name> <operator>=</operator> <name>PGXC_NODE_GTM</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Filter options */</comment>
    <expr_stmt><expr><call><name>check_node_options</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node_host</name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name>node_port</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node_type</name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name>is_primary</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_preferred</name></expr></argument> 
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                ,<argument><expr><operator>&amp;</operator><name>node_group</name></expr></argument>
                ,<argument><expr><operator>&amp;</operator><name>node_cluster_name</name></expr></argument>
                ,<argument><expr><operator>&amp;</operator><name>alter</name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>                
                )</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if<condition>(<expr><operator>!</operator><name>node_cluster_name</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>node_cluster_name</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>PGXCDefaultClusterName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"PGXC node %s: Applying default cluster value: %s"</literal></expr></argument>,
             <argument><expr><name>node_name</name></expr></argument>, <argument><expr><name>node_cluster_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>alter</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name>node_group</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>groupoid</name> <operator>=</operator> <call><name>get_pgxc_groupoid</name><argument_list>(<argument><expr><name>node_group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>groupoid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"node group [%s] is not exist"</literal></expr></argument>, <argument><expr><name>node_group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>node_name</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>nodeOid</name> <operator>=</operator> <call><name>get_pgxc_nodeoid</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nodeOid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"node [%s] is not exist"</literal></expr></argument>, <argument><expr><name>node_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">//if (OidIsValid(groupoid))</comment>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PgxcClassModifyData</name></type> <name>data</name></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>data</name><operator>.</operator><name>group</name></name> <operator>=</operator> <name>groupoid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>data</name><operator>.</operator><name>node</name></name>  <operator>=</operator> <name>nodeOid</name></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>ModifyPgxcClass</name><argument_list>(<argument><expr><name>PGXC_CLASS_ADD_NODE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <return>return;</return>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Check that node name is node in use */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_pgxc_nodeoid_extend</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>, <argument><expr><name>node_cluster_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC Node %s Cluster %s: object already defined"</literal></expr></argument>,
                        <argument><expr><name>node_name</name></expr></argument>,
                        <argument><expr><name>node_cluster_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check length of node name */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>PGXC_NODENAME_LENGTH</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Node name \"%s\" is too long"</literal></expr></argument>,
                        <argument><expr><name>node_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>PgxcCheckNodeValid</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>node_name</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>node_cluster_name</name></expr></argument>, <argument><expr><name>node_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* check if group is exist */</comment>
    <if_stmt><if>if<condition>(<expr><name>node_group</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>groupoid</name> <operator>=</operator> <call><name>get_pgxc_groupoid</name><argument_list>(<argument><expr><name>node_group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>groupoid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"node group [%s] is not exist"</literal></expr></argument>, <argument><expr><name>node_group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
    <comment type="block">/* Compute node identifier */</comment>
    <expr_stmt><expr><name>node_id</name> <operator>=</operator> <call><name>generate_node_id</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check that this node is not created as a primary if one already
     * exists.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_primary</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>primary_data_node</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>node_type</name> <operator>==</operator> <name>PGXC_NODE_DATANODE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC node %s: two nodes cannot be primary"</literal></expr></argument>,
                        <argument><expr><name>node_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/*
     * Check gtm only has one primary node
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>PGXC_NODE_GTM</name> <operator>==</operator> <name>node_type</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_primary</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC node %s: only master gtm accepted"</literal></expr></argument>, <argument><expr><name>node_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><call><name>ValidateCreateGtmNode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Then assign default values if necessary
     * First for port.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>node_port</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>node_port</name> <operator>=</operator> <literal type="number">5432</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"PGXC node %s: Applying default port value: %d"</literal></expr></argument>,
             <argument><expr><name>node_name</name></expr></argument>, <argument><expr><name>node_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Then apply default value for host */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>node_host</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>node_host</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"localhost"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"PGXC node %s: Applying default host value: %s"</literal></expr></argument>,
             <argument><expr><name>node_name</name></expr></argument>, <argument><expr><name>node_host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>


    <comment type="block">/* Iterate through all attributes initializing nulls and values */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>Natts_pgxc_node</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name>  <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * Open the relation for insertion
     * This is necessary to generate a unique Oid for the new node
     * There could be a relation race here if a similar Oid
     * being created before the heap is inserted.
     */</comment>
    <expr_stmt><expr><name>pgxcnodesrel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>PgxcNodeRelationId</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Get the count of datanodes and coordinators added so far and make sure
     * we're not exceeding the configured limits
     *
     * XXX This is not full proof because someone may first set
     * max_coordinators or max_datanodes to a high value, add nodes and then
     * lower the value again.
     */</comment>
    <expr_stmt><expr><call><name>count_coords_datanodes</name><argument_list>(<argument><expr><name>pgxcnodesrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>coordCount</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dnCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>node_type</name> <operator>==</operator> <name>PGXC_NODE_DATANODE</name> <operator>&amp;&amp;</operator> <name>dnCount</name> <operator>&gt;=</operator> <name>TBASE_MAX_DATANODE_NUMBER</name><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>node_type</name> <operator>==</operator> <name>PGXC_NODE_COORDINATOR</name> <operator>&amp;&amp;</operator> <name>coordCount</name> <operator>&gt;=</operator> <name>TBASE_MAX_COORDINATOR_NUMBER</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add more than %d %s"</literal></expr></argument>,
                     <argument><expr><ternary><condition><expr><name>node_type</name> <operator>==</operator> <name>PGXC_NODE_COORDINATOR</name></expr> ?</condition><then>
                     <expr><name>TBASE_MAX_COORDINATOR_NUMBER</name></expr> </then><else>: <expr><name>TBASE_MAX_DATANODE_NUMBER</name></expr></else></ternary></expr></argument>,
                     <argument><expr><ternary><condition><expr><name>node_type</name> <operator>==</operator> <name>PGXC_NODE_COORDINATOR</name></expr> ?</condition><then>
                     <expr><literal type="string">"coordinators"</literal></expr> </then><else>: <expr><literal type="string">"datanodes"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"increase the value of %s GUC and restart the cluster"</literal></expr></argument>,
                     <argument><expr><ternary><condition><expr><name>node_type</name> <operator>==</operator> <name>PGXC_NODE_COORDINATOR</name></expr> ?</condition><then>
                     <expr><literal type="string">"max_coordinators"</literal></expr> </then><else>: <expr><literal type="string">"max_datanodes"</literal></expr></else></ternary></expr></argument>
                     )</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Build entry tuple */</comment>
    
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pgxc_node_name</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pgxc_node_type</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>node_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pgxc_node_port</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>node_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pgxc_node_host</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>node_host</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pgxc_node_is_primary</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>is_primary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pgxc_node_is_preferred</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>is_preferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pgxc_node_id</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>node_id</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pgxc_node_cluster_name</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>node_cluster_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    

    <expr_stmt><expr><name>htup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>pgxcnodesrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>nodeOid</name> <operator>=</operator> <call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>pgxcnodesrel</name></expr></argument>, <argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pgxcnodesrel</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
    <comment type="block">/* add this node to group*/</comment>
    <if_stmt><if>if<condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>groupoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>AddNodeToGroup</name><argument_list>(<argument><expr><name>nodeOid</name></expr></argument>, <argument><expr><name>groupoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* add this node to all shard tables in group */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>groupoid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PgxcClassModifyData</name></type> <name>data</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>data</name><operator>.</operator><name>group</name></name> <operator>=</operator> <name>groupoid</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>data</name><operator>.</operator><name>node</name></name>  <operator>=</operator> <name>nodeOid</name></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>ModifyPgxcClass</name><argument_list>(<argument><expr><name>PGXC_CLASS_ADD_NODE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>is_primary</name> <operator>&amp;&amp;</operator> <name>node_type</name> <operator>==</operator> <name>PGXC_NODE_DATANODE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>primary_data_node</name> <operator>=</operator> <name>nodeOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * PgxcNodeAlter
 *
 * Alter a PGXC node
 */</comment>
<function><type><name>void</name></type>
<name>PgxcNodeAlter</name><parameter_list>(<parameter><decl><type><name>AlterNodeStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>node_name</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>node_name</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>node_host</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name>node_type</name> <init>= <expr><name>PGXC_NODE_NONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>node_port</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_preferred</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_primary</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>oldtup</name></decl>, <decl><type ref="prev"/><name>newtup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>nodeOid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type>        <name><name>new_record</name><index>[<expr><name>Natts_pgxc_node</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>new_record_nulls</name><index>[<expr><name>Natts_pgxc_node</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name><name>new_record_repl</name><index>[<expr><name>Natts_pgxc_node</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>        <name>node_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>coordCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>dnCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>node_group</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>         <modifier>*</modifier></type><name>node_cluster</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>            <name>groupoid</name>    <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>alter</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


    <comment type="block">/* Only a DB administrator can alter cluster nodes */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to change cluster nodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


    <comment type="block">/* Filter options */</comment>
    <expr_stmt><expr><call><name>get_node_cluster_name</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node_cluster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>NULL</name> <operator>!=</operator> <name>node_cluster</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"CLUSTER could not be modified."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>stmt</name><operator>-&gt;</operator><name>cluster_name</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>node_cluster</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>PGXCMainClusterName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"PGXC node %s: Applying default cluster value: %s"</literal></expr></argument>,
             <argument><expr><name>node_name</name></expr></argument>, <argument><expr><name>node_cluster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>node_cluster</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>cluster_name</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    
    <expr_stmt><expr><name>nodeOid</name> <operator>=</operator> <call><name>get_pgxc_nodeoid_extend</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>, <argument><expr><name>node_cluster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Check that node exists */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nodeOid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>nodeOid</name> <operator>=</operator> <call><name>get_pgxc_nodeoid_extend</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>, <argument><expr><name>PGXCDefaultClusterName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nodeOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC Node %s: object not defined"</literal></expr></argument>,
                            <argument><expr><name>node_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/* Open new tuple, checks are performed on it and new values */</comment>
    <expr_stmt><expr><name>oldtup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>PGXCNODEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nodeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for object %u"</literal></expr></argument>, <argument><expr><name>nodeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


    <comment type="block">/*
     * check_options performs some internal checks on option values
     * so set up values.
     */</comment>
    <expr_stmt><expr><name>node_host</name> <operator>=</operator> <call><name>get_pgxc_nodehost</name><argument_list>(<argument><expr><name>nodeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>node_port</name> <operator>=</operator> <call><name>get_pgxc_nodeport</name><argument_list>(<argument><expr><name>nodeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>is_preferred</name> <operator>=</operator> <call><name>is_pgxc_nodepreferred</name><argument_list>(<argument><expr><name>nodeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>is_primary</name> <operator>=</operator> <call><name>is_pgxc_nodeprimary</name><argument_list>(<argument><expr><name>nodeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>node_type</name> <operator>=</operator> <call><name>get_pgxc_nodetype</name><argument_list>(<argument><expr><name>nodeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>node_id</name> <operator>=</operator> <call><name>get_pgxc_node_id</name><argument_list>(<argument><expr><name>nodeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Filter options */</comment>
    <expr_stmt><expr><call><name>check_node_options</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node_host</name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name>node_port</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node_type</name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name>is_primary</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_preferred</name></expr></argument>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                , <argument><expr><operator>&amp;</operator><name>node_group</name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name>node_cluster</name></expr></argument>,
                <argument><expr><operator>&amp;</operator><name>alter</name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                )</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>node_type</name></name> <operator>=</operator> <name>node_type</name></expr>;</expr_stmt>
    
    <comment type="block">/*
     * Two nodes cannot be primary at the same time. If the primary
     * node is this node itself, well there is no point in having an
     * error.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_primary</name> <operator>&amp;&amp;</operator>
        <call><name>OidIsValid</name><argument_list>(<argument><expr><name>primary_data_node</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <name>nodeOid</name> <operator>!=</operator> <name>primary_data_node</name>  <operator>&amp;&amp;</operator>
        <name>PGXC_NODE_DATANODE</name> <operator>==</operator> <name>node_type</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC node %s: two nodes cannot be primary"</literal></expr></argument>,
                        <argument><expr><name>node_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/*
     * Check only one gtm node can be primary
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>PGXC_NODE_GTM</name> <operator>==</operator> <name>node_type</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_primary</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC node %s: only master gtm accepted"</literal></expr></argument>, <argument><expr><name>node_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>ValidateAlterGtmNode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Look at the node tuple, and take exclusive lock on it */</comment>
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>PgxcNodeRelationId</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Get the count of datanodes and coordinators added so far and make sure
     * we're not exceeding the configured limits
     */</comment>
    <expr_stmt><expr><call><name>count_coords_datanodes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>coordCount</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dnCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>node_type</name> <operator>==</operator> <name>PGXC_NODE_DATANODE</name> <operator>&amp;&amp;</operator> <name>dnCount</name> <operator>&gt;=</operator> <name>TBASE_MAX_DATANODE_NUMBER</name><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>node_type</name> <operator>==</operator> <name>PGXC_NODE_COORDINATOR</name> <operator>&amp;&amp;</operator> <name>coordCount</name> <operator>&gt;=</operator> <name>TBASE_MAX_COORDINATOR_NUMBER</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add more than %d %s"</literal></expr></argument>,
                     <argument><expr><ternary><condition><expr><name>node_type</name> <operator>==</operator> <name>PGXC_NODE_COORDINATOR</name></expr> ?</condition><then>
                     <expr><name>TBASE_MAX_COORDINATOR_NUMBER</name></expr> </then><else>: <expr><name>TBASE_MAX_DATANODE_NUMBER</name></expr></else></ternary></expr></argument>,
                     <argument><expr><ternary><condition><expr><name>node_type</name> <operator>==</operator> <name>PGXC_NODE_COORDINATOR</name></expr> ?</condition><then>
                     <expr><literal type="string">"coordinators"</literal></expr> </then><else>: <expr><literal type="string">"datanodes"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"increase the value of %s GUC and restart the cluster"</literal></expr></argument>,
                     <argument><expr><ternary><condition><expr><name>node_type</name> <operator>==</operator> <name>PGXC_NODE_COORDINATOR</name></expr> ?</condition><then>
                     <expr><literal type="string">"max_coordinators"</literal></expr> </then><else>: <expr><literal type="string">"max_datanodes"</literal></expr></else></ternary></expr></argument>
                     )</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Update values for catalog entry */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>new_record</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_record</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>new_record_nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_record_nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>new_record_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_record_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_record</name><index>[<expr><name>Anum_pgxc_node_port</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>node_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_record_repl</name><index>[<expr><name>Anum_pgxc_node_port</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_record</name><index>[<expr><name>Anum_pgxc_node_host</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
        <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>node_host</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_record_repl</name><index>[<expr><name>Anum_pgxc_node_host</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_record</name><index>[<expr><name>Anum_pgxc_node_type</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>node_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_record_repl</name><index>[<expr><name>Anum_pgxc_node_type</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_record</name><index>[<expr><name>Anum_pgxc_node_is_primary</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>is_primary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_record_repl</name><index>[<expr><name>Anum_pgxc_node_is_primary</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_record</name><index>[<expr><name>Anum_pgxc_node_is_preferred</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>is_preferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_record_repl</name><index>[<expr><name>Anum_pgxc_node_is_preferred</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_record</name><index>[<expr><name>Anum_pgxc_node_id</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name>node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_record_repl</name><index>[<expr><name>Anum_pgxc_node_id</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_record</name><index>[<expr><name>Anum_pgxc_node_cluster_name</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> 
        <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>node_cluster</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_record_repl</name><index>[<expr><name>Anum_pgxc_node_cluster_name</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    

    <comment type="block">/* Update relation */</comment>
    <expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>new_record</name></expr></argument>,
                               <argument><expr><name>new_record_nulls</name></expr></argument>, <argument><expr><name>new_record_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oldtup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Release lock at Commit */</comment>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <comment type="block">/* 
     * 1. add node to group_members in pgxc_group 
     * 2. add node to pgxc_class
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>isRestoreMode</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>node_group</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return ;</return></block_content></block></if></if_stmt>
    
        <comment type="block">/* check node does not belong to any group */</comment>
        <if_stmt><if>if <condition>(<expr><name>InvalidOid</name> <operator>!=</operator> <call><name>GetGroupOidByNode</name><argument_list>(<argument><expr><name>nodeOid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"node %s already in group %s, can not move to group %s"</literal></expr></argument>, 
                        <argument><expr><name>node_name</name></expr></argument>,
                        <argument><expr><call><name>GetGroupNameByNode</name><argument_list>(<argument><expr><name>nodeOid</name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><name>node_group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    
        <if_stmt><if>if<condition>(<expr><name>node_group</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>groupoid</name> <operator>=</operator> <call><name>get_pgxc_groupoid</name><argument_list>(<argument><expr><name>node_group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>groupoid</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"node group [%s] is not exist"</literal></expr></argument>, <argument><expr><name>node_group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/* add this node to pgxc_group*/</comment>
        <comment type="block">/* add this node to all shard tables in group */</comment>
        <if_stmt><if>if<condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>groupoid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PgxcClassModifyData</name></type> <name>data</name></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>data</name><operator>.</operator><name>group</name></name> <operator>=</operator> <name>groupoid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>data</name><operator>.</operator><name>node</name></name>  <operator>=</operator> <name>nodeOid</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>AddNodeToGroup</name><argument_list>(<argument><expr><name>nodeOid</name></expr></argument>, <argument><expr><name>groupoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>ModifyPgxcClass</name><argument_list>(<argument><expr><name>PGXC_CLASS_ADD_NODE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * PgxcNodeRemove
 *
 * Remove a PGXC node
 */</comment>
<function><type><name>void</name></type>
<name>PgxcNodeRemove</name><parameter_list>(<parameter><decl><type><name>DropNodeStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>relation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>    <modifier>*</modifier></type><name>node_name</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>node_name</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>        <name>noid</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type>         <name>is_primary</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name>skey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>groupoid</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>char</name></type>        <name>node_type</name> <init>= <expr><name>PGXC_NODE_NONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pgxc_node</name></type>    <name>nodeForm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>node_cluster</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>           <modifier>*</modifier></type><name>node_group</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>        <modifier>*</modifier></type><name>node_cluster_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>alter</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>is_preferred</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>node_host</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>node_port</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Only a DB administrator can remove cluster nodes */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to remove cluster nodes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>stmt</name><operator>-&gt;</operator><name>cluster_name</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>node_cluster</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>PGXCMainClusterName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"PGXC node %s: Applying default cluster value: %s"</literal></expr></argument>,
             <argument><expr><name>node_name</name></expr></argument>, <argument><expr><name>node_cluster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>node_cluster</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>cluster_name</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <comment type="block">/* Filter options */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>is_primary</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>is_preferred</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>node_type</name> <operator>=</operator> <name>PGXC_NODE_DATANODE</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>check_node_options</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node_host</name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>node_port</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>node_type</name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>is_primary</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_preferred</name></expr></argument> 
                            ,<argument><expr><operator>&amp;</operator><name>node_group</name></expr></argument>
                            ,<argument><expr><operator>&amp;</operator><name>node_cluster_name</name></expr></argument>
                            ,<argument><expr><operator>&amp;</operator><name>alter</name></expr></argument>            
                            )</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>alter</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>node_cluster</name></expr></argument>, <argument><expr><name>PGXCMainClusterName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name>noid</name> <operator>=</operator> <call><name>get_pgxc_nodeoid_extend</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>, <argument><expr><name>node_cluster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>noid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>groupoid</name> <operator>=</operator> <call><name>GetGroupOidByNode</name><argument_list>(<argument><expr><name>noid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">//if (OidIsValid(groupoid))</comment>
            <block>{<block_content>
                <decl_stmt><decl><type><name>PgxcClassModifyData</name></type> <name>data</name></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>data</name><operator>.</operator><name>group</name></name> <operator>=</operator> <name>groupoid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>data</name><operator>.</operator><name>node</name></name>  <operator>=</operator> <name>noid</name></expr>;</expr_stmt>
                
                <expr_stmt><expr><call><name>ModifyPgxcClass</name><argument_list>(<argument><expr><name>PGXC_CLASS_DROP_NODE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block></if></if_stmt>

        <return>return;</return>
    </block_content>}</block></if></if_stmt>
    
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>noid</name> <operator>=</operator> <call><name>get_pgxc_nodeoid_extend</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>, <argument><expr><name>node_cluster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Check if node is defined */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>noid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC Node %s: object not defined"</literal></expr></argument>,
                        <argument><expr><name>node_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>node_name</name></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>node_cluster</name></expr></argument>, <argument><expr><name>PGXCMainClusterName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC Node %s: cannot drop local node"</literal></expr></argument>,
                        <argument><expr><name>node_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check if node has any shard */</comment>
    <expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>PgxcShardMapRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
                <argument><expr><name>Anum_pgxc_shard_map_primarycopy</name></expr></argument>,
                <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, 
                <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>noid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>scan</name>    <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>,
                                  <argument><expr><name>PgxcShardMapGroupIndexId</name></expr></argument>, 
                                  <argument><expr><name>true</name></expr></argument>,
                                  <argument><expr><name>NULL</name></expr></argument>, 
                                  <argument><expr><literal type="number">1</literal></expr></argument>, 
                                  <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                              

    <expr_stmt><expr><name>tup</name>  <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"shard info left on node"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"maybe you should drop shard first"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <comment type="block">/* PGXCTODO:
     * Is there any group which has this node as member
     * XC Tables will also have this as a member in their array
     * Do this search in the local data structure.
     * If a node is removed, it is necessary to check if there is a distributed
     * table on it. If there are only replicated table it is OK.
     * However, we have to be sure that there are no pooler agents in the cluster pointing to it.
     */</comment>

    <comment type="block">/* Delete the pgxc_node tuple */</comment>
    <expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>PgxcNodeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PGXCNODEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>noid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC Node %s: object not defined"</literal></expr></argument>,
                        <argument><expr><name>node_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>    
    <expr_stmt><expr><name>nodeForm</name> <operator>=</operator> <operator>(</operator><name>Form_pgxc_node</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>node_type</name> <operator>=</operator> <name><name>nodeForm</name><operator>-&gt;</operator><name>node_type</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>simple_heap_delete</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MIGRATE_</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>PGXC_NODE_GTM</name> <operator>!=</operator> <name>node_type</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>groupoid</name> <operator>=</operator> <call><name>RemoveNodeFromGroup</name><argument_list>(<argument><expr><name>noid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* remove this node from all shard tables in group */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>groupoid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>PgxcClassModifyData</name></type> <name>data</name></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>data</name><operator>.</operator><name>group</name></name> <operator>=</operator> <name>groupoid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>data</name><operator>.</operator><name>node</name></name>  <operator>=</operator> <name>noid</name></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>ModifyPgxcClass</name><argument_list>(<argument><expr><name>PGXC_CLASS_DROP_NODE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>is_primary</name> <operator>=</operator> <call><name>is_pgxc_nodeprimary</name><argument_list>(<argument><expr><name>noid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>is_primary</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>primary_data_node</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>void</name></type> <name>PgxcCheckNodeValid</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>clustername</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>         <name>valid</name>  <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>        <name>rownum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type>      <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tuple</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"check node cluster name %s name %s localname %s"</literal></expr></argument>, <argument><expr><name>clustername</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>isRestoreMode</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>PGXC_NODE_DATANODE</name> <operator>==</operator> <name>type</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>PgxcNodeRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>SnapshotSelf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Form_pgxc_node</name></type>  <name>nodeForm</name> <init>= <expr><operator>(</operator><name>Form_pgxc_node</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>clustername</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodeForm</name><operator>-&gt;</operator><name>node_cluster_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>( <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodeForm</name><operator>-&gt;</operator><name>node_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PGXCNodeName</name></expr></argument>)</argument_list></call> 
                        <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodeForm</name><operator>-&gt;</operator><name>node_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> 
                        <operator>&amp;&amp;</operator> <operator>(</operator><name>PGXC_NODE_GTM</name> <operator>!=</operator> <name><name>nodeForm</name><operator>-&gt;</operator><name>node_type</name></name><operator>)</operator></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>valid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC Node name %s cluster %s must be defined in ascii order existing node name %s cluster %s"</literal></expr></argument>, 
                                 <argument><expr><name>name</name></expr></argument>, <argument><expr><name>clustername</name></expr></argument>,  <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodeForm</name><operator>-&gt;</operator><name>node_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nodeForm</name><operator>-&gt;</operator><name>node_cluster_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>    
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>rownum</name><operator>++</operator></expr>;</expr_stmt>
            
        </block_content>}</block></while>
        <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>NodeTableLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>valid</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC Node name %s must be defined in ascii order"</literal></expr></argument>, 
                                 <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>rownum</name> <operator>&gt;</operator> <name>MAX_NODES_NUMBER</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PGXC Node too many nodes already, limit is %d"</literal></expr></argument>, <argument><expr><name>MAX_NODES_NUMBER</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/* When create master gtm node, supposed to be no gtm info in pgxc_node. If found, report ERROR. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> 
<name>ValidateCreateGtmNode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>gtmtup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pgxc_node</name></type>    <name>nodeForm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>         <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>PgxcNodeRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>gtmtup</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>nodeForm</name> <operator>=</operator> <operator>(</operator><name>Form_pgxc_node</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>gtmtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>PGXC_NODE_GTM</name> <operator>==</operator> <name><name>nodeForm</name><operator>-&gt;</operator><name>node_type</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Master gtm node already exists"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* When alter master gtm node, supposed to be exactly one gtm info entry in pgxc_node. If not, report ERROR. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> 
<name>ValidateAlterGtmNode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Relation</name></type>    <name>rel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>tup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>tuple_cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pgxc_node</name></type>    <name>nodeForm</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>PgxcNodeRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>nodeForm</name> <operator>=</operator> <operator>(</operator><name>Form_pgxc_node</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>PGXC_NODE_GTM</name> <operator>==</operator> <name><name>nodeForm</name><operator>-&gt;</operator><name>node_type</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>tuple_cnt</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* In alter gtm node command, only one gtm tuple will be found */</comment>
    <if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>!=</operator> <name>tuple_cnt</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%d gtm nodes are found, shoule be only one"</literal></expr></argument>, <argument><expr><name>tuple_cnt</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
