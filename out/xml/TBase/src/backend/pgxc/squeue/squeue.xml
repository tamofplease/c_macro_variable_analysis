<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/pgxc/squeue/squeue.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * squeue.c
 *
 *      Shared queue is for data exchange in shared memory between sessions,
 * one of which is a producer, providing data rows. Others are consumer agents -
 * sessions initiated from other datanodes, the main purpose of them is to read
 * rows from the shared queue and send then to the parent data node.
 *    The producer is usually a consumer at the same time, it sends back tuples
 * to the parent node without putting it to the queue.
 *
 * Copyright (c) 2012-2014, TransLattice, Inc.
 *
 * IDENTIFICATION
 *      $$
 *
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pgxc_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/prepare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/nodemgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/pgxcnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/squeue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/s_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq-be.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shm_toc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/printtup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execParallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/elog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type>   <name>NSQueues</name> <init>= <expr><literal type="number">64</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>   <name>SQueueSize</name> <init>= <expr><literal type="number">64</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>extern</specifier> <name>ProtocolVersion</name></type> <name>FrontendProtocol</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>  <name>g_UseDataPump</name>         <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt><comment type="block">/* Use data pumb, true default. */</comment>
<decl_stmt><decl><type><name>bool</name></type>  <name>g_DataPumpDebug</name>       <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt><comment type="block">/* enable debug info */</comment>
<decl_stmt><decl><type><name>int32</name></type> <name>g_SndThreadNum</name>        <init>= <expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* Two sender threads default.  */</comment>
<decl_stmt><decl><type><name>int32</name></type> <name>g_SndThreadBufferSize</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>   <comment type="block">/* in Kilo bytes. */</comment>
<decl_stmt><decl><type><name>int32</name></type> <name>g_SndBatchSize</name>        <init>= <expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt>    <comment type="block">/* in Kilo bytes. */</comment>
<decl_stmt><decl><type><name>int</name></type>   <name>consumer_connect_timeout</name> <init>= <expr><literal type="number">128</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* in seconds */</comment>
<decl_stmt><decl><type><name>int</name></type>   <name>g_DisConsumer_timeout</name> <init>= <expr><literal type="number">60</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* in minutes */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_CURSOR_LEN</name></cpp:macro>      <cpp:value>64</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATA_PUMP_SOCKET_DIR</name></cpp:macro>  <cpp:value>"pg_datapump"</cpp:value></cpp:define>   <comment type="block">/* socket dir for data pump */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_SEND_SHARE_DATA</name></cpp:macro>       <cpp:value>UINT64CONST(0xFFFFFFFFFFFFFF01)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_SEND_CONS_MAP</name></cpp:macro>         <cpp:value>UINT64CONST(0xFFFFFFFFFFFFFF02)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_SEND_SENDER_SEM</name></cpp:macro>       <cpp:value>UINT64CONST(0xFFFFFFFFFFFFFF03)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_SEND_DATA_BUFFER</name></cpp:macro>      <cpp:value>UINT64CONST(0xFFFFFFFFFFFFFF04)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_SEND_WORKER_STATUS</name></cpp:macro>    <cpp:value>UINT64CONST(0xFFFFFFFFFFFFFF05)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_SEND_NODE_NO_SOCKET</name></cpp:macro>   <cpp:value>UINT64CONST(0xFFFFFFFFFFFFFF06)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_SEND_NODE_SEND_DONE</name></cpp:macro>   <cpp:value>UINT64CONST(0xFFFFFFFFFFFFFF07)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_SEND_SENDER_ERROR</name></cpp:macro>     <cpp:value>UINT64CONST(0xFFFFFFFFFFFFFF08)</cpp:value></cpp:define>



<decl_stmt><decl><type><specifier>static</specifier> <name>dsm_handle</name></type> <name>parallel_send_seg_handle</name> <init>= <expr><name>DSM_HANDLE_INVALID</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>dsm_segment</name> <modifier>*</modifier></type><name>dsm_seg</name>                <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>SqueueRole</name></type> <name>role</name> <init>= <expr><name>Squeue_None</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>SharedQueue</name></type> <name>share_sq</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>SharedQueue</name></type> <name>share_sq_bak</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>in_data_pump</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>execute_error</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>end_query_requested</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARALLEL_MAGIC</name></cpp:macro>                        <cpp:value>0x50477c7c</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LONG_TUPLE</name></cpp:macro> <cpp:value>-42</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>ConsumerSync</name>
<block>{
    <decl_stmt><decl><type><name>LWLock</name>       <modifier>*</modifier></type><name>cs_lwlock</name></decl>;</decl_stmt>         <comment type="block">/* Synchronize access to the consumer queue */</comment>
    <decl_stmt><decl><type><name>Latch</name></type>         <name>cs_latch</name></decl>;</decl_stmt>     <comment type="block">/* The latch consumer is waiting on */</comment>
}</block></struct></type> <name>ConsumerSync</name>;</typedef>


<comment type="block">/*
 * Shared memory structure to store synchronization info to access shared queues
 */</comment>
<typedef>typedef <type><struct>struct <name>SQueueSync</name>
<block>{
    <decl_stmt><decl><type><name>void</name>        <modifier>*</modifier></type><name>queue</name></decl>;</decl_stmt>             <comment type="block">/* NULL if not assigned to any queue */</comment>
    <decl_stmt><decl><type><name>LWLock</name>       <modifier>*</modifier></type><name>sqs_producer_lwlock</name></decl>;</decl_stmt> <comment type="block">/* Synchronize access to the queue */</comment>
    <decl_stmt><decl><type><name>Latch</name></type>         <name>sqs_producer_latch</name></decl>;</decl_stmt> <comment type="block">/* the latch producer is waiting on */</comment>
    <decl_stmt><decl><type><name>ConsumerSync</name></type> <name><name>sqs_consumer_sync</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* actual length is TBASE_MAX_DATANODE_NUMBER-1 is
                                        * not known on compile time */</comment>
}</block></struct></type> <name>SQueueSync</name>;</typedef>

<comment type="block">/* Both producer and consumer are working */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSUMER_ACTIVE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<comment type="block">/* Producer have finished work successfully and waits for consumer */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSUMER_EOF</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<comment type="block">/* Producer encountered error and waits for consumer to disconnect */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSUMER_ERROR</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<comment type="block">/* Consumer is finished with the query, OK to unbind */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONSUMER_DONE</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>


<comment type="block">/* State of a single consumer */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>int</name></type>            <name>cs_pid</name></decl>;</decl_stmt>            <comment type="block">/* Process id of the consumer session */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>cs_node</name></decl>;</decl_stmt>        <comment type="block">/* Node id of the consumer parent */</comment>
    <comment type="block">/*
     * Queue state. The queue is a cyclic queue where stored tuples in the
     * DataRow format, first goes the lengths of the tuple in host format,
     * because it never sent over network followed by tuple bytes.
     */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>cs_ntuples</name></decl>;</decl_stmt>     <comment type="block">/* Number of tuples in the queue */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>cs_status</name></decl>;</decl_stmt>         <comment type="block">/* See CONSUMER_* defines above */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>cs_qstart</name></decl>;</decl_stmt>        <comment type="block">/* Where consumer queue begins */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>cs_qlength</name></decl>;</decl_stmt>        <comment type="block">/* The size of the consumer queue */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>cs_qreadpos</name></decl>;</decl_stmt>    <comment type="block">/* The read position in the consumer queue */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>cs_qwritepos</name></decl>;</decl_stmt>    <comment type="block">/* The write position in the consumer queue */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type>        <name>send_fd</name></decl>;</decl_stmt>        <comment type="block">/* true if send fd to producer */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>cs_done</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQUEUE_STAT</name></cpp:ifdef>
    <decl_stmt><decl><type><name>long</name></type>         <name>stat_writes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>stat_reads</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>         <name>stat_buff_writes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>stat_buff_reads</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>stat_buff_returns</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>ConsState</name>;</typedef>

<comment type="block">/* Shared queue header */</comment>
<typedef>typedef <type><struct>struct <name>SQueueHeader</name>
<block>{
    <decl_stmt><decl><type><name>char</name></type>        <name><name>sq_key</name><index>[<expr><name>SQUEUE_KEYSIZE</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Hash entry key should be at the
                                 * beginning of the hash entry */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>sq_pid</name></decl>;</decl_stmt>         <comment type="block">/* Process id of the producer session */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>sq_nodeid</name></decl>;</decl_stmt>        <comment type="block">/* Node id of the producer parent */</comment>
    <decl_stmt><decl><type><name>SQueueSync</name> <modifier>*</modifier></type><name>sq_sync</name></decl>;</decl_stmt>        <comment type="block">/* Associated sinchronization objects */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>sq_refcnt</name></decl>;</decl_stmt>        <comment type="block">/* Reference count to this entry */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQUEUE_STAT</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type>        <name>stat_finish</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>        <name>stat_paused</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
     <decl_stmt><decl><type><name>DataPumpSender</name></type> <name>sender</name></decl>;</decl_stmt> <comment type="block">/* used for locally data transfering */</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>with_params</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>sender_destroy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>parallelWorkerSendTuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>numParallelWorkers</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSender</name></type> <name>parallelSendControl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>       <name><name>nodeMap</name><index>[<expr><name>MAX_NODES_NUMBER</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>sq_error</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>err_msg</name><index>[<expr><name>ERR_MSGSIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>has_err_msg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>producer_done</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>nConsumer_done</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>slock_t</name></type>        <name>lock</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>int</name></type>            <name>sq_nconsumers</name></decl>;</decl_stmt>    <comment type="block">/* Number of consumers */</comment>
    <decl_stmt><decl><type><name>ConsState</name></type>     <name><name>sq_consumers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></decl>;</decl_stmt><comment type="block">/* variable length array */</comment>
}</block></struct></type> <name>SQueueHeader</name>;</typedef>


<comment type="block">/*
 * Hash table where all shared queues are stored. Key is the queue name, value
 * is SharedQueue
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>SharedQueues</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>LWLockPadded</name> <modifier>*</modifier></type><name>SQueueLocks</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Pool of synchronization items
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>SQueueSyncs</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQUEUE_SYNC_SIZE</name></cpp:macro> \
    <cpp:value>(sizeof(SQueueSync) + (TBASE_MAX_DATANODE_NUMBER-1) * sizeof(ConsumerSync))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_SQUEUE_SYNC</name><parameter_list>(<parameter><type><name>idx</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>((SQueueSync *) (((char *) SQueueSyncs) + (idx) * SQUEUE_SYNC_SIZE))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQUEUE_HDR_SIZE</name><parameter_list>(<parameter><type><name>nconsumers</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>(sizeof(SQueueHeader) + (nconsumers) * sizeof(ConsState))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_FREE_SPACE</name><parameter_list>(<parameter><type><name>cstate</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>((cstate)-&gt;cs_ntuples &gt; 0 ? \
        ((cstate)-&gt;cs_qreadpos &gt;= (cstate)-&gt;cs_qwritepos ? \
            (cstate)-&gt;cs_qreadpos - (cstate)-&gt;cs_qwritepos : \
            (cstate)-&gt;cs_qlength + (cstate)-&gt;cs_qreadpos \
                                 - (cstate)-&gt;cs_qwritepos) \
        : (cstate)-&gt;cs_qlength)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_WRITE</name><parameter_list>(<parameter><type><name>cstate</name></type></parameter>, <parameter><type><name>len</name></type></parameter>, <parameter><type><name>buf</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do \
    { \
        if ((cstate)-&gt;cs_qwritepos + (len) &lt;= (cstate)-&gt;cs_qlength) \
        { \
            memcpy((cstate)-&gt;cs_qstart + (cstate)-&gt;cs_qwritepos, buf, len); \
            (cstate)-&gt;cs_qwritepos += (len); \
            if ((cstate)-&gt;cs_qwritepos == (cstate)-&gt;cs_qlength) \
                (cstate)-&gt;cs_qwritepos = 0; \
        } \
        else \
        { \
            int part = (cstate)-&gt;cs_qlength - (cstate)-&gt;cs_qwritepos; \
            memcpy((cstate)-&gt;cs_qstart + (cstate)-&gt;cs_qwritepos, buf, part); \
            (cstate)-&gt;cs_qwritepos = (len) - part; \
            memcpy((cstate)-&gt;cs_qstart, (buf) + part, (cstate)-&gt;cs_qwritepos); \
        } \
    } while(0)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUEUE_READ</name><parameter_list>(<parameter><type><name>cstate</name></type></parameter>, <parameter><type><name>len</name></type></parameter>, <parameter><type><name>buf</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do \
    { \
        if ((cstate)-&gt;cs_qreadpos + (len) &lt;= (cstate)-&gt;cs_qlength) \
        { \
            memcpy(buf, (cstate)-&gt;cs_qstart + (cstate)-&gt;cs_qreadpos, len); \
            (cstate)-&gt;cs_qreadpos += (len); \
            if ((cstate)-&gt;cs_qreadpos == (cstate)-&gt;cs_qlength) \
                (cstate)-&gt;cs_qreadpos = 0; \
        } \
        else \
        { \
            int part = (cstate)-&gt;cs_qlength - (cstate)-&gt;cs_qreadpos; \
            memcpy(buf, (cstate)-&gt;cs_qstart + (cstate)-&gt;cs_qreadpos, part); \
            (cstate)-&gt;cs_qreadpos = (len) - part; \
            memcpy((buf) + part, (cstate)-&gt;cs_qstart, (cstate)-&gt;cs_qreadpos); \
        } \
    } while(0)</cpp:value></cpp:define>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>sq_push_long_tuple</name><parameter_list>(<parameter><decl><type><name>ConsState</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>RemoteDataRow</name></type> <name>datarow</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sq_pull_long_tuple</name><parameter_list>(<parameter><decl><type><name>ConsState</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>RemoteDataRow</name></type> <name>datarow</name></decl></parameter>,
                                <parameter><decl><type><name>int</name></type> <name>consumerIdx</name></decl></parameter>, <parameter><decl><type><name>SQueueSync</name> <modifier>*</modifier></type><name>sqsync</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<typedef>typedef <type><struct>struct <name>DisConsumer</name>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>sq_key</name><index>[<expr><name>SQUEUE_KEYSIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>nConsumer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>time</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name><name>disconnect</name><index>[<expr><name>TBASE_MAX_DATANODE_NUMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>DisConsumer</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>DisConsumerHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<comment type="block">/*
typedef struct
{
    int             m_cnt;
    pthread_mutex_t m_mutex;
    pthread_cond_t  m_cond;
}ThreadSema;
*/</comment>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>ThreadSemaInit</name><parameter_list>(<parameter><decl><type><name>ThreadSema</name> <modifier>*</modifier></type><name>sema</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>init</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>ThreadSemaDown</name><parameter_list>(<parameter><decl><type><name>ThreadSema</name> <modifier>*</modifier></type><name>sema</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>ThreadSemaUp</name><parameter_list>(<parameter><decl><type><name>ThreadSema</name> <modifier>*</modifier></type><name>sema</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef  <type><name>slock_t</name></type> <name>pg_spin_lock</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>spinlock_init</name><parameter_list>(<parameter><decl><type><name>pg_spin_lock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>spinlock_lock</name><parameter_list>(<parameter><decl><type><name>pg_spin_lock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>spinlock_unlock</name><parameter_list>(<parameter><decl><type><name>pg_spin_lock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>;</function_decl>


<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>INVALID_BORDER</name></cpp:macro>     <cpp:value>(~((uint32)0))</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct 
<block>{
    <decl_stmt><decl><type><name>char</name>               <modifier>*</modifier></type><name>m_buf</name></decl>;</decl_stmt>    <comment type="block">/* Data buffer */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type>           <name>m_Length</name></decl>;</decl_stmt>  <comment type="block">/* Data buffer length */</comment>
    
    <comment type="block">/* lock to protect offset and status */</comment>
    <decl_stmt><decl><type><name>pg_spin_lock</name></type>       <name>pointerlock</name></decl>;</decl_stmt>                                        
    
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>uint32</name></type>       <name>m_Head</name></decl>;</decl_stmt>       <comment type="block">/* Head of the loop */</comment>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>uint32</name></type>    <name>m_Tail</name></decl>;</decl_stmt>       <comment type="block">/* Tail of the buffer */</comment>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>uint32</name></type>    <name>m_Border</name></decl>;</decl_stmt>     <comment type="block">/* end of last tuple, so that we can send a complete tuple */</comment>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>uint32</name></type>    <name>m_WrapAround</name></decl>;</decl_stmt> <comment type="block">/* wrap around of the queue , for read only */</comment>
}</block></struct></type><name>DataPumpBuf</name>;</typedef>
<comment type="block">/*
typedef enum  
{ 
    MT_THR_JOINABLE, 
    MT_THR_DETACHED 
}MT_thr_detach;
*/</comment>
<typedef>typedef <type><enum>enum 
<block>{ 
    <decl><name>DataPumpSndStatus_no_socket</name>       <init>= <expr><literal type="number">0</literal></expr></init></decl>, 
    <decl><name>DataPumpSndStatus_set_socket</name>      <init>= <expr><literal type="number">1</literal></expr></init></decl>, 
    <decl><name>DataPumpSndStatus_data_sending</name>       <init>= <expr><literal type="number">2</literal></expr></init></decl>,
    <decl><name>DataPumpSndStatus_incomplete_data</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>,
    <decl><name>DataPumpSndStatus_done</name>              <init>= <expr><literal type="number">4</literal></expr></init></decl>,
    <decl><name>DataPumpSndStatus_error</name>           <init>= <expr><literal type="number">5</literal></expr></init></decl>, 
    <decl><name>DataPumpSndStatus_butty</name></decl> 
}</block></enum></type><name>DataPumpSndStatus</name>;</typedef>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>int32</name></type>              <name>nodeindex</name></decl>;</decl_stmt> <comment type="block">/* Node index */</comment>
    <decl_stmt><decl><type><name>int32</name></type>              <name>sock</name></decl>;</decl_stmt>      <comment type="block">/* socket to transfer data */</comment>
    <decl_stmt><decl><type><name>DataPumpSndStatus</name></type>  <name>status</name></decl>;</decl_stmt>    <comment type="block">/* status of the data sending */</comment>

    
    <decl_stmt><decl><type><name>pg_spin_lock</name></type>       <name>lock</name></decl>;</decl_stmt>      <comment type="block">/* lock to protect status */</comment>

    <decl_stmt><decl><type><name>int32</name></type>              <name>errorno</name></decl>;</decl_stmt>   <comment type="block">/* error number of system call */</comment>
    
    <decl_stmt><decl><type><name>DataPumpBuf</name>        <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>      <comment type="block">/* buffer used to send data */</comment>
    
    <decl_stmt><decl><type><name>uint32</name></type>              <name>last_offset</name></decl>;</decl_stmt><comment type="block">/* used for fast send */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>              <name>remaining_length</name></decl>;</decl_stmt>

    
    <decl_stmt><decl><type><name>size_t</name></type>                <name>ntuples</name></decl>;</decl_stmt>     <comment type="block">/* counter for tuple */</comment>
    <decl_stmt><decl><type><name>size_t</name></type>              <name>ntuples_put</name></decl>;</decl_stmt> <comment type="block">/* number of tuples put into tuplestore */</comment>
    <decl_stmt><decl><type><name>size_t</name></type>              <name>ntuples_get</name></decl>;</decl_stmt> <comment type="block">/* number of tuples get from tuplestore */</comment>
    <decl_stmt><decl><type><name>size_t</name></type>                <name>nfast_send</name></decl>;</decl_stmt>  <comment type="block">/* counter for tuple */</comment>

    <decl_stmt><decl><type><name>size_t</name></type>                <name>sleep_count</name></decl>;</decl_stmt> <comment type="block">/* counter sleep */</comment>
}</block></struct></type><name>DataPumpNodeControl</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
    <comment type="block">/* Nodes control of the cursor. */</comment>
    <decl_stmt><decl><type><name>DataPumpNodeControl</name>   <modifier>*</modifier></type><name>nodes</name></decl>;</decl_stmt>
    
    <comment type="block">/* Nodes range of this thread. */</comment>
    <decl_stmt><decl><type><name>int32</name></type>                <name>node_base</name></decl>;</decl_stmt> <comment type="block">/* include */</comment>        
    <decl_stmt><decl><type><name>int32</name></type>              <name>node_end</name></decl>;</decl_stmt>  <comment type="block">/* exclude */</comment>
    <decl_stmt><decl><type><name>int32</name></type>              <name>node_num</name></decl>;</decl_stmt>  <comment type="block">/* total node number */</comment>
    
    
    <decl_stmt><decl><type><name>bool</name></type>               <name>thread_need_quit</name></decl>;</decl_stmt> <comment type="block">/* quit flag */</comment>
    <decl_stmt><decl><type><name>bool</name></type>               <name>error</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>               <name>quit_status</name></decl>;</decl_stmt>         <comment type="block">/* succeessful quit or not */</comment>
    
    <decl_stmt><decl><type><name>bool</name></type>               <name>thread_running</name></decl>;</decl_stmt>     <comment type="block">/* running flag */</comment>
    <decl_stmt><decl><type><name>ThreadSema</name></type>         <name>send_sem</name></decl>;</decl_stmt>         <comment type="block">/* used to wait for data */</comment>
    <decl_stmt><decl><type><name>ThreadSema</name></type>         <name>quit_sem</name></decl>;</decl_stmt>         <comment type="block">/* used to wait for thread quit */</comment>
}</block></struct></type><name>DataPumpThreadControl</name>;</typedef>

<comment type="block">/* */</comment>
<typedef>typedef <type><struct>struct <name>ConvertControl</name>
<block>{
    <decl_stmt><decl><type><name>char</name></type>          <name><name>sqname</name><index>[<expr><name>MAX_CURSOR_LEN</name></expr>]</index></name></decl>;</decl_stmt>   
    <decl_stmt><decl><type><name>int</name></type>           <name>maxConn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>           <name>connect_num</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>           <name>errNO</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ConvertStatus</name></type> <name>cstatus</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ThreadSema</name></type>    <name>quit_sem</name></decl>;</decl_stmt>         <comment type="block">/* used to wait for thread quit */</comment>

    <decl_stmt><decl><type><name>TimestampTz</name></type>   <name>begin_stamp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TimestampTz</name></type>   <name>finish_stamp</name></decl>;</decl_stmt>
}</block></struct></type><name>ConvertControl</name>;</typedef>

<comment type="block">/* One struct for each cursor. */</comment>
<typedef>typedef <type><struct>struct <name>DataPumpSenderControl</name>
<block>{
    <decl_stmt><decl><type><name>int32</name></type>                 <name>node_num</name></decl>;</decl_stmt>       <comment type="block">/* number of node to send data */</comment>
    <decl_stmt><decl><type><name>DataPumpNodeControl</name>   <modifier>*</modifier></type><name>nodes</name></decl>;</decl_stmt>         <comment type="block">/* sending status for nodes of this cursor */</comment>

    <decl_stmt><decl><type><name>int32</name></type>                 <name>thread_num</name></decl>;</decl_stmt>     <comment type="block">/* number of thread to send data */</comment>
    <decl_stmt><decl><type><name>DataPumpThreadControl</name> <modifier>*</modifier></type><name>thread_control</name></decl>;</decl_stmt><comment type="block">/* thread control of the sending threads */</comment>

    <decl_stmt><decl><type><name>ConvertControl</name></type>        <name>convert_control</name></decl>;</decl_stmt><comment type="block">/* control info of thread convert */</comment>

    <decl_stmt><decl><type><name>TupleTableSlot</name>        <modifier>*</modifier></type><name>temp_slot</name></decl>;</decl_stmt>     <comment type="block">/* temp slot used to put_tuplestore */</comment>
    <decl_stmt><decl><type><name>int32</name></type>                  <name>tuple_len</name></decl>;</decl_stmt>      <comment type="block">/* MAX tuplelen of sent tuple */</comment>
}</block></struct></type><name>DataPumpSenderControl</name>;</typedef>

<comment type="block">/*
  *
  * This part is used for parallel workers to send tuples directly without gather/gatherMerge.
  *
  */</comment>
<typedef>typedef <type><struct>struct <name>ParallelSendDataQueue</name>
<block>{
    <decl_stmt><decl><type><name>int32</name></type>            <name>nodeId</name></decl>;</decl_stmt>            <comment type="block">/* which node to send data */</comment>
    <decl_stmt><decl><type><name>int32</name></type>            <name>parallelWorkerNum</name></decl>;</decl_stmt>  <comment type="block">/* send data by which worker */</comment>
    <decl_stmt><decl><type><name>size_t</name></type>           <name>tuples_put</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>           <name>tuples_get</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>           <name>ntuples</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>           <name>fast_send</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>           <name>normal_send</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>           <name>send_times</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>           <name>no_data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>           <name>send_data_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>           <name>write_data_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>             <name>long_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>             <name>wait_free_space</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataPumpSndStatus</name></type>     <name>status</name></decl>;</decl_stmt>      <comment type="block">/* status of the data sending */</comment>
    <decl_stmt><decl><type><name>bool</name></type>             <name>stuck</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>             <name>last_send</name></decl>;</decl_stmt>
    

    <comment type="block">/* lock to protect offset and status */</comment>
    <decl_stmt><decl><type><name>pg_spin_lock</name></type>     <name>bufLock</name></decl>;</decl_stmt>                                        

    <decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name></type>    <name>bufFull</name></decl>;</decl_stmt>            <comment type="block">/* buffer is full? */</comment>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>uint32</name></type>     <name>bufHead</name></decl>;</decl_stmt>            <comment type="block">/* Head of the loop */</comment>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>uint32</name></type>  <name>bufTail</name></decl>;</decl_stmt>            <comment type="block">/* Tail of the buffer */</comment>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>uint32</name></type>  <name>bufBorder</name></decl>;</decl_stmt>          <comment type="block">/* end of last tuple, so that we can send a complete tuple */</comment>

    <decl_stmt><decl><type><name>ThreadSema</name></type>       <name>sendSem</name></decl>;</decl_stmt>            <comment type="block">/* worker need to wait for sem to be set when queue is full */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type>         <name>bufLength</name></decl>;</decl_stmt>          <comment type="block">/* data buffer length */</comment>
    <decl_stmt><decl><type><name>char</name></type>             <name><name>buffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></decl>;</decl_stmt>          <comment type="block">/* data buffer */</comment>
}</block></struct></type> <name>ParallelSendDataQueue</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PW_DATA_QUEUE_SIZE</name></cpp:macro> <cpp:value>(offsetof(ParallelSendDataQueue, buffer) + g_SndThreadBufferSize * 1024)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>ParallelSendNodeControl</name>
<block>{
    <decl_stmt><decl><type><name>int32</name></type>                   <name>nodeId</name></decl>;</decl_stmt>             <comment type="block">/* which node to send data */</comment>
    <decl_stmt><decl><type><name>int32</name></type>                   <name>sock</name></decl>;</decl_stmt>               <comment type="block">/* socket to send data */</comment>
    <decl_stmt><decl><type><name>int32</name></type>                   <name>numParallelWorkers</name></decl>;</decl_stmt> <comment type="block">/* total number of parallel workers */</comment>
    <decl_stmt><decl><type><name>DataPumpSndStatus</name></type>       <name>status</name></decl>;</decl_stmt>             <comment type="block">/* status of the data sending */</comment>

    <decl_stmt><decl><type><name>pg_spin_lock</name></type>            <name>lock</name></decl>;</decl_stmt>                <comment type="block">/* lock to protect status */</comment>

    <decl_stmt><decl><type><name>int32</name></type>                   <name>errorno</name></decl>;</decl_stmt>            <comment type="block">/* error number of system call */</comment>

    <decl_stmt><decl><type><name>int32</name></type>                   <name>current_buffer</name></decl>;</decl_stmt>     <comment type="block">/* which buffer to be sent */</comment>
    <decl_stmt><decl><type><name>ParallelSendDataQueue</name>   <modifier>*</modifier><modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>            <comment type="block">/* buffer used to send data */</comment>
    
    <decl_stmt><decl><type><name>uint32</name></type>                  <name>last_offset</name></decl>;</decl_stmt>        <comment type="block">/* used for fast send */</comment>
    <decl_stmt><decl><type><name>uint32</name></type>                  <name>remaining_length</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>size_t</name></type>                    <name>ntuples</name></decl>;</decl_stmt>            <comment type="block">/* counter for tuple */</comment>
    <decl_stmt><decl><type><name>size_t</name></type>                    <name>sleep_count</name></decl>;</decl_stmt>        <comment type="block">/* counter sleep */</comment>
    <decl_stmt><decl><type><name>size_t</name></type>                  <name>send_timies</name></decl>;</decl_stmt>
}</block></struct></type> <name>ParallelSendNodeControl</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ParallelWorkerControl</name>
<block>{
    <decl_stmt><decl><type><name>int32</name></type>   <name>parallelWorkerNum</name></decl>;</decl_stmt>                  
    <decl_stmt><decl><type><name>int32</name></type>   <name>numNodes</name></decl>;</decl_stmt>                           <comment type="block">/* number of datanodes */</comment>
    <decl_stmt><decl><type><name>int32</name></type>   <name>tupleLen</name></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>int32</name></type>   <name>numThreads</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>ThreadSema</name> <modifier>*</modifier></type><name>threadSem</name></decl>;</decl_stmt>             <comment type="block">/* wake up sender to send data */</comment>

    <decl_stmt><decl><type><name>ParallelSendDataQueue</name>   <modifier>*</modifier><modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>           <comment type="block">/* data buffer to datanodes */</comment>
}</block></struct></type> <name>ParallelWorkerControl</name>;</typedef>

<typedef>typedef <type><enum>enum <name>ParallelSendStatus</name>
<block>{
    <decl><name>ParallelSend_Error</name></decl>,
    <decl><name>ParallelSend_None</name></decl>,
    <decl><name>ParallelSend_Init</name></decl>,
    <decl><name>ParallelSend_ExecDone</name></decl>,
    <decl><name>ParallelSend_SendDone</name></decl>,
    <decl><name>ParallelSend_Finish</name></decl>
}</block></enum></type> <name>ParallelSendStatus</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>ParallelSendStatus</name> <modifier>*</modifier></type><name>senderstatus</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>ParallelSendSharedData</name>
<block>{
    <decl_stmt><decl><type><name>int32</name></type>      <name>numExpectedParallelWorkers</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>      <name>numLaunchedParallelWorkers</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>      <name>numNodes</name></decl>;</decl_stmt>  
    <decl_stmt><decl><type><name>int32</name></type>      <name>numSenderThreads</name></decl>;</decl_stmt>               <comment type="block">/* number of thread senders */</comment>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>sender_error</name></decl>;</decl_stmt>                   <comment type="block">/* sender thread occured error, need to quit */</comment>
    <decl_stmt><decl><type><name>char</name></type>       <name><name>sq_key</name><index>[<expr><name>SQUEUE_KEYSIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type>      <name><name>nodeMap</name><index>[<expr><name>MAX_NODES_NUMBER</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nodeNoSocket</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSendStatus</name> <modifier>*</modifier></type><name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nodeSendDone</name></decl>;</decl_stmt>
        
    <comment type="block">/* used to create locator for parallel workers */</comment>
    <decl_stmt><decl><type><name>char</name></type>       <name>distributionType</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>  <name>distributionKey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>        <name>keytype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name>        <modifier>*</modifier></type><name>consMap</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>ThreadSema</name> <modifier>*</modifier></type><name>threadSem</name></decl>;</decl_stmt>                     <comment type="block">/* sem used to wake up thread sender */</comment>

    <decl_stmt><decl><type><name>ParallelSendDataQueue</name>     <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>         <comment type="block">/* data buffer to datanodes */</comment>
}</block></struct></type> <name>ParallelSendSharedData</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ParallelSendThreadControl</name>
<block>{
    <decl_stmt><decl><type><name>int32</name></type>              <name>threadNum</name></decl>;</decl_stmt>
    <comment type="block">/* Nodes control of the cursor. */</comment>
    <decl_stmt><decl><type><name>ParallelSendNodeControl</name> <modifier>*</modifier></type><name>nodes</name></decl>;</decl_stmt>
    
    <comment type="block">/* Nodes range of this thread. */</comment>
    <decl_stmt><decl><type><name>int32</name></type>                <name>node_base</name></decl>;</decl_stmt>        <comment type="block">/* include */</comment>        
    <decl_stmt><decl><type><name>int32</name></type>              <name>node_end</name></decl>;</decl_stmt>         <comment type="block">/* exclude */</comment>
    <decl_stmt><decl><type><name>int32</name></type>              <name>node_num</name></decl>;</decl_stmt>         <comment type="block">/* total node number */</comment>
    
    
    <decl_stmt><decl><type><name>bool</name></type>               <name>thread_need_quit</name></decl>;</decl_stmt> <comment type="block">/* quit flag */</comment>
    <decl_stmt><decl><type><name>bool</name></type>               <name>quit_status</name></decl>;</decl_stmt>         <comment type="block">/* succeessful quit or not */</comment>
    
    <decl_stmt><decl><type><name>bool</name></type>               <name>thread_running</name></decl>;</decl_stmt>     <comment type="block">/* running flag */</comment>
    <decl_stmt><decl><type><name>ThreadSema</name></type>         <name>quit_sem</name></decl>;</decl_stmt>         <comment type="block">/* used to wait for thread quit */</comment>
    <decl_stmt><decl><type><name>ThreadSema</name> <modifier>*</modifier></type><name>threadSem</name></decl>;</decl_stmt>       <comment type="block">/* wait for data */</comment>
}</block></struct></type> <name>ParallelSendThreadControl</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ParallelSendControl</name>
<block>{
    <decl_stmt><decl><type><name>int32</name></type>                       <name>numParallelWorkers</name></decl>;</decl_stmt><comment type="block">/* number of parallel workers */</comment>
    <decl_stmt><decl><type><name>int32</name></type>                       <name>numNodes</name></decl>;</decl_stmt>          <comment type="block">/* number of node to send data */</comment>
    <decl_stmt><decl><type><name>ParallelSendNodeControl</name>     <modifier>*</modifier></type><name>nodes</name></decl>;</decl_stmt>            <comment type="block">/* sending status for nodes of this cursor */</comment>

    <decl_stmt><decl><type><name>int32</name></type>                       <name>numThreads</name></decl>;</decl_stmt>        <comment type="block">/* number of thread to send data */</comment>
    <decl_stmt><decl><type><name>ParallelSendThreadControl</name>   <modifier>*</modifier></type><name>threadControl</name></decl>;</decl_stmt>    <comment type="block">/* thread control of the sending threads */</comment>

    <decl_stmt><decl><type><name>ConvertControl</name></type>              <name>convertControl</name></decl>;</decl_stmt>    <comment type="block">/* control info of thread convert */</comment>

    <decl_stmt><decl><type><name>bool</name>                       <modifier>*</modifier></type><name>nodeNoSocket</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>                       <modifier>*</modifier></type><name>nodeSendDone</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSendStatus</name>         <modifier>*</modifier></type><name>status</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>ParallelSendSharedData</name>      <modifier>*</modifier></type><name>sharedData</name></decl>;</decl_stmt>       <comment type="block">/* global data in share memory */</comment>
}</block></struct></type> <name>ParallelSendControl</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ParallelSendDestReceiver</name>
<block>{
    <decl_stmt><decl><type><name>DestReceiver</name></type> <name>pub</name></decl>;</decl_stmt>                <comment type="block">/* public fields */</comment>
    <decl_stmt><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name></decl>;</decl_stmt>               <comment type="block">/* share memory */</comment>
    <decl_stmt><decl><type><name>Locator</name>        <modifier>*</modifier></type><name>locator</name></decl>;</decl_stmt>           <comment type="block">/* decide which node the tuple should be sent to */</comment>
    <decl_stmt><decl><type><name>ParallelWorkerControl</name> <modifier>*</modifier></type><name>control</name></decl>;</decl_stmt> <comment type="block">/* worker control */</comment>
    <decl_stmt><decl><type><name>AttrNumber</name></type> <name>distKey</name></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>ParallelSendSharedData</name> <modifier>*</modifier></type><name>sharedData</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier><modifier>*</modifier></type><name>tstores</name></decl>;</decl_stmt>                    <comment type="block">/* storage to buffer data if destination queue
                                                         * is full */</comment>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>mycontext</name></decl>;</decl_stmt>        <comment type="block">/* context containing TQueueDestReceiver */</comment>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>tmpcxt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>      <name>tupledesc</name></decl>;</decl_stmt>        <comment type="block">/* current top-level tuple descriptor */</comment>
    <decl_stmt><decl><type><name>SharedQueue</name></type> <name>squeue</name></decl>;</decl_stmt>             <comment type="block">/* share queue */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <decl_stmt><decl><type><name>uint64</name></type>      <name>send_tuples</name></decl>;</decl_stmt>        <comment type="block">/* total tuples sent to shm_mq */</comment>
    <decl_stmt><decl><type><name>TimestampTz</name></type> <name>send_total_time</name></decl>;</decl_stmt>    <comment type="block">/* total time for sending the tuples */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>ParallelSendDestReceiver</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>DataPumpNodeCheck</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>sndctl</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeindex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>DataPumpRawSendData</name><parameter_list>(<parameter><decl><type><name>DataPumpNodeControl</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>sock</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>reason</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>DataSize</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>FreeSpace</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name>  <modifier>*</modifier></type><name>GetData</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>uiLen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>   <name>IncDataOff</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>uiLen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name>  <modifier>*</modifier></type><name>GetWriteOff</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>uiLen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>   <name>IncWriteOff</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>uiLen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name>  <modifier>*</modifier></type><name>GetWriteOff</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>uiLen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>    <name>ReserveSpace</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>   <name>FillReserveSpace</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>FreeSpace</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>   <name>SetBorder</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name>  <modifier>*</modifier></type><name>DataPumpSenderThread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>  <name>PutData</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="line">//static int32 CreateThread(void *(*f) (void *), void *arg, int32 mode);</comment>
<function_decl><type><specifier>static</specifier> <name>DataPumpBuf</name> <modifier>*</modifier></type><name>BuildDataPumpBuf</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitDataPumpNodeControl</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>nodeindex</name></decl></parameter>, <parameter><decl><type><name>DataPumpNodeControl</name> <modifier>*</modifier></type><name>control</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DataPumpCleanThread</name><parameter_list>(<parameter><decl><type><name>DataPumpSenderControl</name> <modifier>*</modifier></type><name>sender</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>DataPumpFlushAllData</name><parameter_list>(<parameter><decl><type><name>DataPumpNodeControl</name>  <modifier>*</modifier></type><name>nodes</name></decl></parameter>, <parameter><decl><type><name>DataPumpThreadControl</name><modifier>*</modifier></type> <name>control</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DataPumpSendLoop</name><parameter_list>(<parameter><decl><type><name>DataPumpNodeControl</name>  <modifier>*</modifier></type><name>nodes</name></decl></parameter>, <parameter><decl><type><name>DataPumpThreadControl</name><modifier>*</modifier></type> <name>control</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DestoryDataPumpBuf</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitDataPumpThreadControl</name><parameter_list>(<parameter><decl><type><name>DataPumpThreadControl</name> <modifier>*</modifier></type><name>control</name></decl></parameter>, <parameter><decl><type><name>DataPumpNodeControl</name> <modifier>*</modifier></type><name>nodes</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>total</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CreateSenderThread</name><parameter_list>(<parameter><decl><type><name>DataPumpSenderControl</name> <modifier>*</modifier></type><name>sender</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATA_PUMP_PREFIX</name></cpp:macro> <cpp:value>"DataPump "</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>convert_connect</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sqname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>convert_listen</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sqname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxconn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>convert_sendfds</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>fds_to_send</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>convert_recvfds</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>fds</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>send_fd_with_nodeid</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sqname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodeid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>consumerIdx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>ConvertThreadMain</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ConvertDone</name><parameter_list>(<parameter><decl><type><name>ConvertControl</name> <modifier>*</modifier></type><name>convert</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>DataPumpNodeReadyForSend</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>sndctl</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeindex</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>DataPumpSendToNode</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>sndctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeindex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>DataPumpTupleStoreDump</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>sndctl</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeindex</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeId</name></decl></parameter>,
                                             <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tmpslot</name></decl></parameter>, 
                                             <parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tuplestore</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>socket_set_nonblocking</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>non_block</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DataPumpWakeupSender</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>sndctl</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeindex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ExecFastSendDatarow</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>sndctl</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeindex</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>tmpcxt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>  <name>ReturnSpace</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>BufferOffsetAdd</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>pointer</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>ParallelSendControl</name><modifier>*</modifier></type> <name>BuildParallelSendControl</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>sq</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitParallelSendNodeControl</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>nodeId</name></decl></parameter>, <parameter><decl><type><name>ParallelSendNodeControl</name> <modifier>*</modifier></type><name>control</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>numParallelWorkers</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitParallelSendThreadControl</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>threadNum</name></decl></parameter>, <parameter><decl><type><name>ParallelSendThreadControl</name> <modifier>*</modifier></type><name>control</name></decl></parameter>, <parameter><decl><type><name>ParallelSendNodeControl</name> <modifier>*</modifier></type><name>nodes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitParallelSendSharedData</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>sq</name></decl></parameter>, <parameter><decl><type><name>ParallelSendControl</name> <modifier>*</modifier></type><name>senderControl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>consMap_len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MapNodeDataBuffer</name><parameter_list>(<parameter><decl><type><name>ParallelSendControl</name> <modifier>*</modifier></type><name>senderControl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>ParallelConvertThreadMain</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>ParallelSenderThreadMain</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ParallelSenderSendData</name><parameter_list>(<parameter><decl><type><name>ParallelSendThreadControl</name> <modifier>*</modifier></type><name>threadControl</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>last_send</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SendNodeData</name><parameter_list>(<parameter><decl><type><name>ParallelSendNodeControl</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>last_send</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>GetNodeData</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>uiLen</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>long_tuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>NodeDataSize</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>long_tuple</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>wait_free_space</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>  <name>IncNodeDataOff</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>uiLen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>RawSendNodeData</name><parameter_list>(<parameter><decl><type><name>ParallelSendNodeControl</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>sock</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type> <name>reason</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>SetNodeSocket</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>sndctl</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeindex</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeId</name></decl></parameter>,  <parameter><decl><type><name>int32</name></type> <name>socket</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>  <name>ParallelSendCleanThread</name><parameter_list>(<parameter><decl><type><name>ParallelSendControl</name> <modifier>*</modifier></type><name>sender</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DestoryParallelSendControl</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>sndctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodeid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ParallelSendReceiveSlot</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ParallelSendStartupReceiver</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>operation</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>typeinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ParallelSendShutdownReceiver</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ParallelSendDestroyReceiver</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SendNodeDataRemote</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>squeue</name></decl></parameter>, <parameter><decl><type><name>ParallelWorkerControl</name> <modifier>*</modifier></type><name>control</name></decl></parameter>, <parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>consumerIdx</name></decl></parameter>,
                           <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier><modifier>*</modifier></type><name>tuplestore</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>tmpcxt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ParallelSendDataRow</name><parameter_list>(<parameter><decl><type><name>ParallelWorkerControl</name> <modifier>*</modifier></type><name>control</name></decl></parameter>, <parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>consumerIdx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>BufferFreeSpace</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetBufferBorderAndWaitFlag</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>long_tuple</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wait_free_space</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PutNodeData</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>GetBufferWriteOff</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>uiLen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>IncBufferWriteOff</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>uiLen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ParallelFastSendDatarow</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeindex</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>tmpcxt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ReserveBufferSpace</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FillReserveBufferSpace</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>DataBufferOffsetAdd</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>pointer</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ReturnBufferSpace</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>PumpTupleStoreToBuffer</name><parameter_list>(<parameter><decl><type><name>ParallelWorkerControl</name> <modifier>*</modifier></type><name>control</name></decl></parameter>, <parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>consumerIdx</name></decl></parameter>,
                               <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tmpslot</name></decl></parameter>, <parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tuplestore</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>tmpcxt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DestroyParallelSendReceiver</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>NodeStatusCheck</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>squeue</name></decl></parameter>, <parameter><decl><type><name>ParallelSendControl</name> <modifier>*</modifier></type><name>parallelSendControl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numLaunchedParallelWorkers</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ParallelSendCleanAll</name><parameter_list>(<parameter><decl><type><name>ParallelSendControl</name> <modifier>*</modifier></type><name>sender</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodeid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ParallelWorkerExecDone</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numLaunchedParallelWorkers</name></decl></parameter>, <parameter><decl><type><name>ParallelSendStatus</name> <modifier>*</modifier></type><name>status</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ParallelWorkerSendDone</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numLaunchedParallelWorkers</name></decl></parameter>, <parameter><decl><type><name>ParallelSendStatus</name> <modifier>*</modifier></type><name>status</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CreateParallelSenderThread</name><parameter_list>(<parameter><decl><type><name>ParallelSendControl</name> <modifier>*</modifier></type><name>sender</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ConsumerExit</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>sq</name></decl></parameter>, <parameter><decl><type><name>ParallelSendControl</name> <modifier>*</modifier></type><name>sender</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numParallelWorkers</name></decl></parameter>, 
                              <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>count</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>unconnect</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReportErrorConsumer</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>squeue</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * SharedQueuesInit
 *    Initialize the reference on the shared memory hash table where all shared
 * queues are stored. Invoked during postmaster initialization.
 */</comment>
<function><type><name>void</name></type>
<name>SharedQueuesInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASHCTL</name></type> <name>info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>        <name>hash_flags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>     <name>found</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <name>SQUEUE_KEYSIZE</name></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>g_UseDataPump</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <call><name>SQUEUE_HDR_SIZE</name><argument_list>(<argument><expr><name>TBASE_MAX_DATANODE_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <name>SQUEUE_SIZE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Create hash table of fixed size to avoid running out of
     * SQueueSyncs
     */</comment>
    <expr_stmt><expr><name>hash_flags</name> <operator>=</operator> <name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FIXED_SIZE</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>SharedQueues</name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"Shared Queues"</literal></expr></argument>, <argument><expr><name>NUM_SQUEUES</name></expr></argument>,
                                 <argument><expr><name>NUM_SQUEUES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><name>hash_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>g_UseDataPump</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HASHCTL</name></type> <name>ctl</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>        <name>flags</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <name>SQUEUE_KEYSIZE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DisConsumer</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

        <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FIXED_SIZE</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>DisConsumerHash</name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"Disconnect Consumers"</literal></expr></argument>, <argument><expr><name>NUM_SQUEUES</name></expr></argument>,
                             <argument><expr><name>NUM_SQUEUES</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Synchronization stuff is in separate structure because we need to
     * initialize all items now while in the postmaster.
     * The structure is actually an array, each array entry is assigned to
     * each instance of SharedQueue in use.
     */</comment>
    <expr_stmt><expr><name>SQueueSyncs</name> <operator>=</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Shared Queues Sync"</literal></expr></argument>,
                                  <argument><expr><name>SQUEUE_SYNC_SIZE</name> <operator>*</operator> <name>NUM_SQUEUES</name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>    <name>i</name></decl>, <decl><type ref="prev"/><name>l</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>    <name>nlocks</name> <init>= <expr><operator>(</operator><name>NUM_SQUEUES</name> <operator>*</operator> <operator>(</operator><name>TBASE_MAX_DATANODE_NUMBER</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt> <comment type="block">/* 
                                                      * (TBASE_MAX_DATANODE_NUMBER - 1)
                                                      * consumers + 1 producer
                                                      */</comment>
        <decl_stmt><decl><type><name>bool</name></type>    <name>foundLocks</name></decl>;</decl_stmt>

        <comment type="block">/* Initialize LWLocks for queues */</comment>
        <expr_stmt><expr><name>SQueueLocks</name> <operator>=</operator> <operator>(</operator><name>LWLockPadded</name> <operator>*</operator><operator>)</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Shared Queue Locks"</literal></expr></argument>,
                        <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LWLockPadded</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nlocks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>foundLocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* either both syncs and locks, or none of them */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator> <name>foundLocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Register the trannche tranche in the main tranches array */</comment>
        <expr_stmt><expr><call><name>LWLockRegisterTranche</name><argument_list>(<argument><expr><name>LWTRANCHE_SHARED_QUEUES</name></expr></argument>, <argument><expr><literal type="string">"Shared Queue Locks"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_SQUEUES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SQueueSync</name> <modifier>*</modifier></type><name>sqs</name> <init>= <expr><call><name>GET_SQUEUE_SYNC</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>sqs</name><operator>-&gt;</operator><name>queue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>SQueueLocks</name><index>[<expr><name>l</name></expr>]</index></name><operator>)</operator><operator>.</operator><name>lock</name></expr></argument>, <argument><expr><name>LWTRANCHE_SHARED_QUEUES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sqs</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>SQueueLocks</name><index>[<expr><name>l</name><operator>++</operator></expr>]</index></name><operator>)</operator><operator>.</operator><name>lock</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>InitSharedLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqs</name><operator>-&gt;</operator><name>sqs_producer_latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>TBASE_MAX_DATANODE_NUMBER</name><operator>-</operator><literal type="number">1</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><call><name>InitSharedLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqs</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>cs_latch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>SQueueLocks</name><index>[<expr><name>l</name></expr>]</index></name><operator>)</operator><operator>.</operator><name>lock</name></expr></argument>,
                                 <argument><expr><name>LWTRANCHE_SHARED_QUEUES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>sqs</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>SQueueLocks</name><index>[<expr><name>l</name><operator>++</operator></expr>]</index></name><operator>)</operator><operator>.</operator><name>lock</name></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>Size</name></type>
<name>SharedQueueShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Size</name></type> <name>sqs_size</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>sqs_size</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><name>NUM_SQUEUES</name></expr></argument>, <argument><expr><name>SQUEUE_SYNC_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>g_UseDataPump</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>sqs_size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>sqs_size</name></expr></argument>, <argument><expr><call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>NUM_SQUEUES</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DisConsumer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if<condition>(<expr><name>g_UseDataPump</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><call><name>add_size</name><argument_list>(<argument><expr><name>sqs_size</name></expr></argument>, <argument><expr><call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>NUM_SQUEUES</name></expr></argument>, <argument><expr><call><name>SQUEUE_HDR_SIZE</name><argument_list>(<argument><expr><name>TBASE_MAX_DATANODE_NUMBER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <return>return <expr><call><name>add_size</name><argument_list>(<argument><expr><name>sqs_size</name></expr></argument>, <argument><expr><call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>NUM_SQUEUES</name></expr></argument>, <argument><expr><name>SQUEUE_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SharedQueueAcquire
 *     Reserve a named shared queue for future data exchange between processes
 * supplying tuples to remote Datanodes. Invoked when a remote query plan is
 * registered on the Datanode. The number of consumers is known at this point,
 * so shared queue may be formatted during reservation. The first process that
 * is acquiring the shared queue on the Datanode does the formatting.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<decl_stmt><decl><type><name>void</name></type>
<name>SharedQueueAcquire</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>sqname</name></expr></argument>, <argument><expr><name>int</name> <name>ncons</name></expr></argument>, <argument><expr><name>bool</name> <name>parallelSend</name></expr></argument>, <argument><expr><name>int</name> <name>numParallelWorkers</name></expr></argument>, <argument><expr><name>bool</name> <name>with_params</name></expr></argument>)</argument_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<name>void</name>
<name>SharedQueueAcquire</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>sqname</name></expr></argument>, <argument><expr><name>int</name> <name>ncons</name></expr></argument>)</argument_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SharedQueue</name></type> <name>sq</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>trycount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsConnFromDatanode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ncons</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>tryagain</name>:</label>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SQueuesLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Setup PGXC_PARENT_NODE_ID right now to ensure that the cleanup happens
     * correctly even if the consumer never really binds to the shared queue.
     */</comment>
    <expr_stmt><expr><name>PGXC_PARENT_NODE_ID</name> <operator>=</operator> <call><name>PGXCNodeGetNodeIdFromName</name><argument_list>(<argument><expr><name>PGXC_PARENT_NODE</name></expr></argument>,
            <argument><expr><operator>&amp;</operator><name>PGXC_PARENT_NODE_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>PGXC_PARENT_NODE_ID</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SQueuesLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not get nodeid, maybe node %s is droppped."</literal></expr></argument>, <argument><expr><name>PGXC_PARENT_NODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>sq</name> <operator>=</operator> <operator>(</operator><name>SharedQueue</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>SharedQueues</name></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>HASH_ENTER_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sq</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SQueuesLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of shared queue, please increase shared_queues"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* First process acquiring queue should format it */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>        <name>qsize</name></decl>;</decl_stmt>   <comment type="block">/* Size of one queue */</comment>
        <decl_stmt><decl><type><name>int</name></type>        <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>heapPtr</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <decl_stmt><decl><type><name>SQueueSync</name> <modifier>*</modifier></type><name>sqsync</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Create a new SQueue %s and format it for %d consumers"</literal></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>ncons</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Initialize the shared queue */</comment>
        <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_nodeid</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_refcnt</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQUEUE_STAT</name></cpp:ifdef>
        <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>stat_finish</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>stat_paused</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>sender_destroy</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_error</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>with_params</name></name> <operator>=</operator> <name>with_params</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>parallelWorkerSendTuple</name></name> <operator>=</operator> <name>parallelSend</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>numParallelWorkers</name></name>      <operator>=</operator> <name>numParallelWorkers</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ERR_MSGSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>has_err_msg</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>producer_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>nConsumer_done</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sq</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/*
         * Assign sync object (latches to wait on)
         * XXX We may want to optimize this and do smart search instead of
         * iterating the array.
         */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_SQUEUES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SQueueSync</name> <modifier>*</modifier></type><name>sqs</name> <init>= <expr><call><name>GET_SQUEUE_SYNC</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>sqs</name><operator>-&gt;</operator><name>queue</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>sqs</name><operator>-&gt;</operator><name>queue</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>sq</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name></name> <operator>=</operator> <name>sqs</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>g_UseDataPump</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name> <operator>=</operator> <name>ncons</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name> <operator>=</operator> <name>ncons</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        
        <comment type="block">/* Determine queue size for a single consumer */</comment>
        <expr_stmt><expr><name>qsize</name> <operator>=</operator> <operator>(</operator><name>SQUEUE_SIZE</name> <operator>-</operator> <call><name>SQUEUE_HDR_SIZE</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>heapPtr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>sq</name></expr>;</expr_stmt>
        <comment type="block">/* Skip header */</comment>
        <expr_stmt><expr><name>heapPtr</name> <operator>+=</operator> <call><name>SQUEUE_HDR_SIZE</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<comment type="block">/* Init latch */</comment>
		<expr_stmt><expr><name>sqsync</name> <operator>=</operator> <name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>InitSharedLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* Set up consumer queues */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ConsState</name> <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>sq</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_ntuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>=</operator> <name>CONSUMER_ACTIVE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_qstart</name></name> <operator>=</operator> <name>heapPtr</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_qlength</name></name> <operator>=</operator> <name>qsize</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_qreadpos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_qwritepos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>send_fd</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>InitSharedLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_latch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>heapPtr</name> <operator>+=</operator> <name>qsize</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>heapPtr</name> <operator>&lt;=</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>sq</name><operator>)</operator> <operator>+</operator> <name>SQUEUE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Found an existing SQueue %s - (sq_pid:%d, sq_nodeid:%d,"</literal>
            <literal type="string">" sq_nconsumers:%d"</literal></expr></argument>,
            <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_pid</name></name></expr></argument>, <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>, <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, consumer (%d) information (cs_pid:%d,"</literal>
                    <literal type="string">" cs_node:%d, cs_ntuples:%d, cs_status: %d"</literal></expr></argument>,
                    <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                    <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_pid</name></expr></argument>, 
                    <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_node</name></expr></argument>, 
                    <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_ntuples</name></expr></argument>, 
                    <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        </block_content>}</block></for>

        <comment type="block">/*
         * A race condition is possible here. The previous operation might  use
         * the same Shared Queue name if that was different execution of the
         * same Portal. So here we should try to determine if that Shared Queue
         * belongs to this execution or that is not-yet-released Shared Queue
         * of previous operation.
         * Though at the moment I am not sure, but I believe the BIND stage is
         * only happening after completion of ACQUIRE stage, so it is enough
         * to verify the producer (the very first node that binds) is not bound
         * yet. If it is bound, sleep for a moment and try again. No reason to
         * sleep longer, the producer needs just a quantum of CPU time to UNBIND
         * itself.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>sq</name><operator>-&gt;</operator><name>sq_pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type>        <name>old_squeue</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ConsState</name> <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>sq</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name> <operator>==</operator> <name>PGXC_PARENT_NODE_ID</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>SQueueSync</name> <modifier>*</modifier></type><name>sqsync</name> <init>= <expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name></name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>,
                                  <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* verify status */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>!=</operator> <name>CONSUMER_DONE</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>old_squeue</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <if_stmt><if>if <condition>(<expr><name>old_squeue</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SQueuesLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><ternary><condition><expr><operator>(</operator><name>trycount</name> <operator>&lt;</operator> <literal type="number">10</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">10000L</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue race condition, give the old producer to "</literal>
                        <literal type="string">"finish the work and retry again"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>trycount</name><operator>++</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>trycount</name> <operator>&gt;=</operator> <literal type="number">20</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Couldn't resolve SQueue race condition after"</literal>
                            <literal type="string">" %d tries"</literal></expr></argument>, <argument><expr><name>trycount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <goto>goto <name>tryagain</name>;</goto>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_refcnt</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SQueuesLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s acquire, nodeid %d, pid %d."</literal></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>PGXC_PARENT_NODE_ID</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></decl></decl_stmt>


<comment type="block">/*
 * SharedQueueBind
 *    Bind to the shared queue specified by sqname either as a consumer or as a
 * producer. The first process that binds to the shared queue becomes a producer
 * and receives the consumer map, others become consumers and receive queue
 * indexes to read tuples from.
 * The consNodes int list identifies the nodes involved in the current step.
 * The distNodes int list describes result distribution of the current step.
 * The consNodes should be a subset of distNodes.
 * The myindex and consMap parameters are binding results. If caller process
 * is bound to the query as a producer myindex is set to -1 and index of the
 * each consumer (order number in the consNodes) is stored to the consMap array
 * at the position of the node in the distNodes. For the producer node
 * SQ_CONS_SELF is stored, nodes from distNodes list which are not members of
 * consNodes or if it was reported they won't read results, they are represented
 * as SQ_CONS_NONE.
 */</comment>
<function><type><name>SharedQueue</name></type>
<name>SharedQueueBind</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqname</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>consNodes</name></decl></parameter>,
                                   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>distNodes</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>myindex</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>consMap</name></decl></parameter>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
                                   ,
                                    <parameter><decl><type><name>DataPumpSender</name> <modifier>*</modifier></type><name>sender</name></decl></parameter>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                                    )</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SharedQueue</name></type> <name>sq</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SQueuesLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>PGXC_PARENT_NODE_ID</name> <operator>=</operator> <call><name>PGXCNodeGetNodeIdFromName</name><argument_list>(<argument><expr><name>PGXC_PARENT_NODE</name></expr></argument>,
            <argument><expr><operator>&amp;</operator><name>PGXC_PARENT_NODE_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>sq</name> <operator>=</operator> <operator>(</operator><name>SharedQueue</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>SharedQueues</name></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>PGXC_PARENT_NODE_ID</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SQueuesLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not get nodeid, maybe node %s is droppped."</literal></expr></argument>, <argument><expr><name>PGXC_PARENT_NODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <comment type="block">/*
     * It's not clear but it seems that if the producer fails even before a
     * consumer binds to the shared queue, the producer may remove the shared
     * queue (or would refcount mechanism fully protect us against that?). So
     * instead of panicing, just throw a soft error.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SQueuesLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Shared queue %s not found"</literal></expr></argument>, <argument><expr><name>sqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Now acquire the queue-specific lock and then release the top level lock.
     * We must follow a strict ordering between SQueuesLock,
     * sqs_producer_lwlock and the consumer cs_lwlock to avoid a deadlock.
     */</comment>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SQueuesLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>sq</name><operator>-&gt;</operator><name>sq_pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
            <comment type="block">/* Producer */</comment>
            <decl_stmt><decl><type><name>int</name></type>        <name>i</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <decl_stmt><decl><type><name>int</name></type> <name>pro_nodeid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>pro_index</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>consMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Bind node %s to squeue of step %s as a producer, parentPGXCNode %s, parentPGXCPid %d"</literal></expr></argument>,
				 <argument><expr><name>PGXC_PARENT_NODE</name></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>parentPGXCNode</name></expr></argument>, <argument><expr><name>parentPGXCPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Initialize the shared queue */</comment>
            <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_nodeid</name></name> <operator>=</operator> <name>PGXC_PARENT_NODE_ID</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>OwnLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name><operator>-&gt;</operator><name>sqs_producer_latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_NODES_NUMBER</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>nodeMap</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>SQ_CONS_INIT</name></expr>;</expr_stmt>
            </block_content>}</block></for>
                            
            <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <expr_stmt><expr><name>role</name> <operator>=</operator> <name>Squeue_Producer</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>share_sq</name> <operator>=</operator> <name>sq</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>share_sq_bak</name> <operator>=</operator> <name>sq</name></expr>;</expr_stmt>
                
            <if_stmt><if>if <condition>(<expr><name>g_UseDataPump</name></expr>)</condition>
            <block>{<block_content>
                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>distNodes</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type>            <name>nodeid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <decl_stmt><decl><type><name>ConsState</name>  <modifier>*</modifier></type><name>cstate</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type>         <name>j</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><call><name>list_member_int</name><argument_list>(<argument><expr><name>consNodes</name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <expr_stmt><expr><name>cstate</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>sq</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name> <operator>==</operator> <name>nodeid</name></expr>)</condition>
                            <block>{<block_content>
                                <comment type="block">/* The process already reported that queue won't read */</comment>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Node %d of SQueue %s is released already "</literal>
                                        <literal type="string">"at consumer %d, cs_status %d"</literal></expr></argument>,
                                     <argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>consMap</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>SQ_CONS_NONE</name></expr>;</expr_stmt>

                                <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>nodeMap</name><index>[<expr><name>nodeid</name></expr>]</index></name> <operator>=</operator> <name>SQ_CONS_NONE</name></expr>;</expr_stmt>
                                
                                <break>break;</break>
                            </block_content>}</block></if>
                            <if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
                            <block>{<block_content>
                                <comment type="block">/* found unused slot, assign the consumer to it */</comment>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Node %d of SQueue %s is bound at consumer "</literal>
                                        <literal type="string">"%d, cs_status %d"</literal></expr></argument>,
                                        <argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>consMap</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name> <operator>=</operator> <name>nodeid</name></expr>;</expr_stmt>

                                <if_stmt><if>if <condition>(<expr><name>nodeid</name> <operator>&gt;=</operator> <name>MAX_NODES_NUMBER</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"nodeid(%d) exceeds max number(%d) of nodes."</literal></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name>MAX_NODES_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                                
                                <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>nodeMap</name><index>[<expr><name>nodeid</name></expr>]</index></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

                                <if_stmt><if>if<condition>(<expr><name>nodeid</name> <operator>==</operator> <name>PGXC_PARENT_NODE_ID</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>pro_index</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
                                    <expr_stmt><expr><name>pro_nodeid</name> <operator>=</operator> <name>nodeid</name></expr>;</expr_stmt>
                                    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>=</operator> <name>CONSUMER_DONE</name></expr>;</expr_stmt>
                                    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                                
                                <break>break;</break>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></for>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Node %d of SQueue %s is not in the "</literal>
                                <literal type="string">"redistribution list and hence would never connect"</literal></expr></argument>,
                                <argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name>sqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>consMap</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>SQ_CONS_NONE</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>nodeMap</name><index>[<expr><name>nodeid</name></expr>]</index></name> <operator>=</operator> <name>SQ_CONS_NONE</name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>distNodes</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int</name></type>            <name>nodeid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="block">/*
                     * Producer won't go to shared queue to hand off tuple to itself,
                     * so we do not need to create queue for that entry.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name>nodeid</name> <operator>==</operator> <name>PGXC_PARENT_NODE_ID</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* Producer must be in the consNodes list */</comment>
                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_member_int</name><argument_list>(<argument><expr><name>consNodes</name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s consumer @%d is set to self"</literal></expr></argument>,
                                <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>consMap</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>SQ_CONS_SELF</name></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><name>nodeid</name> <operator>&gt;=</operator> <name>MAX_NODES_NUMBER</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"nodeid(%d) exceeds max number(%d) of nodes."</literal></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name>MAX_NODES_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        
                        <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>nodeMap</name><index>[<expr><name>nodeid</name></expr>]</index></name> <operator>=</operator> <name>SQ_CONS_SELF</name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <comment type="block">/*
                     * This node may connect as a consumer, store consumer id to the map
                     * and initialize consumer queue
                     */</comment>
                    <if type="elseif">else if <condition>(<expr><call><name>list_member_int</name><argument_list>(<argument><expr><name>consNodes</name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>ConsState</name>  <modifier>*</modifier></type><name>cstate</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>int</name></type>         <name>j</name></decl>;</decl_stmt>

                        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <expr_stmt><expr><name>cstate</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>sq</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name> <operator>==</operator> <name>nodeid</name></expr>)</condition>
                            <block>{<block_content>
                                <comment type="block">/* The process already reported that queue won't read */</comment>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Node %d of SQueue %s is released already "</literal>
                                        <literal type="string">"at consumer %d, cs_status %d"</literal></expr></argument>,
                                     <argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>consMap</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>SQ_CONS_NONE</name></expr>;</expr_stmt>

                                <if_stmt><if>if <condition>(<expr><name>nodeid</name> <operator>&gt;=</operator> <name>MAX_NODES_NUMBER</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"nodeid(%d) exceeds max number(%d) of nodes."</literal></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name>MAX_NODES_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                                
                                <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>nodeMap</name><index>[<expr><name>nodeid</name></expr>]</index></name> <operator>=</operator> <name>SQ_CONS_NONE</name></expr>;</expr_stmt>
                                <break>break;</break>
                            </block_content>}</block></if>
                            <if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
                            <block>{<block_content>
                                <comment type="block">/* found unused slot, assign the consumer to it */</comment>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Node %d of SQueue %s is bound at consumer "</literal>
                                        <literal type="string">"%d, cs_status %d"</literal></expr></argument>,
                                        <argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>consMap</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name> <operator>=</operator> <name>nodeid</name></expr>;</expr_stmt>

                                <if_stmt><if>if <condition>(<expr><name>nodeid</name> <operator>&gt;=</operator> <name>MAX_NODES_NUMBER</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"nodeid(%d) exceeds max number(%d) of nodes."</literal></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name>MAX_NODES_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                                
                                <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>nodeMap</name><index>[<expr><name>nodeid</name></expr>]</index></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
                                <break>break;</break>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></for>
                     </block_content>}</block></if>
                    <comment type="block">/*
                     * Consumer from this node won't ever connect as upper level step
                     * is not executed on the node. Discard resuls that may go to that
                     * node, if any.
                     */</comment>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Node %d of SQueue %s is not in the "</literal>
                                <literal type="string">"redistribution list and hence would never connect"</literal></expr></argument>,
                                <argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name>sqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>consMap</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>SQ_CONS_NONE</name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block>
            </block_content>}</block></else></if_stmt>
            <if_stmt><if>if <condition>(<expr><name>myindex</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>myindex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * Increment the refcnt only when producer binds. This is a bit
             * asymmetrical, but the way things are currently setup, a consumer
             * though calls SharedQueueBind, never calls SharedQueueUnBind. The
             * unbinding is done only by the producer after it waits for all
             * consumers to finish.
             *
             * XXX This ought to be fixed someday to simplify things in Shared
             * Queue handling
             */</comment> 
            <comment type="line">//sq-&gt;sq_refcnt++;</comment>

            <if_stmt><if>if <condition>(<expr><name>g_UseDataPump</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                  * if parallel workers can send tuples directly, use parallel mode;
                  * else use the default single mode.
                  */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>sq</name><operator>-&gt;</operator><name>parallelWorkerSendTuple</name></name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ParallelSendControl</name> <modifier>*</modifier></type><name>parallelSender</name> <init>= <expr><call><name>BuildParallelSendControl</name><argument_list>(<argument><expr><name>sq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>parallelSender</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to create parallel sender control."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/* store nodeid, consumerIdx, sockfd */</comment>
                    <if_stmt><if>if<condition>(<expr><call><name>SetNodeSocket</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>parallelSendControl</name></name></expr></argument>, <argument><expr><name>pro_index</name></expr></argument>, <argument><expr><name>pro_nodeid</name></expr></argument>, <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DataPumpOK</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not set sockfd of producer."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>sender</name> <operator>=</operator> <call><name>BuildDataPumpSenderControl</name><argument_list>(<argument><expr><name>sq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>sender</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to create sender control."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/* store nodeid, consumerIdx, sockfd */</comment>
                    <if_stmt><if>if<condition>(<expr><call><name>DataPumpSetNodeSocket</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>, <argument><expr><name>pro_index</name></expr></argument>, <argument><expr><name>pro_nodeid</name></expr></argument>, <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DataPumpOK</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not set sockfd of producer."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s bind as producer, nodeid %d, pid %d, consumeridx %d."</literal></expr></argument>,
                          <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>pro_nodeid</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>pro_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>     <name>nconsumers</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

        <comment type="block">/* Producer should be different process */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_pid</name></name> <operator>!=</operator> <name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s has a bound producer from node %d, pid %d"</literal></expr></argument>,
                <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>, <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Bind node %s to SQueue %s as a consumer %d, parentPGXCNode %s, parentPGXCPid %d"</literal></expr></argument>, <argument><expr><name>PGXC_PARENT_NODE</name></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_pid</name></name></expr></argument>, <argument><expr><name>parentPGXCNode</name></expr></argument>, <argument><expr><name>parentPGXCPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Sanity checks */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>myindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>myindex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <comment type="block">/* Ensure the passed in consumer list matches the queue */</comment>
        <expr_stmt><expr><name>nconsumers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>consNodes</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type>         <name>nodeid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>nodeid</name> <operator>==</operator> <name><name>sq</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * This node is a producer it should be in the consumer list,
                 * but no consumer queue for it
                 */</comment>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* find consumer queue for the node */</comment>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ConsState</name> <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>sq</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name> <operator>==</operator> <name>nodeid</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>nconsumers</name><operator>++</operator></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>nodeid</name> <operator>==</operator> <name>PGXC_PARENT_NODE_ID</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * Current consumer queue is that from which current
                         * session will be sending out data rows.
                         * Initialize the queue to let producer know we are
                         * here and runnng.
                         */</comment>
                        <decl_stmt><decl><type><name>SQueueSync</name> <modifier>*</modifier></type><name>sqsync</name> <init>= <expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name></name></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, consumer node %d is same as "</literal>
                                <literal type="string">"the parent node"</literal></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>,
                                      <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/* Make sure no consumer bound to the queue already */</comment>
                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/* make sure the queue is ready to read */</comment>
                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_qlength</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/* verify status */</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>==</operator> <name>CONSUMER_ERROR</name> <operator>||</operator>
                                <name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>==</operator> <name>CONSUMER_DONE</name></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></init></decl>;</decl_stmt>
                            <comment type="block">/*
                             * Producer failed by the time the consumer connect.
                             * Change status to "Done" to allow producer unbind
                             * and report problem to the parent.
                             */</comment>
                            <comment type="line">//cstate-&gt;cs_status = CONSUMER_DONE;</comment>
                            <comment type="block">/* Producer may be waiting for status change */</comment>
                            <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PRODUCER_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Squeue %s Pid %d:Producer failed while we were waiting - status was %d, err_msg %s"</literal></expr></argument>, 
                                     <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <comment type="block">/*
                         * Any other status is acceptable. Normally it would be
                         * ACTIVE. If producer have had only few rows to emit
                         * and it is already done the status would be EOF.
                         */</comment>

                        <comment type="block">/* Set up the consumer */</comment>
                        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>

                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, consumer at %d, status %d - "</literal>
                                <literal type="string">"setting up consumer node %d, pid %d"</literal></expr></argument>,
                                <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>,
                                <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/* return found index */</comment>
                        <expr_stmt><expr><operator>*</operator><name>myindex</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

                        <expr_stmt><expr><call><name>OwnLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_latch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><name>role</name> <operator>=</operator> <name>Squeue_Consumer</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>share_sq</name> <operator>=</operator> <name>sq</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
                        if (g_UseDataPump)
                        {
                            LWLockRelease(sq-&gt;sq_sync-&gt;sqs_producer_lwlock);
                            
                            while(1)
                            {
                                if (send_fd_with_nodeid(sq-&gt;sq_key, nodeid, i))
                                {
                                    if (g_DataPumpDebug)
                                    {
                                        elog(LOG, "Squeue %s:succeed to send fd, nodeid %d, consumeridx %d, pid %d.",
                                                  sq-&gt;sq_key, nodeid, i, MyProcPid);
                                    }
                                    break;
                                }
                                else
                                {
                                    LWLockAcquire(sqsync-&gt;sqs_consumer_sync[i].cs_lwlock, LW_SHARED);
                                    if (cstate-&gt;cs_status == CONSUMER_EOF)
                                    {
                                        if (g_DataPumpDebug)
                                        {
                                            elog(LOG, "Squeue %s:failed to send fd because producer have finished work, nodeid %d, consumeridx %d, pid %d.",
                                                      sq-&gt;sq_key, nodeid, i, MyProcPid);
                                        }
                                        LWLockRelease(sqsync-&gt;sqs_consumer_sync[i].cs_lwlock);
                                        break;
                                    }
                                    else if (cstate-&gt;cs_status == CONSUMER_ERROR ||
                                            cstate-&gt;cs_status == CONSUMER_DONE)
                                    {
                                        LWLockRelease(sqsync-&gt;sqs_consumer_sync[i].cs_lwlock);
                                        ereport(ERROR,
                                            (errcode(ERRCODE_PRODUCER_ERROR),
                                             errmsg("Producer failed while we were waiting for sending fd - status was %d", cstate-&gt;cs_status)));
                                    }
                                    LWLockRelease(sqsync-&gt;sqs_consumer_sync[i].cs_lwlock);
                                }

                                pg_usleep(1000L);
                            }

                            if (g_DataPumpDebug)
                            {
                                elog(LOG, "Squeue %s bind as consumer, nodeid %d, pid %d, consumeridx %d.",
                                          sqname, nodeid, MyProcPid, i);
                            }

                            return sq;
                        }

                        elog(DEBUG1, "queue %s, nodeid %d, pid %d, bind.", sqname, nodeid, MyProcPid);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    </block_content>}</block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, consumer node %d is not same as "</literal>
                                <literal type="string">"the parent node %d"</literal></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>,
                                <argument><expr><name>PGXC_PARENT_NODE_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
            <comment type="block">/* Check if entry was found and therefore loop was broken */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/* should not happen */</comment>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>myindex</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s bind as comsumer:failed to found slot for consumer, pid %d."</literal></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Check the consumer is found */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>myindex</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>g_UseDataPump</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name> <operator>==</operator> <operator>(</operator><name>nconsumers</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name> <operator>==</operator> <name>nconsumers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>sq</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Push data from the local tuplestore to the queue for specified consumer.
 * Return true if succeeded and the tuplestore is now empty. Return false
 * if specified queue has not enough room for the next tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SharedQueueDump</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>squeue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>consumerIdx</name></decl></parameter>,
                           <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tmpslot</name></decl></parameter>, <parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tuplestore</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ConsState</name>  <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>squeue</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"Dumping SQueue %s data for consumer at %d, "</literal>
            <literal type="string">"producer - node %d, pid %d, "</literal>
            <literal type="string">"consumer - node %d, pid %d, status %d"</literal></expr></argument>,
            <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>,
            <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_pid</name></name></expr></argument>,
            <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* discard stored data if consumer is not active */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>!=</operator> <name>CONSUMER_ACTIVE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"Discarding SQueue %s data for consumer at %d not active"</literal></expr></argument>,
                <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>tuplestore_clear</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Tuplestore does not clear eof flag on the active read pointer, causing
     * the store is always in EOF state once reached when there is a single
     * read pointer. We do not want behavior like this and workaround by using
     * secondary read pointer. Primary read pointer (0) is active when we are
     * writing to the tuple store, also it is used to bookmark current position
     * when reading to be able to roll back and return just read tuple back to
     * the store if we failed to write it out to the queue.
     * Secondary read pointer is for reading, and its eof flag is cleared if a
     * tuple is written to the store.
     */</comment>
    <expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If we have something in the tuplestore try to push this to the queue */</comment>
    <while>while <condition>(<expr><operator>!</operator><call><name>tuplestore_ateof</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* save position */</comment>
        <expr_stmt><expr><call><name>tuplestore_copy_read_pointer</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Try to get next tuple to the temporary slot */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>tmpslot</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* false means the tuplestore in EOF state */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"Tuplestore for SQueue %s returned EOF"</literal></expr></argument>,
                    <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQUEUE_STAT</name></cpp:ifdef>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>stat_buff_reads</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* The slot should contain a data row */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tmpslot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* check if queue has enough room for the data */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>QUEUE_FREE_SPACE</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>tmpslot</name><operator>-&gt;</operator><name>tts_datarow</name><operator>-&gt;</operator><name>msglen</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If stored tuple does not fit empty queue we are entering special
             * procedure of pushing it through.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_ntuples</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * If pushing throw is completed wake up and proceed to next
                 * tuple, there could be enough space in the consumer queue to
                 * fit more.
                 */</comment>
                <decl_stmt><decl><type><name>bool</name></type> <name>done</name> <init>= <expr><call><name>sq_push_long_tuple</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>tmpslot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="block">/*
                 * sq_push_long_tuple writes some data anyway, so wake up
                 * the consumer.
                 */</comment>
                <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>squeue</name><operator>-&gt;</operator><name>sq_sync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>.</operator><name>cs_latch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>done</name></expr>)</condition><block type="pseudo"><block_content>
                    <continue>continue;</continue></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* Restore read position to get same tuple next time */</comment>
            <expr_stmt><expr><call><name>tuplestore_copy_read_pointer</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQUEUE_STAT</name></cpp:ifdef>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>stat_buff_returns</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="block">/* We might advance the mark, try to truncate */</comment>
            <expr_stmt><expr><call><name>tuplestore_trim</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Prepare for writing, set proper read pointer */</comment>
            <expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* ... and exit */</comment>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Enqueue data */</comment>
            <expr_stmt><expr><call><name>QUEUE_WRITE</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>tmpslot</name><operator>-&gt;</operator><name>tts_datarow</name><operator>-&gt;</operator><name>msglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>QUEUE_WRITE</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>tmpslot</name><operator>-&gt;</operator><name>tts_datarow</name><operator>-&gt;</operator><name>msglen</name></name></expr></argument>, <argument><expr><name><name>tmpslot</name><operator>-&gt;</operator><name>tts_datarow</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Increment tuple counter. If it was 0 consumer may be waiting for
             * data so try to wake it up */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>cs_ntuples</name></name><operator>)</operator><operator>++</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>squeue</name><operator>-&gt;</operator><name>sq_sync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>.</operator><name>cs_latch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Remove rows we have just read */</comment>
    <expr_stmt><expr><call><name>tuplestore_trim</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* prepare for writes, set read pointer 0 as active */</comment>
    <expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SharedQueueWrite
 *    Write data from the specified slot to the specified queue. If the
 * tuplestore passed in has tuples try and write them first.
 * If specified queue is full the tuple is put into the tuplestore which is
 * created if necessary
 */</comment>
<function><type><name>void</name></type>
<name>SharedQueueWrite</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>squeue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>consumerIdx</name></decl></parameter>,
                            <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier><modifier>*</modifier></type><name>tuplestore</name></decl></parameter>,
                            <parameter><decl><type><name>MemoryContext</name></type> <name>tmpcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ConsState</name>  <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>squeue</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SQueueSync</name> <modifier>*</modifier></type><name>sqsync</name> <init>= <expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_sync</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LWLockId</name></type>    <name>clwlock</name> <init>= <expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteDataRow</name></type> <name>datarow</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>free_datarow</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_qlength</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>clwlock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQUEUE_STAT</name></cpp:ifdef>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>stat_writes</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If we have anything in the local storage try to dump this first,
     * but do not try to dump often to avoid overhead of creating temporary
     * tuple slot. It should be OK to dump if queue is half empty.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>tuplestore</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>dumped</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>QUEUE_FREE_SPACE</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_qlength</name></name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tmpslot</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>tmpslot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>dumped</name> <operator>=</operator> <call><name>SharedQueueDump</name><argument_list>(<argument><expr><name>squeue</name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>, <argument><expr><name>tmpslot</name></expr></argument>, <argument><expr><operator>*</operator><name>tuplestore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tmpslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>dumped</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* No room to even dump local store, append the tuple to the store
             * and exit */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQUEUE_STAT</name></cpp:ifdef>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>stat_buff_writes</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>clwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><operator>*</operator><name>tuplestore</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Get datarow from the tuple slot */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * The function ExecCopySlotDatarow always make a copy, but here we
         * can optimize and avoid copying the data, so we just get the reference
         */</comment>
        <expr_stmt><expr><name>datarow</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>free_datarow</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>datarow</name> <operator>=</operator> <call><name>ExecCopySlotDatarow</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tmpcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>free_datarow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>QUEUE_FREE_SPACE</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>datarow</name><operator>-&gt;</operator><name>msglen</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Not enough room, store tuple locally */</comment>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>clwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* clean up */</comment>
        <if_stmt><if>if <condition>(<expr><name>free_datarow</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>datarow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* Create tuplestore if does not exist */</comment>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>tuplestore</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name>            <name>ptrno</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type>         <name><name>storename</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQUEUE_STAT</name></cpp:ifdef>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Start buffering %s node %d, %d tuples in queue, %ld writes and %ld reads so far"</literal></expr></argument>,
                 <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_ntuples</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>stat_writes</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>stat_reads</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><operator>*</operator><name>tuplestore</name> <operator>=</operator> <call><name>tuplestore_begin_datarow</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>, <argument><expr><name>tmpcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* We need is to be able to remember/restore the read position */</comment>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>storename</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="string">"%s node %d"</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>tuplestore_collect_stat</name><argument_list>(<argument><expr><operator>*</operator><name>tuplestore</name></expr></argument>, <argument><expr><name>storename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/*
             * Allocate a second read pointer to read from the store. We know
             * it must have index 1, so needn't store that.
             */</comment>
            <expr_stmt><expr><name>ptrno</name> <operator>=</operator> <call><name>tuplestore_alloc_read_pointer</name><argument_list>(<argument><expr><operator>*</operator><name>tuplestore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ptrno</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQUEUE_STAT</name></cpp:ifdef>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>stat_buff_writes</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/* Append the slot to the store... */</comment>
        <expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><operator>*</operator><name>tuplestore</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* ... and exit */</comment>
        <return>return;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* do not supply data to closed consumer */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>==</operator> <name>CONSUMER_ACTIVE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, consumer is active, writing data"</literal></expr></argument>,
                    <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* write out the data */</comment>
            <expr_stmt><expr><call><name>QUEUE_WRITE</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>datarow</name><operator>-&gt;</operator><name>msglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>QUEUE_WRITE</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name><name>datarow</name><operator>-&gt;</operator><name>msglen</name></name></expr></argument>, <argument><expr><name><name>datarow</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Increment tuple counter. If it was 0 consumer may be waiting for
             * data so try to wake it up */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>cs_ntuples</name></name><operator>)</operator><operator>++</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>.</operator><name>cs_latch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, consumer is not active, no need to supply data"</literal></expr></argument>,
                    <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* clean up */</comment>
        <if_stmt><if>if <condition>(<expr><name>free_datarow</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>datarow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>clwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * SharedQueueRead
 *    Read one data row from the specified queue into the provided tupleslot.
 * Returns true if EOF is reached on the specified consumer queue.
 * If the queue is empty, behavior is controlled by the canwait parameter.
 * If canwait is true it is waiting while row is available or EOF or error is
 * reported, if it is false, the slot is emptied and false is returned.
 */</comment>
<function><type><name>bool</name></type>
<name>SharedQueueRead</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>squeue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>consumerIdx</name></decl></parameter>,
                            <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>canwait</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ConsState</name>  <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>squeue</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SQueueSync</name> <modifier>*</modifier></type><name>sqsync</name> <init>= <expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_sync</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteDataRow</name></type> <name>datarow</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>datalen</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_qlength</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>g_UseDataPump</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cstate</name><operator>-&gt;</operator><name>send_fd</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>nodeid</name> <init>= <expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sqname</name> <init>= <expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s:try to send fd, nodeid %d, consumeridx %d, pid %d."</literal></expr></argument>,
                          <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>send_fd_with_nodeid</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s:succeed to send fd, nodeid %d, consumeridx %d, pid %d."</literal></expr></argument>,
                                  <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>send_fd</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>==</operator> <name>CONSUMER_EOF</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s:failed to send fd because producer have finished work, nodeid %d, consumeridx %d, pid %d."</literal></expr></argument>,
                                      <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>==</operator> <name>CONSUMER_ERROR</name> <operator>||</operator>
                            <name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>==</operator> <name>CONSUMER_DONE</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PRODUCER_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Squeue %s Pid %d:Producer failed while we were waiting for sending fd - status was %d, err_msg %s"</literal></expr></argument>, 
                             <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>squeue</name><operator>-&gt;</operator><name>sender_destroy</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"squeue %s Pid %d: Producer failed(destroy) while we were waiting for sending fd - status was %d, err_msg %s"</literal></expr></argument>,
						   <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

                <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>

            <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s bind as consumer, nodeid %d, pid %d, consumeridx %d."</literal></expr></argument>,
                          <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If we run out of produced data while reading, we would like to wake up
     * and tell the producer to produce more. But in order to ensure that the
     * producer does not miss the signal, we must obtain sufficient lock on the
     * queue. In order to allow multiple consumers to read from their
     * respective queues at the same time, we obtain a SHARED lock on the
     * queue. But the producer must obtain an EXCLUSIVE lock to ensure it does
     * not miss the signal.
     *
     * Again, important to follow strict lock ordering.
     */</comment> 
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>!=</operator> <name>CONSUMER_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_ntuples</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, consumer node %d, pid %d, status %d - "</literal>
                <literal type="string">"no tuples in the queue"</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>,
                <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>==</operator> <name>CONSUMER_EOF</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, consumer node %d, pid %d, status %d - "</literal>
                    <literal type="string">"EOF marked. Informing produer by setting CONSUMER_DONE"</literal></expr></argument>,
                    <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>,
                    <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Inform producer the consumer have done the job */</comment>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>=</operator> <name>CONSUMER_DONE</name></expr>;</expr_stmt>
            <comment type="block">/* no need to receive notifications */</comment>
            <expr_stmt><expr><call><name>DisownLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>.</operator><name>cs_latch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* producer done the job and no more rows expected, clean up */</comment>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/*
             * notify the producer, it may be waiting while consumers
             * are finishing
             */</comment>
            <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>share_sq</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>==</operator> <name>CONSUMER_ERROR</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, consumer node %d, pid %d, status %d - "</literal>
                    <literal type="string">"CONSUMER_ERROR set"</literal></expr></argument>,
                    <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>,
                    <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/*
             * There was a producer error while waiting.
             * Release all the locks and report problem to the caller.
             */</comment>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Reporting error will cause transaction rollback and clean up of
             * all portals. We can not mark the portal so it does not access
             * the queue so we should hold it for now. We should prevent queue
             * unbound in between.
             */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__PG_REGRESS__</name></cpp:ifdef>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PRODUCER_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to read from SQueue %s, "</literal>
                         <literal type="string">"consumer (node %d, pid %d, status %d) - "</literal>
                         <literal type="string">"CONSUMER_ERROR set, err_msg %s"</literal></expr></argument>,
                         <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>,
                         <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PRODUCER_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Failed to read from SQueue, "</literal>
						 <literal type="string">"CONSUMER_ERROR set, err_msg %s"</literal></expr></argument>,
						 <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name><name>squeue</name><operator>-&gt;</operator><name>sender_destroy</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"squeue %s Pid %d: Producer failed while we were reading data from squeue - status was %d, err_msg %s"</literal></expr></argument>,
				   <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
        <comment type="block">/* got end query request */</comment>
        <if_stmt><if>if <condition>(<expr><name>end_query_requested</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>end_query_requested</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>squeue</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>nConsumer_done</name></name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>squeue</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"squeue %s consumer %d pid %d set query done."</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if <condition>(<expr><name>canwait</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Prepare waiting on empty buffer */</comment>
            <expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>.</operator><name>cs_latch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, consumer (node %d, pid %d, status %d) - "</literal>
                    <literal type="string">"no queued tuples to read, waiting "</literal>
                    <literal type="string">"for producer to produce more data"</literal></expr></argument>,
                    <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>,
                    <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Inform the producer to produce more while we wait for it */</comment>
            <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Wait for notification about available info */</comment>
            <expr_stmt><expr><call><name>WaitLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>.</operator><name>cs_latch</name></expr></argument>,
                    <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name> <operator>|</operator> <name>WL_TIMEOUT</name></expr></argument>, <argument><expr><literal type="number">1000L</literal></expr></argument>,
                    <argument><expr><name>WAIT_EVENT_MQ_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* got the notification, restore lock and try again */</comment>
            <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, consumer (node %d, pid %d, status %d) - "</literal>
                    <literal type="string">"no queued tuples to read, caller can't wait "</literal></expr></argument>,
                    <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>,
                    <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></else></if_stmt>

    </block_content>}</block></while>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, consumer (node %d, pid %d, status %d) - "</literal>
            <literal type="string">"%d queued tuples to read"</literal></expr></argument>,
            <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>,
            <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>,
            <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_ntuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* have at least one row, read it in and store to slot */</comment>
    <expr_stmt><expr><call><name>QUEUE_READ</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>datalen</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>datarow</name> <operator>=</operator> <operator>(</operator><name>RemoteDataRow</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RemoteDataRowData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>datarow</name><operator>-&gt;</operator><name>msgnode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>datarow</name><operator>-&gt;</operator><name>msglen</name></name> <operator>=</operator> <name>datalen</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>datalen</name> <operator>&gt;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_qlength</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>sq_pull_long_tuple</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>datarow</name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>, <argument><expr><name>sqsync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>QUEUE_READ</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>datalen</name></expr></argument>, <argument><expr><name><name>datarow</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    <expr_stmt><expr><call><name>ExecStoreDataRowTuple</name><argument_list>(<argument><expr><name>datarow</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>cs_ntuples</name></name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQUEUE_STAT</name></cpp:ifdef>
    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>stat_reads</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* sanity check */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>cs_ntuples</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>==</operator> <operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>cs_qreadpos</name></name> <operator>==</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_qwritepos</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Mark specified consumer as closed discarding all input which may already be
 * in the queue.
 * If consumerIdx is -1 the producer is cleaned up. Producer need to wait for
 * consumers before releasing the queue, so if there are yet active consumers,
 * they are notified about the problem and they should disconnect from the
 * queue as soon as possible.
 */</comment>
<function><type><name>void</name></type>
<name>SharedQueueReset</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>squeue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>consumerIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>SQueueSync</name> <modifier>*</modifier></type><name>sqsync</name> <init>= <expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_sync</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* 
     * We may have already cleaned up, but then an abort signalled us to clean up.
     * Avoid segmentation fault on abort
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sqsync</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>consumerIdx</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, requested to reset producer node %d, pid %d - "</literal>
                    <literal type="string">"Now also resetting all consumers"</literal></expr></argument>,
                    <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <comment type="block">/* tell sender and convert to exit */</comment>
        <if_stmt><if>if <condition>(<expr><name>g_UseDataPump</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ReportErrorConsumer</name><argument_list>(<argument><expr><name>squeue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>squeue</name><operator>-&gt;</operator><name>sender_destroy</name></name> <operator>&amp;&amp;</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_pid</name></name> <operator>==</operator> <name>MyProcPid</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>squeue</name><operator>-&gt;</operator><name>parallelWorkerSendTuple</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>DataPumpWaitSenderDone</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>DestoryDataPumpSenderControl</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender_destroy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ParallelSendCleanThread</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>parallelSendControl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>DestoryParallelSendControl</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>parallelSendControl</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>parallelSendControl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender_destroy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <expr_stmt><expr><name>share_sq</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>RemoveDisConsumerHash</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* check queue states */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ConsState</name> <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><name><name>squeue</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * If producer being reset before it is reached the end of the
             * result set, that means consumer probably would not get all
             * the rows and it should report error if the consumer's parent ever
             * try to read. No need to raise error if consumer is just closed.
             * If consumer is done already we do not need to change the status.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>!=</operator> <name>CONSUMER_EOF</name> <operator>&amp;&amp;</operator>
                    <name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>!=</operator> <name>CONSUMER_DONE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, reset consumer at %d, "</literal>
                        <literal type="string">"consumer node %d, pid %d, status %d - marking CONSUMER_ERROR"</literal></expr></argument>,
                        <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name></expr></argument>,
                        <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>=</operator> <name>CONSUMER_ERROR</name></expr>;</expr_stmt>
                <comment type="block">/* discard tuples which may already be in the queue */</comment>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_ntuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <comment type="block">/* keep consistent with cs_ntuples*/</comment>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_qreadpos</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_qwritepos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

                <comment type="block">/* wake up consumer if it is sleeping */</comment>
                <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_latch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Tell producer about change in the state */</comment>
                <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s:producer(pid %d, nodeid %d) reset consumer idx %d, nodeid %d, pid %d."</literal></expr></argument>,
                               <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_pid</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>ConsState</name>  <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>squeue</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, requested to reset consumer at %d, "</literal>
                    <literal type="string">"consumer node %d, pid %d, status %d"</literal></expr></argument>,
                    <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name></expr></argument>,
                    <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>,
                      <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>!=</operator> <name>CONSUMER_DONE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, consumer at %d, "</literal>
                <literal type="string">"consumer node %d, pid %d, status %d - marking CONSUMER_DONE"</literal></expr></argument>,
                <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name></expr></argument>,
                <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Inform producer the consumer have done the job */</comment>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>=</operator> <name>CONSUMER_DONE</name></expr>;</expr_stmt>
            <comment type="block">/*
             * No longer need to receive notifications. If consumer has not
             * connected the latch is not owned
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>DisownLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>.</operator><name>cs_latch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <comment type="block">/*
             * notify the producer, it may be waiting while consumers
             * are finishing
             */</comment>
            <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s:consumer reset consumer idx %d, nodeid %d, pid %d."</literal></expr></argument>,
                           <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>SetDisConnectConsumer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cons</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DisConsumer</name> <modifier>*</modifier></type><name>ent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"SetDisConnectConsumer: squeue %s pid %d cons %d"</literal></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>cons</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>DisconnectConsLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* vacuum */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name>DisConsumerHash</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <operator>(</operator><name>NUM_SQUEUES</name> <operator>/</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>g_DisConsumer_timeout</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>scan_status</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>DisConsumer</name>  <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TimestampTz</name></type> <name>t</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>, <argument><expr><name>DisConsumerHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><operator>(</operator><name>item</name> <operator>=</operator> <operator>(</operator><name>DisConsumer</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scan_status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>t</name> <operator>-</operator> <name><name>item</name><operator>-&gt;</operator><name>time</name></name> <operator>&gt;=</operator> <operator>(</operator><name>g_DisConsumer_timeout</name> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <name>USECS_PER_SEC</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>DisConsumerHash</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>DisConsumer</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>DisConsumerHash</name></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>HASH_ENTER_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ent</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DisconnectConsLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SetDisConnectConsumer: could not find hash entry, out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>PGXC_PARENT_NODE_ID</name> <operator>=</operator> <call><name>PGXCNodeGetNodeIdFromName</name><argument_list>(<argument><expr><name>PGXC_PARENT_NODE</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name>PGXC_PARENT_NODE_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>PGXC_PARENT_NODE_ID</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DisconnectConsLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SetDisConnectConsumer: could not get nodeid, maybe node %s is droppped."</literal></expr></argument>, <argument><expr><name>PGXC_PARENT_NODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>nConsumer</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>disconnect</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>TBASE_MAX_DATANODE_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ent</name><operator>-&gt;</operator><name>disconnect</name><index>[<expr><name>PGXC_PARENT_NODE_ID</name></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>nConsumer</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>disconnect</name><index>[<expr><name>PGXC_PARENT_NODE_ID</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>ent</name><operator>-&gt;</operator><name>nConsumer</name></name> <operator>==</operator> <name>cons</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>DisConsumerHash</name></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
        
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DisconnectConsLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>IsConsumerDisConnect</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sqname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodeid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>disconnect</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DisConsumer</name> <modifier>*</modifier></type><name>ent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>DisconnectConsLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>ent</name> <operator>=</operator> <operator>(</operator><name>DisConsumer</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>DisConsumerHash</name></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>disconnect</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>disconnect</name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>disconnect</name><index>[<expr><name>nodeid</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DisconnectConsLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>disconnect</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>RemoveDisConsumerHash</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sqname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>DisconnectConsLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>DisConsumerHash</name></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>DisconnectConsLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Disconnect a remote consumer for the given shared queue.
 *
 * A node may not join a shared queue in certain circumstances such as when the
 * other side of the join has not produced any rows and the RemoteSubplan is
 * not at all executed on the node. Even in that case, we should receive a
 * 'statement close' message from the remote node and mark that specific
 * consumer as DONE.
 */</comment>
<function><type><name>void</name></type>
<name>SharedQueueDisconnectConsumer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqname</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SharedQueue</name></type> <name>squeue</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SQueueSync</name> <modifier>*</modifier></type><name>sqsync</name></decl>;</decl_stmt>
    
    <comment type="block">/*
     * Be prepared to be called even when there are no shared queues setup.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>SharedQueues</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s: SharedQueueDisconnectConsumer Pid %d, nodeid %d"</literal></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>PGXC_PARENT_NODE_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SQueuesLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>squeue</name> <operator>=</operator> <operator>(</operator><name>SharedQueue</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>SharedQueues</name></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name> <operator>||</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sender_destroy</name></name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name> <operator>||</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>
        <comment type="block">/*
         * If the shared queue with the given name is not found or if the
         * producer has not yet bound, nothing is done.
         *
         * XXX Is it possible that the producer binds after this remote
         * consumer has closed the statement? If that happens, the prodcuer
         * will not know that this consumer is not going to connect. We
         * need to study this further and make adjustments if necessary.
         */</comment>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SQueuesLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s: SharedQueueDisconnectConsumer squeue not Found Pid %d, nodeid %d"</literal></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>PGXC_PARENT_NODE_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return;</return>
    </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>sqsync</name> <operator>=</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_sync</name></name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    PGXC_PARENT_NODE_ID = PGXCNodeGetNodeIdFromName(PGXC_PARENT_NODE,
                            &amp;PGXC_PARENT_NODE_TYPE);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SQueuesLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* check queue states */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ConsState</name> <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><name><name>squeue</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name> <operator>==</operator> <name>PGXC_PARENT_NODE_ID</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>=</operator> <name>CONSUMER_DONE</name></expr>;</expr_stmt>
            <comment type="block">/* discard tuples which may already be in the queue */</comment>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_ntuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <comment type="block">/* keep consistent with cs_ntuples*/</comment>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_qreadpos</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_qwritepos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s:consumer disconnect consumer idx %d, nodeid %d, pid %d."</literal></expr></argument>, 
                           <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <break>break;</break>
        </block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
        <if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name> <operator>=</operator> <name>PGXC_PARENT_NODE_ID</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>=</operator> <name>CONSUMER_DONE</name></expr>;</expr_stmt>
            <comment type="block">/* discard tuples which may already be in the queue */</comment>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_ntuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <comment type="block">/* keep consistent with cs_ntuples*/</comment>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_qreadpos</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_qwritepos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s:consumer(not found) disconnect consumer idx %d, nodeid %d, pid %d."</literal></expr></argument>, 
                           <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <break>break;</break>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>        
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Assume that not yet connected consumers won't connect and reset them.
 * That should allow to Finish/UnBind the queue gracefully and prevent
 * producer hanging.
 */</comment>
<function><type><name>void</name></type>
<name>SharedQueueResetNotConnected</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>squeue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SQueueSync</name> <modifier>*</modifier></type><name>sqsync</name> <init>= <expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_sync</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, resetting all unconnected consumers"</literal></expr></argument>,
            <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_sync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check queue states */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ConsState</name> <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><name><name>squeue</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                <name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>!=</operator> <name>CONSUMER_DONE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, consumer at %d, consumer node %d, pid %d, "</literal>
                    <literal type="string">"status %d is cancelled - marking CONSUMER_ERROR"</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                    <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>=</operator> <name>CONSUMER_DONE</name></expr>;</expr_stmt>
            <comment type="block">/* discard tuples which may already be in the queue */</comment>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_ntuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <comment type="block">/* keep consistent with cs_ntuples*/</comment>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_qreadpos</name></name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_qwritepos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

            <comment type="block">/* wake up consumer if it is sleeping */</comment>
            <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_latch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s: producer(pid %d, nodeid %d) reset NotConnected consumer idx %d, nodeid %d, pid %d."</literal></expr></argument>,
                           <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_pid</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wait on the producer latch, for timeout msec. If timeout occurs, return
 * true, else return false.
 */</comment>
<function><type><name>bool</name></type>
<name>SharedQueueWaitOnProducerLatch</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>squeue</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>SQueueSync</name> <modifier>*</modifier></type><name>sqsync</name> <init>= <expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_sync</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>WaitLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_latch</name></name></expr></argument>,
            <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name> <operator>|</operator> <name>WL_TIMEOUT</name></expr></argument>,
            <argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>WAIT_EVENT_MQ_INTERNAL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>rc</name> <operator>&amp;</operator> <operator>(</operator><name>WL_TIMEOUT</name><operator>|</operator><name>WL_POSTMASTER_DEATH</name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Determine if producer can safely pause work.
 * The producer can pause if all consumers have enough data to read while
 * producer is sleeping.
 * Obvoius case when the producer can not pause if at least one queue is empty.
 */</comment>
<function><type><name>bool</name></type>
<name>SharedQueueCanPause</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>squeue</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>SQueueSync</name> <modifier>*</modifier></type><name>sqsync</name> <init>= <expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_sync</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>         <name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>usedspace</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ncons</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>usedspace</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>ncons</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>result</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>i</name> <operator>&lt;</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_nconsumers</name></name><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ConsState</name> <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>squeue</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * Count only consumers that may be blocked.
         * If producer has finished scanning and pushing local buffers some
         * consumers may be finished already.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>==</operator> <name>CONSUMER_ACTIVE</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* can not pause if some queue is empty */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>cs_ntuples</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>usedspace</name> <operator>+=</operator> <operator>(</operator><ternary><condition><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_qwritepos</name></name> <operator>&gt;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_qreadpos</name></name></expr> ?</condition><then>
                              <expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_qwritepos</name></name> <operator>-</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_qreadpos</name></name></expr> </then><else>:
                              <expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_qlength</name></name> <operator>+</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_qwritepos</name></name>
                                                 <operator>-</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_qreadpos</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>ncons</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ncons</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Pause only if average consumer queue is full more then on half.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>usedspace</name> <operator>/</operator> <name>ncons</name> <operator>&gt;</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>cs_qlength</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQUEUE_STAT</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>stat_paused</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>SharedQueueFinish</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>squeue</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>,
                              <parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier><modifier>*</modifier></type><name>tuplestore</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>            <name>tuplestore_done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>           <name>unfinish_tuplestore</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SQueueSync</name> <modifier>*</modifier></type><name>sqsync</name> <init>= <expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_sync</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tmpslot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>             <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>             <name>nstores</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>             <name>send_times</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>             <name>timeout</name> <init>= <expr><name>consumer_connect_timeout</name> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, finishing the SQueue - producer node %d, "</literal>
            <literal type="string">"pid %d, nconsumers %d"</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>,
            <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_pid</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sqsync</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, finishing the SQueue - producer node %d, "</literal>
            <literal type="string">"pid %d, nconsumers %d"</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>,
            <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_pid</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>g_UseDataPump</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>squeue</name><operator>-&gt;</operator><name>sender_destroy</name></name> <operator>&amp;&amp;</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_pid</name></name> <operator>==</operator> <name>MyProcPid</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>squeue</name><operator>-&gt;</operator><name>parallelWorkerSendTuple</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type>  <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>  <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ParallelSendControl</name> <modifier>*</modifier></type><name>parallelSendControl</name> <init>= <expr><name><name>squeue</name><operator>-&gt;</operator><name>parallelSendControl</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ParallelSendNodeControl</name>  <modifier>*</modifier></type><name>nodes</name> <init>= <expr><name><name>parallelSendControl</name><operator>-&gt;</operator><name>nodes</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ParallelSendSharedData</name> <modifier>*</modifier></type><name>sharedData</name> <init>= <expr><name><name>parallelSendControl</name><operator>-&gt;</operator><name>sharedData</name></name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>ParallelSendCleanThread</name><argument_list>(<argument><expr><name>parallelSendControl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>NodeStatusCheck</name><argument_list>(<argument><expr><name>squeue</name></expr></argument>, <argument><expr><name>parallelSendControl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"parallel sender:node status abnormal."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                
                <comment type="block">/* sanity check and log stats */</comment>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ConsState</name> <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><name><name>squeue</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>ParallelSendNodeControl</name>  <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>                    
                    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>DataPumpSndStatus_set_socket</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <block>{<block_content>
                        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>sharedData</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><name><name>buffer</name><operator>-&gt;</operator><name>tuples_get</name></name> <operator>!=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>tuples_put</name></name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"node %d, workerId %d, get_tuples:%zu, put_tuples:%zu, fast_send:%zu, normal_send:%zu, total:%zu"</literal></expr></argument>,
                                             <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>tuples_get</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>tuples_put</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>fast_send</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>normal_send</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>ntuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>

                            <if_stmt><if>if <condition>(<expr><name><name>buffer</name><operator>-&gt;</operator><name>normal_send</name></name> <operator>+</operator> <name><name>buffer</name><operator>-&gt;</operator><name>fast_send</name></name> <operator>!=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>ntuples</name></name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"node %d, workerId %d, fast_send:%zu, normal_send:%zu, total:%zu"</literal></expr></argument>,
                                             <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>fast_send</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>normal_send</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>ntuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>

                            <if_stmt><if>if <condition>(<expr><name><name>buffer</name><operator>-&gt;</operator><name>bufHead</name></name> <operator>!=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>bufTail</name></name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"data left in buffer. node %d, buffer %d, head %u, tail %u, border %u."</literal></expr></argument>,
                                            <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>bufHead</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>bufTail</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>bufBorder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>

                            <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"SendTuples Statistic node %d, workerId %d, get_tuples:%zu, put_tuples:%zu, fast_send:%zu, normal_send:%zu, total:%zu."</literal> 
                                           <literal type="string">"buffer head:%u, buffer tail:%u, buffer border:%u."</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>tuples_get</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>tuples_put</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>fast_send</name></name></expr></argument>, 
                                           <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>normal_send</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>ntuples</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>bufHead</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>bufTail</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>bufBorder</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></for>

                        <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"node %d, sleep_count:%zu"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sleep_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>sharedData</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"node %d does not fetch tuples, workerId %d, get_tuples:%zu, put_tuples:%zu, fast_send:%zu, normal_send:%zu, total:%zu"</literal></expr></argument>,
                                           <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>tuples_get</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>tuples_put</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>fast_send</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>normal_send</name></name></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>ntuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></for>
                    </block_content>}</block></else></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name> <operator>!=</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sock</name></name> <operator>=</operator> <name>NO_SOCKET</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></for>
                
                <expr_stmt><expr><call><name>DestoryParallelSendControl</name><argument_list>(<argument><expr><name>parallelSendControl</name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>parallelSendControl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                
                <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender_destroy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>share_sq</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, parallel finishing the SQueue - producer node %d, "</literal>
                                 <literal type="string">"pid %d, nconsumers %d"</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>,
                                 <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_pid</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
<label><name>SEND_DATA</name>:</label>
            <block>{<block_content>
                <decl_stmt><decl><type><name>DataPumpSenderControl</name> <modifier>*</modifier></type><name>sender</name>   <init>= <expr><operator>(</operator><name>DataPumpSenderControl</name><operator>*</operator><operator>)</operator><name><name>squeue</name><operator>-&gt;</operator><name>sender</name></name></expr></init></decl>;</decl_stmt>
                <do>do
                <block>{<block_content>
                    <expr_stmt><expr><name>unfinish_tuplestore</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name>nstores</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>ConsState</name> <modifier>*</modifier></type><name>cstate</name>         <init>= <expr><operator>&amp;</operator><name><name>squeue</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>DataPumpNodeControl</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                        <comment type="line">//LWLockAcquire(sqsync-&gt;sqs_consumer_sync[i].cs_lwlock, LW_EXCLUSIVE);</comment>

                        <if_stmt><if>if <condition>(<expr><name>end_query_requested</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>producer_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>end_query_requested</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                            <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>squeue</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>nConsumer_done</name></name><operator>++</operator></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>squeue</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"SharedQueueFinish:squeue %s producer set query done"</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>

                        <if_stmt><if>if <condition>(<expr><call><name>IsConsumerDisConnect</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>==</operator> <name>CONSUMER_ACTIVE</name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>=</operator> <name>CONSUMER_DONE</name></expr>;</expr_stmt>

                                <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"SharedQueueFinish:squeue %s set consumer %d done"</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block></if></if_stmt>
                            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>

                        <if_stmt><if>if <condition>(<expr><name><name>tuplestore</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/* If the consumer is not reading just destroy the tuplestore */</comment>
                            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>!=</operator> <name>CONSUMER_ACTIVE</name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name> <operator>!=</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name><operator>)</operator> <operator>||</operator>
                                <operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name> <operator>==</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name> <operator>&amp;&amp;</operator> <name><name>squeue</name><operator>-&gt;</operator><name>producer_done</name></name><operator>)</operator> <operator>||</operator>
                                <operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>cs_done</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>send_fd</name></name><operator>)</operator></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>tuplestore</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>tuplestore</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                                <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s finish: consumer idx %d, nodeid %d does not need the data,"</literal>
                                              <literal type="string">"destroy the tuplestore."</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>

                                <comment type="block">/* consumer do not need more data, such as limit case */</comment>
                                <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>cs_done</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>send_fd</name></name><operator>)</operator> <operator>||</operator>
                                    <operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name> <operator>==</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name> <operator>&amp;&amp;</operator> <name><name>squeue</name><operator>-&gt;</operator><name>producer_done</name></name><operator>)</operator></expr>)</condition>
                                <block>{<block_content>
                                    <while>while <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name><operator>-&gt;</operator><name>m_Head</name></name> <operator>!=</operator> <name><name>node</name><operator>-&gt;</operator><name>buffer</name><operator>-&gt;</operator><name>m_Tail</name></name></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><call><name>DataPumpWakeupSender</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>DataPumpNodeCheck</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition>
                                        <block>{<block_content>
                                            <comment type="line">//LWLockRelease(sqsync-&gt;sqs_consumer_sync[i].cs_lwlock);</comment>
                                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SharedQueueFinish:node %d status abnormal."</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        </block_content>}</block></if></if_stmt>
                                        <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">50L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></while>
                                    
                                    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_done</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>send_fd</name></name></expr>)</condition>
                                    <block>{<block_content>
                                        <comment type="block">/* release fd */</comment>
                                        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr>)</condition>
                                        <block>{<block_content>
                                            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sock</name></name> <operator>=</operator> <name>NO_SOCKET</name></expr>;</expr_stmt>
                                        </block_content>}</block></if></if_stmt>
                                        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>=</operator> <name>CONSUMER_EOF</name></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block></if>
                            <else>else
                            <block>{<block_content>
                                <expr_stmt><expr><name>nstores</name><operator>++</operator></expr>;</expr_stmt>
                            
                                <if_stmt><if>if <condition>(<expr><name>tmpslot</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name>tmpslot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if>
                                <else>else
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>tmpslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></else></if_stmt>
                                <expr_stmt><expr><name>tuplestore_done</name> <operator>=</operator> <call><name>DataPumpTupleStoreDump</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, 
                                                                         <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>,
                                                                         <argument><expr><name>tmpslot</name></expr></argument>, 
                                                                         <argument><expr><name><name>tuplestore</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                                     
                                <if_stmt><if>if <condition>(<expr><name>tuplestore_done</name></expr>)</condition>
                                <block>{<block_content>                
                                    <while>while <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name><operator>-&gt;</operator><name>m_Head</name></name> <operator>!=</operator> <name><name>node</name><operator>-&gt;</operator><name>buffer</name><operator>-&gt;</operator><name>m_Tail</name></name></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><call><name>DataPumpWakeupSender</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>DataPumpNodeCheck</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition>
                                        <block>{<block_content>
                                            <comment type="line">//LWLockRelease(sqsync-&gt;sqs_consumer_sync[i].cs_lwlock);</comment>
                                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SharedQueueFinish:node %d status abnormal."</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        </block_content>}</block></if></if_stmt>
                                        <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">50L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></while>
                                    
                                    <expr_stmt><expr><name>nstores</name><operator>--</operator></expr>;</expr_stmt>
                                    
                                    <comment type="block">/* sanity check */</comment>
                                    <if_stmt><if>if<condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ntuples_get</name></name> <operator>!=</operator> <name><name>node</name><operator>-&gt;</operator><name>ntuples_put</name></name></expr>)</condition>
                                    <block>{<block_content>
                                        <comment type="line">//LWLockRelease(sqsync-&gt;sqs_consumer_sync[i].cs_lwlock);</comment>
                                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"tuplestore with nodeid:%d, cursor %s ended abnormally, put_tuples:%zu, get_tuples:%zu"</literal></expr></argument>, 
                                            <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ntuples_put</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ntuples_get</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>
                                    
                                    <expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>tuplestore</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><name><name>tuplestore</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                                    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>==</operator> <name>CONSUMER_ACTIVE</name></expr>)</condition>
                                    <block>{<block_content>
                                        <comment type="block">/* release fd */</comment>
                                        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr>)</condition>
                                        <block>{<block_content>
                                            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sock</name></name> <operator>=</operator> <name>NO_SOCKET</name></expr>;</expr_stmt>
                                        </block_content>}</block></if></if_stmt>
                                        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>=</operator> <name>CONSUMER_EOF</name></expr>;</expr_stmt>

                                    </block_content>}</block></if></if_stmt>
                                    
                                    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                    <block>{<block_content>
                                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"ended tuplestore with nodeid:%d, cursor %s, put_tuples:%zu, get_tuples:%zu, send_tuples:%zu, nfast_send:%zu, sleep_count:%zu"</literal></expr></argument>,
                                        <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ntuples_put</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ntuples_get</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ntuples</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nfast_send</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sleep_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block>
                                </block_content>}</block></if>
                                <else>else
                                <block>{<block_content>
                                    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>DataPumpSndStatus_set_socket</name></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><name>nstores</name><operator>--</operator></expr>;</expr_stmt>
                                        <expr_stmt><expr><name>unfinish_tuplestore</name><operator>++</operator></expr>;</expr_stmt>

                                        <if_stmt><if>if<condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
                                        <block>{<block_content>
                                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"unfinished tuplestore with nodeid:%d, cursor %s, put_tuples:%zu, get_tuples:%zu, nfast_send:%zu, sleep_count:%zu"</literal></expr></argument>,
                                            <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ntuples_put</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ntuples_get</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nfast_send</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sleep_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                        </block_content>}</block></if></if_stmt>
                                    </block_content>}</block></if>
                                    <if type="elseif">else if<condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>DataPumpSndStatus_incomplete_data</name> <operator>||</operator>
                                            <name><name>node</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>DataPumpSndStatus_error</name></expr>)</condition>
                                    <block>{<block_content>
                                        <comment type="line">//LWLockRelease(sqsync-&gt;sqs_consumer_sync[i].cs_lwlock);</comment>
                                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"node %d status abnormal!errmsg:%s."</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>errorno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>
                                </block_content>}</block></else></if_stmt>
                            </block_content>}</block></else></if_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>                            
                            <while>while <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name><operator>-&gt;</operator><name>m_Head</name></name> <operator>!=</operator> <name><name>node</name><operator>-&gt;</operator><name>buffer</name><operator>-&gt;</operator><name>m_Tail</name></name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>DataPumpWakeupSender</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>DataPumpNodeCheck</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition>
                                <block>{<block_content>
                                    <comment type="line">//LWLockRelease(sqsync-&gt;sqs_consumer_sync[i].cs_lwlock);</comment>
                                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SharedQueueFinish:node %d status abnormal."</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                                <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">50L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></while>

                            <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>==</operator> <name>CONSUMER_ACTIVE</name></expr>)</condition>
                            <block>{<block_content>
                                <comment type="block">/* release fd */</comment>
                                <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>sock</name></name> <operator>!=</operator> <name>NO_SOCKET</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sock</name></name> <operator>=</operator> <name>NO_SOCKET</name></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>

                                <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>=</operator> <name>CONSUMER_EOF</name></expr>;</expr_stmt>
                                </block_content>}</block></if>
                                <else>else
                                <block>{<block_content>
                                    <comment type="block">/* wait all consumers done */</comment>
                                    <expr_stmt><expr><name>nstores</name><operator>++</operator></expr>;</expr_stmt>
                                </block_content>}</block></else></if_stmt>
                            </block_content>}</block></if></if_stmt>
                            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"squeue %s finish consumer %d pid %d"</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></else></if_stmt>

                        <comment type="line">//LWLockRelease(sqsync-&gt;sqs_consumer_sync[i].cs_lwlock);</comment>
                    </block_content>}</block></for>

					<comment type="block">/*
					 * Check sq_error status to avoid endless loop here
					 */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_error</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SharedQueueFinish: shared_queue %s error because of query-cancel."</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name>unfinish_tuplestore</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block>while<condition>(<expr><name>unfinish_tuplestore</name></expr>)</condition>;</do>
                
                <if_stmt><if>if <condition>(<expr><name>nstores</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>bool</name></type> <name>ret</name></decl>;</decl_stmt>
                    
                    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>DataPumpWaitSenderDone</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"sender thread failed to exit."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/* sanity check */</comment>
                    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>DataPumpNodeControl</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>DataPumpSndStatus_done</name></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if<condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name><operator>-&gt;</operator><name>m_Head</name></name> <operator>!=</operator> <name><name>node</name><operator>-&gt;</operator><name>buffer</name><operator>-&gt;</operator><name>m_Tail</name></name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"node buffer corrupted."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>

                        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_latch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></for>
                    <expr_stmt><expr><call><name>DestoryDataPumpSenderControl</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender_destroy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>share_sq</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>RemoveDisConsumerHash</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>tmpslot</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tmpslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, finishing the SQueue - producer node %d, "</literal>
                                    <literal type="string">"pid %d, nconsumers %d"</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>,
                                    <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_pid</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <return>return <expr><literal type="number">0</literal></expr>;</return>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
                    if (tmpslot)
                        ExecDropSingleTupleTableSlot(tmpslot);

                    return nstores;
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                    <comment type="block">/* send all data to consumer until end */</comment>
                    <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>send_times</name><operator>++</operator></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>send_times</name> <operator>==</operator> <name>timeout</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>send_times</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

                        <comment type="block">/* reset consumer in case of unexpected exception */</comment>
                        <if_stmt><if>if <condition>(<expr><call><name>SharedQueueWaitOnProducerLatch</name><argument_list>(<argument><expr><name>squeue</name></expr></argument>, <argument><expr><literal type="number">10000L</literal></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>SharedQueueResetNotConnected</name><argument_list>(<argument><expr><name>squeue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>

                    <goto>goto <name>SEND_DATA</name>;</goto>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></else></if_stmt>
                
            </block_content>}</block></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ConsState</name> <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><name><name>squeue</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQUEUE_STAT</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>squeue</name><operator>-&gt;</operator><name>stat_finish</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Finishing %s node %d, %ld writes and %ld reads so far, %ld buffer writes, %ld buffer reads, %ld tuples returned to buffer"</literal></expr></argument>,
                 <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>stat_writes</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>stat_reads</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>stat_buff_writes</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>stat_buff_reads</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>stat_buff_returns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s finishing, consumer at %d, consumer node %d, pid %d, "</literal>
                <literal type="string">"status %d"</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * if the tuplestore has data and consumer queue has space for some
         * try to push rows to the queue. We do not want to do that often
         * to avoid overhead of temp tuple slot allocation.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tuplestore</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* If the consumer is not reading just destroy the tuplestore */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>!=</operator> <name>CONSUMER_ACTIVE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>tuplestore</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tuplestore</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>nstores</name><operator>++</operator></expr>;</expr_stmt>
                <comment type="block">/*
                 * Attempt to dump tuples from the store require tuple slot
                 * allocation, that is not a cheap operation, so proceed if
                 * target queue has enough space.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>QUEUE_FREE_SPACE</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_qlength</name></name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>tmpslot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name>tmpslot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><call><name>SharedQueueDump</name><argument_list>(<argument><expr><name>squeue</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>tmpslot</name></expr></argument>, <argument><expr><name><name>tuplestore</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>tuplestore</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>tuplestore</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>=</operator> <name>CONSUMER_EOF</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>nstores</name><operator>--</operator></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <comment type="block">/* Consumer may be sleeping, wake it up */</comment>
                    <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_latch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * XXX This can only be called by the producer. So no need
                     * to set producer latch.
                     */</comment>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* it set eof if not yet set */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>==</operator> <name>CONSUMER_ACTIVE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>=</operator> <name>CONSUMER_EOF</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_latch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/*
                 * XXX This can only be called by the producer. So no need to
                 * set producer latch.
                 */</comment>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <if_stmt><if>if <condition>(<expr><name>tmpslot</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tmpslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQUEUE_STAT</name></cpp:ifdef>
    <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>stat_finish</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>nstores</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SharedQueueUnBind
 *    Cancel binding of current process to the shared queue. If the process
 * was a producer it should pass in the array of tuplestores where tuples were
 * queueed when it was unsafe to block. If any of the tuplestores holds data
 * rows they are written to the queue. The length of the array of the
 * tuplestores should be the same as the count of consumers. It is OK if some
 * entries are NULL. When a consumer unbinds from the shared queue it should
 * set the tuplestore parameter to NULL.
 */</comment>
<function><type><name>void</name></type>
<name>SharedQueueUnBind</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>squeue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>failed</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>SQueueSync</name> <modifier>*</modifier></type><name>sqsync</name> <init>= <expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_sync</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>wait_result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>i</name>                <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>consumer_running</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, unbinding the SQueue (failed: %c) - producer node %d, "</literal>
            <literal type="string">"pid %d, nconsumers %d"</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>failed</name></expr> ?</condition><then> <expr><literal type="char">'T'</literal></expr> </then><else>: <expr><literal type="char">'F'</literal></expr></else></ternary></expr></argument>,
            <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_pid</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sqsync</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<label><name>CHECK</name>:</label>
    <comment type="block">/* loop while there are active consumers */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>c_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>unbound_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* check queue states */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ConsState</name> <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><name><name>squeue</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s unbinding, check consumer at %d, consumer node %d, pid %d, "</literal>
                    <literal type="string">"status %d"</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                    <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* is consumer working yet ? */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>==</operator> <name>CONSUMER_ACTIVE</name> <operator>&amp;&amp;</operator> <name>failed</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, consumer status CONSUMER_ACTIVE, but "</literal>
                        <literal type="string">"the operation has failed - marking CONSUMER_ERROR"</literal></expr></argument>,
                        <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>=</operator> <name>CONSUMER_ERROR</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>!=</operator> <name>CONSUMER_DONE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>failed</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, consumer not yet done, wake it up and "</literal>
                        <literal type="string">"wait for it to finish reading"</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>c_count</name><operator>++</operator></expr>;</expr_stmt>
                <comment type="block">/* Wake up consumer if it is sleeping */</comment>
                <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_latch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* producer will continue waiting */</comment>
                <expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>unbound_count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>c_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, wait while %d consumers finish, %d consumers"</literal>
                    <literal type="string">"not yet bound"</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>c_count</name></expr></argument>, <argument><expr><name>unbound_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* wait for a notification */</comment>
        <expr_stmt><expr><name>wait_result</name> <operator>=</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_latch</name></name></expr></argument>,
                                <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name> <operator>|</operator> <name>WL_TIMEOUT</name></expr></argument>,
                                <argument><expr><literal type="number">10000L</literal></expr></argument>, <argument><expr><name>WAIT_EVENT_MQ_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If we hit a timeout, reset the consumers which still hasn't
         * connected. We already make an assumption that consumers that don't
         * connect in time, would never connect and drop those consumers.
         *
         * XXX Unfortunately, while this is not the best way to handle the
         * problem, we have not found a reliable way to tell whether a specific
         * consumer will ever connect or not. So this kludge at least avoids a
         * infinite hang.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>wait_result</name> <operator>&amp;</operator> <name>WL_TIMEOUT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>SharedQueueResetNotConnected</name><argument_list>(<argument><expr><name>squeue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SQUEUE_STAT</name></cpp:ifdef>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Producer %s is done, there were %ld pauses"</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>stat_paused</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, producer node %d, pid %d - unbound successfully"</literal></expr></argument>,
                <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>g_UseDataPump</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SqueueProducerExit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SQueuesLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * In rear situation, after consumers just bind to the shared queue, the producer timeout and remove the shared queue.
     * This will cause a SEGV in the consumer. So here recheck if there are some consumers binded to the queue, if so, we need to wait them to 
     * finish.
     */</comment>
    <expr_stmt><expr><name>consumer_running</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ConsState</name> <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><name><name>squeue</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* found a consumer running */</comment>
        <if_stmt><if>if <condition>(<expr><name>CONSUMER_ACTIVE</name> <operator>==</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, consumer node %d, pid %d, status %d, "</literal>
                    <literal type="string">"started running after we finished unbind"</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>,
                    <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>consumer_running</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>consumer_running</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s have %d consumers started running after we "</literal>
                <literal type="string">"unbound, recheck now"</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>consumer_running</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SQueuesLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>CHECK</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* All is done, clean up */</comment>
    <expr_stmt><expr><call><name>DisownLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    if (--squeue-&gt;sq_refcnt == 0)
    {
        <comment type="block">/* Now it is OK to remove hash table entry */</comment>
        squeue-&gt;sq_sync = NULL;
        sqsync-&gt;queue = NULL;
        if (hash_search(SharedQueues, squeue-&gt;sq_key, HASH_REMOVE, NULL) != squeue)
            elog(PANIC, "Shared queue data corruption");
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SQueuesLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>distributed_query_analyze</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>DropQueryAnalyzeInfo</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
 * If queue with specified name still exists set mark respective consumer as
 * "Done". Due to executor optimization consumer may never connect the queue,
 * and should allow producer to finish it up if it is known the consumer will
 * never connect.
 */</comment>
<function><type><name>void</name></type>
<name>SharedQueueRelease</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqname</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>                    <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>SharedQueue</name></type>     <name>sq</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SQueuesLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>sq</name> <operator>=</operator> <operator>(</operator><name>SharedQueue</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>SharedQueues</name></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><specifier>volatile</specifier> <name>SQueueSync</name>    <modifier>*</modifier></type><name>sqsync</name> <init>= <expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>                        <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sqsync</name> <operator>&amp;&amp;</operator> <name><name>sqsync</name><operator>-&gt;</operator><name>queue</name></name> <operator>==</operator> <name>sq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s producer node %d, pid %d  - requested to release"</literal></expr></argument>,
                <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>, <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If the SharedQ is not bound, we can't just remove it because
         * somebody might have just created a fresh entry and is going to bind
         * to it soon. We assume that the future producer will eventually
         * release the SharedQ
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>sq</name><operator>-&gt;</operator><name>sq_nodeid</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, producer not bound "</literal></expr></argument>, <argument><expr><name>sqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>done</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Do not bother releasing producer, all necessary work will be
         * done upon UnBind.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>sq</name><operator>-&gt;</operator><name>sq_nodeid</name></name> <operator>!=</operator> <name>PGXC_PARENT_NODE_ID</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, we are consumer from node %d"</literal></expr></argument>, <argument><expr><name>sqname</name></expr></argument>,
                    <argument><expr><name>PGXC_PARENT_NODE_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* find specified node in the consumer lists */</comment>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ConsState</name> <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>sq</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name> <operator>==</operator> <name>PGXC_PARENT_NODE_ID</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>,
                                  <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, consumer node %d, pid %d, "</literal>
                            <literal type="string">"status %d"</literal></expr></argument>,  <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>,
                            <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * If the consumer pid is not set, we are looking at a race
                     * condition where the old producer (which supplied the
                     * tuples to this remote datanode) may have finished and
                     * marked all consumers as CONSUMER_EOF, the consumers
                     * themeselves consumed all the tuples and marked
                     * themselves as CONSUMER_DONE. The old producer in that
                     * case may have actually removed the SharedQ from shared
                     * memory. But if a new execution for this same portal
                     * comes before the consumer sends a "Close Portal" message
                     * (which subsequently calls this function), we may end up
                     * corrupting state for the upcoming consumer for this new
                     * execution of the portal.
                     *
                     * It seems best to just ignore the release call in such
                     * cases.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, consumer node %d, already released"</literal></expr></argument>,
                            <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>!=</operator> <name>CONSUMER_DONE</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* Inform producer the consumer have done the job */</comment>
                        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>=</operator> <name>CONSUMER_DONE</name></expr>;</expr_stmt>
                        <comment type="block">/* no need to receive notifications */</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>DisownLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_latch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <comment type="block">/*
                         * notify the producer, it may be waiting while
                         * consumers are finishing
                         */</comment>
                        <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, release consumer at %d, node "</literal>
                                <literal type="string">"%d, pid %d, status %d "</literal></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                                <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name></expr></argument>,
                                <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* exit */</comment>
                    <goto>goto <name>done</name>;</goto>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, consumer from node %d never bound"</literal></expr></argument>,
                    <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>PGXC_PARENT_NODE_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/*
             * The consumer was never bound. Find empty consumer slot and
             * register node here to let producer know that the node will never
             * be consuming.
             */</comment>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ConsState</name> <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>sq</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>,
                                  <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* Inform producer the consumer have done the job */</comment>
                    <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>=</operator> <name>CONSUMER_DONE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SQueue %s, consumer at %d marking as "</literal>
                            <literal type="string">"CONSUMER_DONE"</literal></expr></argument>, <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<label><name>done</name>:</label>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><name>sq</name> <operator>&amp;&amp;</operator> <name><name>sq</name><operator>-&gt;</operator><name>sq_pid</name></name> <operator>==</operator> <name>MyProcPid</name> <operator>&amp;&amp;</operator> <name><name>sq</name><operator>-&gt;</operator><name>sq_nodeid</name></name> <operator>==</operator> <name>PGXC_PARENT_NODE_ID</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name><operator>-&gt;</operator><name>sqs_producer_latch</name><operator>.</operator><name>owner_pid</name></name> <operator>==</operator> <name>MyProcPid</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>DisownLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name><operator>-&gt;</operator><name>sqs_producer_latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>RemoveDisConsumerHash</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>sq</name> <operator>&amp;&amp;</operator> <name><name>sq</name><operator>-&gt;</operator><name>with_params</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>RemoveDisConsumerHash</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/*
     * If we are the last holder of the SQueue, remove it from the hash table
     * to avoid any leak
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>sq</name> <operator>&amp;&amp;</operator> <operator>--</operator><name><name>sq</name><operator>-&gt;</operator><name>sq_refcnt</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Now it is OK to remove hash table entry */</comment>
        <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name><operator>-&gt;</operator><name>queue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>hash_search</name><argument_list>(<argument><expr><name>SharedQueues</name></expr></argument>, <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>sq</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Shared queue data corruption"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SQueuesLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Called when the backend is ending.
 */</comment>
<function><type><name>void</name></type>
<name>SharedQueuesCleanup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Need to be able to look into catalogs */</comment>
    <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <call><name>ResourceOwnerCreate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"SharedQueuesCleanup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Release all registered prepared statements.
     * If a shared queue name is associated with the statement this queue will
     * be released.
     */</comment>
    <expr_stmt><expr><call><name>DropAllPreparedStatements</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Release everything */</comment>
    <expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>RESOURCE_RELEASE_BEFORE_LOCKS</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>RESOURCE_RELEASE_LOCKS</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>RESOURCE_RELEASE_AFTER_LOCKS</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * sq_push_long_tuple
 *    Routine to push through the consumer state tuple longer the the consumer
 *    queue. Long tuple is written by a producer partially, and only when the
 *    consumer queue is empty.
 *    The consumer can determine that the tuple being read is long if the length
 *    of the tuple which is read before data is exceeding queue length.
 *       Consumers is switching to the long tuple mode and read in the portion of
 *      data which is already in the queue. After reading in each portion of data
 *    consumer sets cs_ntuples to LONG_TUPLE to indicate it is in long tuple
 *    mode, and writes out number of already read bytes to the beginning of the
 *    queue.
 *    While Consumer is reading in tuple data Producer may work on other task:
 *    execute query and send tuples to other Customers. If Producer sees the
 *    LONG_TUPLE indicator it may write out next portion. The tuple remains
 *    current in the tuplestore, and Producer just needs to read offset from
 *    the buffer to know what part of data to write next.
 *    After tuple is completely written the Producer is advancing to next tuple
 *    and continue operation in normal mode.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>sq_push_long_tuple</name><parameter_list>(<parameter><decl><type><name>ConsState</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>RemoteDataRow</name></type> <name>datarow</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_ntuples</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* the tuple is too big to fit the queue, start pushing it through */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
        <comment type="block">/*
         * Output actual message size, to prepare consumer:
         * allocate memory and set up transmission.
         */</comment>
        <expr_stmt><expr><call><name>QUEUE_WRITE</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>datarow</name><operator>-&gt;</operator><name>msglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Output as much as possible */</comment>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_qlength</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>datarow</name><operator>-&gt;</operator><name>msglen</name></name> <operator>&gt;</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>QUEUE_WRITE</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>datarow</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_ntuples</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>    <name>len</name></decl>;</decl_stmt>

        <comment type="block">/* Continue pushing through long tuple */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_ntuples</name></name> <operator>==</operator> <name>LONG_TUPLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * Consumer outputs number of bytes already read at the beginning of
         * the queue.
         */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_qstart</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&lt;</operator> <name><name>datarow</name><operator>-&gt;</operator><name>msglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* remaining data */</comment>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>datarow</name><operator>-&gt;</operator><name>msglen</name></name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
        <comment type="block">/*
         * We are sending remaining lengs just for sanity check at the consumer
         * side
         */</comment>
        <expr_stmt><expr><call><name>QUEUE_WRITE</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_qlength</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* does not fit yet */</comment>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_qlength</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>QUEUE_WRITE</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>datarow</name><operator>-&gt;</operator><name>msg</name></name> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_ntuples</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* now we are done */</comment>
            <expr_stmt><expr><call><name>QUEUE_WRITE</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>datarow</name><operator>-&gt;</operator><name>msg</name></name> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_ntuples</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * sq_pull_long_tuple
 *    Read in from the queue data of a long tuple which does not the queue.
 *    See sq_push_long_tuple for more details
 *
 *    The function is entered with LWLocks held on the consumer as well as
 *    procuder sync. The function exits with both of those locks held, even
 *    though internally it may release those locks before going to sleep.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sq_pull_long_tuple</name><parameter_list>(<parameter><decl><type><name>ConsState</name> <modifier>*</modifier></type><name>cstate</name></decl></parameter>, <parameter><decl><type><name>RemoteDataRow</name></type> <name>datarow</name></decl></parameter>,
                               <parameter><decl><type><name>int</name></type> <name>consumerIdx</name></decl></parameter>, <parameter><decl><type><name>SQueueSync</name> <modifier>*</modifier></type><name>sqsync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>datarow</name><operator>-&gt;</operator><name>msglen</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ConsumerSync</name> <modifier>*</modifier></type><name>sync</name> <init>= <expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>consumerIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <comment type="block">/* determine how many bytes to read */</comment>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_qlength</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_qlength</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* read data */</comment>
        <expr_stmt><expr><call><name>QUEUE_READ</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>datarow</name><operator>-&gt;</operator><name>msg</name></name> <operator>+</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* remember how many we read already */</comment>
        <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

        <comment type="block">/* check if we are done */</comment>
        <if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <name><name>datarow</name><operator>-&gt;</operator><name>msglen</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return;</return></block_content></block></if></if_stmt>

        <comment type="block">/* need more, set up queue to accept data from the producer */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_ntuples</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* allow exactly one incomplete tuple */</comment>
        <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_ntuples</name></name> <operator>=</operator> <name>LONG_TUPLE</name></expr>;</expr_stmt> <comment type="block">/* long tuple mode marker */</comment>
        <comment type="block">/* Inform producer how many bytes we have already */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_qstart</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Release locks and wait until producer supply more data */</comment>
        <while>while <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_ntuples</name></name> <operator>==</operator> <name>LONG_TUPLE</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * First up wake the producer
             */</comment>
            <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * We must reset the consumer latch while holding the lock to
             * ensure the producer can't change the state in between.
             */</comment>
            <expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sync</name><operator>-&gt;</operator><name>cs_latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Now release all locks before going into a wait state
             */</comment>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sync</name><operator>-&gt;</operator><name>cs_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Wait for notification about available info */</comment>
            <expr_stmt><expr><call><name>WaitLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sync</name><operator>-&gt;</operator><name>cs_latch</name></name></expr></argument>, <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                    <argument><expr><name>WAIT_EVENT_MQ_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* got the notification, restore lock and try again */</comment>
            <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_producer_lwlock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sync</name><operator>-&gt;</operator><name>cs_lwlock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <comment type="block">/* Read length of remaining data */</comment>
        <expr_stmt><expr><call><name>QUEUE_READ</name><argument_list>(<argument><expr><name>cstate</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Make sure we are doing the same tuple */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <name>len</name> <operator>==</operator> <name><name>datarow</name><operator>-&gt;</operator><name>msglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* next iteration */</comment>
    </block_content>}</block></for>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<function><type><name>void</name></type> <name>ThreadSemaInit</name><parameter_list>(<parameter><decl><type><name>ThreadSema</name> <modifier>*</modifier></type><name>sema</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>init</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>sema</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>sema</name><operator>-&gt;</operator><name>m_cnt</name></name> <operator>=</operator> <name>init</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sema</name><operator>-&gt;</operator><name>m_mutex</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pthread_cond_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sema</name><operator>-&gt;</operator><name>m_cond</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ThreadSemaDown</name><parameter_list>(<parameter><decl><type><name>ThreadSema</name> <modifier>*</modifier></type><name>sema</name></decl></parameter>)</parameter_list>
<block>{<block_content>            
    <if_stmt><if>if <condition>(<expr><name>sema</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sema</name><operator>-&gt;</operator><name>m_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>
        <if_stmt><if>if <condition>(<expr><operator>--</operator><operator>(</operator><name><name>sema</name><operator>-&gt;</operator><name>m_cnt</name></name><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> 
        <block>{<block_content>
            <comment type="block">/* thread goes to sleep */</comment>

            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pthread_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sema</name><operator>-&gt;</operator><name>m_cond</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sema</name><operator>-&gt;</operator><name>m_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sema</name><operator>-&gt;</operator><name>m_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ThreadSemaUp</name><parameter_list>(<parameter><decl><type><name>ThreadSema</name> <modifier>*</modifier></type><name>sema</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>sema</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sema</name><operator>-&gt;</operator><name>m_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>sema</name><operator>-&gt;</operator><name>m_cnt</name></name><operator>)</operator><operator>++</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> 
        <block>{<block_content>
            <comment type="block">/*wake up sleeping thread*/</comment>                
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sema</name><operator>-&gt;</operator><name>m_cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sema</name><operator>-&gt;</operator><name>m_mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>spinlock_init</name><parameter_list>(<parameter><decl><type><name>pg_spin_lock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>    
    <expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>spinlock_lock</name><parameter_list>(<parameter><decl><type><name>pg_spin_lock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>lock</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>spinlock_unlock</name><parameter_list>(<parameter><decl><type><name>pg_spin_lock</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>lock</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * The following funciton is used to handle lockless message queue.
 */</comment>
 
<comment type="block">/* Get data pointer, use with the following functions. */</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>GetData</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>uiLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type> <name>border</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>tail</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>  <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>DataSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>pointerlock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>border</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_Border</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tail</name>   <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_Tail</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>pointerlock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>INVALID_BORDER</name> <operator>==</operator> <name>border</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>uiLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* read from tail to border*/</comment>
        <if_stmt><if>if <condition>(<expr><name>border</name> <operator>&gt;=</operator>  <name>tail</name></expr>)</condition>
        <block>{<block_content> 
             <comment type="block">/* Only sender increases m_Tail, no need to lock. */</comment>
             <expr_stmt><expr><operator>*</operator><name>uiLen</name> <operator>=</operator> <name>border</name> <operator>-</operator> <name>tail</name></expr>;</expr_stmt>  
             <expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_buf</name></name> <operator>+</operator> <name>tail</name></expr>;</expr_stmt>    
             
             <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>pointerlock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <comment type="block">/* No more data. */</comment>
             <if_stmt><if>if <condition>(<expr><name>border</name> <operator>==</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_Border</name></name></expr>)</condition>
              <block>{<block_content>                 
                <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>m_Border</name></name> <operator>=</operator> <name>INVALID_BORDER</name></expr>;</expr_stmt>
              </block_content>}</block></if></if_stmt>
             <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>pointerlock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>  
            <comment type="block">/* read from tail to end */</comment>
            <expr_stmt><expr><operator>*</operator><name>uiLen</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_Length</name></name> <operator>-</operator> <name>tail</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_buf</name></name> <operator>+</operator> <name>tail</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>m_WrapAround</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt> 
        <return>return <expr><name>data</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>uiLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Increate data offset, used after finishing read data from queue. */</comment>
<function><type><name>void</name></type> <name>IncDataOff</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>uiLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>pointerlock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>m_Tail</name></name>  <operator>=</operator>  <operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>m_Tail</name></name> <operator>+</operator> <name>uiLen</name><operator>)</operator><operator>%</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_Length</name></name></expr>;</expr_stmt>                  
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>pointerlock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Return total data size in buffer */</comment>
<function><type><name>uint32</name></type> <name>DataSize</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type> <name>border</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>head</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>tail</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>size</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>pointerlock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>head</name>   <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_Head</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tail</name>   <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_Tail</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>border</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_Border</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>pointerlock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <if_stmt><if>if <condition>(<expr><name>INVALID_BORDER</name> <operator>==</operator> <name>border</name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        
        <if_stmt><if>if <condition>(<expr><name>tail</name> <operator>&lt;=</operator> <name>head</name></expr>)</condition>
        <block>{<block_content>    
            <expr_stmt><expr><name>size</name> <operator>=</operator> <name>head</name> <operator>-</operator> <name>tail</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_Length</name></name> <operator>-</operator> <name>tail</name> <operator>+</operator> <name>head</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        
        <return>return <expr><name>size</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* Get the pointer to write and return the length to write. */</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>GetWriteOff</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>uiLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type> <name>head</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>tail</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>  <modifier>*</modifier></type><name>ptr</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>FreeSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>pointerlock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>head</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_Head</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tail</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_Tail</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>pointerlock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <if_stmt><if>if <condition>(<expr><name>head</name> <operator>&gt;=</operator>  <name>tail</name></expr>)</condition>
        <block>{<block_content> 
           <comment type="block">/* tail is the beginning of the queue. */</comment>
           <if_stmt><if>if <condition>(<expr><name>tail</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
           <block>{<block_content>
               
               <expr_stmt><expr><operator>*</operator><name>uiLen</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_Length</name></name> <operator>-</operator> <name>head</name></expr>;</expr_stmt>                 
           </block_content>}</block></if>
           <else>else
           <block>{<block_content>
               <comment type="block">/* Reserved one byte as flag. */</comment>
               <expr_stmt><expr><operator>*</operator><name>uiLen</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_Length</name></name> <operator>-</operator> <name>head</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>                 
           </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>               
           <comment type="block">/* Reserved one byte as flag. */</comment>
           <expr_stmt><expr><operator>*</operator><name>uiLen</name> <operator>=</operator> <name>tail</name> <operator>-</operator> <name>head</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>        
        <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_buf</name></name> <operator>+</operator> <name>head</name></expr>;</expr_stmt>
        <return>return <expr><name>ptr</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></else></if_stmt>    
</block_content>}</block></function>

<comment type="block">/* Used to increase the write pointer after write some data. */</comment>
<function><type><name>void</name></type> <name>IncWriteOff</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>uiLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>pointerlock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
           <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>m_Head</name></name>  <operator>+=</operator> <name>uiLen</name></expr>;</expr_stmt>
           <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>m_Head</name></name>  <operator>=</operator>  <name><name>buf</name><operator>-&gt;</operator><name>m_Head</name></name> <operator>%</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_Length</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>pointerlock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Reserve space in print buffer */</comment>
<function><type><name>int</name></type> <name>ReserveSpace</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* not enough space avaliable, wait */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>FreeSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>len</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>offset</name>    <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_Head</name></name></expr>;</expr_stmt>
           <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>m_Head</name></name>  <operator>=</operator>  <operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>m_Head</name></name>  <operator>+</operator> <name>len</name><operator>)</operator><operator>%</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_Length</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>        
</block_content>}</block></function>

<function><type><name>uint32</name></type> <name>BufferOffsetAdd</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>pointer</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>

    <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
    <block>{<block_content>    
           <return>return <expr><operator>(</operator><name>pointer</name> <operator>+</operator> <name>offset</name><operator>)</operator> <operator>%</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_Length</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>        
</block_content>}</block></function>
<comment type="block">/* No need to lock, reader never read the data before we set border. */</comment>
<function><type><name>int</name></type> <name>ReturnSpace</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>m_Head</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>        
</block_content>}</block></function>

<comment type="block">/* Fill data into reserved by ReserveSpace */</comment>
<function><type><name>void</name></type> <name>FillReserveSpace</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type> <name>bytes2end</name>      <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>bytesfrombegin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   

    <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
    <block>{<block_content>        
        <expr_stmt><expr><name>bytes2end</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_Length</name></name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name>bytes2end</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>m_buf</name></name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>bytesfrombegin</name> <operator>=</operator> <name>len</name> <operator>-</operator> <name>bytes2end</name></expr>;</expr_stmt>                
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>m_buf</name></name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>bytes2end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>m_buf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name> <operator>+</operator> <name>bytes2end</name></expr></argument>, <argument><expr><name>bytesfrombegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>    
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Return free space of the buffer. */</comment>
<function><type><name>uint32</name></type> <name>FreeSpace</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type> <name>head</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>tail</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>len</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>pointerlock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>head</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_Head</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tail</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_Tail</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>pointerlock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>tail</name> <operator>&lt;=</operator> <name>head</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <name>tail</name> <operator>+</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_Length</name></name> <operator>-</operator> <name>head</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <name>tail</name> <operator>-</operator> <name>head</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>len</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Set tuple end border of the buffer. */</comment>
<function><type><name>void</name></type> <name>SetBorder</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>pointerlock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>m_Border</name></name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>m_Head</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>pointerlock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/* Send data into buffer */</comment>
<function><type><name>void</name></type> <name>PutData</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>    
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>  <name>bufferLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>  <name>needLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>  <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>needLen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>            
        <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>GetWriteOff</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bufferLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>bufferLen</name> <operator>&gt;=</operator> <name>needLen</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>needLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>IncWriteOff</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>needLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>bufferLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>IncWriteOff</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufferLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>needLen</name> <operator>-=</operator> <name>bufferLen</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>offset</name>  <operator>+=</operator> <name>bufferLen</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>int32</name></type> <name>CreateThread</name><parameter_list>(<parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>f</name>) <parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>

    <decl_stmt><decl><type><name>pthread_attr_t</name></type> <name>attr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pthread_t</name></type>      <name>threadid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pthread_attr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>mode</name></expr>)</condition> 
    <block>{<block_content>
        <case>case <expr><name>MT_THR_JOINABLE</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pthread_attr_setdetachstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>PTHREAD_CREATE_JOINABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><name>MT_THR_DETACHED</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pthread_attr_setdetachstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>PTHREAD_CREATE_DETACHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>        
        <default>default:</default>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid thread mode %d\n"</literal></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
    </block_content>}</block></switch>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>threadid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ignore all signals, leave signal for main thread to process */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ThreadSigmask</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>sigset_t</name></type>  <name>new_mask</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_mask</name></expr></argument>, <argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_mask</name></expr></argument>, <argument><expr><name>SIGALRM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_mask</name></expr></argument>, <argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_mask</name></expr></argument>, <argument><expr><name>SIGINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_mask</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_mask</name></expr></argument>, <argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_mask</name></expr></argument>, <argument><expr><name>SIGPIPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_mask</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_mask</name></expr></argument>, <argument><expr><name>SIGUSR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_mask</name></expr></argument>, <argument><expr><name>SIGFPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_mask</name></expr></argument>, <argument><expr><name>SIGCHLD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* ignore signals*/</comment>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pthread_sigmask</name><argument_list>(<argument><expr><name>SIG_BLOCK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_mask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Build data pump buffer.
 */</comment>
<function><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>BuildDataPumpBuf</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buff</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>buff</name> <operator>=</operator> <operator>(</operator><name>DataPumpBuf</name><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DataPumpBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buff</name><operator>-&gt;</operator><name>m_Length</name></name> <operator>=</operator> <name>g_SndThreadBufferSize</name> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buff</name><operator>-&gt;</operator><name>m_buf</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name><name>buff</name><operator>-&gt;</operator><name>m_Length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>spinlock_init</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buff</name><operator>-&gt;</operator><name>pointerlock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buff</name><operator>-&gt;</operator><name>m_Head</name></name>            <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buff</name><operator>-&gt;</operator><name>m_Tail</name></name>            <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    
    <expr_stmt><expr><name><name>buff</name><operator>-&gt;</operator><name>m_WrapAround</name></name>     <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>    
    <expr_stmt><expr><name><name>buff</name><operator>-&gt;</operator><name>m_Border</name></name>          <operator>=</operator> <name>INVALID_BORDER</name></expr>;</expr_stmt>        
    <return>return <expr><name>buff</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Build data pump node control.
 */</comment>
<function><type><name>void</name></type> <name>InitDataPumpNodeControl</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>nodeindex</name></decl></parameter>, <parameter><decl><type><name>DataPumpNodeControl</name> <modifier>*</modifier></type><name>control</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>nodeindex</name></name>   <operator>=</operator> <name>nodeindex</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>sock</name></name>         <operator>=</operator> <name>NO_SOCKET</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>status</name></name>         <operator>=</operator> <name>DataPumpSndStatus_no_socket</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>spinlock_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>control</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>buffer</name></name>      <operator>=</operator> <call><name>BuildDataPumpBuf</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>ntuples_get</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>ntuples_put</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Build data pump thread control.
 */</comment>
<function><type><name>void</name></type> <name>InitDataPumpThreadControl</name><parameter_list>(<parameter><decl><type><name>DataPumpThreadControl</name> <modifier>*</modifier></type><name>control</name></decl></parameter>, <parameter><decl><type><name>DataPumpNodeControl</name> <modifier>*</modifier></type><name>nodes</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>total</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>nodes</name></name>               <operator>=</operator> <name>nodes</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>node_base</name></name>         <operator>=</operator> <name>base</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>node_end</name></name>          <operator>=</operator> <name>end</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>node_num</name></name>          <operator>=</operator> <name>total</name></expr>;</expr_stmt>  

    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>thread_need_quit</name></name>  <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>thread_running</name></name>    <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ThreadSemaInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>control</name><operator>-&gt;</operator><name>send_sem</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ThreadSemaInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>control</name><operator>-&gt;</operator><name>quit_sem</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Create data pump sender thread.
 */</comment>
<function><type><name>bool</name></type> <name>CreateSenderThread</name><parameter_list>(<parameter><decl><type><name>DataPumpSenderControl</name> <modifier>*</modifier></type><name>sender</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>succeed</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>i</name>       <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>ret</name>     <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sender</name><operator>-&gt;</operator><name>thread_num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>        
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>CreateThread</name><argument_list>(<argument><expr><name>DataPumpSenderThread</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>thread_control</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>MT_THR_DETACHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>succeed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Set running status for the thread. */</comment>
        <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>thread_control</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>thread_running</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>succeed</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* create convert thread */</comment>
        <expr_stmt><expr><call><name>ThreadSemaInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>quit_sem</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>CreateThread</name><argument_list>(<argument><expr><name>ConvertThreadMain</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>sender</name></expr></argument>, <argument><expr><name>MT_THR_DETACHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>succeed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>cstatus</name></name> <operator>=</operator> <name>ConvertRunning</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>succeed</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>DataPumpCleanThread</name><argument_list>(<argument><expr><name>sender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>succeed</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Create data pump control and init the threads.
 */</comment>
<function><type><name>DataPumpSender</name></type> <name>BuildDataPumpSenderControl</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>sq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>      <name>succeed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>       <name>i</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>     <name>base</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>     <name>step</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>int32</name></type>     <name>end</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>DataPumpSenderControl</name> <modifier>*</modifier></type><name>sender_control</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>sender_control</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DataPumpSenderControl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sender_control</name><operator>-&gt;</operator><name>node_num</name></name> <operator>=</operator> <name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sender_control</name><operator>-&gt;</operator><name>nodes</name></name>    <operator>=</operator> <operator>(</operator><name>DataPumpNodeControl</name><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DataPumpNodeControl</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>sender_control</name><operator>-&gt;</operator><name>node_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ConsState</name>  <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>sq</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>InitDataPumpNodeControl</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sender_control</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Use the minimal one as thread number. */</comment>
    <expr_stmt><expr><name><name>sender_control</name><operator>-&gt;</operator><name>thread_num</name></name> <operator>=</operator> <ternary><condition><expr><name>g_SndThreadNum</name> <operator>&gt;</operator> <name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr> ?</condition><then> <expr><name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr> </then><else>: <expr><name>g_SndThreadNum</name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sender_control</name><operator>-&gt;</operator><name>thread_control</name></name> <operator>=</operator> <operator>(</operator><name>DataPumpThreadControl</name><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DataPumpThreadControl</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>sender_control</name><operator>-&gt;</operator><name>thread_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>DIVIDE_UP</name><argument_list>(<argument><expr><name><name>sender_control</name><operator>-&gt;</operator><name>node_num</name></name></expr></argument>, <argument><expr><name><name>sender_control</name><operator>-&gt;</operator><name>thread_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sender_control</name><operator>-&gt;</operator><name>thread_num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>sender_control</name><operator>-&gt;</operator><name>thread_num</name></name>  <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>base</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>end</name>  <operator>=</operator> <name>base</name> <operator>+</operator> <name>step</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>base</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>end</name> <operator>=</operator> <name><name>sender_control</name><operator>-&gt;</operator><name>node_num</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>InitDataPumpThreadControl</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sender_control</name><operator>-&gt;</operator><name>thread_control</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>sender_control</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name><name>sender_control</name><operator>-&gt;</operator><name>node_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
		<comment type="block">/* Set running status for the thread. not running now */</comment>
		<expr_stmt><expr><name><name>sender_control</name><operator>-&gt;</operator><name>thread_control</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>thread_running</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>		
    </block_content>}</block></for>

    <comment type="block">/* set sqname and max connection */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>sender_control</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>sqname</name></name></expr></argument>, <argument><expr><name>MAX_CURSOR_LEN</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sender_control</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>maxConn</name></name> <operator>=</operator> <name><name>sender_control</name><operator>-&gt;</operator><name>node_num</name></name></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>succeed</name> <operator>=</operator> <call><name>CreateSenderThread</name><argument_list>(<argument><expr><name>sender_control</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>succeed</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>DestoryDataPumpSenderControl</name><argument_list>(<argument><expr><name>sender_control</name></expr></argument>, <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>sender_destroy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>sender</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><name>DATA_PUMP_PREFIX</name><literal type="string">"start thread failed for %s"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>sender</name></name> <operator>=</operator> <name>sender_control</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Squeue:%s(Pid:%d), create %d sender, 1 convert."</literal></expr></argument>, <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name><name>sender_control</name><operator>-&gt;</operator><name>thread_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return <expr><name>sender_control</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>DestoryDataPumpSenderControl</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>sndctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodeid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>  <name>i</name>         <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataPumpSenderControl</name> <modifier>*</modifier></type><name>sender</name>   <init>= <expr><operator>(</operator><name>DataPumpSenderControl</name><operator>*</operator><operator>)</operator><name>sndctl</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sndctl</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>sender</name><operator>-&gt;</operator><name>thread_control</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>sender</name><operator>-&gt;</operator><name>thread_control</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>thread_control</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>sender</name><operator>-&gt;</operator><name>nodes</name></name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sender</name><operator>-&gt;</operator><name>node_num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>        
            <expr_stmt><expr><call><name>DestoryDataPumpBuf</name><argument_list>(<argument><expr><name><name>sender</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>sender</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sock</name> <operator>!=</operator> <name>NO_SOCKET</name> <operator>&amp;&amp;</operator> <name><name>sender</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeindex</name> <operator>!=</operator> <name>nodeid</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>sender</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sock</name> <operator>=</operator> <name>NO_SOCKET</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>sender</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
</block_content>}</block></function>

<function><type><name>void</name></type> <name>DestoryDataPumpBuf</name><parameter_list>(<parameter><decl><type><name>DataPumpBuf</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>m_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>DataPumpSendLoop</name><parameter_list>(<parameter><decl><type><name>DataPumpNodeControl</name>  <modifier>*</modifier></type><name>nodes</name></decl></parameter>, <parameter><decl><type><name>DataPumpThreadControl</name><modifier>*</modifier></type> <name>control</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int32</name></type>  <name>stuck_nodes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>  <name>reason</name>      <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>  <name>status</name>      <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>  <name>nodeindex</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>    <name>ret</name>         <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>len</name>         <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>data</name>       <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    
    <comment type="block">/* Loop to send data. */</comment>
    <do>do 
    <block>{<block_content>
        <expr_stmt><expr><name>stuck_nodes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>nodeindex</name> <operator>=</operator> <name><name>control</name><operator>-&gt;</operator><name>node_base</name></name></expr>;</init> <condition><expr><name>nodeindex</name> <operator>&lt;</operator> <name><name>control</name><operator>-&gt;</operator><name>node_end</name></name> <operator>&amp;&amp;</operator> <name>nodeindex</name> <operator>&lt;</operator> <name><name>control</name><operator>-&gt;</operator><name>node_num</name></name></expr>;</condition> <incr><expr><name>nodeindex</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>status</name> <operator>=</operator> <name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>status</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <comment type="block">/* status is valid */</comment>
            <if_stmt><if>if <condition>(<expr><name>status</name> <operator>&gt;=</operator> <name>DataPumpSndStatus_set_socket</name> <operator>&amp;&amp;</operator> <name>status</name>  <operator>&lt;=</operator> <name>DataPumpSndStatus_data_sending</name></expr>)</condition>
            <block>{<block_content>
                <do>do 
                <block>{<block_content>
                    <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>GetData</name><argument_list>(<argument><expr><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>DataPumpRawSendData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>sock</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                
                        <if_stmt><if>if <condition>(<expr><name>EOF</name> <operator>==</operator> <name>ret</name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/* We got error. */</comment>
                            <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>status</name>  <operator>=</operator> <name>DataPumpSndStatus_error</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>errorno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>                    
                        
                        <comment type="block">/* increase data offset */</comment>
                        <expr_stmt><expr><call><name>IncDataOff</name><argument_list>(<argument><expr><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>buffer</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
                        
                        <comment type="block">/* Socket got stuck. */</comment>
                        <if_stmt><if>if <condition>(<expr><name>reason</name> <operator>==</operator> <name>EAGAIN</name> <operator>||</operator> <name>reason</name> <operator>==</operator> <name>EWOULDBLOCK</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>DataSize</name><argument_list>(<argument><expr><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                            <block>{<block_content>
                                <comment type="block">/* Break sending to the node, switch to the next one. */</comment>
                                <expr_stmt><expr><name>stuck_nodes</name><operator>++</operator></expr>;</expr_stmt>
                                <break>break;</break>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="block">/* No more complete tuples. */</comment>
                        <break>break;</break>
                    </block_content>}</block></else></if_stmt>
                    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>DataSize</name><argument_list>(<argument><expr><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* Get status. */</comment>
                    <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>status</name> <operator>=</operator> <name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>status</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>while <condition>(<expr><operator>(</operator><name>status</name> <operator>&gt;=</operator> <name>DataPumpSndStatus_set_socket</name> <operator>&amp;&amp;</operator> <name>status</name>  <operator>&lt;=</operator> <name>DataPumpSndStatus_data_sending</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>len</name></expr>)</condition>;</do>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>while<condition>(<expr><name>stuck_nodes</name></expr>)</condition>;</do>
</block_content>}</block></function>
<comment type="block">/*
 * Ensure all data flush out when cursor is done.
 */</comment>
<function><type><name>bool</name></type> <name>DataPumpFlushAllData</name><parameter_list>(<parameter><decl><type><name>DataPumpNodeControl</name>  <modifier>*</modifier></type><name>nodes</name></decl></parameter>, <parameter><decl><type><name>DataPumpThreadControl</name><modifier>*</modifier></type> <name>control</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int32</name></type>  <name>stuck_nodes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>  <name>reason</name>      <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>  <name>status</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>   <name>succeed</name>   <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>  <name>nodeindex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>    <name>ret</name>       <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>len</name>       <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>data</name>     <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    
    <comment type="block">/* Loop to send data. */</comment>
    <do>do
    <block>{<block_content>
        <expr_stmt><expr><name>stuck_nodes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>nodeindex</name> <operator>=</operator> <name><name>control</name><operator>-&gt;</operator><name>node_base</name></name></expr>;</init> <condition><expr><name>nodeindex</name> <operator>&lt;</operator> <name><name>control</name><operator>-&gt;</operator><name>node_end</name></name> <operator>&amp;&amp;</operator> <name>nodeindex</name> <operator>&lt;</operator> <name><name>control</name><operator>-&gt;</operator><name>node_num</name></name></expr>;</condition> <incr><expr><name>nodeindex</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>status</name> <operator>=</operator> <name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>status</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <comment type="block">/* status is valid */</comment>
            <if_stmt><if>if <condition>(<expr><name>status</name> <operator>&gt;=</operator> <name>DataPumpSndStatus_set_socket</name> <operator>&amp;&amp;</operator> <name>status</name>  <operator>&lt;=</operator> <name>DataPumpSndStatus_data_sending</name></expr>)</condition>
            <block>{<block_content>
                <do>do 
                <block>{<block_content>
                    <comment type="block">/* Data left in buffer, send them all. */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name><name>buffer</name><operator>-&gt;</operator><name>m_Tail</name></name> <operator>!=</operator> <name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name><name>buffer</name><operator>-&gt;</operator><name>m_Head</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name><name>buffer</name><operator>-&gt;</operator><name>m_Border</name></name> <operator>=</operator> <name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name><name>buffer</name><operator>-&gt;</operator><name>m_Head</name></name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    
                    <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>GetData</name><argument_list>(<argument><expr><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>DataPumpRawSendData</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>sock</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                
                        <if_stmt><if>if <condition>(<expr><name>EOF</name> <operator>==</operator> <name>ret</name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/* We got error. */</comment>
                            <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>status</name>  <operator>=</operator> <name>DataPumpSndStatus_error</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>errorno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>succeed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                            <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                        
                        <comment type="block">/* increase data offset */</comment>
                        <expr_stmt><expr><call><name>IncDataOff</name><argument_list>(<argument><expr><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>buffer</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/* Socket got stuck. */</comment>
                        <if_stmt><if>if <condition>(<expr><name>reason</name> <operator>==</operator> <name>EAGAIN</name> <operator>||</operator> <name>reason</name> <operator>==</operator> <name>EWOULDBLOCK</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>DataSize</name><argument_list>(<argument><expr><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
                            <block>{<block_content>
                                <comment type="block">/* Break sending to the node, switch to the next one. */</comment>
                                <expr_stmt><expr><name>stuck_nodes</name><operator>++</operator></expr>;</expr_stmt>
                                <break>break;</break>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="block">/* No more complete tuples, it is vary wired situation to get into the branch. */</comment>
                        <if_stmt><if>if <condition>(<expr><call><name>DataSize</name><argument_list>(<argument><expr><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>status</name>  <operator>=</operator> <name>DataPumpSndStatus_incomplete_data</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>errorno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>succeed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                        </block_content>}</block></if>    
                        <else>else
                        <block>{<block_content>
                            <comment type="block">/* Job done, set status. */</comment>
                            <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>status</name>  <operator>=</operator> <name>DataPumpSndStatus_done</name></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                        <break>break;</break>
                    </block_content>}</block></else></if_stmt>
                    
                    <comment type="block">/* Get status. */</comment>
                    <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>status</name> <operator>=</operator> <name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>status</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>while <condition>(<expr><operator>(</operator><name>status</name> <operator>&gt;=</operator> <name>DataPumpSndStatus_set_socket</name> <operator>&amp;&amp;</operator> <name>status</name>  <operator>&lt;=</operator> <name>DataPumpSndStatus_data_sending</name><operator>)</operator></expr>)</condition>;</do>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>while<condition>(<expr><name>stuck_nodes</name></expr>)</condition>;</do>
    <return>return <expr><name>succeed</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Datapump sender thread.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>DataPumpSenderThread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DataPumpNodeControl</name>  <modifier>*</modifier></type> <name>nodes</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataPumpThreadControl</name><modifier>*</modifier></type> <name>thread</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>thread</name> <operator>=</operator> <operator>(</operator><name>DataPumpThreadControl</name><operator>*</operator><operator>)</operator><name>arg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>nodes</name>  <operator>=</operator>  <name><name>thread</name><operator>-&gt;</operator><name>nodes</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ThreadSigmask</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>thread_running</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Waiting for orders. */</comment>
        <expr_stmt><expr><call><name>ThreadSemaDown</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>send_sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* error, quit directly */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>thread</name><operator>-&gt;</operator><name>error</name></name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <comment type="block">/* We have been told to quit. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>thread</name><operator>-&gt;</operator><name>thread_need_quit</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>quit_status</name></name> <operator>=</operator> <call><name>DataPumpFlushAllData</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/* Loop to send data. */</comment>
        <expr_stmt><expr><call><name>DataPumpSendLoop</name><argument_list>(<argument><expr><name>nodes</name></expr></argument>, <argument><expr><name>thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>thread_running</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <comment type="block">/* Tell main thread quit is done. */</comment>
    <expr_stmt><expr><call><name>ThreadSemaUp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>quit_sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* check node status and report error if node is abnormal */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>DataPumpNodeCheck</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>sndctl</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeindex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DataPumpSenderControl</name> <modifier>*</modifier></type><name>sender</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataPumpNodeControl</name>   <modifier>*</modifier></type><name>node</name>     <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>sender</name> <operator>=</operator> <operator>(</operator><name>DataPumpSenderControl</name><operator>*</operator><operator>)</operator><name>sndctl</name></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>DataPumpSndStatus_incomplete_data</name> <operator>||</operator>
        <name><name>node</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>DataPumpSndStatus_error</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"node %d status abnormal.errmsg:%s."</literal></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>errorno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>sender</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>cstatus</name></name> <operator>!=</operator> <name>ConvertRunning</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"convert status abnormal.errmsg:%s."</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name><name>sender</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>errNO</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return data write to the socket. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>DataPumpRawSendData</name><parameter_list>(<parameter><decl><type><name>DataPumpNodeControl</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>sock</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>reason</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>  <name>offset</name>       <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>  <name>nbytes_write</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>offset</name> <operator>&lt;</operator> <name>len</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>nbytes_write</name> <operator>=</operator> <call><name>send</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>offset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nbytes_write</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>
            <block>{<block_content>
                <continue>continue;</continue>        <comment type="block">/* Ok if we were interrupted */</comment>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Ok if no data writable without blocking, and the socket is in
             * non-blocking mode.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EAGAIN</name> <operator>||</operator>
                <name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name></expr>)</condition>
            <block>{<block_content>                
                <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sleep_count</name></name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>reason</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
                <return>return <expr><name>offset</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><operator>*</operator><name>reason</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
            <return>return <expr><name>EOF</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>nbytes_write</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    
    <return>return <expr><name>offset</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>DataPumpTupleStoreDump</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>sndctl</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeindex</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeId</name></decl></parameter>,
                                 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tmpslot</name></decl></parameter>, 
                                 <parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tuplestore</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives    </comment>
    <decl_stmt><decl><type><name>bool</name></type>                  <name>sendall</name>   <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>                   <name>ret</name>        <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>DataPumpNodeControl</name>   <modifier>*</modifier></type><name>node</name>     <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataPumpSenderControl</name> <modifier>*</modifier></type><name>sender</name>   <init>= <expr><operator>(</operator><name>DataPumpSenderControl</name><operator>*</operator><operator>)</operator><name>sndctl</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>DataPumpNodeReadyForSend</name><argument_list>(<argument><expr><name>sndctl</name></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>, <argument><expr><name>nodeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Can't send data now, append data to the tuplestore. */</comment>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>DataPumpOK</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>DataPumpSndError_unreachable_node</name> <operator>==</operator> <name>ret</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* No need to send data, trade it as done. */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"DataPumpTupleStoreDump::remote node:%d never read data."</literal></expr></argument>, <argument><expr><name>nodeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>DataPumpConvert_error</name> <operator>==</operator> <name>ret</name> <operator>||</operator>
                 <name>DataPumpSndError_node_error</name> <operator>==</operator> <name>ret</name> <operator>||</operator>
                 <name>DataPumpSndError_io_error</name> <operator>==</operator> <name>ret</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"DataPumpTupleStoreDump::DataPump status:%d abnormal!"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/* Append the slot to the store... */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>tmpslot</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>, <argument><expr><name>tmpslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ntuples_put</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>sendall</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else 
    <block>{<block_content>
        
        <comment type="block">/* Read from tuplestore and send the tuple.*/</comment>
        <comment type="block">/*
         * Tuplestore does not clear eof flag on the active read pointer, causing
         * the store is always in EOF state once reached when there is a single
         * read pointer. We do not want behavior like this and workaround by using
         * secondary read pointer. Primary read pointer (0) is active when we are
         * writing to the tuple store, also it is used to bookmark current position
         * when reading to be able to roll back and return just read tuple back to
         * the store if we failed to write it out to the queue.
         * Secondary read pointer is for reading, and its eof flag is cleared if a
         * tuple is written to the store.
         */</comment>
        <expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If we have something in the tuplestore try to push this to the queue */</comment>
        <while>while <condition>(<expr><operator>!</operator><call><name>tuplestore_ateof</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* save position */</comment>
            <expr_stmt><expr><call><name>tuplestore_copy_read_pointer</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Try to get next tuple to the temporary slot */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>tmpslot</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* false means the tuplestore in EOF state */</comment>    
                <expr_stmt><expr><name>sendall</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ntuples_get</name></name><operator>++</operator></expr>;</expr_stmt>
            
            <comment type="block">/* The slot should contain a data row */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tmpslot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>DataPumpSendToNode</name><argument_list>(<argument><expr><name>sndctl</name></expr></argument>, <argument><expr><name><name>tmpslot</name><operator>-&gt;</operator><name>tts_datarow</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>, <argument><expr><name><name>tmpslot</name><operator>-&gt;</operator><name>tts_datarow</name><operator>-&gt;</operator><name>msglen</name></name></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* check if queue has enough room for the data */</comment>
            <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>DataPumpOK</name></expr>)</condition>
            <block>{<block_content>

                <comment type="block">/* Restore read position to get same tuple next time */</comment>
                <expr_stmt><expr><call><name>tuplestore_copy_read_pointer</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* We might advance the mark, try to truncate */</comment>
                <expr_stmt><expr><call><name>tuplestore_trim</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Prepare for writing, set proper read pointer */</comment>
                <expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <expr_stmt><expr><name>sendall</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ntuples_get</name></name><operator>--</operator></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* Big enough, send data. */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>DataSize</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>g_SndBatchSize</name> <operator>*</operator> <literal type="number">1024</literal></expr>)</condition>
                <block>{<block_content>    
                    <expr_stmt><expr><call><name>DataPumpWakeupSender</name><argument_list>(<argument><expr><name>sndctl</name></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>

        <comment type="block">/* Handle the latest row. */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_ateof</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>sendall</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>sendall</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/* Remove rows we have just read */</comment>
        <expr_stmt><expr><call><name>tuplestore_trim</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* prepare for writes, set read pointer 0 as active */</comment>
        <expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>sendall</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int32</name></type> <name>DataPumpSendToNode</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>sndctl</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeindex</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>                  <name>long_tuple</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                   <name>cursor</name>     <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>                   <name>tuple_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>DataPumpSenderControl</name> <modifier>*</modifier></type><name>sender</name>   <init>= <expr><operator>(</operator><name>DataPumpSenderControl</name><operator>*</operator><operator>)</operator><name>sndctl</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataPumpNodeControl</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        
    <expr_stmt><expr><name>tuple_len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* msg type 'D' */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>tuple_len</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>tuple_len</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>tuple_len</name> <operator>&gt;=</operator> <name><name>node</name><operator>-&gt;</operator><name>buffer</name><operator>-&gt;</operator><name>m_Length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>long_tuple</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>FreeSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <operator>(</operator><name>uint32</name><operator>)</operator><name>tuple_len</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>long_tuple</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>DataPumpWakeupSender</name><argument_list>(<argument><expr><name>sndctl</name></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>DataPumpSndError_no_space</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>long_tuple</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* MsgType */</comment>
        <expr_stmt><expr><call><name>PutData</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"D"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Data length */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>uint32</name></type>        <name>n32</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PutData</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Data */</comment>
        <expr_stmt><expr><call><name>PutData</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SetBorder</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>uint32</name></type> <name>header_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>data_len</name> <init>= <expr><call><name>FreeSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>header_len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        
        <if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>header_len</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/* put message 'D' */</comment>
        <while>while <condition>(<expr><name>data_len</name> <operator>&lt;</operator> <name>header_len</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>DataPumpWakeupSender</name><argument_list>(<argument><expr><name>sndctl</name></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">50L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>DataPumpSndStatus_error</name></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><name>DataPumpSndError_io_error</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><name>data_len</name> <operator>=</operator> <call><name>FreeSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>PutData</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><literal type="string">"D"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Data length */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>uint32</name></type>        <name>n32</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PutData</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>cursor</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        
        <while>while <condition>(<expr><name>len</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>data_len</name> <operator>=</operator> <call><name>FreeSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>data_len</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>write_len</name> <init>= <expr><ternary><condition><expr><name>len</name> <operator>&gt;</operator> <name>data_len</name></expr> ?</condition><then> <expr><name>data_len</name></expr> </then><else>: <expr><name>len</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                
                <expr_stmt><expr><call><name>PutData</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name>cursor</name></expr></argument>, <argument><expr><name>write_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>cursor</name> <operator>=</operator> <name>cursor</name> <operator>+</operator> <name>write_len</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>len</name> <operator>=</operator> <name>len</name> <operator>-</operator> <name>write_len</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>DataPumpWakeupSender</name><argument_list>(<argument><expr><name>sndctl</name></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">50L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>DataPumpSndStatus_error</name></expr>)</condition>
                <block>{<block_content>
                    <return>return <expr><name>DataPumpSndError_io_error</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>
    
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ntuples</name></name><operator>++</operator></expr>;</expr_stmt>

    <return>return <expr><name>DataPumpOK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int32</name></type>  <name>DataPumpNodeReadyForSend</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>sndctl</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeindex</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DataPumpNodeControl</name>   <modifier>*</modifier></type><name>node</name>     <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataPumpSenderControl</name> <modifier>*</modifier></type><name>sender</name>   <init>= <expr><operator>(</operator><name>DataPumpSenderControl</name><operator>*</operator><operator>)</operator><name>sndctl</name></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><name><name>sender</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>cstatus</name></name> <operator>!=</operator> <name>ConvertRunning</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"convert thread status:%d abnormal, maxconn:%d, conn_num:%d, errno:%d"</literal></expr></argument>, 
                                                        <argument><expr><name><name>sender</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>cstatus</name></name></expr></argument>, 
                                                        <argument><expr><name><name>sender</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>maxConn</name></name></expr></argument>, 
                                                        <argument><expr><name><name>sender</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>connect_num</name></name></expr></argument>, 
                                                        <argument><expr><name><name>sender</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>errNO</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>DataPumpConvert_error</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nodeindex</name></name> <operator>!=</operator> <name>nodeId</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>DataPumpSndError_node_error</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Use lock to check status and socket */</comment>
    <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NO_SOCKET</name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>sock</name></name> <operator>||</operator> <name>DataPumpSndStatus_no_socket</name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>DataPumpSndError_no_socket</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>DataPumpSndStatus_error</name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>DataPumpSndError_io_error</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>DATAPUMP_UNREACHABLE_NODE_FD</name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>sock</name></name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>DataPumpSndError_unreachable_node</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>DataPumpOK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Send DataRow to DataPumb.
 */</comment>
<function><type><name>int32</name></type>  <name>DataPumpSendDataRow</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>sndctl</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeindex</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeId</name></decl></parameter>,  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>                   <name>ret</name>        <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>DataPumpNodeControl</name>   <modifier>*</modifier></type><name>node</name>     <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataPumpSenderControl</name> <modifier>*</modifier></type><name>sender</name>   <init>= <expr><operator>(</operator><name>DataPumpSenderControl</name><operator>*</operator><operator>)</operator><name>sndctl</name></expr></init></decl>;</decl_stmt>

    
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>DataPumpNodeReadyForSend</name><argument_list>(<argument><expr><name>sndctl</name></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>, <argument><expr><name>nodeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>DataPumpOK</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>ret</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>DataPumpSendToNode</name><argument_list>(<argument><expr><name>sndctl</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>DataPumpOK</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>ret</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Big enough, send data. */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>DataSize</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>g_SndBatchSize</name> <operator>*</operator> <literal type="number">1024</literal></expr>)</condition>
    <block>{<block_content>    
        <expr_stmt><expr><call><name>DataPumpWakeupSender</name><argument_list>(<argument><expr><name>sndctl</name></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>DataPumpOK</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * When job done, tell sender to finish.
 */</comment>
<function><type><name>bool</name></type> <name>DataPumpWaitSenderDone</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>sndctl</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>                   <name>succeed</name>   <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>                  <name>ret</name>       <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>                   <name>threadid</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>                 <name>nodeindex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataPumpNodeControl</name>   <modifier>*</modifier></type><name>node</name>     <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataPumpThreadControl</name> <modifier>*</modifier></type><name>thread</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataPumpSenderControl</name> <modifier>*</modifier></type><name>sender</name>   <init>= <expr><operator>(</operator><name>DataPumpSenderControl</name><operator>*</operator><operator>)</operator><name>sndctl</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>                  <modifier>*</modifier></type><name>send_quit</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sndctl</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>send_quit</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>sender</name><operator>-&gt;</operator><name>thread_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>sender</name><operator>-&gt;</operator><name>thread_control</name></name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>threadid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>threadid</name> <operator>&lt;</operator> <name><name>sender</name><operator>-&gt;</operator><name>thread_num</name></name></expr>;</condition> <incr><expr><name>threadid</name> <operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>thread</name> <operator>=</operator> <operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>thread_control</name><index>[<expr><name>threadid</name></expr>]</index></name></expr>;</expr_stmt>
            <comment type="block">/* Set quit flag and tell sender to quit. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>thread</name><operator>-&gt;</operator><name>thread_running</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>thread_need_quit</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <name>error</name></expr>;</expr_stmt>
                
                <expr_stmt><expr><call><name>ThreadSemaUp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>send_sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

                <expr_stmt><expr><name><name>send_quit</name><index>[<expr><name>threadid</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <for>for <control>(<init><expr><name>threadid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>threadid</name> <operator>&lt;</operator> <name><name>sender</name><operator>-&gt;</operator><name>thread_num</name></name></expr>;</condition> <incr><expr><name>threadid</name> <operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>send_quit</name><index>[<expr><name>threadid</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>thread</name> <operator>=</operator> <operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>thread_control</name><index>[<expr><name>threadid</name></expr>]</index></name></expr>;</expr_stmt>
                <comment type="block">/* Wait for sender to quit. */</comment>        
                <expr_stmt><expr><call><name>ThreadSemaDown</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>quit_sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>thread</name><operator>-&gt;</operator><name>quit_status</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><name>DATA_PUMP_PREFIX</name><literal type="string">"thread:%d send data finish with error"</literal></expr></argument>, <argument><expr><name>threadid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
                    <for>for <control>(<init><expr><name>nodeindex</name> <operator>=</operator> <name><name>thread</name><operator>-&gt;</operator><name>node_base</name></name></expr>;</init> <condition><expr><name>nodeindex</name> <operator>&lt;</operator> <name><name>thread</name><operator>-&gt;</operator><name>node_end</name></name> <operator>&amp;&amp;</operator> <name>nodeindex</name><operator>&lt;</operator> <name><name>thread</name><operator>-&gt;</operator><name>node_num</name></name></expr>;</condition> <incr><expr><name>nodeindex</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>DataPumpSndStatus_done</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><name>DATA_PUMP_PREFIX</name><literal type="string">"thread:%d node:%d remaining datasize:%u failed for %s, errno:%d"</literal></expr></argument>, <argument><expr><name>threadid</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nodeindex</name></name></expr></argument>, <argument><expr><call><name>DataSize</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>errorno</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>errorno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></for>
                    <expr_stmt><expr><name>succeed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s: thread id %d done."</literal></expr></argument>, <argument><expr><name><name>sender</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>sqname</name></name></expr></argument>, <argument><expr><name>threadid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>send_quit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* tell convert to exit */</comment>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ConvertDone</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>convert_control</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>succeed</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>succeed</name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Squeue:%s(Pid:%d), destroy %d sender, 1 convert."</literal></expr></argument>, <argument><expr><name><name>sender</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>sqname</name></name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name><name>sender</name><operator>-&gt;</operator><name>thread_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return <expr><name>succeed</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * When create thread failed, tell other thread to quit.
 */</comment>
<function><type><name>void</name></type> <name>DataPumpCleanThread</name><parameter_list>(<parameter><decl><type><name>DataPumpSenderControl</name> <modifier>*</modifier></type><name>sender</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>                   <name>threadid</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataPumpThreadControl</name> <modifier>*</modifier></type><name>thread</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    
    <for>for <control>(<init><expr><name>threadid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>threadid</name> <operator>&lt;</operator> <name><name>sender</name><operator>-&gt;</operator><name>thread_num</name></name></expr>;</condition> <incr><expr><name>threadid</name> <operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>thread</name> <operator>=</operator> <operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>thread_control</name><index>[<expr><name>threadid</name></expr>]</index></name></expr>;</expr_stmt>
        <comment type="block">/* Set quit flag and tell sender to quit. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>thread</name><operator>-&gt;</operator><name>thread_running</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>thread_need_quit</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ThreadSemaUp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>send_sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <for>for <control>(<init><expr><name>threadid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>threadid</name> <operator>&lt;</operator> <name><name>sender</name><operator>-&gt;</operator><name>thread_num</name></name></expr>;</condition> <incr><expr><name>threadid</name> <operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>thread</name> <operator>=</operator> <operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>thread_control</name><index>[<expr><name>threadid</name></expr>]</index></name></expr>;</expr_stmt>
		<comment type="block">/* Wait for sender to quit. */</comment>	
		<if_stmt><if>if <condition>(<expr><name><name>thread</name><operator>-&gt;</operator><name>thread_need_quit</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ThreadSemaDown</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>quit_sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>ConvertDone</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>convert_control</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
</block_content>}</block></function>

<comment type="block">/*
 * Set node socket.
 */</comment>
<function><type><name>int32</name></type>  <name>DataPumpSetNodeSocket</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>sndctl</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeindex</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeId</name></decl></parameter>,  <parameter><decl><type><name>int32</name></type> <name>socket</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DataPumpNodeControl</name>   <modifier>*</modifier></type><name>node</name>     <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataPumpSenderControl</name> <modifier>*</modifier></type><name>sender</name>   <init>= <expr><operator>(</operator><name>DataPumpSenderControl</name><operator>*</operator><operator>)</operator><name>sndctl</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>nodeindex</name> <operator>&gt;=</operator> <name><name>sender</name><operator>-&gt;</operator><name>node_num</name></name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>DataPumpSndError_node_error</name></expr>;</return>
    </block_content>}</block></if></if_stmt>


    <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nodeindex</name></name> <operator>!=</operator> <name>nodeId</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>DataPumpSndError_node_error</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Use lock to check status and socket */</comment>
    <expr_stmt><expr><call><name>socket_set_nonblocking</name><argument_list>(<argument><expr><name>socket</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NO_SOCKET</name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>sock</name></name> <operator>&amp;&amp;</operator> <name>DataPumpSndStatus_no_socket</name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sock</name></name>   <operator>=</operator> <name>socket</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>DataPumpSndStatus_set_socket</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>DataPumpOK</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>DataPumpSndError_bad_status</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* make connection to convert */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>convert_connect</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sqname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>fd</name></decl>,
                <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>sock_path</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_un</name></name></type> <name>unix_addr</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sock_path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>DATA_PUMP_SOCKET_DIR</name></expr></argument>, <argument><expr><name>sqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* create a Unix domain stream socket */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>socket</name><argument_list>(<argument><expr><name>AF_UNIX</name></expr></argument>, <argument><expr><name>SOCK_STREAM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EMFILE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"make socket to producer:%s failed for %s"</literal></expr></argument>, <argument><expr><name>sock_path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"make socket to producer:%s failed for %s"</literal></expr></argument>, <argument><expr><name>sock_path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unix_addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unix_addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>unix_addr</name><operator>.</operator><name>sun_family</name></name> <operator>=</operator> <name>AF_UNIX</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>unix_addr</name><operator>.</operator><name>sun_path</name></name></expr></argument>, <argument><expr><name>sock_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>unix_addr</name><operator>.</operator><name>sun_family</name></name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
        <call><name>strlen</name><argument_list>(<argument><expr><name><name>unix_addr</name><operator>.</operator><name>sun_path</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>connect</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator> <name>unix_addr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"connect to producer:%s failed for %s, pid:%d"</literal></expr></argument>, <argument><expr><name>sock_path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>fd</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <comment type="block">/* TODO support for non-unix platform */</comment>
    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only supports UNIX socket"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>convert_listen</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sock_path</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxconn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>fd</name></decl>,
                <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_un</name></name></type> <name>unix_addr</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>

    <comment type="block">/* create a Unix domain stream socket */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>socket</name><argument_list>(<argument><expr><name>AF_UNIX</name></expr></argument>, <argument><expr><name>SOCK_STREAM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* fill in socket address structure */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unix_addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unix_addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>unix_addr</name><operator>.</operator><name>sun_family</name></name> <operator>=</operator> <name>AF_UNIX</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>unix_addr</name><operator>.</operator><name>sun_path</name></name></expr></argument>, <argument><expr><name>sock_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>unix_addr</name><operator>.</operator><name>sun_family</name></name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
        <call><name>strlen</name><argument_list>(<argument><expr><name><name>unix_addr</name><operator>.</operator><name>sun_path</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* bind the name to the descriptor */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>bind</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator> <name>unix_addr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* tell kernel we're a server */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>listen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>maxconn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>fd</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEND_MSG_BUFFER_SIZE</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>
<comment type="block">/*
 * Build up a message carrying file descriptors or process numbers and send them over specified
 * connection
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>convert_sendfds</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>fds_to_send</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>iovec</name></name></type> <name><name>iov</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>msghdr</name></name></type> <name>msg</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>   <name><name>buf</name><index>[<expr><name>SEND_MSG_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>n32</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>cmsghdr</name></name> <modifier>*</modifier></type><name>cmptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>fd_buf</name><index>[<expr><call><name>CMSG_SPACE</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>iov</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iov_base</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>iov</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iov_len</name> <operator>=</operator> <name>SEND_MSG_BUFFER_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_iov</name></name> <operator>=</operator> <name>iov</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_iovlen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_namelen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_control</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_controllen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>fdptr</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_control</name></name> <operator>=</operator> <name>fd_buf</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_controllen</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>fd_buf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name>cmptr</name> <operator>=</operator> <call><name>CMSG_FIRSTHDR</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cmptr</name><operator>-&gt;</operator><name>cmsg_level</name></name> <operator>=</operator> <name>SOL_SOCKET</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cmptr</name><operator>-&gt;</operator><name>cmsg_type</name></name> <operator>=</operator> <name>SCM_RIGHTS</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cmptr</name><operator>-&gt;</operator><name>cmsg_len</name></name> <operator>=</operator> <call><name>CMSG_LEN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>fdptr</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>CMSG_DATA</name><argument_list>(<argument><expr><name>cmptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* the fd to pass */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>fdptr</name></expr></argument>, <argument><expr><name>fds_to_send</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//memcpy(CMSG_DATA(CMSG_FIRSTHDR(&amp;msg)), fds_to_send, count * sizeof(int));</comment>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>sendmsg</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>SEND_MSG_BUFFER_SIZE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>err</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
        <comment type="block">/* 
          * if errno is broken pipe or connection reset by peer, the producer may have finished
          * work, and we do not need to send fd any more.
          */</comment>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>err</name> <operator>==</operator> <name>EPIPE</name> <operator>||</operator> <operator>*</operator><name>err</name> <operator>==</operator> <name>ECONNRESET</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"convert_sendfds sendmsg failed for:%s."</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><operator>*</operator><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"convert_sendfds sendmsg failed for:%s."</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><operator>*</operator><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <return>return <expr><name>EOF</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read a message from the specified connection carrying file descriptors
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>convert_recvfds</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>fds</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint</name></type>        <name>n32</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>buf</name><index>[<expr><name>SEND_MSG_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>iovec</name></name></type> <name><name>iov</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>msghdr</name></name></type> <name>msg</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>cmsghdr</name></name> <modifier>*</modifier></type> <name>cmsg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>fd_buf</name><index>[<expr><call><name>CMSG_SPACE</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count</name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>iov</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iov_base</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>iov</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>iov_len</name> <operator>=</operator> <name>SEND_MSG_BUFFER_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_iov</name></name> <operator>=</operator> <name>iov</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_iovlen</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_namelen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_control</name></name> <operator>=</operator> <name>fd_buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msg_controllen</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>fd_buf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>recvmsg</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>failure</name>;</goto></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>failure</name>;</goto></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>r</name> <operator>!=</operator> <name>SEND_MSG_BUFFER_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>failure</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Verify response */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'f'</literal></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>failure</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>n32</name> <operator>!=</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>failure</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If connection count is 0 it means pool does not have connections
     * to  fulfill request. Otherwise number of returned connections
     * should be equal to requested count. If it not the case consider this
     * a protocol violation. (Probably connection went out of sync)
     */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>n32</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>failure</name>;</goto></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>n32</name> <operator>!=</operator> <name>count</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>failure</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>cmsg</name> <operator>=</operator> <call><name>CMSG_FIRSTHDR</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>cmsg</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>failure</name>;</goto></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>fds</name></expr></argument>, <argument><expr><call><name>CMSG_DATA</name><argument_list>(<argument><expr><call><name>CMSG_FIRSTHDR</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
<label><name>failure</name>:</label>
    <return>return <expr><name>EOF</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* send nodeid and consumerIdx to convert */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>send_fd_with_nodeid</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sqname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodeid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>consumerIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n32</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>convert_connect</name><argument_list>(<argument><expr><name>sqname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not connect to convert with cursor \"%s\", pid:%d"</literal></expr></argument>,
                        <argument><expr><name>sqname</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* send nodeid */</comment>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>send</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if<condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>err</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>EPIPE</name> <operator>||</operator> <name>err</name> <operator>==</operator> <name>ECONNRESET</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* producer may have finished work, and we do not need to send anything. */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not send nodeid to convert, errmsg:%s; producer may have finished work."</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not send nodeid to convert, errmsg:%s."</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* send consumer index  */</comment>
    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>consumerIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>send</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>err</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>EPIPE</name> <operator>||</operator> <name>err</name> <operator>==</operator> <name>ECONNRESET</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* producer may have finished work, and we do not need to send anything. */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not send consumerIdx to convert, errmsg:%s; producer may have finished work."</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not send consumerIdx to convert, errmsg:%s."</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* send fd */</comment>
    <if_stmt><if>if<condition>(<expr><call><name>convert_sendfds</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>MyProcPort</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>err</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>EPIPE</name> <operator>||</operator> <name>err</name> <operator>==</operator> <name>ECONNRESET</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* producer may have finished work, and we do not need to send anything. */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not send sockfd to convert, errmsg:%s; producer may have finished work."</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not send sockfd to convert, errmsg:%s."</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>ConvertThreadMain</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SOCK_PATH_LEN</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>bool</name></type> <name>exit_flag</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nodeid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>consumerIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>sockfd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>listen_fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>con_fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataPumpSenderControl</name> <modifier>*</modifier></type><name>control</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>sock_path</name><index>[<expr><name>SOCK_PATH_LEN</name></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ThreadSigmask</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>control</name> <operator>=</operator> <operator>(</operator><name>DataPumpSenderControl</name> <operator>*</operator><operator>)</operator><name>arg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>begin_stamp</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sock_path</name></expr></argument>, <argument><expr><name>SOCK_PATH_LEN</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>DATA_PUMP_SOCKET_DIR</name></expr></argument>, <argument><expr><name><name>control</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>sqname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>listen_fd</name> <operator>=</operator> <call><name>convert_listen</name><argument_list>(<argument><expr><name>sock_path</name></expr></argument>, <argument><expr><name><name>control</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>maxConn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>listen_fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>errNO</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>cstatus</name></name> <operator>=</operator> <name>ConvertListenError</name></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>    

    <while>while<condition>(<expr><name>true</name></expr>)</condition>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
        if (control-&gt;convert_control.connect_num == (control-&gt;convert_control.maxConn - 1))
        {
            control-&gt;convert_control.finish_stamp = GetCurrentTimestamp();
        }
        
        if (exit_flag &amp;&amp; control-&gt;convert_control.connect_num == control-&gt;convert_control.maxConn)
        {
            close(listen_fd);
            control-&gt;convert_control.cstatus = ConvertExit;
            unlink(sock_path);
            break;
        }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if <condition>(<expr><name>exit_flag</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>finish_stamp</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>listen_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>cstatus</name></name> <operator>=</operator> <name>ConvertExit</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>sock_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name>con_fd</name> <operator>=</operator> <call><name>accept</name><argument_list>(<argument><expr><name>listen_fd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>con_fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>listen_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>errNO</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>cstatus</name></name> <operator>=</operator> <name>ConvertAcceptError</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>sock_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>connect_num</name></name><operator>++</operator></expr>;</expr_stmt>
        
        <comment type="block">/* recv nodeid */</comment>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>recv</name><argument_list>(<argument><expr><name>con_fd</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>nodeid</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>con_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>listen_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>errNO</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>cstatus</name></name> <operator>=</operator> <name>ConvertRecvNodeidError</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>sock_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name>nodeid</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>nodeid</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>exit_flag</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>con_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* recv consumer index  */</comment>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>recv</name><argument_list>(<argument><expr><name>con_fd</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>consumerIdx</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>con_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>listen_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>errNO</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>cstatus</name></name> <operator>=</operator> <name>ConvertRecvNodeindexError</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>sock_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>consumerIdx</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>consumerIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* recv fd */</comment>
        <if_stmt><if>if<condition>(<expr><call><name>convert_recvfds</name><argument_list>(<argument><expr><name>con_fd</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sockfd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>con_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>listen_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>errNO</name></name>   <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>cstatus</name></name> <operator>=</operator> <name>ConvertRecvSockfdError</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>sock_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* store nodeid, consumerIdx, sockfd */</comment>
        <if_stmt><if>if<condition>(<expr><call><name>DataPumpSetNodeSocket</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name>sockfd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DataPumpOK</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>con_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>listen_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>cstatus</name></name> <operator>=</operator> <name>ConvertSetSockfdError</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>sock_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>con_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>ThreadSemaUp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>control</name><operator>-&gt;</operator><name>convert_control</name><operator>.</operator><name>quit_sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ConvertDone</name><parameter_list>(<parameter><decl><type><name>ConvertControl</name> <modifier>*</modifier></type><name>convert</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_RETRY</name></cpp:macro> <cpp:value>60000</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>bool</name></type> <name>succeed</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nodeid</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>retry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>convert</name><operator>-&gt;</operator><name>cstatus</name></name> <operator>!=</operator> <name>ConvertRunning</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>succeed</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

<label><name>RETRY</name>:</label>

    <expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>convert_connect</name><argument_list>(<argument><expr><name><name>convert</name><operator>-&gt;</operator><name>sqname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if<condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>retry</name><operator>++</operator></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>retry</name> <operator>&lt;</operator> <name>MAX_RETRY</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>convert</name><operator>-&gt;</operator><name>cstatus</name></name> <operator>!=</operator> <name>ConvertRunning</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>succeed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                <return>return <expr><name>succeed</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <goto>goto <name>RETRY</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"producer failed to connect convert for %d times, errmsg:%s"</literal></expr></argument>, <argument><expr><name>retry</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>convert</name><operator>-&gt;</operator><name>cstatus</name></name> <operator>!=</operator> <name>ConvertRunning</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>succeed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>succeed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>succeed</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

        <comment type="block">/* send nodeid */</comment>
    <expr_stmt><expr><name>nodeid</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>send</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>nodeid</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"producer failed to send nodeid to convert, errmsg:%s."</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <if_stmt><if>if <condition>(<expr><name><name>convert</name><operator>-&gt;</operator><name>cstatus</name></name> <operator>!=</operator> <name>ConvertRunning</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>succeed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>succeed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>succeed</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ThreadSemaDown</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>convert</name><operator>-&gt;</operator><name>quit_sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>succeed</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Squeue:%s establish connection cost %ld us"</literal></expr></argument>, <argument><expr><name><name>convert</name><operator>-&gt;</operator><name>sqname</name></name></expr></argument>, <argument><expr><name><name>convert</name><operator>-&gt;</operator><name>finish_stamp</name></name> <operator>-</operator> <name><name>convert</name><operator>-&gt;</operator><name>begin_stamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>succeed</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SendDataRemote</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>squeue</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>consumerIdx</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier><modifier>*</modifier></type><name>tuplestore</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>tmpcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives    </comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>fast_send_done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>send_all</name>       <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>free_datarow</name>   <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>nodeid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>ret</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ConsState</name>  <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>squeue</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteDataRow</name></type> <name>datarow</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataPumpSenderControl</name> <modifier>*</modifier></type><name>sender</name>   <init>= <expr><operator>(</operator><name>DataPumpSenderControl</name><operator>*</operator><operator>)</operator><name><name>squeue</name><operator>-&gt;</operator><name>sender</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataPumpNodeControl</name>   <modifier>*</modifier></type><name>node</name>     <init>= <expr><operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>consumerIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_error</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"SendDataRemote: shared_queue %s error."</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>ERR</name>;</goto>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name>end_query_requested</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>producer_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>end_query_requested</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>squeue</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>nConsumer_done</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>squeue</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"SendDataRemote:squeue %s producer %d set query done"</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* all consumers done, do not produce data anymore */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>squeue</name><operator>-&gt;</operator><name>nConsumer_done</name></name> <operator>==</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>Executor_done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"SendDataRemote:squeue %s producer %d all consumers done."</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* consumer do not need data anymore */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name> <operator>==</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_pid</name></name> <operator>&amp;&amp;</operator> <name><name>squeue</name><operator>-&gt;</operator><name>producer_done</name></name><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name> <operator>!=</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_pid</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_done</name></name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if consumer do not need data anymore*/</comment>

    <expr_stmt><expr><name>nodeid</name> <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>DataPumpNodeReadyForSend</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>DataPumpOK</name> <operator>==</operator> <name>ret</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* No tuplestore created, we send datarow directly. */</comment>
        <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <operator>*</operator><name>tuplestore</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Get datarow from the tuple slot */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>datarow</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>free_datarow</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* Try fast send. */</comment>
                <expr_stmt><expr><name>fast_send_done</name> <operator>=</operator> <call><name>ExecFastSendDatarow</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>sender</name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>, <argument><expr><name>tmpcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>fast_send_done</name></expr>)</condition>
                <block>{<block_content>
                    <return>return;</return>
                </block_content>}</block></if></if_stmt>        
                <expr_stmt><expr><name>in_data_pump</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>datarow</name> <operator>=</operator> <call><name>ExecCopySlotDatarow</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tmpcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>in_data_pump</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>free_datarow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>DataPumpSendDataRow</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name><name>datarow</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>, <argument><expr><name><name>datarow</name><operator>-&gt;</operator><name>msglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
            <if_stmt><if>if<condition>(<expr><name>DataPumpOK</name> <operator>==</operator> <name>ret</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if<condition>(<expr><name>free_datarow</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>datarow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>datarow</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <return>return;</return>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>DataPumpConvert_error</name> <operator>==</operator> <name>ret</name> <operator>||</operator>
                     <name>DataPumpSndError_node_error</name> <operator>==</operator> <name>ret</name> <operator>||</operator>
                     <name>DataPumpSndError_io_error</name> <operator>==</operator> <name>ret</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if<condition>(<expr><name>free_datarow</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>datarow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>datarow</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <goto>goto <name>ERR</name>;</goto>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>DataPumpSndError_unreachable_node</name> <operator>==</operator> <name>ret</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* consumer never need data */</comment>
                <if_stmt><if>if<condition>(<expr><name>free_datarow</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>datarow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>datarow</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
            
            <if_stmt><if>if<condition>(<expr><name>free_datarow</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>datarow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>datarow</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* DataPumpSndError_no_socket or DataPumpSndError_no_space */</comment>
            <if_stmt><if>if<condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"DataPump status:%d, need to put slot into tuplestore."</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Empty tuple store, send the data. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>tuplestore_ateof</name><argument_list>(<argument><expr><operator>*</operator><name>tuplestore</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Get datarow from the tuple slot */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>datarow</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>free_datarow</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Try fast send. */</comment>
                    <expr_stmt><expr><name>fast_send_done</name> <operator>=</operator> <call><name>ExecFastSendDatarow</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>sender</name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>, <argument><expr><name>tmpcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>fast_send_done</name></expr>)</condition>
                    <block>{<block_content>
                        <return>return;</return>
                    </block_content>}</block></if></if_stmt>        

                    <expr_stmt><expr><name>in_data_pump</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>datarow</name> <operator>=</operator> <call><name>ExecCopySlotDatarow</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tmpcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>in_data_pump</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>free_datarow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                
                <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>DataPumpSendDataRow</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name><name>datarow</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>, <argument><expr><name><name>datarow</name><operator>-&gt;</operator><name>msglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
                <if_stmt><if>if<condition>(<expr><name>DataPumpOK</name> <operator>==</operator> <name>ret</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if<condition>(<expr><name>free_datarow</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>datarow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>datarow</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <return>return;</return>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>DataPumpConvert_error</name> <operator>==</operator> <name>ret</name> <operator>||</operator>
                         <name>DataPumpSndError_node_error</name> <operator>==</operator> <name>ret</name> <operator>||</operator>
                         <name>DataPumpSndError_io_error</name> <operator>==</operator> <name>ret</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if<condition>(<expr><name>free_datarow</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>datarow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>datarow</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <goto>goto <name>ERR</name>;</goto>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name>DataPumpSndError_unreachable_node</name> <operator>==</operator> <name>ret</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* consumer never need data */</comment>
                    <if_stmt><if>if<condition>(<expr><name>free_datarow</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>datarow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>datarow</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <return>return;</return>
                </block_content>}</block></if></if_stmt>
                
                <if_stmt><if>if<condition>(<expr><name>free_datarow</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>datarow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>datarow</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <comment type="block">/* DataPumpSndError_no_socket or DataPumpSndError_no_space */</comment>
                <if_stmt><if>if<condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"DataPump status:%d, need to put slot into tuplestore."</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*Build the temp slot. We will not DROP this slot when finish the cursor. We need upper level to reset the MCTX. */</comment>
                <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sender</name><operator>-&gt;</operator><name>temp_slot</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name><operator>-&gt;</operator><name>temp_slot</name></name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name><operator>-&gt;</operator><name>temp_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                        
                
                <comment type="block">/* We got a tuplestore, dump it first. */</comment>
                <expr_stmt><expr><name>send_all</name> <operator>=</operator> <call><name>DataPumpTupleStoreDump</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>, 
                                                   <argument><expr><name>consumerIdx</name></expr></argument>, 
                                                   <argument><expr><name>nodeid</name></expr></argument>,
                                                      <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name><operator>-&gt;</operator><name>temp_slot</name></name></expr></argument>, 
                                                   <argument><expr><operator>*</operator><name>tuplestore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Send the tuple if the tuplestore is empty. */</comment>
                <if_stmt><if>if <condition>(<expr><name>send_all</name></expr>)</condition>
                <block>{<block_content>                    
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* Get datarow from the tuple slot */</comment>
                        <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>datarow</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>free_datarow</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <comment type="block">/* Try fast send. */</comment>
                            <expr_stmt><expr><name>fast_send_done</name> <operator>=</operator> <call><name>ExecFastSendDatarow</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>sender</name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>, <argument><expr><name>tmpcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>fast_send_done</name></expr>)</condition>
                            <block>{<block_content>
                                <return>return;</return>
                            </block_content>}</block></if></if_stmt>        

                            <expr_stmt><expr><name>in_data_pump</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>datarow</name> <operator>=</operator> <call><name>ExecCopySlotDatarow</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tmpcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>in_data_pump</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>free_datarow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                        
                        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>DataPumpSendDataRow</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name><name>datarow</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>, <argument><expr><name><name>datarow</name><operator>-&gt;</operator><name>msglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>DataPumpOK</name> <operator>==</operator> <name>ret</name></expr>)</condition>
                        <block>{<block_content>
                            <if_stmt><if>if<condition>(<expr><name>free_datarow</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>datarow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name>datarow</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                            <return>return;</return>
                        </block_content>}</block></if></if_stmt>

                        <if_stmt><if>if<condition>(<expr><name>free_datarow</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>datarow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>datarow</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <comment type="block">/* Failure!! Put tuple to tuplestore. */</comment>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <return>return;</return>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>DataPumpSndError_unreachable_node</name> <operator>==</operator> <name>ret</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Remote node unreachable, just drop the tuple. */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"SendDataRemote::remote node:%d never read data."</literal></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <return>return;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>DataPumpConvert_error</name> <operator>==</operator> <name>ret</name> <operator>||</operator>
             <name>DataPumpSndError_node_error</name> <operator>==</operator> <name>ret</name> <operator>||</operator>
             <name>DataPumpSndError_io_error</name> <operator>==</operator> <name>ret</name></expr>)</condition>
    <block>{<block_content>
        <goto>goto <name>ERR</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Error ocurred or the node is not ready at present,  store the tuple into the tuplestore. */</comment>
    <comment type="block">/* Create tuplestore if does not exist.*/</comment>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <operator>*</operator><name>tuplestore</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name>            <name>ptrno</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>         <name><name>storename</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>


        <expr_stmt><expr><operator>*</operator><name>tuplestore</name> <operator>=</operator> <call><name>tuplestore_begin_datarow</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name> <operator>/</operator> <name>NumDataNodes</name></expr></argument>, <argument><expr><name>tmpcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* We need is to be able to remember/restore the read position */</comment>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>storename</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="string">"%s node %d"</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>tuplestore_collect_stat</name><argument_list>(<argument><expr><operator>*</operator><name>tuplestore</name></expr></argument>, <argument><expr><name>storename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * Allocate a second read pointer to read from the store. We know
         * it must have index 1, so needn't store that.
         */</comment>
        <expr_stmt><expr><name>ptrno</name> <operator>=</operator> <call><name>tuplestore_alloc_read_pointer</name><argument_list>(<argument><expr><operator>*</operator><name>tuplestore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ptrno</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"create tuplestore with nodeid %d, cursor %s."</literal></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>in_data_pump</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <comment type="block">/* Append the slot to the store... */</comment>
    <expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><operator>*</operator><name>tuplestore</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>in_data_pump</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ntuples_put</name></name><operator>++</operator></expr>;</expr_stmt>
    
    <return>return;</return>

<label><name>ERR</name>:</label>
    <expr_stmt><expr><call><name>DataPumpWaitSenderDone</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>DestoryDataPumpSenderControl</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender_destroy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SendDataRemote::DataPump status:%d abnormal!"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>bool</name></type> <name>socket_set_nonblocking</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>non_block</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* get old flags */</comment>
    <expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_GETFL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* flip O_NONBLOCK */</comment>
    <if_stmt><if>if <condition>(<expr><name>non_block</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>O_NONBLOCK</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>O_NONBLOCK</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* set new flags */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>fcntl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>F_SETFL</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ExecFastSendDatarow</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>sndctl</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeindex</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>tmpcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_RESERVE_STEP</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SLEEP_TIMES</name></cpp:macro> <cpp:value>50</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>uint32</name></type>          <name>free_size</name>       <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16</name></type>             <name>n16</name>             <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>            <name>tuple_len</name>       <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>             <name>i</name>                <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataPumpSenderControl</name> <modifier>*</modifier></type><name>sender</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataPumpNodeControl</name>   <modifier>*</modifier></type><name>node</name>     <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>         <name>tdesc</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type>      <name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>head</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>sender</name>   <operator>=</operator> <operator>(</operator><name>DataPumpSenderControl</name><operator>*</operator><operator>)</operator><name>sndctl</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>node</name>     <operator>=</operator> <operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name></expr>;</expr_stmt>
    
    
    <comment type="block">/* Get tuple length. */</comment>
    <expr_stmt><expr><name>tuple_len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* msg type 'D' */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>tuple_len</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name><name>sender</name><operator>-&gt;</operator><name>tuple_len</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>tuple_len</name></name> <operator>=</operator> <name>DEFAULT_RESERVE_STEP</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>tuple_len</name> <operator>+=</operator> <name><name>sender</name><operator>-&gt;</operator><name>tuple_len</name></name></expr>;</expr_stmt>    

    <expr_stmt><expr><name>head</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>buffer</name><operator>-&gt;</operator><name>m_Head</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>free_size</name> <operator>=</operator> <call><name>FreeSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>free_size</name> <operator>&gt;</operator> <name>tuple_len</name></expr>)</condition>    
    <block>{<block_content>
        <decl_stmt><decl><type><name>int32</name></type>  <name>ret</name>         <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>tmp</name>         <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>leng_ptr</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>write_len</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        
        <decl_stmt><decl><type><name>uint32</name></type> <name>n32</name>         <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>data_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>remaining_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type>    <name>savecxt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>ReserveSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>tuple_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>remaining_length</name> <operator>=</operator> <name>tuple_len</name></expr>;</expr_stmt>
        <comment type="block">/* MsgType */</comment>
        <expr_stmt><expr><call><name>FillReserveSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><literal type="string">"D"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>data_offset</name> <operator>=</operator> <call><name>BufferOffsetAdd</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>remaining_length</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        
        <comment type="block">/* Init length, exclude command tag. */</comment>
        <expr_stmt><expr><name>write_len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <comment type="block">/* Data length */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>leng_ptr</name>         <operator>=</operator> <name>data_offset</name></expr>;</expr_stmt>        
            <expr_stmt><expr><name>data_offset</name> <operator>=</operator> <call><name>BufferOffsetAdd</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>remaining_length</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>    

            <expr_stmt><expr><name>write_len</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/* Data */</comment>
        
        <comment type="block">/* ensure we have all values */</comment>
        <expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* if temporary memory context is specified reset it */</comment>
        <if_stmt><if>if <condition>(<expr><name>tmpcxt</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>tmpcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>savecxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>tmpcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* Number of parameter values */</comment>
        <expr_stmt><expr><name>n16</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name><name>tdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* No possiblity of memory short, we reserved DEFAULT_RESERVE_STEP bytes above. */</comment>
        <expr_stmt><expr><call><name>FillReserveSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n16</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>data_offset</name> <operator>=</operator> <call><name>BufferOffsetAdd</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>remaining_length</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

        <comment type="block">/* Write length */</comment>
        <expr_stmt><expr><name>write_len</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        
        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
        appendBinaryStringInfo(&amp;buf, (char *) &amp;n16, 2);
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
                appendBinaryStringInfo(&amp;buf, (char *) &amp;n32, 4);
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <if_stmt><if>if <condition>(<expr><name>write_len</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <name><name>node</name><operator>-&gt;</operator><name>buffer</name><operator>-&gt;</operator><name>m_Length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>remaining_length</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int</name></type> <name>sleep_times</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                        
                        <do>do
                        <block>{<block_content>
                            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ReserveSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>DEFAULT_RESERVE_STEP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition>
                            <block>{<block_content>
                                <break>break;</break>
                            </block_content>}</block></if></if_stmt>
                            <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DataPumpNodeCheck</name><argument_list>(<argument><expr><name>sndctl</name></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>ReturnSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ExecFastSendDatarow:node %d status abnormal."</literal></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>

                            <expr_stmt><expr><name>sleep_times</name><operator>++</operator></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><name>sleep_times</name> <operator>==</operator> <name>MAX_SLEEP_TIMES</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>ReturnSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                                
                                <return>return <expr><name>false</name></expr>;</return>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block>while<condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>;</do>

                        <comment type="block">/* sanity check */</comment>
                        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>remaining_length</name> <operator>+</operator> <name>data_offset</name><operator>)</operator> <operator>%</operator> <name><name>node</name><operator>-&gt;</operator><name>buffer</name><operator>-&gt;</operator><name>m_Length</name></name> <operator>!=</operator> <name>tmp</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ReturnSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"mismatch in Fast end."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        
                        <expr_stmt><expr><name>remaining_length</name> <operator>+=</operator> <name>DEFAULT_RESERVE_STEP</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>FillReserveSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>data_offset</name> <operator>=</operator> <call><name>BufferOffsetAdd</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>remaining_length</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                
                <comment type="block">/* Write length */</comment>
                <expr_stmt><expr><name>write_len</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><name><name>tdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>uint32</name></type>  <name>reserve_len</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>        <name>typOutput</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>    <name>typIsVarlena</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Datum</name></type>    <name>pval</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>pstring</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>        <name>len</name></decl>;</decl_stmt>

                <comment type="block">/* Get info needed to output the value */</comment>
                <expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typOutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIsVarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/*
                 * If we have a toasted datum, forcibly detoast it here to avoid
                 * memory leakage inside the type's output routine.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>typIsVarlena</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>pval</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>pval</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <comment type="block">/*
                  * column is composite type, need to send tupledesc to remote node
                  */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>rec</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Oid</name></type>            <name>tupType</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int32</name></type>        <name>tupTypmod</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>StringInfoData</name></type>  <name>tupdesc_data</name></decl>;</decl_stmt>
                    
                    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tupdesc_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    
                    <comment type="block">/* -2 to indicate this is composite type */</comment>
                    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>write_len</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <name><name>node</name><operator>-&gt;</operator><name>buffer</name><operator>-&gt;</operator><name>m_Length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>remaining_length</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>int</name></type> <name>sleep_times</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                            
                            <do>do
                            <block>{<block_content>
                                <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ReserveSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>DEFAULT_RESERVE_STEP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition>
                                <block>{<block_content>
                                    <break>break;</break>
                                </block_content>}</block></if></if_stmt>
                                <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DataPumpNodeCheck</name><argument_list>(<argument><expr><name>sndctl</name></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>ReturnSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>
                                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ExecFastSendDatarow:node %d status abnormal."</literal></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                                
                                <expr_stmt><expr><name>sleep_times</name><operator>++</operator></expr>;</expr_stmt>

                                <if_stmt><if>if <condition>(<expr><name>sleep_times</name> <operator>==</operator> <name>MAX_SLEEP_TIMES</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>ReturnSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                    <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>
                                    
                                    <return>return <expr><name>false</name></expr>;</return>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block>while<condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>;</do>

                            <comment type="block">/* sanity check */</comment>
                            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>remaining_length</name> <operator>+</operator> <name>data_offset</name><operator>)</operator> <operator>%</operator> <name><name>node</name><operator>-&gt;</operator><name>buffer</name><operator>-&gt;</operator><name>m_Length</name></name> <operator>!=</operator> <name>tmp</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>ReturnSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"mismatch in Fast end."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                            
                            <expr_stmt><expr><name>remaining_length</name> <operator>+=</operator> <name>DEFAULT_RESERVE_STEP</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><call><name>FillReserveSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>data_offset</name> <operator>=</operator> <call><name>BufferOffsetAdd</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>remaining_length</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    
                    <comment type="block">/* Write length */</comment>
                    <expr_stmt><expr><name>write_len</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>


                    <expr_stmt><expr><name>rec</name> <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>pval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* Extract type info from the tuple itself */</comment>
                    <expr_stmt><expr><name>tupType</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tupTypmod</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>tupType</name></expr></argument>, <argument><expr><name>tupTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>FormRowDescriptionMessage</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>tupdesc_data</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* write rowDesctiption */</comment>
                    <if_stmt><if>if <condition>(<expr><name>write_len</name> <operator>+</operator> <name>len</name> <operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <name><name>node</name><operator>-&gt;</operator><name>buffer</name><operator>-&gt;</operator><name>m_Length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name><name>tupdesc_data</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>remaining_length</name> <operator>&lt;</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>len</name><operator>)</operator></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>int</name></type> <name>sleep_times</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><name>reserve_len</name> <operator>=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>len</name><operator>)</operator> <operator>+</operator> <name>DEFAULT_RESERVE_STEP</name></expr>;</expr_stmt>
                            <do>do
                            <block>{<block_content>
                                <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ReserveSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>reserve_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition>
                                <block>{<block_content>
                                    <break>break;</break>
                                </block_content>}</block></if></if_stmt>
                                <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DataPumpNodeCheck</name><argument_list>(<argument><expr><name>sndctl</name></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>ReturnSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>
                                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ExecFastSendDatarow:node %d status abnormal."</literal></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>

                                <expr_stmt><expr><name>sleep_times</name><operator>++</operator></expr>;</expr_stmt>

                                <if_stmt><if>if <condition>(<expr><name>sleep_times</name> <operator>==</operator> <name>MAX_SLEEP_TIMES</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>ReturnSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                    <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>
                                    
                                    <return>return <expr><name>false</name></expr>;</return>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block>while<condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>;</do>

                            <comment type="block">/* sanity check */</comment>
                            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>remaining_length</name> <operator>+</operator> <name>data_offset</name><operator>)</operator> <operator>%</operator> <name><name>node</name><operator>-&gt;</operator><name>buffer</name><operator>-&gt;</operator><name>m_Length</name></name> <operator>!=</operator> <name>tmp</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>ReturnSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"mismatch in Fast end."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                            
                            <expr_stmt><expr><name>remaining_length</name> <operator>+=</operator> <name>reserve_len</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><call><name>FillReserveSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>data_offset</name> <operator>=</operator> <call><name>BufferOffsetAdd</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>remaining_length</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                    
                        <expr_stmt><expr><call><name>FillReserveSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><name><name>tupdesc_data</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>data_offset</name> <operator>=</operator> <call><name>BufferOffsetAdd</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>remaining_length</name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    
                    <expr_stmt><expr><name>write_len</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                    <expr_stmt><expr><name>write_len</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

                    <comment type="block">/* MemoryContextReset will do it */</comment>
                    <comment type="line">//pfree(tupdesc_data.data);</comment>
                </block_content>}</block></if></if_stmt>
                
                <comment type="block">/* Convert Datum to string */</comment>
                <expr_stmt><expr><name>pstring</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typOutput</name></expr></argument>, <argument><expr><name>pval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* copy data to the buffer */</comment>
                <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
                appendBinaryStringInfo(&amp;buf, (char *) &amp;n32, 4);
                appendBinaryStringInfo(&amp;buf, pstring, len);
                <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

                <if_stmt><if>if <condition>(<expr><name>write_len</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>len</name> <operator>&gt;=</operator> <name><name>node</name><operator>-&gt;</operator><name>buffer</name><operator>-&gt;</operator><name>m_Length</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>pstring</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Reserve space. */</comment>
                    <if_stmt><if>if <condition>(<expr><name>remaining_length</name> <operator>&lt;</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>len</name><operator>)</operator></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int</name></type> <name>sleep_times</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                        
                        <expr_stmt><expr><name>reserve_len</name> <operator>=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>len</name><operator>)</operator> <operator>+</operator> <name>DEFAULT_RESERVE_STEP</name></expr>;</expr_stmt>
                        <do>do
                        <block>{<block_content>
                            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ReserveSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>reserve_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition>
                            <block>{<block_content>
                                <break>break;</break>
                            </block_content>}</block></if></if_stmt>
                            <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DataPumpNodeCheck</name><argument_list>(<argument><expr><name>sndctl</name></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>ReturnSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ExecFastSendDatarow:node %d status abnormal."</literal></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>

                            <expr_stmt><expr><name>sleep_times</name><operator>++</operator></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><name>sleep_times</name> <operator>==</operator> <name>MAX_SLEEP_TIMES</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>ReturnSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                                
                                <return>return <expr><name>false</name></expr>;</return>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block>while<condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>;</do>
                        <comment type="block">/* sanity check */</comment>
                        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>remaining_length</name> <operator>+</operator> <name>data_offset</name><operator>)</operator> <operator>%</operator> <name><name>node</name><operator>-&gt;</operator><name>buffer</name><operator>-&gt;</operator><name>m_Length</name></name> <operator>!=</operator> <name>tmp</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ReturnSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"mismatch in Fast end."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        
                        <expr_stmt><expr><name>remaining_length</name> <operator>+=</operator> <name>reserve_len</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    
                    <comment type="block">/* Data length */</comment>
                    <expr_stmt><expr><call><name>FillReserveSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>data_offset</name> <operator>=</operator> <call><name>BufferOffsetAdd</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>remaining_length</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

                    <comment type="block">/* Data self */</comment>
                    <expr_stmt><expr><call><name>FillReserveSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><name>pstring</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>data_offset</name> <operator>=</operator> <call><name>BufferOffsetAdd</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>remaining_length</name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <comment type="block">/* MemoryContextReset will do it */</comment>
                <comment type="line">//pfree(pstring);</comment>
                <comment type="line">//pstring = NULL;</comment>
                
                <comment type="block">/* Write length */</comment>
                <expr_stmt><expr><name>write_len</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

                <comment type="block">/* Write length */</comment>
                <expr_stmt><expr><name>write_len</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>

        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
        <comment type="block">/* restore memory context to allocate result */</comment>
        if (savecxt)
        {
            MemoryContextSwitchTo(savecxt);
        }

        <comment type="block">/* copy data to the buffer */</comment>
        datarow = (RemoteDataRow) palloc(sizeof(RemoteDataRowData) + buf.len);
        datarow-&gt;msgnode = InvalidOid;
        datarow-&gt;msglen = buf.len;
        memcpy(datarow-&gt;msg, buf.data, buf.len);
        pfree(buf.data);
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* Write data length, we reserve data above. */</comment>
        <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>write_len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FillReserveSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>leng_ptr</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* Return space if needed. */</comment>
        <if_stmt><if>if <condition>(<expr><name>remaining_length</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ReturnSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>        

        <if_stmt><if>if <condition>(<expr><name><name>data</name><operator>.</operator><name>len</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">//int sleep_times = 0;</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>data_len</name> <init>= <expr><name><name>data</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>data</name><operator>.</operator><name>cursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            
            <while>while <condition>(<expr><name>data_len</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>uint32</name></type> <name>len</name> <init>= <expr><call><name>FreeSpace</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>uint32</name></type> <name>write_len</name> <init>= <expr><ternary><condition><expr><name>data_len</name> <operator>&gt;</operator> <name>len</name></expr> ?</condition><then> <expr><name>len</name></expr> </then><else>: <expr><name>data_len</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                        
                    <expr_stmt><expr><call><name>PutData</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name><name>data</name><operator>.</operator><name>cursor</name></name></expr></argument>, <argument><expr><name>write_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>data</name><operator>.</operator><name>cursor</name></name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>cursor</name></name> <operator>+</operator> <name>write_len</name></expr>;</expr_stmt>

                    <expr_stmt><expr><name>data_len</name> <operator>=</operator> <name>data_len</name> <operator>-</operator> <name>write_len</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>DataPumpWakeupSender</name><argument_list>(<argument><expr><name>sndctl</name></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">50L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DataPumpNodeCheck</name><argument_list>(<argument><expr><name>sndctl</name></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ExecFastSendDatarow:node %d status abnormal."</literal></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
                    sleep_times++;

                    if (sleep_times == MAX_SLEEP_TIMES)
                    {
                        ReturnSpace(node-&gt;buffer, head);

                        pfree(data.data);
                        
                        return false;
                    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></while>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Big enough, send data. */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>DataSize</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>g_SndBatchSize</name> <operator>*</operator> <literal type="number">1024</literal></expr>)</condition>
            <block>{<block_content>    
                <expr_stmt><expr><call><name>DataPumpWakeupSender</name><argument_list>(<argument><expr><name>sndctl</name></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>SetBorder</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>data</name><operator>.</operator><name>len</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Save max tuple_len */</comment>
            <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>tuple_len</name></name> <operator>=</operator> <ternary><condition><expr><name><name>sender</name><operator>-&gt;</operator><name>tuple_len</name></name> <operator>&gt;</operator> <operator>(</operator><name>write_len</name> <operator>-</operator> <literal type="number">5</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>sender</name><operator>-&gt;</operator><name>tuple_len</name></name></expr> </then><else>: <expr><operator>(</operator><name>write_len</name> <operator>-</operator> <literal type="number">5</literal><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* MemoryContextReset will do it */</comment>
        <comment type="line">//pfree(data.data);</comment>

        <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ntuples</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nfast_send</name></name><operator>++</operator></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Not enough space, wakeup sender. */</comment>
        <expr_stmt><expr><call><name>DataPumpWakeupSender</name><argument_list>(<argument><expr><name>sndctl</name></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DataPumpNodeCheck</name><argument_list>(<argument><expr><name>sndctl</name></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ExecFastSendDatarow:node %d status abnormal."</literal></expr></argument>, <argument><expr><name>nodeindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>DataPumpWakeupSender</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>sndctl</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeindex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type> <name>threadid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name>step</name>     <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataPumpThreadControl</name> <modifier>*</modifier></type><name>thread</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataPumpSenderControl</name> <modifier>*</modifier></type><name>sender</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DataPumpNodeControl</name>   <modifier>*</modifier></type><name>node</name>     <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>sender</name>   <operator>=</operator> <operator>(</operator><name>DataPumpSenderControl</name><operator>*</operator><operator>)</operator><name>sndctl</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>DIVIDE_UP</name><argument_list>(<argument><expr><name><name>sender</name><operator>-&gt;</operator><name>node_num</name></name></expr></argument>, <argument><expr><name><name>sender</name><operator>-&gt;</operator><name>thread_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>threadid</name> <operator>=</operator> <name>nodeindex</name> <operator>/</operator> <name>step</name></expr>;</expr_stmt>        
    
    <expr_stmt><expr><name>thread</name> <operator>=</operator> <operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>thread_control</name><index>[<expr><name>threadid</name></expr>]</index></name></expr>;</expr_stmt>
    
    <comment type="block">/* Tell thread to send data. */</comment>
    <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SetBorder</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ThreadSemaUp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>send_sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>create_datapump_socket_dir</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>DIR</name>           <modifier>*</modifier></type><name>temp_dir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>temp_de</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>        <name><name>rm_path</name><index>[<expr><name>MAXPGPATH</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/*
      * create data pump socket dir if not exist,
      * else clean the socket dir
      */</comment>
    <expr_stmt><expr><name>temp_dir</name> <operator>=</operator> <call><name>AllocateDir</name><argument_list>(<argument><expr><name>DATA_PUMP_SOCKET_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>temp_dir</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* does not exist, create dir  */</comment>
        <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><call><name>mkdir</name><argument_list>(<argument><expr><name>DATA_PUMP_SOCKET_DIR</name></expr></argument>, <argument><expr><name>S_IRWXU</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not create dir \"%s\" for data pump, errMsg:%s"</literal></expr></argument>, 
                     <argument><expr><name>DATA_PUMP_SOCKET_DIR</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"could not open dir \"%s\", errMsg:%s"</literal></expr></argument>, <argument><expr><name>DATA_PUMP_SOCKET_DIR</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <return>return;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* exist, remove all the files */</comment>
        <while>while <condition>(<expr><operator>(</operator><name>temp_de</name> <operator>=</operator> <call><name>ReadDir</name><argument_list>(<argument><expr><name>temp_dir</name></expr></argument>, <argument><expr><name>DATA_PUMP_SOCKET_DIR</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>temp_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                <call><name>strcmp</name><argument_list>(<argument><expr><name><name>temp_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><literal type="string">".."</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <continue>continue;</continue></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>rm_path</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rm_path</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>,
                     <argument><expr><name>DATA_PUMP_SOCKET_DIR</name></expr></argument>, <argument><expr><name><name>temp_de</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>rm_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>FreeDir</name><argument_list>(<argument><expr><name>temp_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* build control center to manager data transfering */</comment>
<function><type><specifier>static</specifier> <name>ParallelSendControl</name><modifier>*</modifier></type> 
<name>BuildParallelSendControl</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>sq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>      <name>succeed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>       <name>i</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>     <name>base</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>     <name>step</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>int32</name></type>     <name>end</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>    
    
    <decl_stmt><decl><type><name>ParallelSendControl</name> <modifier>*</modifier></type><name>senderControl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>senderControl</name> <operator>=</operator> <operator>(</operator><name>ParallelSendControl</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelSendControl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* remote node number and sender number */</comment>
    <expr_stmt><expr><name><name>senderControl</name><operator>-&gt;</operator><name>numNodes</name></name>   <operator>=</operator> <name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>senderControl</name><operator>-&gt;</operator><name>numParallelWorkers</name></name> <operator>=</operator> <name><name>sq</name><operator>-&gt;</operator><name>numParallelWorkers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>senderControl</name><operator>-&gt;</operator><name>numThreads</name></name> <operator>=</operator> <ternary><condition><expr><name>g_SndThreadNum</name> <operator>&gt;</operator> <name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr> ?</condition><then> <expr><name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr> </then><else>: <expr><name>g_SndThreadNum</name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/* init remote nodes control */</comment>
    <expr_stmt><expr><name><name>senderControl</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <operator>(</operator><name>ParallelSendNodeControl</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelSendNodeControl</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numNodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ConsState</name>  <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>sq</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>InitParallelSendNodeControl</name><argument_list>(<argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>senderControl</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>numParallelWorkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* init sender control */</comment>
    <expr_stmt><expr><name><name>senderControl</name><operator>-&gt;</operator><name>threadControl</name></name> <operator>=</operator> <operator>(</operator><name>ParallelSendThreadControl</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelSendThreadControl</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numThreads</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>base</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>end</name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>DIVIDE_UP</name><argument_list>(<argument><expr><name><name>senderControl</name><operator>-&gt;</operator><name>numNodes</name></name></expr></argument>, <argument><expr><name><name>senderControl</name><operator>-&gt;</operator><name>numThreads</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numThreads</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>    
    <block>{<block_content>
        <expr_stmt><expr><call><name>InitParallelSendThreadControl</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>senderControl</name><operator>-&gt;</operator><name>threadControl</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>senderControl</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numThreads</name></name>  <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>base</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>end</name>  <operator>=</operator> <name>base</name> <operator>+</operator> <name>step</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>base</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>end</name> <operator>=</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numNodes</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name><name>senderControl</name><operator>-&gt;</operator><name>threadControl</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>node_base</name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>senderControl</name><operator>-&gt;</operator><name>threadControl</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>node_end</name>  <operator>=</operator> <name>end</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>senderControl</name><operator>-&gt;</operator><name>threadControl</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>node_num</name>  <operator>=</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numNodes</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* init convert control */</comment>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>senderControl</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>sqname</name></name></expr></argument>, <argument><expr><name>MAX_CURSOR_LEN</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>senderControl</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>maxConn</name></name> <operator>=</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numNodes</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ThreadSemaInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>senderControl</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>quit_sem</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* init share data structure */</comment>
    <expr_stmt><expr><call><name>InitParallelSendSharedData</name><argument_list>(<argument><expr><name>sq</name></expr></argument>, <argument><expr><name>senderControl</name></expr></argument>, <argument><expr><name><name>senderControl</name><operator>-&gt;</operator><name>numNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* map node buffer to shared buffer */</comment>
    <expr_stmt><expr><call><name>MapNodeDataBuffer</name><argument_list>(<argument><expr><name>senderControl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* map sender's sem to shared sem */</comment>
    <comment type="line">//MapThreadSenderSem(senderControl);</comment>

    <expr_stmt><expr><name><name>senderControl</name><operator>-&gt;</operator><name>status</name></name>                 <operator>=</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>sharedData</name><operator>-&gt;</operator><name>status</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>senderControl</name><operator>-&gt;</operator><name>nodeNoSocket</name></name>           <operator>=</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>sharedData</name><operator>-&gt;</operator><name>nodeNoSocket</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>senderControl</name><operator>-&gt;</operator><name>nodeSendDone</name></name>           <operator>=</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>sharedData</name><operator>-&gt;</operator><name>nodeSendDone</name></name></expr>;</expr_stmt>

    <comment type="block">/* all resources are ready, fire senders up */</comment>
    <expr_stmt><expr><name>succeed</name> <operator>=</operator> <call><name>CreateParallelSenderThread</name><argument_list>(<argument><expr><name>senderControl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>succeed</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>DestoryParallelSendControl</name><argument_list>(<argument><expr><name>senderControl</name></expr></argument>, <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>sender_destroy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>parallelSendControl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><name>DATA_PUMP_PREFIX</name><literal type="string">"start thread failed for %s"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>parallelSendControl</name></name> <operator>=</operator> <name>senderControl</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>execute_error</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <return>return <expr><name>senderControl</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * init parallel worker node control
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> 
<name>InitParallelSendNodeControl</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>nodeId</name></decl></parameter>, <parameter><decl><type><name>ParallelSendNodeControl</name> <modifier>*</modifier></type><name>control</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>numParallelWorkers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>nodeId</name></name>             <operator>=</operator> <name>nodeId</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>sock</name></name>               <operator>=</operator> <name>NO_SOCKET</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>numParallelWorkers</name></name> <operator>=</operator> <name>numParallelWorkers</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>status</name></name>             <operator>=</operator> <name>DataPumpSndStatus_no_socket</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>spinlock_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>control</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>ntuples</name></name>            <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>sleep_count</name></name>        <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>current_buffer</name></name>     <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>send_timies</name></name>        <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* pointer to data buffer in share memory, set later */</comment>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <operator>(</operator><name>ParallelSendDataQueue</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelSendDataQueue</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>numParallelWorkers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
</block_content>}</block></function>

<comment type="block">/* init sender control */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitParallelSendThreadControl</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>threadNum</name></decl></parameter>, <parameter><decl><type><name>ParallelSendThreadControl</name> <modifier>*</modifier></type><name>control</name></decl></parameter>, <parameter><decl><type><name>ParallelSendNodeControl</name> <modifier>*</modifier></type><name>nodes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>threadNum</name></name>        <operator>=</operator> <name>threadNum</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>thread_need_quit</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>nodes</name></name>            <operator>=</operator> <name>nodes</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ThreadSemaInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>control</name><operator>-&gt;</operator><name>quit_sem</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>thread_need_quit</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>thread_running</name></name>   <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* allocate space in share memory for sender and parallel workers to send tuples */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitParallelSendSharedData</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>sq</name></decl></parameter>, <parameter><decl><type><name>ParallelSendControl</name> <modifier>*</modifier></type><name>senderControl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>consMap_len</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>           <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name>           <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>bufferIndex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type> <name>segsize</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>shm_toc</name>     <modifier>*</modifier></type><name>toc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>shm_toc_estimator</name></type> <name>estimator</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSendSharedData</name>  <modifier>*</modifier></type><name>sharedData</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 

    <comment type="block">/* estimate the total space needed in share memory */</comment>
    <expr_stmt><expr><call><name>shm_toc_initialize_estimator</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estimator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estimator</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelSendSharedData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estimator</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estimator</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelSendStatus</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numParallelWorkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estimator</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estimator</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estimator</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estimator</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numNodes</name></name> <operator>*</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numParallelWorkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estimator</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* consmap */</comment>
    <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estimator</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>consMap_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estimator</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    
    <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estimator</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estimator</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    <comment type="block">/* sender sem */</comment>
    shm_toc_estimate_chunk(&amp;estimator, sizeof(ThreadSema) * senderControl-&gt;numThreads);
    shm_toc_estimate_keys(&amp;estimator, 1);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* data buffer */</comment>
    <expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estimator</name></expr></argument>, <argument><expr><name>PW_DATA_QUEUE_SIZE</name> <operator>*</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numNodes</name></name> <operator>*</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numParallelWorkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estimator</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* estimate done, got total space needed in share memory, set up! */</comment>
    <expr_stmt><expr><name>segsize</name> <operator>=</operator> <call><name>shm_toc_estimate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>estimator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dsm_seg</name> <operator>=</operator> <call><name>dsm_create</name><argument_list>(<argument><expr><name>segsize</name></expr></argument>, <argument><expr><name>DSM_CREATE_NULL_IF_MAXSEGMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>dsm_seg</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not create dsm for parallel workers to send tuples."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>toc</name> <operator>=</operator> <call><name>shm_toc_create</name><argument_list>(<argument><expr><name>PARALLEL_MAGIC</name></expr></argument>,
                         <argument><expr><call><name>dsm_segment_address</name><argument_list>(<argument><expr><name>dsm_seg</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name>segsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* init each part of share data */</comment>
    <expr_stmt><expr><name>sharedData</name> <operator>=</operator> <operator>(</operator><name>ParallelSendSharedData</name> <operator>*</operator><operator>)</operator>
                  <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelSendSharedData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_SEND_SHARE_DATA</name></expr></argument>, <argument><expr><name>sharedData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>sharedData</name><operator>-&gt;</operator><name>numExpectedParallelWorkers</name></name> <operator>=</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numParallelWorkers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sharedData</name><operator>-&gt;</operator><name>numNodes</name></name>                   <operator>=</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numNodes</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sharedData</name><operator>-&gt;</operator><name>numSenderThreads</name></name>           <operator>=</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numThreads</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sharedData</name><operator>-&gt;</operator><name>sender_error</name></name>               <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>sharedData</name><operator>-&gt;</operator><name>sender_error</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_SEND_SENDER_ERROR</name></expr></argument>, <argument><expr><name><name>sharedData</name><operator>-&gt;</operator><name>sender_error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>sharedData</name><operator>-&gt;</operator><name>nodeMap</name></name></expr></argument>, <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>nodeMap</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>MAX_NODES_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>sharedData</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>SQUEUE_KEYSIZE</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>sharedData</name><operator>-&gt;</operator><name>status</name></name>  <operator>=</operator> <operator>(</operator><name>ParallelSendStatus</name> <operator>*</operator><operator>)</operator><call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelSendStatus</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numParallelWorkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_SEND_WORKER_STATUS</name></expr></argument>, <argument><expr><name><name>sharedData</name><operator>-&gt;</operator><name>status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numParallelWorkers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>sharedData</name><operator>-&gt;</operator><name>status</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>ParallelSend_None</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>sharedData</name><operator>-&gt;</operator><name>nodeNoSocket</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_SEND_NODE_NO_SOCKET</name></expr></argument>, <argument><expr><name><name>sharedData</name><operator>-&gt;</operator><name>nodeNoSocket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>sharedData</name><operator>-&gt;</operator><name>nodeNoSocket</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>sharedData</name><operator>-&gt;</operator><name>nodeSendDone</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numNodes</name></name> <operator>*</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numParallelWorkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>sharedData</name><operator>-&gt;</operator><name>nodeSendDone</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numNodes</name></name> <operator>*</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numParallelWorkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_SEND_NODE_SEND_DONE</name></expr></argument>, <argument><expr><name><name>sharedData</name><operator>-&gt;</operator><name>nodeSendDone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* cons_map will be filled later */</comment>
    <expr_stmt><expr><name><name>sharedData</name><operator>-&gt;</operator><name>consMap</name></name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>consMap_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_SEND_CONS_MAP</name></expr></argument>, <argument><expr><name><name>sharedData</name><operator>-&gt;</operator><name>consMap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    <comment type="block">/* init sender sem */</comment>
    sharedData-&gt;threadSem = (ThreadSema *)shm_toc_allocate(toc, sizeof(ThreadSema) * senderControl-&gt;numThreads);
    for (i = 0; i &lt; senderControl-&gt;numThreads; i++)
    {
        ThreadSemaInit(&amp;sharedData-&gt;threadSem[i], 0);
    }
    shm_toc_insert(toc, PARALLEL_SEND_SENDER_SEM, sharedData-&gt;threadSem);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* 
      * init each data buffer 
      */</comment>
    <expr_stmt><expr><name><name>sharedData</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <operator>(</operator><name>ParallelSendDataQueue</name> <operator>*</operator><operator>)</operator><call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, 
                          <argument><expr><name>PW_DATA_QUEUE_SIZE</name> <operator>*</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numNodes</name></name> <operator>*</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numParallelWorkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numParallelWorkers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numNodes</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ConsState</name>  <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>sq</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
            
            <expr_stmt><expr><name>bufferIndex</name> <operator>=</operator> <name>i</name> <operator>*</operator> <name><name>senderControl</name><operator>-&gt;</operator><name>numNodes</name></name> <operator>+</operator> <name>j</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator><name>ParallelSendDataQueue</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>sharedData</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name>bufferIndex</name> <operator>*</operator> <name>PW_DATA_QUEUE_SIZE</name><operator>)</operator></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>bufLength</name></name> <operator>=</operator> <name>g_SndThreadBufferSize</name> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>bufHead</name></name>   <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>bufTail</name></name>   <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>bufBorder</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>parallelWorkerNum</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>nodeId</name></name>  <operator>=</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>bufFull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>tuples_get</name></name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>tuples_put</name></name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>fast_send</name></name>   <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>normal_send</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>send_times</name></name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>no_data</name></name>     <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>send_data_len</name></name>  <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>write_data_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>long_tuple</name></name>     <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>wait_free_space</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>status</name></name>         <operator>=</operator> <name>DataPumpSndStatus_no_socket</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>stuck</name></name>          <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>last_send</name></name>      <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ThreadSemaInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buffer</name><operator>-&gt;</operator><name>sendSem</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>spinlock_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buffer</name><operator>-&gt;</operator><name>bufLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_SEND_DATA_BUFFER</name></expr></argument>, <argument><expr><name><name>sharedData</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>parallel_send_seg_handle</name> <operator>=</operator> <call><name>dsm_segment_handle</name><argument_list>(<argument><expr><name>dsm_seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>senderControl</name><operator>-&gt;</operator><name>sharedData</name></name> <operator>=</operator> <name>sharedData</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s: InitParallelSendSharedData successfully."</literal></expr></argument>, <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* 
  * data buffers have been already create in share memory, 
  * we need to point to the corresponding buffer for each node.
  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>MapNodeDataBuffer</name><parameter_list>(<parameter><decl><type><name>ParallelSendControl</name> <modifier>*</modifier></type><name>senderControl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>                           <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name>                           <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numParallelWorkers</name>          <init>= <expr><name><name>senderControl</name><operator>-&gt;</operator><name>numParallelWorkers</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nodeId</name>                      <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numNodes</name>                    <init>= <expr><name><name>senderControl</name><operator>-&gt;</operator><name>numNodes</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSendNodeControl</name> <modifier>*</modifier></type><name>nodes</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSendDataQueue</name>   <modifier>*</modifier></type><name>buffer</name> <init>= <expr><name><name>senderControl</name><operator>-&gt;</operator><name>sharedData</name><operator>-&gt;</operator><name>buffer</name></name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numNodes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>nodes</name>  <operator>=</operator> <operator>&amp;</operator><name><name>senderControl</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nodeId</name> <operator>=</operator> <name><name>nodes</name><operator>-&gt;</operator><name>nodeId</name></name></expr>;</expr_stmt>
        
        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numParallelWorkers</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>nodes</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>ParallelSendDataQueue</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buffer</name> <operator>+</operator> <operator>(</operator><name>j</name> <operator>*</operator> <name>numNodes</name> <operator>+</operator> <name>i</name><operator>)</operator> <operator>*</operator> <name>PW_DATA_QUEUE_SIZE</name><operator>)</operator></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>nodeId</name> <operator>!=</operator> <name><name>nodes</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>nodeId</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"map node buffer %d to wrong shared buffer %d."</literal></expr></argument>, <argument><expr><name>nodeId</name></expr></argument>, <argument><expr><name><name>nodes</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>nodeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * create sender thread to send tuples 
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> 
<name>CreateParallelSenderThread</name><parameter_list>(<parameter><decl><type><name>ParallelSendControl</name> <modifier>*</modifier></type><name>sender</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>succeed</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>i</name>       <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>ret</name>     <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sender</name><operator>-&gt;</operator><name>numThreads</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>        
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>CreateThread</name><argument_list>(<argument><expr><name>ParallelSenderThreadMain</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>threadControl</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>MT_THR_DETACHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>succeed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Set running status for the thread. */</comment>
        <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>threadControl</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>thread_running</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>succeed</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>CreateThread</name><argument_list>(<argument><expr><name>ParallelConvertThreadMain</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>sender</name></expr></argument>, <argument><expr><name>MT_THR_DETACHED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>succeed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>cstatus</name></name> <operator>=</operator> <name>ConvertRunning</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>succeed</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ParallelSendCleanThread</name><argument_list>(<argument><expr><name>sender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>        
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>succeed</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>ParallelConvertThreadMain</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SOCK_PATH_LEN</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>bool</name></type> <name>exit_flag</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nodeid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>consumerIdx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>sockfd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>listen_fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>con_fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSendControl</name> <modifier>*</modifier></type><name>control</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>sock_path</name><index>[<expr><name>SOCK_PATH_LEN</name></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ThreadSigmask</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>control</name> <operator>=</operator> <operator>(</operator><name>ParallelSendControl</name> <operator>*</operator><operator>)</operator><name>arg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>begin_stamp</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sock_path</name></expr></argument>, <argument><expr><name>SOCK_PATH_LEN</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>DATA_PUMP_SOCKET_DIR</name></expr></argument>, <argument><expr><name><name>control</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>sqname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>listen_fd</name> <operator>=</operator> <call><name>convert_listen</name><argument_list>(<argument><expr><name>sock_path</name></expr></argument>, <argument><expr><name><name>control</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>maxConn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if<condition>(<expr><name>listen_fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>errNO</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>cstatus</name></name> <operator>=</operator> <name>ConvertListenError</name></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>    

    <while>while<condition>(<expr><name>true</name></expr>)</condition>
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
        if (control-&gt;convert_control.connect_num == (control-&gt;convert_control.maxConn - 1))
        {
            control-&gt;convert_control.finish_stamp = GetCurrentTimestamp();
        }
        
        if (exit_flag &amp;&amp; control-&gt;convert_control.connect_num == control-&gt;convert_control.maxConn)
        {
            close(listen_fd);
            control-&gt;convert_control.cstatus = ConvertExit;
            unlink(sock_path);
            break;
        }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if_stmt><if>if <condition>(<expr><name>exit_flag</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>finish_stamp</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>listen_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>cstatus</name></name> <operator>=</operator> <name>ConvertExit</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>sock_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name>con_fd</name> <operator>=</operator> <call><name>accept</name><argument_list>(<argument><expr><name>listen_fd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>con_fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>listen_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>errNO</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>cstatus</name></name> <operator>=</operator> <name>ConvertAcceptError</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>sock_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>connect_num</name></name><operator>++</operator></expr>;</expr_stmt>
        
        <comment type="block">/* recv nodeid */</comment>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>recv</name><argument_list>(<argument><expr><name>con_fd</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>nodeid</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>con_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>listen_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>errNO</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>cstatus</name></name> <operator>=</operator> <name>ConvertRecvNodeidError</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>sock_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name>nodeid</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if<condition>(<expr><name>nodeid</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>exit_flag</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>con_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* recv consumer index  */</comment>
        <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>recv</name><argument_list>(<argument><expr><name>con_fd</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>consumerIdx</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">4</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>con_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>listen_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>errNO</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>cstatus</name></name> <operator>=</operator> <name>ConvertRecvNodeindexError</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>sock_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>consumerIdx</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>consumerIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* recv fd */</comment>
        <if_stmt><if>if<condition>(<expr><call><name>convert_recvfds</name><argument_list>(<argument><expr><name>con_fd</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>sockfd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>con_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>listen_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>errNO</name></name>   <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>cstatus</name></name> <operator>=</operator> <name>ConvertRecvSockfdError</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>sock_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* store nodeid, consumerIdx, sockfd */</comment>
        <if_stmt><if>if<condition>(<expr><call><name>SetNodeSocket</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>, <argument><expr><name>sockfd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DataPumpOK</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>con_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>listen_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>cstatus</name></name> <operator>=</operator> <name>ConvertSetSockfdError</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>sock_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>con_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>ThreadSemaUp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>control</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>quit_sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>ParallelSenderThreadMain</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>send_times</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>ParallelSendThreadControl</name> <modifier>*</modifier></type><name>threadControl</name> <init>= <expr><operator>(</operator><name>ParallelSendThreadControl</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ThreadSigmask</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* loop to send data until told to exit */</comment>
    <while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* wait for data coming */</comment>
        <comment type="line">//ThreadSemaDown(threadControl-&gt;threadSem);</comment>
        <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">100L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>send_times</name><operator>++</operator></expr>;</expr_stmt>
        
        <comment type="block">/* send data */</comment>
        <expr_stmt><expr><call><name>ParallelSenderSendData</name><argument_list>(<argument><expr><name>threadControl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* try to send data if any, then exit */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>threadControl</name><operator>-&gt;</operator><name>thread_need_quit</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ParallelSenderSendData</name><argument_list>(<argument><expr><name>threadControl</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name><name>threadControl</name><operator>-&gt;</operator><name>thread_running</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ThreadSemaUp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>threadControl</name><operator>-&gt;</operator><name>quit_sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* sender thread send data to remote nodes */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParallelSenderSendData</name><parameter_list>(<parameter><decl><type><name>ParallelSendThreadControl</name> <modifier>*</modifier></type><name>threadControl</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>last_send</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>stuck</name>                     <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nodeIndex</name>                  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>base</name>                       <init>= <expr><name><name>threadControl</name><operator>-&gt;</operator><name>node_base</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>end</name>                        <init>= <expr><name><name>threadControl</name><operator>-&gt;</operator><name>node_end</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>numNodes</name>                   <init>= <expr><name><name>threadControl</name><operator>-&gt;</operator><name>node_num</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>  <name>nodeStatus</name>              <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSendNodeControl</name> <modifier>*</modifier></type><name>node</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <do>do
    <block>{<block_content>
        <expr_stmt><expr><name>stuck</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>nodeIndex</name> <operator>=</operator> <name>base</name></expr>;</init> <condition><expr><name>nodeIndex</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <name>nodeIndex</name> <operator>&lt;</operator> <name>numNodes</name></expr>;</condition> <incr><expr><name>nodeIndex</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>&amp;</operator><name><name>threadControl</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>nodeIndex</name></expr>]</index></name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>nodeStatus</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>status</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* socket is valid, try to send data */</comment>
            <if_stmt><if>if <condition>(<expr><name>nodeStatus</name> <operator>&gt;=</operator> <name>DataPumpSndStatus_set_socket</name> <operator>&amp;&amp;</operator> <name>nodeStatus</name>  <operator>&lt;=</operator> <name>DataPumpSndStatus_data_sending</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>SendNodeData</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>last_send</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* node socket got stuck, retry later */</comment>
                    <expr_stmt><expr><name>stuck</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>last_send</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>DataPumpSndStatus_error</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>DataPumpSndStatus_done</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block>while<condition>(<expr><name>stuck</name></expr>)</condition>;</do>
</block_content>}</block></function>

<comment type="block">/* send data to node
  * if socket got stuck, return true
  * else return false 
  */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SendNodeData</name><parameter_list>(<parameter><decl><type><name>ParallelSendNodeControl</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>last_send</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>   <name>should_send</name>   <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>   <name>long_tuple</name>    <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>   <name>wait_free_space</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>    <name>i</name>             <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>len</name>           <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>  <name>ret</name>           <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>  <name>reason</name>        <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>data</name>         <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name>current_buffer</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>current_buffer</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>  <name>data_size</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>send_timies</name></name><operator>++</operator></expr>;</expr_stmt>
    
    <comment type="block">/* 
      * each node has n buffers to n parallel workers. we try to send all data in current buffer,
      * then advance to next buffer, this must be more efficient. if got any errors, break out.
      * If socket got stuck, return stuck to upper level.
      */</comment>
    <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name><name>node</name><operator>-&gt;</operator><name>current_buffer</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>buffer</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>DataPumpSndStatus_set_socket</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>buffer</name><operator>-&gt;</operator><name>stuck</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>should_send</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>buffer</name><operator>-&gt;</operator><name>last_send</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>should_send</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>should_send</name> <operator>=</operator> <name>last_send</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>should_send</name></expr>)</condition>
            <block>{<block_content>
				<expr_stmt><expr><name>data_size</name> <operator>=</operator> <call><name>NodeDataSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>long_tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wait_free_space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* 
				 * If wait_free_space is true, sender thread should send data to free buffer space,
				 * else wait until data_size reach to batch threshold.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>wait_free_space</name> <operator>&amp;&amp;</operator> <name>data_size</name> <operator>&lt;</operator> <name>g_SndBatchSize</name> <operator>*</operator> <literal type="number">1024</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>current_buffer</name></name> <operator>=</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>current_buffer</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>node</name><operator>-&gt;</operator><name>numParallelWorkers</name></name></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>current_buffer</name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>current_buffer</name></name></expr>)</condition>
                    <block>{<block_content>
                        <break>break;</break>
                    </block_content>}</block></if></if_stmt>

                    <continue>continue;</continue>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            
            <do>do
            <block>{<block_content>
                <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>GetNodeData</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>long_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>long_tuple</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>stuck</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        <return>return <expr><name>true</name></expr>;</return>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>no_data</name></name><operator>++</operator></expr>;</expr_stmt>
                        <break>break;</break>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>send_times</name></name><operator>++</operator></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
                    if (!buffer-&gt;stuck)
                    {
                        if (data[0] != 'D' &amp;&amp; buffer-&gt;bufTail != 0)
                        {            
                            <comment type="block">/* data content mismatch. we need 'D' here, but got others. */</comment>
                            abort();
                        }
                    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>RawSendNodeData</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                
                    <if_stmt><if>if <condition>(<expr><name>EOF</name> <operator>==</operator> <name>ret</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* We got error. */</comment>
                        <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>status</name></name>  <operator>=</operator> <name>DataPumpSndStatus_error</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>errorno</name></name> <operator>=</operator> <name>reason</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numParallelWorkers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>status</name> <operator>=</operator> <name>DataPumpSndStatus_error</name></expr>;</expr_stmt>
                        </block_content>}</block></for>
                        <return>return <expr><name>false</name></expr>;</return>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>send_data_len</name></name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>
                    
                    <comment type="block">/* increase data offset */</comment>
                    <expr_stmt><expr><call><name>IncNodeDataOff</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
                    
                    <comment type="block">/* Socket got stuck. */</comment>
                    <if_stmt><if>if <condition>(<expr><name>reason</name> <operator>==</operator> <name>EAGAIN</name> <operator>||</operator> <name>reason</name> <operator>==</operator> <name>EWOULDBLOCK</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>ret</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>errorno</name></name> <operator>=</operator> <name>reason</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>stuck</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            <return>return <expr><name>true</name></expr>;</return>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/* get left data length */</comment>
					<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>NodeDataSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>long_tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wait_free_space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>long_tuple</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>stuck</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                            <return>return <expr><name>true</name></expr>;</return>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>while<condition>(<expr><name>len</name></expr>)</condition>;</do>

            <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>stuck</name></name>      <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            
            <if_stmt><if>if <condition>(<expr><name>last_send</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>DataPumpSndStatus_done</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>current_buffer</name></name> <operator>=</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>current_buffer</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>node</name><operator>-&gt;</operator><name>numParallelWorkers</name></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>current_buffer</name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>current_buffer</name></name></expr>)</condition>
        <block>{<block_content>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* send successfully */</comment>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get data pointer, use with the following functions. */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetNodeData</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>uiLen</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>long_tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type> <name>border</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>tail</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>  <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
    <block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>wait_flag</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>NodeDataSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>long_tuple</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wait_flag</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>uiLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>bufLock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>border</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufBorder</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tail</name>   <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufTail</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>long_tuple</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>long_tuple</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>bufLock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>INVALID_BORDER</name> <operator>==</operator> <name>border</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>uiLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* read from tail to border*/</comment>
        <if_stmt><if>if <condition>(<expr><name>border</name> <operator>&gt;=</operator>  <name>tail</name></expr>)</condition>
        <block>{<block_content> 
             <comment type="block">/* Only sender increases m_Tail, no need to lock. */</comment>
             <expr_stmt><expr><operator>*</operator><name>uiLen</name> <operator>=</operator> <name>border</name> <operator>-</operator> <name>tail</name></expr>;</expr_stmt>  
             <expr_stmt><expr><name>data</name>   <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name>tail</name></expr>;</expr_stmt>    
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
             spinlock_lock(&amp;(buf-&gt;bufLock));
             <comment type="block">/* No more data. */</comment>
             if (border == buf-&gt;bufBorder)
              {                 
                buf-&gt;bufBorder = INVALID_BORDER;
              }
             spinlock_unlock(&amp;(buf-&gt;bufLock));
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
             
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>  
            <comment type="block">/* read from tail to end */</comment>
            <expr_stmt><expr><operator>*</operator><name>uiLen</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufLength</name></name> <operator>-</operator> <name>tail</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name>tail</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt> 
        
        <return>return <expr><name>data</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>uiLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Return total data size in buffer */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type> 
<name>NodeDataSize</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>long_tuple</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>wait_free_space</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type> <name>border</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>tail</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>size</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>bufLock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tail</name>   <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufTail</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>border</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufBorder</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>long_tuple</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>long_tuple</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>wait_free_space</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>wait_free_space</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>bufLock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <if_stmt><if>if <condition>(<expr><name>INVALID_BORDER</name> <operator>==</operator> <name>border</name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        
        <if_stmt><if>if <condition>(<expr><name>tail</name> <operator>&lt;=</operator> <name>border</name></expr>)</condition>
        <block>{<block_content>    
            <expr_stmt><expr><name>size</name> <operator>=</operator> <name>border</name> <operator>-</operator> <name>tail</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufLength</name></name> <operator>-</operator> <name>tail</name> <operator>+</operator> <name>border</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        
        <return>return <expr><name>size</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Increate data offset, used after finishing read data from queue. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> 
<name>IncNodeDataOff</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>uiLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>bufLock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>bufTail</name></name> <operator>=</operator>  <operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>bufTail</name></name> <operator>+</operator> <name>uiLen</name><operator>)</operator> <operator>%</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufLength</name></name></expr>;</expr_stmt>                  
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>bufLock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Return data write to the socket. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> 
<name>RawSendNodeData</name><parameter_list>(<parameter><decl><type><name>ParallelSendNodeControl</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>sock</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type> <name>data</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type> <name>reason</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name></type>  <name>offset</name>       <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>  <name>nbytes_write</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>offset</name> <operator>&lt;</operator> <name>len</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>nbytes_write</name> <operator>=</operator> <call><name>send</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>offset</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>nbytes_write</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>
            <block>{<block_content>
                <continue>continue;</continue>        <comment type="block">/* Ok if we were interrupted */</comment>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Ok if no data writable without blocking, and the socket is in
             * non-blocking mode.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EAGAIN</name> <operator>||</operator>
                <name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name></expr>)</condition>
            <block>{<block_content>                
                <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sleep_count</name></name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>reason</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
                <return>return <expr><name>offset</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><operator>*</operator><name>reason</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
            <return>return <expr><name>EOF</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>nbytes_write</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    
    <return>return <expr><name>offset</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32</name></type>  
<name>SetNodeSocket</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>sndctl</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeindex</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeId</name></decl></parameter>,  <parameter><decl><type><name>int32</name></type> <name>socket</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParallelSendNodeControl</name>  <modifier>*</modifier></type><name>node</name>     <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSendControl</name>   <modifier>*</modifier></type><name>sender</name>   <init>= <expr><operator>(</operator><name>ParallelSendControl</name> <operator>*</operator><operator>)</operator><name>sndctl</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>nodeindex</name> <operator>&gt;=</operator> <name><name>sender</name><operator>-&gt;</operator><name>numNodes</name></name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>DataPumpSndError_node_error</name></expr>;</return>
    </block_content>}</block></if></if_stmt>


    <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>nodeindex</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nodeId</name></name> <operator>!=</operator> <name>nodeId</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>DataPumpSndError_node_error</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Use lock to check status and socket */</comment>
    <expr_stmt><expr><call><name>socket_set_nonblocking</name><argument_list>(<argument><expr><name>socket</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>NO_SOCKET</name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>sock</name></name> <operator>&amp;&amp;</operator> <name>DataPumpSndStatus_no_socket</name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sock</name></name>   <operator>=</operator> <name>socket</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>DataPumpSndStatus_set_socket</name></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sender</name><operator>-&gt;</operator><name>numParallelWorkers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>status</name> <operator>=</operator> <name>DataPumpSndStatus_set_socket</name></expr>;</expr_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>DataPumpOK</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>DataPumpSndError_bad_status</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> 
<name>ParallelSendCleanThread</name><parameter_list>(<parameter><decl><type><name>ParallelSendControl</name> <modifier>*</modifier></type><name>sender</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>                      <name>ret</name>       <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type>                       <name>threadid</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSendThreadControl</name> <modifier>*</modifier></type><name>thread</name>   <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>                      <modifier>*</modifier></type><name>send_quit</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sender</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>send_quit</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>sender</name><operator>-&gt;</operator><name>numThreads</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>sender</name><operator>-&gt;</operator><name>threadControl</name></name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>threadid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>threadid</name> <operator>&lt;</operator> <name><name>sender</name><operator>-&gt;</operator><name>numThreads</name></name></expr>;</condition> <incr><expr><name>threadid</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>thread</name> <operator>=</operator> <operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>threadControl</name><index>[<expr><name>threadid</name></expr>]</index></name></expr>;</expr_stmt>
            <comment type="block">/* Set quit flag and tell sender to quit. */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>thread</name><operator>-&gt;</operator><name>thread_running</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>thread</name><operator>-&gt;</operator><name>thread_need_quit</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ThreadSemaUp</name><argument_list>(<argument><expr><name><name>thread</name><operator>-&gt;</operator><name>threadSem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

                <expr_stmt><expr><name><name>send_quit</name><index>[<expr><name>threadid</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s: tell thread %d to exit."</literal></expr></argument>, <argument><expr><name><name>sender</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>sqname</name></name></expr></argument>, <argument><expr><name>threadid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <for>for <control>(<init><expr><name>threadid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>threadid</name> <operator>&lt;</operator> <name><name>sender</name><operator>-&gt;</operator><name>numThreads</name></name></expr>;</condition> <incr><expr><name>threadid</name> <operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>send_quit</name><index>[<expr><name>threadid</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>thread</name> <operator>=</operator> <operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>threadControl</name><index>[<expr><name>threadid</name></expr>]</index></name></expr>;</expr_stmt>
                <comment type="block">/* Wait for sender to quit. */</comment>        
                <expr_stmt><expr><call><name>ThreadSemaDown</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thread</name><operator>-&gt;</operator><name>quit_sem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>thread</name><operator>-&gt;</operator><name>thread_running</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s:thread %d done, but status is running."</literal></expr></argument>, <argument><expr><name><name>sender</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>sqname</name></name></expr></argument>,
                              <argument><expr><name>threadid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s:thread %d exit."</literal></expr></argument>, <argument><expr><name><name>sender</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>sqname</name></name></expr></argument>, <argument><expr><name>threadid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>send_quit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ConvertDone</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>convertControl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> 
<name>DestoryParallelSendControl</name> <parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>sndctl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodeid</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>  <name>i</name>         <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSendControl</name> <modifier>*</modifier></type><name>sender</name>   <init>= <expr><operator>(</operator><name>ParallelSendControl</name><operator>*</operator><operator>)</operator><name>sndctl</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>sndctl</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>sender</name><operator>-&gt;</operator><name>threadControl</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>sender</name><operator>-&gt;</operator><name>threadControl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>threadControl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>sender</name><operator>-&gt;</operator><name>nodes</name></name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sender</name><operator>-&gt;</operator><name>numNodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>        
            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>sender</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>sender</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sock</name> <operator>!=</operator> <name>NO_SOCKET</name> <operator>&amp;&amp;</operator> <name><name>sender</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeId</name> <operator>!=</operator> <name>nodeid</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>sender</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sock</name> <operator>=</operator> <name>NO_SOCKET</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>sender</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>dsm_seg</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>dsm_detach</name><argument_list>(<argument><expr><name>dsm_seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dsm_seg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s: DestoryParallelSendControl."</literal></expr></argument>, <argument><expr><name><name>sender</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>sqname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>needParallelSend</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>squeue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>squeue</name><operator>-&gt;</operator><name>parallelWorkerSendTuple</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> 
<name>SetLocatorInfo</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>squeue</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>consMap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>distributionType</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>keytype</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>distributionKey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParallelSendControl</name> <modifier>*</modifier></type><name>sender</name> <init>= <expr><name><name>squeue</name><operator>-&gt;</operator><name>parallelSendControl</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>sharedData</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>sharedData</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>=</operator> <name>distributionType</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>sharedData</name><operator>-&gt;</operator><name>keytype</name></name> <operator>=</operator> <name>keytype</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>sharedData</name><operator>-&gt;</operator><name>distributionKey</name></name> <operator>=</operator> <name>distributionKey</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>sender</name><operator>-&gt;</operator><name>sharedData</name><operator>-&gt;</operator><name>consMap</name></name></expr></argument>, <argument><expr><name>consMap</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>dsm_handle</name></type>
<name>GetParallelSendSegHandle</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>parallel_send_seg_handle</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* set up data queue between parallel workers and senders */</comment>
<function><type><name>DestReceiver</name> <modifier>*</modifier></type>
<name>GetParallelSendReceiver</name><parameter_list>(<parameter><decl><type><name>dsm_handle</name></type> <name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name>                          <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name>                               <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>seg</name>                    <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>shm_toc</name> <modifier>*</modifier></type><name>toc</name>                        <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSendDestReceiver</name> <modifier>*</modifier></type><name>receiver</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>ParallelSendSharedData</name>    <modifier>*</modifier></type><name>sharedData</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>ParallelSendSharedData</name>    <modifier>*</modifier></type><name>sData</name>      <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSendDataQueue</name>   <modifier>*</modifier></type><name>head</name>       <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>seg</name> <operator>=</operator> <call><name>dsm_attach</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>seg</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not map dynamic shared memory segment in GetParallelSendReceiver"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    
    <expr_stmt><expr><name>toc</name> <operator>=</operator> <call><name>shm_toc_attach</name><argument_list>(<argument><expr><name>PARALLEL_MAGIC</name></expr></argument>, <argument><expr><call><name>dsm_segment_address</name><argument_list>(<argument><expr><name>seg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>toc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid magic number in dynamic shared memory segment in GetParallelSendReceiver"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    
    <expr_stmt><expr><name>receiver</name>          <operator>=</operator> <operator>(</operator><name>ParallelSendDestReceiver</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelSendDestReceiver</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>control</name></name> <operator>=</operator> <operator>(</operator><name>ParallelWorkerControl</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelWorkerControl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>seg</name></name> <operator>=</operator> <name>seg</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>dsm_seg</name> <operator>=</operator> <name>seg</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>mycontext</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>tmpcxt</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                                             <argument><expr><literal type="string">"ParallelSendReceiver temp memoryContext"</literal></expr></argument>,
                                             <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>sData</name>               <operator>=</operator> <operator>(</operator><name>ParallelSendSharedData</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelSendSharedData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>sharedData</name>          <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_SEND_SHARE_DATA</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>sData</name><operator>-&gt;</operator><name>numExpectedParallelWorkers</name></name> <operator>=</operator> <name><name>sharedData</name><operator>-&gt;</operator><name>numExpectedParallelWorkers</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sData</name><operator>-&gt;</operator><name>numNodes</name></name>                   <operator>=</operator> <name><name>sharedData</name><operator>-&gt;</operator><name>numNodes</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sData</name><operator>-&gt;</operator><name>numSenderThreads</name></name>           <operator>=</operator> <name><name>sharedData</name><operator>-&gt;</operator><name>numSenderThreads</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>sData</name><operator>-&gt;</operator><name>consMap</name></name>      <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_SEND_CONS_MAP</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>sData</name><operator>-&gt;</operator><name>distributionKey</name></name>  <operator>=</operator> <name><name>sharedData</name><operator>-&gt;</operator><name>distributionKey</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sData</name><operator>-&gt;</operator><name>distributionType</name></name> <operator>=</operator> <name><name>sharedData</name><operator>-&gt;</operator><name>distributionType</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sData</name><operator>-&gt;</operator><name>keytype</name></name>          <operator>=</operator> <name><name>sharedData</name><operator>-&gt;</operator><name>keytype</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sData</name><operator>-&gt;</operator><name>len</name></name>              <operator>=</operator> <name><name>sharedData</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>sData</name><operator>-&gt;</operator><name>nodeMap</name></name></expr></argument>, <argument><expr><name><name>sharedData</name><operator>-&gt;</operator><name>nodeMap</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>MAX_NODES_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>sData</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>sharedData</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>SQUEUE_KEYSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>squeue</name></name> <operator>=</operator> <operator>(</operator><name>SharedQueue</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>SharedQueues</name></expr></argument>, <argument><expr><name><name>sharedData</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Parallel Worker %d Shared queue %s not found"</literal></expr></argument>, <argument><expr><name>ParallelWorkerNumber</name></expr></argument>, <argument><expr><name><name>sharedData</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
    sharedData-&gt;threadSem          = shm_toc_lookup(toc, PARALLEL_SEND_SENDER_SEM, false);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>sData</name><operator>-&gt;</operator><name>status</name></name>                 <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_SEND_WORKER_STATUS</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sData</name><operator>-&gt;</operator><name>status</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator> <name>ParallelSend_Init</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>senderstatus</name> <operator>=</operator> <name><name>sData</name><operator>-&gt;</operator><name>status</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>sData</name><operator>-&gt;</operator><name>nodeNoSocket</name></name>       <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_SEND_NODE_NO_SOCKET</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sData</name><operator>-&gt;</operator><name>nodeSendDone</name></name>       <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_SEND_NODE_SEND_DONE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sData</name><operator>-&gt;</operator><name>sender_error</name></name>       <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_SEND_SENDER_ERROR</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>parallelWorkerNum</name></name> <operator>=</operator> <name>ParallelWorkerNumber</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>numNodes</name></name>   <operator>=</operator> <name><name>sData</name><operator>-&gt;</operator><name>numNodes</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>buffer</name></name>     <operator>=</operator> <operator>(</operator><name>ParallelSendDataQueue</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ParallelSendDataQueue</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>sData</name><operator>-&gt;</operator><name>numNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">//receiver-&gt;control-&gt;threadSem  = sharedData-&gt;threadSem;</comment>
    <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>numThreads</name></name> <operator>=</operator> <name><name>sData</name><operator>-&gt;</operator><name>numSenderThreads</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>sData</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_SEND_DATA_BUFFER</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>head</name>   <operator>=</operator> <operator>(</operator><name>ParallelSendDataQueue</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>sData</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name><name>sData</name><operator>-&gt;</operator><name>numNodes</name></name> <operator>*</operator> <name>ParallelWorkerNumber</name> <operator>*</operator> <name>PW_DATA_QUEUE_SIZE</name><operator>)</operator></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sData</name><operator>-&gt;</operator><name>numNodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>control</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>ParallelSendDataQueue</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>head</name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>PW_DATA_QUEUE_SIZE</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>tstores</name></name> <operator>=</operator> <operator>(</operator><name>Tuplestorestate</name> <operator>*</operator><operator>*</operator><operator>)</operator>
                <call><name>palloc0</name><argument_list>(<argument><expr><name><name>sData</name><operator>-&gt;</operator><name>numNodes</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Tuplestorestate</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>locator</name></name> <operator>=</operator> <call><name>createLocator</name><argument_list>(<argument><expr><name><name>sData</name><operator>-&gt;</operator><name>distributionType</name></name></expr></argument>,
                                    <argument><expr><name>RELATION_ACCESS_INSERT</name></expr></argument>,
                                    <argument><expr><name><name>sData</name><operator>-&gt;</operator><name>keytype</name></name></expr></argument>,
                                    <argument><expr><name>LOCATOR_LIST_INT</name></expr></argument>,
                                    <argument><expr><name><name>sData</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,
                                    <argument><expr><name><name>sData</name><operator>-&gt;</operator><name>consMap</name></name></expr></argument>,
                                    <argument><expr><name>NULL</name></expr></argument>,
                                    <argument><expr><name>false</name></expr></argument>,
                                    <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidAttrNumber</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>sharedData</name></name>      <operator>=</operator> <name>sData</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>distKey</name></name>         <operator>=</operator> <name><name>sData</name><operator>-&gt;</operator><name>distributionKey</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>receiveSlot</name></name> <operator>=</operator> <name>ParallelSendReceiveSlot</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rStartup</name></name>    <operator>=</operator> <name>ParallelSendStartupReceiver</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rShutdown</name></name>   <operator>=</operator> <name>ParallelSendShutdownReceiver</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>rDestroy</name></name>    <operator>=</operator> <name>ParallelSendDestroyReceiver</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>pub</name><operator>.</operator><name>mydest</name></name>      <operator>=</operator> <name>DestParallelSend</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s: worker %d init parallel sendReceiver."</literal></expr></argument>, <argument><expr><name><name>sData</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>ParallelWorkerNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><operator>(</operator><name>DestReceiver</name> <operator>*</operator><operator>)</operator> <name>receiver</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ParallelSendReceiveSlot</name><parameter_list>(<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>ncount</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name>         <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSendDestReceiver</name> <modifier>*</modifier></type><name>receiver</name> <init>= <expr><operator>(</operator><name>ParallelSendDestReceiver</name> <operator>*</operator><operator>)</operator><name>self</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelWorkerControl</name> <modifier>*</modifier></type><name>control</name>     <init>= <expr><name><name>receiver</name><operator>-&gt;</operator><name>control</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSendSharedData</name> <modifier>*</modifier></type><name>sharedData</name> <init>= <expr><name><name>receiver</name><operator>-&gt;</operator><name>sharedData</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>receiver</name><operator>-&gt;</operator><name>distKey</name></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>isnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>receiver</name><operator>-&gt;</operator><name>distKey</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <expr_stmt><expr><name>ncount</name> <operator>=</operator> <call><name>GET_NODES</name><argument_list>(<argument><expr><name><name>receiver</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>ncount</name> <operator>=</operator> <call><name>GET_NODES</name><argument_list>(<argument><expr><name><name>receiver</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>getLocatorResults</name><argument_list>(<argument><expr><name><name>receiver</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Dispatch the tuple */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TimestampTz</name></type> <name>begin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TimestampTz</name></type> <name>end</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>consumerIdx</name> <init>= <expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>savecontext</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>getLocatorDisType</name><argument_list>(<argument><expr><name><name>receiver</name><operator>-&gt;</operator><name>locator</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'S'</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>nodeid</name> <init>= <expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>consumerIdx</name> <operator>=</operator> <name><name>sharedData</name><operator>-&gt;</operator><name>nodeMap</name><index>[<expr><name>nodeid</name></expr>]</index></name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>consumerIdx</name> <operator>==</operator> <name>SQ_CONS_INIT</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Invalid nodeid %d in ParallelSendReceiveSlot."</literal></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>consumerIdx</name> <operator>=</operator> <name><name>result</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>consumerIdx</name> <operator>==</operator> <name>SQ_CONS_NONE</name></expr>)</condition>
        <block>{<block_content>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>savecontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>receiver</name><operator>-&gt;</operator><name>mycontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>begin</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>sharedData</name><operator>-&gt;</operator><name>sender_error</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>DestroyParallelSendReceiver</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not send data to node buffer."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>    
            
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>receiver</name><operator>-&gt;</operator><name>tupledesc</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>tupledesc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>control</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>-&gt;</operator><name>parallelWorkerNum</name> <operator>!=</operator> <name>ParallelWorkerNumber</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"parallel send worker mismatch, buffer worker %d, current worker %d."</literal></expr></argument>,
                         <argument><expr><name><name>control</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>-&gt;</operator><name>parallelWorkerNum</name></expr></argument>, <argument><expr><name>ParallelWorkerNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><call><name>SendNodeDataRemote</name><argument_list>(<argument><expr><name><name>receiver</name><operator>-&gt;</operator><name>squeue</name></name></expr></argument>, <argument><expr><name>control</name></expr></argument>, <argument><expr><name><name>control</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name>consumerIdx</name></expr>]</index></name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, 
                           <argument><expr><operator>&amp;</operator><name><name>receiver</name><operator>-&gt;</operator><name>tstores</name><index>[<expr><name>consumerIdx</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>receiver</name><operator>-&gt;</operator><name>tmpcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>send_tuples</name></name><operator>++</operator></expr>;</expr_stmt>
        
        <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>end</name>   <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>send_total_time</name></name> <operator>+=</operator> <operator>(</operator><name>end</name> <operator>-</operator> <name>begin</name><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParallelSendStartupReceiver</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>operation</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>typeinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* do nothing */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParallelSendShutdownReceiver</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>  <modifier>*</modifier></type><name>send_done</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>   <name>numDone</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>savecontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSendDestReceiver</name> <modifier>*</modifier></type><name>receiver</name> <init>= <expr><operator>(</operator><name>ParallelSendDestReceiver</name> <operator>*</operator><operator>)</operator><name>self</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSendSharedData</name> <modifier>*</modifier></type><name>sharedData</name> <init>= <expr><name><name>receiver</name><operator>-&gt;</operator><name>sharedData</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelWorkerControl</name> <modifier>*</modifier></type><name>control</name>     <init>= <expr><name><name>receiver</name><operator>-&gt;</operator><name>control</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type> <name>tmpslot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SharedQueue</name></type> <name>squeue</name> <init>= <expr><name><name>receiver</name><operator>-&gt;</operator><name>squeue</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>sharedData</name><operator>-&gt;</operator><name>status</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator> <name>ParallelSend_ExecDone</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s:parallel worker %d, exec done!"</literal></expr></argument>, <argument><expr><name><name>sharedData</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument> , <argument><expr><name>ParallelWorkerNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name><name>receiver</name><operator>-&gt;</operator><name>send_tuples</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>savecontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>receiver</name><operator>-&gt;</operator><name>mycontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>tmpslot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name><name>receiver</name><operator>-&gt;</operator><name>tupledesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>send_done</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>sharedData</name><operator>-&gt;</operator><name>numNodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while<condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>sharedData</name><operator>-&gt;</operator><name>numNodes</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>node_index</name> <init>= <expr><name>ParallelWorkerNumber</name> <operator>*</operator> <name><name>sharedData</name><operator>-&gt;</operator><name>numNodes</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ConsState</name>  <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>squeue</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>
                
            <if_stmt><if>if <condition>(<expr><name><name>sharedData</name><operator>-&gt;</operator><name>sender_error</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <call><name>ParallelError</name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>DestroyParallelSendReceiver</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not send data to node buffer."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
                    
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>send_done</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sharedData</name><operator>-&gt;</operator><name>nodeNoSocket</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>control</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>status</name> <operator>==</operator> <name>DataPumpSndStatus_set_socket</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>cs_done</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>send_fd</name></name><operator>)</operator> <operator>||</operator>
                            <operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name> <operator>==</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name> <operator>&amp;&amp;</operator> <name><name>squeue</name><operator>-&gt;</operator><name>producer_done</name></name><operator>)</operator></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>send_done</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <expr_stmt><expr><name><name>send_done</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PumpTupleStoreToBuffer</name><argument_list>(<argument><expr><name>control</name></expr></argument>, <argument><expr><name><name>control</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>tmpslot</name></expr></argument>, <argument><expr><name><name>receiver</name><operator>-&gt;</operator><name>tstores</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>receiver</name><operator>-&gt;</operator><name>mycontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                        
                        <if_stmt><if>if <condition>(<expr><name><name>send_done</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><name>numDone</name><operator>++</operator></expr>;</expr_stmt>

                            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>last_send</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                            <expr_stmt><expr><name><name>sharedData</name><operator>-&gt;</operator><name>nodeSendDone</name><index>[<expr><name>node_index</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name><name>send_done</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>numDone</name><operator>++</operator></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>sharedData</name><operator>-&gt;</operator><name>nodeSendDone</name><index>[<expr><name>node_index</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>numDone</name> <operator>==</operator> <name><name>sharedData</name><operator>-&gt;</operator><name>numNodes</name></name></expr>)</condition>
            <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>sharedData</name><operator>-&gt;</operator><name>numNodes</name></name></expr>;</expr_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tmpslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>send_done</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sharedData</name><operator>-&gt;</operator><name>numNodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>node_index</name> <init>= <expr><name>ParallelWorkerNumber</name> <operator>*</operator> <name><name>sharedData</name><operator>-&gt;</operator><name>numNodes</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>sharedData</name><operator>-&gt;</operator><name>nodeSendDone</name><index>[<expr><name>node_index</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>sharedData</name><operator>-&gt;</operator><name>status</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator> <name>ParallelSend_SendDone</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s:parallel worker %d, send done!"</literal></expr></argument>, <argument><expr><name><name>sharedData</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument> , <argument><expr><name>ParallelWorkerNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParallelSendDestroyReceiver</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParallelSendDestReceiver</name> <modifier>*</modifier></type><name>receiver</name> <init>= <expr><operator>(</operator><name>ParallelSendDestReceiver</name> <operator>*</operator><operator>)</operator><name>self</name></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>enable_statistic</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"ParallelSend: send_tuples:%lu, send_total_time:%ld, avg_time:%lf."</literal></expr></argument>,
                   <argument><expr><name><name>receiver</name><operator>-&gt;</operator><name>send_tuples</name></name></expr></argument>, <argument><expr><name><name>receiver</name><operator>-&gt;</operator><name>send_total_time</name></name></expr></argument>,
                   <argument><expr><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name><name>receiver</name><operator>-&gt;</operator><name>send_total_time</name></name><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name><name>receiver</name><operator>-&gt;</operator><name>send_tuples</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><call><name>DestroyParallelSendReceiver</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ParallelDsmDetach</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendNodeDataRemote</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>squeue</name></decl></parameter>, <parameter><decl><type><name>ParallelWorkerControl</name> <modifier>*</modifier></type><name>control</name></decl></parameter>, <parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>consumerIdx</name></decl></parameter>,
                           <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier><modifier>*</modifier></type><name>tuplestore</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>tmpcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>ret</name>              <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RemoteDataRow</name></type> <name>datarow</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ConsState</name>  <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>squeue</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>consumerIdx</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <comment type="block">/* all consumers done, do not produce data anymore */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>squeue</name><operator>-&gt;</operator><name>nConsumer_done</name></name> <operator>==</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>Executor_done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"SendNodeDataRemote:squeue %s parallelwoker %d pid %d all consumers done."</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>ParallelWorkerNumber</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* consumer do not need data anymore */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name> <operator>==</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_pid</name></name> <operator>&amp;&amp;</operator> <name><name>squeue</name><operator>-&gt;</operator><name>producer_done</name></name><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name> <operator>!=</operator> <name><name>squeue</name><operator>-&gt;</operator><name>sq_pid</name></name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_done</name></name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>


    <if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>DataPumpSndStatus_set_socket</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>datarow</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ParallelSendDataRow</name><argument_list>(<argument><expr><name>control</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>datarow</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>, <argument><expr><name><name>datarow</name><operator>-&gt;</operator><name>msglen</name></name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition>
            <block>{<block_content>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Try fast send. */</comment>
            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ParallelFastSendDatarow</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>control</name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>, <argument><expr><name>tmpcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition>
            <block>{<block_content>
                <return>return;</return>
            </block_content>}</block></if></if_stmt>    
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>DataPumpSndStatus_error</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Error ocurred or the node is not ready at present,  store the tuple into the tuplestore. */</comment>
    <comment type="block">/* Create tuplestore if does not exist.*/</comment>
    <if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <operator>*</operator><name>tuplestore</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name>            <name>ptrno</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type>         <name><name>storename</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>


        <expr_stmt><expr><operator>*</operator><name>tuplestore</name> <operator>=</operator> <call><name>tuplestore_begin_datarow</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name> <operator>/</operator> <name>NumDataNodes</name></expr></argument>, <argument><expr><name>tmpcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* We need is to be able to remember/restore the read position */</comment>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>storename</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="string">"worker %d node %d"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>parallelWorkerNum</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>nodeId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>tuplestore_collect_stat</name><argument_list>(<argument><expr><operator>*</operator><name>tuplestore</name></expr></argument>, <argument><expr><name>storename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * Allocate a second read pointer to read from the store. We know
         * it must have index 1, so needn't store that.
         */</comment>
        <expr_stmt><expr><name>ptrno</name> <operator>=</operator> <call><name>tuplestore_alloc_read_pointer</name><argument_list>(<argument><expr><operator>*</operator><name>tuplestore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ptrno</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>in_data_pump</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    
    <comment type="block">/* Append the slot to the store... */</comment>
    <expr_stmt><expr><call><name>tuplestore_puttupleslot</name><argument_list>(<argument><expr><operator>*</operator><name>tuplestore</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>in_data_pump</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>tuples_put</name></name><operator>++</operator></expr>;</expr_stmt>
    
    <return>return;</return>
</block_content>}</block></function>

<comment type="block">/* 
  * directly put data into data buffer, no matter what happened except that buffer is full,
  * then put data into tuplestore.
  */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ParallelSendDataRow</name><parameter_list>(<parameter><decl><type><name>ParallelWorkerControl</name> <modifier>*</modifier></type><name>control</name></decl></parameter>, <parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>consumerIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>                  <name>long_tuple</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                   <name>cursor</name>     <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>                   <name>tuple_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        
    <expr_stmt><expr><name>tuple_len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* msg type 'D' */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>tuple_len</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>tuple_len</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>tuple_len</name> <operator>&gt;=</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufLength</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>long_tuple</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* no space left, */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>BufferFreeSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <operator>(</operator><name>uint32</name><operator>)</operator><name>tuple_len</name></expr>)</condition>
    <block>{<block_content>
		<comment type="block">/* Set flag to notice sender thread send data without waiting batch size threshold */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>long_tuple</name></expr>)</condition>
        <block>{<block_content>
			<expr_stmt><expr><call><name>SetBufferBorderAndWaitFlag</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">50L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>long_tuple</name></expr>)</condition>
    <block>{<block_content>        
        <comment type="block">/* MsgType */</comment>
        <expr_stmt><expr><call><name>PutNodeData</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"D"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Data length */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>uint32</name></type>        <name>n32</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PutNodeData</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Data */</comment>
        <expr_stmt><expr><call><name>PutNodeData</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SetBufferBorderAndWaitFlag</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>uint32</name></type> <name>header_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>data_len</name> <init>= <expr><call><name>BufferFreeSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>header_len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        
        <if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>header_len</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/* put message 'D' */</comment>
        <while>while <condition>(<expr><name>data_len</name> <operator>&lt;</operator> <name>header_len</name></expr>)</condition>
        <block>{<block_content>
			<expr_stmt><expr><call><name>SetBufferBorderAndWaitFlag</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">100L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>data_len</name> <operator>=</operator> <call><name>BufferFreeSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>DataPumpSndStatus_error</name></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>
        
        <expr_stmt><expr><call><name>PutNodeData</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"D"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Data length */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>uint32</name></type>        <name>n32</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>PutNodeData</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>cursor</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        
        <while>while <condition>(<expr><name>len</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>data_len</name> <operator>=</operator> <call><name>BufferFreeSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>data_len</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>write_len</name> <init>= <expr><ternary><condition><expr><name>len</name> <operator>&gt;</operator> <name>data_len</name></expr> ?</condition><then> <expr><name>data_len</name></expr> </then><else>: <expr><name>len</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
                
                <expr_stmt><expr><call><name>PutNodeData</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name>cursor</name></expr></argument>, <argument><expr><name>write_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>cursor</name> <operator>=</operator> <name>cursor</name> <operator>+</operator> <name>write_len</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>len</name> <operator>=</operator> <name>len</name> <operator>-</operator> <name>write_len</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
				<expr_stmt><expr><call><name>SetBufferBorderAndWaitFlag</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">100L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>DataPumpSndStatus_error</name></expr>)</condition>
                <block>{<block_content>
                    <return>return <expr><name>true</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>

		<expr_stmt><expr><call><name>SetBufferBorderAndWaitFlag</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>ntuples</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>normal_send</name></name><operator>++</operator></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32</name></type> 
<name>BufferFreeSpace</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type> <name>head</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>tail</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>len</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>bufLock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>head</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufHead</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tail</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufTail</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>bufLock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>tail</name> <operator>&lt;=</operator> <name>head</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <name>tail</name> <operator>+</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufLength</name></name> <operator>-</operator> <name>head</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <name>tail</name> <operator>-</operator> <name>head</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <return>return <expr><name>len</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetBufferBorderAndWaitFlag</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>long_tuple</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wait_free_space</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>bufLock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>bufBorder</name></name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufHead</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>long_tuple</name></name> <operator>=</operator> <name>long_tuple</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>wait_free_space</name></name> <operator>=</operator> <name>wait_free_space</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>bufLock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Send data into buffer */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> 
<name>PutNodeData</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>    
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>  <name>bufferLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>  <name>needLen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>  <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>needLen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>write_data_len</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
    
    <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>            
        <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>GetBufferWriteOff</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bufferLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>bufferLen</name> <operator>&gt;=</operator> <name>needLen</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>needLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>IncBufferWriteOff</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>needLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>bufferLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>IncBufferWriteOff</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufferLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>needLen</name> <operator>-=</operator> <name>bufferLen</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>offset</name>  <operator>+=</operator> <name>bufferLen</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetBufferWriteOff</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>uiLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type> <name>head</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>tail</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>  <modifier>*</modifier></type><name>ptr</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>BufferFreeSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>uiLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>bufLock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>head</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufHead</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tail</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufTail</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>bufLock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <if_stmt><if>if <condition>(<expr><name>head</name> <operator>&gt;=</operator>  <name>tail</name></expr>)</condition>
        <block>{<block_content> 
           <comment type="block">/* tail is the beginning of the queue. */</comment>
           <if_stmt><if>if <condition>(<expr><name>tail</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
           <block>{<block_content>
               
               <expr_stmt><expr><operator>*</operator><name>uiLen</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufLength</name></name><operator>-</operator> <name>head</name></expr>;</expr_stmt>                 
           </block_content>}</block></if>
           <else>else
           <block>{<block_content>
               <comment type="block">/* Reserved one byte as flag. */</comment>
               <expr_stmt><expr><operator>*</operator><name>uiLen</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufLength</name></name><operator>-</operator> <name>head</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>                 
           </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>               
           <comment type="block">/* Reserved one byte as flag. */</comment>
           <expr_stmt><expr><operator>*</operator><name>uiLen</name> <operator>=</operator> <name>tail</name> <operator>-</operator> <name>head</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>        
        <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name>head</name></expr>;</expr_stmt>
        <return>return <expr><name>ptr</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>uiLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></else></if_stmt>    
</block_content>}</block></function>

<comment type="block">/* Used to increase the write pointer after write some data. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> 
<name>IncBufferWriteOff</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>uiLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>bufLock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
           <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>bufHead</name></name> <operator>+=</operator> <name>uiLen</name></expr>;</expr_stmt>
           <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>bufHead</name></name> <operator>=</operator>  <name><name>buf</name><operator>-&gt;</operator><name>bufHead</name></name> <operator>%</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufLength</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>bufLock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ParallelFastSendDatarow</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ctl</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nodeindex</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>tmpcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_RESERVE_STEP</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SLEEP_TIMES</name></cpp:macro> <cpp:value>50</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>uint32</name></type>          <name>free_size</name>       <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint16</name></type>             <name>n16</name>             <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type>            <name>tuple_len</name>       <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>             <name>i</name>                <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelWorkerControl</name> <modifier>*</modifier></type><name>control</name>  <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>         <name>tdesc</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>head</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name> <name>tail</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type>        <name>data</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>control</name>  <operator>=</operator> <operator>(</operator><name>ParallelWorkerControl</name><operator>*</operator><operator>)</operator><name>ctl</name></expr>;</expr_stmt>
    
    <comment type="block">/* Get tuple length. */</comment>
    <expr_stmt><expr><name>tuple_len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* msg type 'D' */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>tuple_len</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name><name>control</name><operator>-&gt;</operator><name>tupleLen</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>tupleLen</name></name> <operator>=</operator> <name>DEFAULT_RESERVE_STEP</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>tuple_len</name> <operator>+=</operator> <name><name>control</name><operator>-&gt;</operator><name>tupleLen</name></name></expr>;</expr_stmt>    

    <expr_stmt><expr><name>head</name>      <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufHead</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tail</name>      <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufTail</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>free_size</name> <operator>=</operator> <call><name>BufferFreeSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>free_size</name> <operator>&gt;</operator> <name>tuple_len</name></expr>)</condition>    
    <block>{<block_content>
        <decl_stmt><decl><type><name>int32</name></type>  <name>ret</name>         <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>tmp</name>         <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>leng_ptr</name>    <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>write_len</name>   <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>        
        <decl_stmt><decl><type><name>uint32</name></type> <name>n32</name>         <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>data_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>remaining_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>MemoryContext</name></type>    <name>savecxt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>ReserveBufferSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>tuple_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>remaining_length</name> <operator>=</operator> <name>tuple_len</name></expr>;</expr_stmt>
        <comment type="block">/* MsgType */</comment>
        <expr_stmt><expr><call><name>FillReserveBufferSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><literal type="string">"D"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>data_offset</name> <operator>=</operator> <call><name>DataBufferOffsetAdd</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>remaining_length</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        
        <comment type="block">/* Init length, exclude command tag. */</comment>
        <expr_stmt><expr><name>write_len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <comment type="block">/* Data length */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>leng_ptr</name>         <operator>=</operator> <name>data_offset</name></expr>;</expr_stmt>        
            <expr_stmt><expr><name>data_offset</name> <operator>=</operator> <call><name>DataBufferOffsetAdd</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>remaining_length</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>    

            <expr_stmt><expr><name>write_len</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <comment type="block">/* Data */</comment>
        
        <comment type="block">/* ensure we have all values */</comment>
        <expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* if temporary memory context is specified reset it */</comment>
        <if_stmt><if>if <condition>(<expr><name>tmpcxt</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>tmpcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>savecxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>tmpcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* Number of parameter values */</comment>
        <expr_stmt><expr><name>n16</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name><name>tdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* No possiblity of memory short, we reserved DEFAULT_RESERVE_STEP bytes above. */</comment>
        <expr_stmt><expr><call><name>FillReserveBufferSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n16</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>data_offset</name> <operator>=</operator> <call><name>DataBufferOffsetAdd</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>remaining_length</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

        <comment type="block">/* Write length */</comment>
        <expr_stmt><expr><name>write_len</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        
        
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>write_len</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufLength</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>remaining_length</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int</name></type> <name>sleep_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                        
                        <do>do
                        <block>{<block_content>
                            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ReserveBufferSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>DEFAULT_RESERVE_STEP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition>
                            <block>{<block_content>
                                <break>break;</break>
                            </block_content>}</block></if></if_stmt>
                            <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><name>sleep_time</name><operator>++</operator></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><name>sleep_time</name> <operator>==</operator> <name>MAX_SLEEP_TIMES</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>ReturnBufferSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>

                                <return>return <expr><name>false</name></expr>;</return>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block>while<condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>;</do>

                        <comment type="block">/* sanity check */</comment>
                        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>remaining_length</name> <operator>+</operator> <name>data_offset</name><operator>)</operator> <operator>%</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufLength</name></name> <operator>!=</operator> <name>tmp</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ReturnBufferSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"mismatch in Fast end."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        
                        <expr_stmt><expr><name>remaining_length</name> <operator>+=</operator> <name>DEFAULT_RESERVE_STEP</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    <expr_stmt><expr><call><name>FillReserveBufferSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>data_offset</name> <operator>=</operator> <call><name>DataBufferOffsetAdd</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>remaining_length</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                
                <comment type="block">/* Write length */</comment>
                <expr_stmt><expr><name>write_len</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><name><name>tdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>uint32</name></type>  <name>reserve_len</name>  <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>        <name>typOutput</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>    <name>typIsVarlena</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Datum</name></type>    <name>pval</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>pstring</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>        <name>len</name></decl>;</decl_stmt>

                <comment type="block">/* Get info needed to output the value */</comment>
                <expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typOutput</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typIsVarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/*
                 * If we have a toasted datum, forcibly detoast it here to avoid
                 * memory leakage inside the type's output routine.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>typIsVarlena</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>pval</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>PG_DETOAST_DATUM</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>pval</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <comment type="block">/*
                  * column is composite type, need to send tupledesc to remote node
                  */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>rec</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Oid</name></type>            <name>tupType</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int32</name></type>        <name>tupTypmod</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>StringInfoData</name></type>  <name>tupdesc_data</name></decl>;</decl_stmt>
                    
                    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tupdesc_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    
                    <comment type="block">/* -2 to indicate this is composite type */</comment>
                    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>write_len</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufLength</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>remaining_length</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>int</name></type> <name>sleep_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                            
                            <do>do
                            <block>{<block_content>
                                <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ReserveBufferSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>DEFAULT_RESERVE_STEP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition>
                                <block>{<block_content>
                                    <break>break;</break>
                                </block_content>}</block></if></if_stmt>
                                <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <expr_stmt><expr><name>sleep_time</name><operator>++</operator></expr>;</expr_stmt>

                                <if_stmt><if>if <condition>(<expr><name>sleep_time</name> <operator>==</operator> <name>MAX_SLEEP_TIMES</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>ReturnBufferSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                    <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>

                                    <return>return <expr><name>false</name></expr>;</return>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block>while<condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>;</do>
                    
                            <comment type="block">/* sanity check */</comment>
                            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>remaining_length</name> <operator>+</operator> <name>data_offset</name><operator>)</operator> <operator>%</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufLength</name></name> <operator>!=</operator> <name>tmp</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>ReturnBufferSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"mismatch in Fast end."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                            
                            <expr_stmt><expr><name>remaining_length</name> <operator>+=</operator> <name>DEFAULT_RESERVE_STEP</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><call><name>FillReserveBufferSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>data_offset</name> <operator>=</operator> <call><name>DataBufferOffsetAdd</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>remaining_length</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    
                    <comment type="block">/* Write length */</comment>
                    <expr_stmt><expr><name>write_len</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

                    <expr_stmt><expr><name>rec</name> <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>pval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* Extract type info from the tuple itself */</comment>
                    <expr_stmt><expr><name>tupType</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tupTypmod</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>tupType</name></expr></argument>, <argument><expr><name>tupTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>FormRowDescriptionMessage</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdesc_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>tupdesc_data</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>write_len</name> <operator>+</operator> <name>len</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufLength</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name><name>tupdesc_data</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="block">/* Reserve space. */</comment>
                        <if_stmt><if>if <condition>(<expr><name>remaining_length</name> <operator>&lt;</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>len</name><operator>)</operator></expr>)</condition>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>int</name></type> <name>sleep_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                            
                            <expr_stmt><expr><name>reserve_len</name> <operator>=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>len</name><operator>)</operator> <operator>+</operator> <name>DEFAULT_RESERVE_STEP</name></expr>;</expr_stmt>
                            
                            <do>do
                            <block>{<block_content>
                                <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ReserveBufferSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>reserve_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition>
                                <block>{<block_content>
                                    <break>break;</break>
                                </block_content>}</block></if></if_stmt>
                                <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                
                                <expr_stmt><expr><name>sleep_time</name><operator>++</operator></expr>;</expr_stmt>

                                <if_stmt><if>if <condition>(<expr><name>sleep_time</name> <operator>==</operator> <name>MAX_SLEEP_TIMES</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>ReturnBufferSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                    <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
                                    <block>{<block_content>
                                        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                    </block_content>}</block></if></if_stmt>

                                    <return>return <expr><name>false</name></expr>;</return>
                                </block_content>}</block></if></if_stmt>
                            </block_content>}</block>while<condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>;</do>
                            <comment type="block">/* sanity check */</comment>
                            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>remaining_length</name> <operator>+</operator> <name>data_offset</name><operator>)</operator> <operator>%</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufLength</name></name><operator>!=</operator> <name>tmp</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>ReturnBufferSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>
                                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"mismatch in Fast end."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                            
                            <expr_stmt><expr><name>remaining_length</name> <operator>+=</operator> <name>reserve_len</name></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        
                        <comment type="block">/* Data length */</comment>
                        <expr_stmt><expr><call><name>FillReserveBufferSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>data_offset</name> <operator>=</operator> <call><name>DataBufferOffsetAdd</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>remaining_length</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                    
                        <comment type="block">/* Data self */</comment>
                        <expr_stmt><expr><call><name>FillReserveBufferSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><name><name>tupdesc_data</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>data_offset</name> <operator>=</operator> <call><name>DataBufferOffsetAdd</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>remaining_length</name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                    
                    <comment type="block">/* Write length */</comment>
                    <expr_stmt><expr><name>write_len</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
                    
                    <comment type="block">/* Write length */</comment>
                    <expr_stmt><expr><name>write_len</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

                    <comment type="block">/* MemoryContextReset will do it */</comment>
                    <comment type="line">//pfree(tupdesc_data.data);</comment>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* Convert Datum to string */</comment>
                <expr_stmt><expr><name>pstring</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>typOutput</name></expr></argument>, <argument><expr><name>pval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* copy data to the buffer */</comment>
                <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>write_len</name> <operator>+</operator> <name>len</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufLength</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>pstring</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Reserve space. */</comment>
                    <if_stmt><if>if <condition>(<expr><name>remaining_length</name> <operator>&lt;</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>len</name><operator>)</operator></expr>)</condition>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>int</name></type> <name>sleep_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                        
                        <expr_stmt><expr><name>reserve_len</name> <operator>=</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>len</name><operator>)</operator> <operator>+</operator> <name>DEFAULT_RESERVE_STEP</name></expr>;</expr_stmt>
                        <do>do
                        <block>{<block_content>
                            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ReserveBufferSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>reserve_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition>
                            <block>{<block_content>
                                <break>break;</break>
                            </block_content>}</block></if></if_stmt>
                            <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><name>sleep_time</name><operator>++</operator></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><name>sleep_time</name> <operator>==</operator> <name>MAX_SLEEP_TIMES</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>ReturnBufferSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                
                                <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
                                <block>{<block_content>
                                    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                </block_content>}</block></if></if_stmt>

                                <return>return <expr><name>false</name></expr>;</return>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block>while<condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>;</do>
                        <comment type="block">/* sanity check */</comment>
                        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>remaining_length</name> <operator>+</operator> <name>data_offset</name><operator>)</operator> <operator>%</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufLength</name></name><operator>!=</operator> <name>tmp</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ReturnBufferSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            </block_content>}</block></if></if_stmt>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"mismatch in Fast end."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        
                        <expr_stmt><expr><name>remaining_length</name> <operator>+=</operator> <name>reserve_len</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                    
                    <comment type="block">/* Data length */</comment>
                    <expr_stmt><expr><call><name>FillReserveBufferSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>data_offset</name> <operator>=</operator> <call><name>DataBufferOffsetAdd</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>remaining_length</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

                    <comment type="block">/* Data self */</comment>
                    <expr_stmt><expr><call><name>FillReserveBufferSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><name>pstring</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>data_offset</name> <operator>=</operator> <call><name>DataBufferOffsetAdd</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>remaining_length</name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <comment type="block">/* MemoryContextReset will do it */</comment>
                <comment type="line">//pfree(pstring);</comment>
                <comment type="line">//pstring = NULL;</comment>
                
                <comment type="block">/* Write length */</comment>
                <expr_stmt><expr><name>write_len</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

                <comment type="block">/* Write length */</comment>
                <expr_stmt><expr><name>write_len</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Write data length, we reserve data above. */</comment>
        <expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>write_len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>FillReserveBufferSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>leng_ptr</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <comment type="block">/* Return space if needed. */</comment>
        <if_stmt><if>if <condition>(<expr><name>remaining_length</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ReturnBufferSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>data_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>    

        <if_stmt><if>if <condition>(<expr><name><name>data</name><operator>.</operator><name>len</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">//int sleep_time = 0;</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>data_len</name> <init>= <expr><name><name>data</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>data</name><operator>.</operator><name>cursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            
            <while>while <condition>(<expr><name>data_len</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>uint32</name></type> <name>len</name> <init>= <expr><call><name>BufferFreeSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>uint32</name></type> <name>write_len</name> <init>= <expr><ternary><condition><expr><name>data_len</name> <operator>&gt;</operator> <name>len</name></expr> ?</condition><then> <expr><name>len</name></expr> </then><else>: <expr><name>data_len</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>PutNodeData</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>data</name></name> <operator>+</operator> <name><name>data</name><operator>.</operator><name>cursor</name></name></expr></argument>, <argument><expr><name>write_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>data</name><operator>.</operator><name>cursor</name></name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>cursor</name></name> <operator>+</operator> <name>write_len</name></expr>;</expr_stmt>

                    <expr_stmt><expr><name>data_len</name> <operator>=</operator> <name>data_len</name> <operator>-</operator> <name>write_len</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
					<expr_stmt><expr><call><name>SetBufferBorderAndWaitFlag</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">50L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>DataPumpSndStatus_error</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <comment type="block">/* socket error */</comment>
                        <return>return <expr><name>true</name></expr>;</return>
                    </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
                    sleep_time++;

                    if (sleep_time == MAX_SLEEP_TIMES)
                    {
                        ReturnBufferSpace(buf, head);

                        pfree(data.data);

                        return false;
                    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></while>

			<expr_stmt><expr><call><name>SetBufferBorderAndWaitFlag</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>            
			<expr_stmt><expr><call><name>SetBufferBorderAndWaitFlag</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>data</name><operator>.</operator><name>len</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Save max tuple_len */</comment>
            <expr_stmt><expr><name><name>control</name><operator>-&gt;</operator><name>tupleLen</name></name> <operator>=</operator> <ternary><condition><expr><name><name>control</name><operator>-&gt;</operator><name>tupleLen</name></name> <operator>&gt;</operator> <operator>(</operator><name>write_len</name> <operator>-</operator> <literal type="number">5</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>control</name><operator>-&gt;</operator><name>tupleLen</name></name></expr> </then><else>: <expr><operator>(</operator><name>write_len</name> <operator>-</operator> <literal type="number">5</literal><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* MemoryContextReset will do it */</comment>
        <comment type="line">//pfree(data.data);</comment>

        <if_stmt><if>if <condition>(<expr><name>savecxt</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
                                        
        <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>ntuples</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>fast_send</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>write_data_len</name></name> <operator>+=</operator> <operator>(</operator><name>write_len</name><operator>)</operator></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>
        <comment type="block">/* Not enough space, wakeup sender. */</comment>
        <comment type="line">//ParallelSendWakeupSender(control, buf, nodeindex);</comment>
		<expr_stmt><expr><call><name>SetBufferBorderAndWaitFlag</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//pg_usleep(50L);</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Reserve space in print buffer */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> 
<name>ReserveBufferSpace</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* not enough space avaliable, wait */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>BufferFreeSpace</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>len</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>offset</name>    <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufHead</name></name></expr>;</expr_stmt>
           <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>bufHead</name></name> <operator>=</operator>  <operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>bufHead</name></name> <operator>+</operator> <name>len</name><operator>)</operator><operator>%</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufLength</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>        
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> 
<name>FillReserveBufferSpace</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type> <name>bytes2end</name>      <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>bytesfrombegin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>   

    <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
    <block>{<block_content>        
        <expr_stmt><expr><name>bytes2end</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufLength</name></name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name>bytes2end</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>bytesfrombegin</name> <operator>=</operator> <name>len</name> <operator>-</operator> <name>bytes2end</name></expr>;</expr_stmt>                
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>bytes2end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name> <operator>+</operator> <name>bytes2end</name></expr></argument>, <argument><expr><name>bytesfrombegin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>    
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32</name></type> 
<name>DataBufferOffsetAdd</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>pointer</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>

    <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
    <block>{<block_content>    
           <return>return <expr><operator>(</operator><name>pointer</name> <operator>+</operator> <name>offset</name><operator>)</operator> <operator>%</operator> <name><name>buf</name><operator>-&gt;</operator><name>bufLength</name></name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>        
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> 
<name>ReturnBufferSpace</name><parameter_list>(<parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>bufHead</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>        
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>PumpTupleStoreToBuffer</name><parameter_list>(<parameter><decl><type><name>ParallelWorkerControl</name> <modifier>*</modifier></type><name>control</name></decl></parameter>, <parameter><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>consumerIdx</name></decl></parameter>,
                               <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>tmpslot</name></decl></parameter>, <parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tuplestore</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>tmpcxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>tuplestore</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If we have something in the tuplestore try to push this to the queue */</comment>
        <while>while <condition>(<expr><operator>!</operator><call><name>tuplestore_ateof</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* save position */</comment>
            <expr_stmt><expr><call><name>tuplestore_copy_read_pointer</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Try to get next tuple to the temporary slot */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>tmpslot</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>tuples_get</name></name><operator>++</operator></expr>;</expr_stmt>
            
            <comment type="block">/* The slot should contain a data row */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tmpslot</name><operator>-&gt;</operator><name>tts_datarow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ParallelSendDataRow</name><argument_list>(<argument><expr><name>control</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>tmpslot</name><operator>-&gt;</operator><name>tts_datarow</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>, <argument><expr><name><name>tmpslot</name><operator>-&gt;</operator><name>tts_datarow</name><operator>-&gt;</operator><name>msglen</name></name></expr></argument>, <argument><expr><name>consumerIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt><empty_stmt>;</empty_stmt>
            <comment type="block">/* check if queue has enough room for the data */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition>
            <block>{<block_content>

                <comment type="block">/* Restore read position to get same tuple next time */</comment>
                <expr_stmt><expr><call><name>tuplestore_copy_read_pointer</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* We might advance the mark, try to truncate */</comment>
                <expr_stmt><expr><call><name>tuplestore_trim</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Prepare for writing, set proper read pointer */</comment>
                <expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>tuples_get</name></name><operator>--</operator></expr>;</expr_stmt>
                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block></if></if_stmt>        
        </block_content>}</block></while>

        <comment type="block">/* Remove rows we have just read */</comment>
        <expr_stmt><expr><call><name>tuplestore_trim</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* prepare for writes, set read pointer 0 as active */</comment>
        <expr_stmt><expr><call><name>tuplestore_select_read_pointer</name><argument_list>(<argument><expr><name>tuplestore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>DestroyParallelSendReceiver</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>savecontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSendDestReceiver</name> <modifier>*</modifier></type><name>receiver</name> <init>= <expr><operator>(</operator><name>ParallelSendDestReceiver</name> <operator>*</operator><operator>)</operator><name>self</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSendSharedData</name> <modifier>*</modifier></type><name>sharedData</name> <init>= <expr><name><name>receiver</name><operator>-&gt;</operator><name>sharedData</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelWorkerControl</name> <modifier>*</modifier></type><name>control</name>     <init>= <expr><name><name>receiver</name><operator>-&gt;</operator><name>control</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>savecontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>receiver</name><operator>-&gt;</operator><name>mycontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sharedData</name><operator>-&gt;</operator><name>numNodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>receiver</name><operator>-&gt;</operator><name>tstores</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>receiver</name><operator>-&gt;</operator><name>tstores</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>tstores</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>control</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>receiver</name><operator>-&gt;</operator><name>control</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>control</name></name><operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>receiver</name><operator>-&gt;</operator><name>tstores</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>receiver</name><operator>-&gt;</operator><name>tstores</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="line">//dsm_detach(receiver-&gt;seg);</comment>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>receiver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>savecontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>WaitForParallelWorkerDone</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numParallelWorkers</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>launch_failed</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>shm_toc</name> <modifier>*</modifier></type><name>toc</name>       <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SharedQueue</name></type> <name>squeue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSendSharedData</name>    <modifier>*</modifier></type><name>sharedData</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>int</name></type> <name>unconnect_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>unconnection_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>toc</name> <operator>=</operator> <call><name>shm_toc_attach</name><argument_list>(<argument><expr><name>PARALLEL_MAGIC</name></expr></argument>, <argument><expr><call><name>dsm_segment_address</name><argument_list>(<argument><expr><name>dsm_seg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>toc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid magic number in dynamic shared memory segment in SetParallelWorkerNum."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>sharedData</name>    <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>PARALLEL_SEND_SHARE_DATA</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>sharedData</name><operator>-&gt;</operator><name>numLaunchedParallelWorkers</name></name> <operator>=</operator> <name>numParallelWorkers</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>squeue</name> <operator>=</operator> <operator>(</operator><name>SharedQueue</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>SharedQueues</name></expr></argument>, <argument><expr><name><name>sharedData</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Shared queue %s not found"</literal></expr></argument>, <argument><expr><name><name>sharedData</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>squeue</name><operator>-&gt;</operator><name>parallelWorkerSendTuple</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ParallelSendControl</name> <modifier>*</modifier></type><name>parallelSendControl</name> <init>= <expr><name><name>squeue</name><operator>-&gt;</operator><name>parallelSendControl</name></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>launch_failed</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ParallelSendCleanAll</name><argument_list>(<argument><expr><name>parallelSendControl</name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender_destroy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>parallelSendControl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>, <argument><expr><name>ERR_MSGSIZE</name></expr></argument>, <argument><expr><literal type="string">"could not lunch parallel workers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>has_err_msg</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not lunch parallel workers."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        
        <do>do
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>NodeStatusCheck</name><argument_list>(<argument><expr><name>squeue</name></expr></argument>, <argument><expr><name>parallelSendControl</name></expr></argument>, <argument><expr><name>numParallelWorkers</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ParallelSendCleanAll</name><argument_list>(<argument><expr><name>parallelSendControl</name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender_destroy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>parallelSendControl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not send data to remote nodes."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>end_query_requested</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>producer_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>end_query_requested</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>squeue</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>nConsumer_done</name></name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>squeue</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"WaitForParallelWorkerDone(%s:%d):squeue %s producer %d set query done"</literal></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>while<condition>(<expr><operator>!</operator><call><name>ParallelWorkerExecDone</name><argument_list>(<argument><expr><name>numParallelWorkers</name></expr></argument>, <argument><expr><name><name>parallelSendControl</name><operator>-&gt;</operator><name>status</name></name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

        <comment type="block">/*
          * Assume that not yet connected consumers won't connect and reset them,
          * discard all tuples for them.
          */</comment>
        <do>do
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>NodeStatusCheck</name><argument_list>(<argument><expr><name>squeue</name></expr></argument>, <argument><expr><name>parallelSendControl</name></expr></argument>, <argument><expr><name>numParallelWorkers</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ParallelSendCleanAll</name><argument_list>(<argument><expr><name>parallelSendControl</name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender_destroy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>parallelSendControl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not send data to remote nodes."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>end_query_requested</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>producer_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>end_query_requested</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>squeue</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>nConsumer_done</name></name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>squeue</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"WaitForParallelWorkerDone(%s:%d):squeue %s producer %d set query done"</literal></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>ConsumerExit</name><argument_list>(<argument><expr><name>squeue</name></expr></argument>, <argument><expr><name>parallelSendControl</name></expr></argument>, <argument><expr><name>numParallelWorkers</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>unconnect_count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>unconnection_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
        </block_content>}</block>while<condition>(<expr><operator>!</operator><call><name>ParallelWorkerSendDone</name><argument_list>(<argument><expr><name>numParallelWorkers</name></expr></argument>, <argument><expr><name><name>parallelSendControl</name><operator>-&gt;</operator><name>status</name></name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

        <expr_stmt><expr><name>unconnect_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>unconnection_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>unconnection_node</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <do>do
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>NodeStatusCheck</name><argument_list>(<argument><expr><name>squeue</name></expr></argument>, <argument><expr><name>parallelSendControl</name></expr></argument>, <argument><expr><name>numParallelWorkers</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ParallelSendCleanAll</name><argument_list>(<argument><expr><name>parallelSendControl</name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>sender_destroy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>parallelSendControl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not send data to remote nodes."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>while<condition>(<expr><operator>!</operator><call><name>ConsumerExit</name><argument_list>(<argument><expr><name>squeue</name></expr></argument>, <argument><expr><name>parallelSendControl</name></expr></argument>, <argument><expr><name>numParallelWorkers</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>unconnect_count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>unconnection_node</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

        <expr_stmt><expr><call><name>RemoveDisConsumerHash</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Squeue %s: all parallel workers have finished work."</literal></expr></argument>,
                       <argument><expr><name><name>sharedData</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>NodeStatusCheck</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>squeue</name></decl></parameter>, <parameter><decl><type><name>ParallelSendControl</name> <modifier>*</modifier></type><name>parallelSendControl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numLaunchedParallelWorkers</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSendNodeControl</name>  <modifier>*</modifier></type><name>nodes</name> <init>= <expr><name><name>parallelSendControl</name><operator>-&gt;</operator><name>nodes</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSendSharedData</name> <modifier>*</modifier></type><name>sharedData</name> <init>= <expr><name><name>parallelSendControl</name><operator>-&gt;</operator><name>sharedData</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParallelSendStatus</name> <modifier>*</modifier></type><name>status</name> <init>= <expr><name><name>parallelSendControl</name><operator>-&gt;</operator><name>status</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>parallelSendControl</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>cstatus</name></name> <operator>!=</operator> <name>ConvertRunning</name> <operator>&amp;&amp;</operator>
        <name><name>parallelSendControl</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>cstatus</name></name> <operator>!=</operator> <name>ConvertExit</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"convert thread status:%d abnormal, maxconn:%d, conn_num:%d, errno:%d"</literal></expr></argument>, 
                                                        <argument><expr><name><name>parallelSendControl</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>cstatus</name></name></expr></argument>, 
                                                        <argument><expr><name><name>parallelSendControl</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>maxConn</name></name></expr></argument>, 
                                                        <argument><expr><name><name>parallelSendControl</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>connect_num</name></name></expr></argument>, 
                                                        <argument><expr><name><name>parallelSendControl</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>errNO</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sharedData</name><operator>-&gt;</operator><name>sender_error</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>, <argument><expr><name>ERR_MSGSIZE</name></expr></argument>, <argument><expr><literal type="string">"[squeue %s producer %d]:convert thread status:%d abnormal, maxconn:%d, conn_num:%d, errno:%d"</literal></expr></argument>,
                                      <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_pid</name></name></expr></argument>, <argument><expr><name><name>parallelSendControl</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>cstatus</name></name></expr></argument>, 
                                                        <argument><expr><name><name>parallelSendControl</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>maxConn</name></name></expr></argument>, 
                                                        <argument><expr><name><name>parallelSendControl</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>connect_num</name></name></expr></argument>, 
                                                        <argument><expr><name><name>parallelSendControl</name><operator>-&gt;</operator><name>convertControl</name><operator>.</operator><name>errNO</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>has_err_msg</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>parallelSendControl</name><operator>-&gt;</operator><name>numNodes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>status</name> <operator>==</operator> <name>DataPumpSndStatus_error</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><name><name>sharedData</name><operator>-&gt;</operator><name>sender_error</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"node %d status abnormal, socket error, msg %s"</literal></expr></argument>, <argument><expr><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeId</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>errorno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>, <argument><expr><name>ERR_MSGSIZE</name></expr></argument>, <argument><expr><literal type="string">"[squeue %s producer %d]: node %d status abnormal, socket error, msg %s"</literal></expr></argument>,
                                          <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_pid</name></name></expr></argument>, <argument><expr><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodeId</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>errorno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>has_err_msg</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>numLaunchedParallelWorkers</name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numLaunchedParallelWorkers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>status</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>ParallelSend_Error</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>sharedData</name><operator>-&gt;</operator><name>sender_error</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"[%s:%d]worker %d exit abnormally."</literal></expr></argument> , <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>, <argument><expr><name>ERR_MSGSIZE</name></expr></argument>, <argument><expr><literal type="string">"[squeue %s producer %d]: worker %d exit abnormally"</literal></expr></argument>,
                                                     <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_pid</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>has_err_msg</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>execute_error</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>sharedData</name><operator>-&gt;</operator><name>sender_error</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"some workers may not be launched or exit abnormally."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>, <argument><expr><name>ERR_MSGSIZE</name></expr></argument>, <argument><expr><literal type="string">"[squeue %s producer %d]: some workers may not be launched or exit abnormally"</literal></expr></argument>,
                                                     <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>has_err_msg</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_error</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>sharedData</name><operator>-&gt;</operator><name>sender_error</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"ParallelSendData: shared_queue %s error."</literal></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>, <argument><expr><name>ERR_MSGSIZE</name></expr></argument>, <argument><expr><literal type="string">"[squeue %s producer %d]: ParallelSendData: shared_queue %s error"</literal></expr></argument>,
                                         <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_pid</name></name></expr></argument>, <argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>has_err_msg</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ParallelSendCleanAll</name><parameter_list>(<parameter><decl><type><name>ParallelSendControl</name> <modifier>*</modifier></type><name>sender</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodeid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ParallelSendCleanThread</name><argument_list>(<argument><expr><name>sender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>DestoryParallelSendControl</name><argument_list>(<argument><expr><name>sender</name></expr></argument>, <argument><expr><name>nodeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ParallelWorkerExecDone</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numLaunchedParallelWorkers</name></decl></parameter>, <parameter><decl><type><name>ParallelSendStatus</name> <modifier>*</modifier></type><name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>exec_done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numLaunchedParallelWorkers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>status</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <name>ParallelSend_ExecDone</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>exec_done</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>exec_done</name> <operator>==</operator> <name>numLaunchedParallelWorkers</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ParallelWorkerSendDone</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numLaunchedParallelWorkers</name></decl></parameter>, <parameter><decl><type><name>ParallelSendStatus</name> <modifier>*</modifier></type><name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>exec_done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numLaunchedParallelWorkers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>status</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;=</operator> <name>ParallelSend_SendDone</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>exec_done</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>exec_done</name> <operator>==</operator> <name>numLaunchedParallelWorkers</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>GetConsumerIdx</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>sq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nodeid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>sq</name><operator>-&gt;</operator><name>nodeMap</name><index>[<expr><name>nodeid</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>IsSqueueProducer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><name>role</name> <operator>==</operator> <name>Squeue_Producer</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>IsSqueueConsumer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><operator>(</operator><name>role</name> <operator>==</operator> <name>Squeue_Consumer</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SetSqueueError</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>share_sq</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>share_sq</name><operator>-&gt;</operator><name>sq_error</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SqueueProducerExit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>share_sq</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>share_sq</name><operator>-&gt;</operator><name>sender_destroy</name></name> <operator>&amp;&amp;</operator> <name><name>share_sq</name><operator>-&gt;</operator><name>sq_pid</name></name> <operator>==</operator> <name>MyProcPid</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>share_sq</name><operator>-&gt;</operator><name>parallelWorkerSendTuple</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>DataPumpWaitSenderDone</name><argument_list>(<argument><expr><name><name>share_sq</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>DestoryDataPumpSenderControl</name><argument_list>(<argument><expr><name><name>share_sq</name><operator>-&gt;</operator><name>sender</name></name></expr></argument>, <argument><expr><name><name>share_sq</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>share_sq</name><operator>-&gt;</operator><name>sender</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>share_sq</name><operator>-&gt;</operator><name>sender_destroy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ParallelSendCleanThread</name><argument_list>(<argument><expr><name><name>share_sq</name><operator>-&gt;</operator><name>parallelSendControl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>DestoryParallelSendControl</name><argument_list>(<argument><expr><name><name>share_sq</name><operator>-&gt;</operator><name>parallelSendControl</name></name></expr></argument>, <argument><expr><name><name>share_sq</name><operator>-&gt;</operator><name>sq_nodeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>share_sq</name><operator>-&gt;</operator><name>parallelSendControl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>share_sq</name><operator>-&gt;</operator><name>sender_destroy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>share_sq</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ParallelSendEreport</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>senderstatus</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>senderstatus</name><index>[<expr><name>ParallelWorkerNumber</name></expr>]</index></name> <operator>=</operator> <name>ParallelSend_Error</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>senderstatus</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> 
<name>ParallelDsmDetach</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>dsm_seg</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>senderstatus</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dsm_detach</name><argument_list>(<argument><expr><name>dsm_seg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dsm_seg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ConsumerExit</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>sq</name></decl></parameter>, <parameter><decl><type><name>ParallelSendControl</name> <modifier>*</modifier></type><name>sender</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numParallelWorkers</name></decl></parameter>, 
                  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>count</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>unconnect</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMEOUT</name></cpp:macro> <cpp:value>(consumer_connect_timeout * 1000)</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>node_num</name> <init>= <expr><name><name>sq</name><operator>-&gt;</operator><name>sq_nconsumers</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>all_done</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nodeSendDone</name> <init>= <expr><name><name>sender</name><operator>-&gt;</operator><name>nodeSendDone</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SQueueSync</name> <modifier>*</modifier></type><name>sqsync</name> <init>= <expr><name><name>sq</name><operator>-&gt;</operator><name>sq_sync</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>unconnect_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>node_num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nWorkerDone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nBufferDone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ConsState</name> <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><name><name>sq</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ParallelSendNodeControl</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>&amp;</operator><name><name>sender</name><operator>-&gt;</operator><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numParallelWorkers</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>index</name> <operator>=</operator> <name>j</name> <operator>*</operator> <name>node_num</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
            
            <if_stmt><if>if <condition>(<expr><name><name>nodeSendDone</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>nWorkerDone</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <if_stmt><if>if <condition>(<expr><name>nWorkerDone</name> <operator>==</operator> <name>numParallelWorkers</name></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numParallelWorkers</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ParallelSendDataQueue</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>buffer</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>buffer</name><operator>-&gt;</operator><name>bufHead</name></name> <operator>==</operator> <name><name>buffer</name><operator>-&gt;</operator><name>bufTail</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>nBufferDone</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <if_stmt><if>if <condition>(<expr><name>nBufferDone</name> <operator>==</operator> <name>numParallelWorkers</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>done</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>==</operator> <name>CONSUMER_ACTIVE</name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>=</operator> <name>CONSUMER_EOF</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            
            <expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_latch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* consumer do not need data any more, tell worker to discard all data to this consumer */</comment>
        <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>==</operator> <name>CONSUMER_ACTIVE</name> <operator>&amp;&amp;</operator> <name><name>cstate</name><operator>-&gt;</operator><name>cs_pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>unconnect_node</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>unconnect_node</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>IsConsumerDisConnect</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_node</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>=</operator> <name>CONSUMER_DONE</name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"ConsumerExit: squeue %s Set consumer %d done."</literal></expr></argument>, <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>==</operator> <name>CONSUMER_DONE</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>DataPumpSndStatus_no_socket</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>sender</name><operator>-&gt;</operator><name>nodeNoSocket</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>==</operator> <name>CONSUMER_ACTIVE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>all_done</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>


    <comment type="block">/* 
      *some consumers may went down with exception, and never inform us, we need
      * reset conncetion ourselves
      */</comment>
    <if_stmt><if>if <condition>(<expr><name>unconnect_node</name> <operator>&amp;&amp;</operator> <call><name>bms_subset_compare</name><argument_list>(<argument><expr><name>unconnect_node</name></expr></argument>, <argument><expr><operator>*</operator><name>unconnect</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BMS_EQUAL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>count</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>unconnect_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>count</name><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><operator>*</operator><name>unconnect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>unconnect</name> <operator>=</operator> <name>unconnect_node</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>count</name> <operator>==</operator> <name>TIMEOUT</name></expr>)</condition>
    <block>{<block_content>
        <while>while<condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>bms_first_member</name><argument_list>(<argument><expr><operator>*</operator><name>unconnect</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ConsState</name> <modifier>*</modifier></type><name>cstate</name> <init>= <expr><operator>&amp;</operator><name><name>sq</name><operator>-&gt;</operator><name>sq_consumers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>sq</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>, <argument><expr><name>ERR_MSGSIZE</name></expr></argument>, <argument><expr><literal type="string">"[squeue %s producer %d]: set consumer %d done, because of unconnect"</literal></expr></argument>,
                                               <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_pid</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>sq</name><operator>-&gt;</operator><name>has_err_msg</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>cstate</name><operator>-&gt;</operator><name>cs_status</name></name> <operator>=</operator> <name>CONSUMER_DONE</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>sqsync</name><operator>-&gt;</operator><name>sqs_consumer_sync</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cs_lwlock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"squeue %s Set consumer %d done, because of unconnect."</literal></expr></argument>, <argument><expr><name><name>sq</name><operator>-&gt;</operator><name>sq_key</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><operator>(</operator><operator>*</operator><name>count</name><operator>)</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><operator>*</operator><name>unconnect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>unconnect</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>all_done</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SetParallelSendError</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>execute_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>GetParallelSendError</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name>execute_error</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* sigusr2 handler */</comment>
<function><type><name>void</name></type>
<name>RemoteSubplanSigusr2Handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>g_DataPumpDebug</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Pid %d got SIGUSR2 in RemoteSubplan: %m"</literal></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>end_query_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReportErrorConsumer</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>squeue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>squeue</name><operator>-&gt;</operator><name>has_err_msg</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>StringInfoData</name></type>    <name>data</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>GetErrorMsg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>squeue</name><operator>-&gt;</operator><name>err_msg</name></name></expr></argument>, <argument><expr><name>ERR_MSGSIZE</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>squeue</name><operator>-&gt;</operator><name>has_err_msg</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>data</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>
<function><type><name>PGPipe</name><modifier>*</modifier></type> <name>CreatePipe</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PGPipe</name> <modifier>*</modifier></type><name>pPipe</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>pPipe</name> <operator>=</operator> <call><name>palloc0</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGPipe</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPipe</name><operator>-&gt;</operator><name>m_List</name></name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>palloc0</name><argument_list>( <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <expr_stmt><expr><name><name>pPipe</name><operator>-&gt;</operator><name>m_Length</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>            
    <expr_stmt><expr><name><name>pPipe</name><operator>-&gt;</operator><name>m_Head</name></name>   <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPipe</name><operator>-&gt;</operator><name>m_Tail</name></name>   <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>spinlock_init</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pPipe</name><operator>-&gt;</operator><name>m_lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>pPipe</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>DestoryPipe</name><parameter_list>(<parameter><decl><type><name>PGPipe</name> <modifier>*</modifier></type><name>pPipe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>pPipe</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pPipe</name><operator>-&gt;</operator><name>m_List</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pPipe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<comment type="block">/*ä»éåä¸­ååºä¸ä¸ªååä½¿ç¨ï¼å¦æéåä¸ºç©ºå°±è¿åç©ºæé*/</comment>
<function><type><name>void</name> <modifier>*</modifier></type><name>PipeGet</name><parameter_list>(<parameter><decl><type><name>PGPipe</name> <modifier>*</modifier></type><name>pPipe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pPipe</name><operator>-&gt;</operator><name>m_lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pPipe</name><operator>-&gt;</operator><name>m_Head</name></name> <operator>==</operator> <name><name>pPipe</name><operator>-&gt;</operator><name>m_Tail</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pPipe</name><operator>-&gt;</operator><name>m_lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>                
    </block_content>}</block></if></if_stmt>            
    <expr_stmt><expr><name>ptr</name>                             <operator>=</operator> <name><name>pPipe</name><operator>-&gt;</operator><name>m_List</name><index>[<expr><name><name>pPipe</name><operator>-&gt;</operator><name>m_Head</name></name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPipe</name><operator>-&gt;</operator><name>m_List</name><index>[<expr><name><name>pPipe</name><operator>-&gt;</operator><name>m_Head</name></name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>                
    <expr_stmt><expr><name><name>pPipe</name><operator>-&gt;</operator><name>m_Head</name></name>                   <operator>=</operator> <operator>(</operator><name><name>pPipe</name><operator>-&gt;</operator><name>m_Head</name></name>  <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>pPipe</name><operator>-&gt;</operator><name>m_Length</name></name></expr>;</expr_stmt>  
    <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pPipe</name><operator>-&gt;</operator><name>m_lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*å¾éåä¸­æ¾å¥ä¸ä¸ªå¯¹è±¡ï¼å¦æéåæ»¡å°±è¿åéé¶*/</comment>
<function><type><name>int</name></type> <name>PipePut</name><parameter_list>(<parameter><decl><type><name>PGPipe</name> <modifier>*</modifier></type><name>pPipe</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pPipe</name><operator>-&gt;</operator><name>m_lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pPipe</name><operator>-&gt;</operator><name>m_Tail</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>pPipe</name><operator>-&gt;</operator><name>m_Length</name></name> <operator>==</operator> <name><name>pPipe</name><operator>-&gt;</operator><name>m_Head</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pPipe</name><operator>-&gt;</operator><name>m_lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>pPipe</name><operator>-&gt;</operator><name>m_List</name><index>[<expr><name><name>pPipe</name><operator>-&gt;</operator><name>m_Tail</name></name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pPipe</name><operator>-&gt;</operator><name>m_Tail</name></name> <operator>=</operator> <operator>(</operator><name><name>pPipe</name><operator>-&gt;</operator><name>m_Tail</name></name>  <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>pPipe</name><operator>-&gt;</operator><name>m_Length</name></name></expr>;</expr_stmt>  
    <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pPipe</name><operator>-&gt;</operator><name>m_lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>bool</name></type> <name>PipeIsFull</name><parameter_list>(<parameter><decl><type><name>PGPipe</name> <modifier>*</modifier></type><name>pPipe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pPipe</name><operator>-&gt;</operator><name>m_lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pPipe</name><operator>-&gt;</operator><name>m_Tail</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>pPipe</name><operator>-&gt;</operator><name>m_Length</name></name> <operator>==</operator> <name><name>pPipe</name><operator>-&gt;</operator><name>m_Head</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pPipe</name><operator>-&gt;</operator><name>m_lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pPipe</name><operator>-&gt;</operator><name>m_lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>bool</name></type> <name>IsEmpty</name><parameter_list>(<parameter><decl><type><name>PGPipe</name> <modifier>*</modifier></type><name>pPipe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pPipe</name><operator>-&gt;</operator><name>m_lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>pPipe</name><operator>-&gt;</operator><name>m_Tail</name></name> <operator>==</operator> <name><name>pPipe</name><operator>-&gt;</operator><name>m_Head</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pPipe</name><operator>-&gt;</operator><name>m_lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pPipe</name><operator>-&gt;</operator><name>m_lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>PipeLength</name><parameter_list>(<parameter><decl><type><name>PGPipe</name> <modifier>*</modifier></type><name>pPipe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>spinlock_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pPipe</name><operator>-&gt;</operator><name>m_lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name><name>pPipe</name><operator>-&gt;</operator><name>m_Tail</name></name> <operator>-</operator> <name><name>pPipe</name><operator>-&gt;</operator><name>m_Head</name></name> <operator>+</operator> <name><name>pPipe</name><operator>-&gt;</operator><name>m_Length</name></name><operator>)</operator> <operator>%</operator> <name><name>pPipe</name><operator>-&gt;</operator><name>m_Length</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>spinlock_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>pPipe</name><operator>-&gt;</operator><name>m_lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>SqueueName</name><parameter_list>(<parameter><decl><type><name>SharedQueue</name></type> <name>sq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>sq</name><operator>-&gt;</operator><name>sq_key</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
