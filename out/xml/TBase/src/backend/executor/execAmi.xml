<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/executor/execAmi.c"><comment type="block">/*
 * Tencent is pleased to support the open source community by making TBase available.  
 * 
 * Copyright (C) 2019 THL A29 Limited, a Tencent company.  All rights reserved.
 * 
 * TBase is licensed under the BSD 3-Clause License, except for the third-party component listed below. 
 * 
 * A copy of the BSD 3-Clause License is included in this file.
 * 
 * Other dependencies and licenses:
 * 
 * Open Source Software Licensed Under the PostgreSQL License: 
 * --------------------------------------------------------------------
 * 1. Postgres-XL XL9_5_STABLE
 * Portions Copyright (c) 2015-2016, 2ndQuadrant Ltd
 * Portions Copyright (c) 2012-2015, TransLattice, Inc.
 * Portions Copyright (c) 2010-2017, Postgres-XC Development Group
 * Portions Copyright (c) 1996-2015, The PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, The Regents of the University of California
 * 
 * Terms of the PostgreSQL License: 
 * --------------------------------------------------------------------
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS
 * DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * 
 * Terms of the BSD 3-Clause License:
 * --------------------------------------------------------------------
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of THL A29 Limited nor the names of its contributors may be used to endorse or promote products derived from this software without 
 * specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH 
 * DAMAGE.
 * 
 */</comment>
<comment type="block">/*-------------------------------------------------------------------------
 *
 * execAmi.c
 *      miscellaneous executor access method routines
 *
 * Portions Copyright (c) 2012-2014, TransLattice, Inc.
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *    src/backend/executor/execAmi.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/amapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAgg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAppend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeBitmapAnd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeBitmapHeapscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeBitmapIndexscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeBitmapOr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeCtescan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeCustom.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeForeignscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeFunctionscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeGather.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeGroup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeGroup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeHashjoin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeIndexonlyscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeIndexscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeLimit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeLockRows.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeMaterial.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeMergeAppend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeMergejoin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeModifyTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeNamedtuplestorescan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeNestloop.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeProjectSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeRecursiveunion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeResult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSamplescan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSeqscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSetOp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSort.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSubplan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSubqueryscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeTableFuncscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeTidscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeUnique.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeValuesscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeWindowAgg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeWorktablescan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/execRemote.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IndexSupportsBackwardScan</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexid</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * ExecReScan
 *        Reset a plan node so that its output can be re-scanned.
 *
 * Note that if the plan node has parameters that have changed value,
 * the output might be different from last time.
 */</comment>
<function><type><name>void</name></type>
<name>ExecReScan</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/* If collecting timing stats, update them */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>instrument</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>InstrEndLoop</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * If we have changed parameters, propagate that info.
     *
     * Note: ExecReScanSetParamPlan() can add bits to node-&gt;chgParam,
     * corresponding to the output param(s) that the InitPlan will update.
     * Since we make only one pass over the list, that means that an InitPlan
     * can depend on the output param(s) of a sibling InitPlan only if that
     * sibling appears earlier in the list.  This is workable for now given
     * the limited ways in which one InitPlan could depend on another, but
     * eventually we might need to work harder (or else make the planner
     * enlarge the extParam/allParam sets to include the params of depended-on
     * InitPlans).
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;initPlan</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>sstate</name> <init>= <expr><operator>(</operator><name>SubPlanState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>splan</name> <init>= <expr><name><name>sstate</name><operator>-&gt;</operator><name>planstate</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>extParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>    <comment type="block">/* don't care about child
                                                 * local Params */</comment>
                <expr_stmt><expr><call><name>UpdateChangedParamSet</name><argument_list>(<argument><expr><name>splan</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecReScanSetParamPlan</name><argument_list>(<argument><expr><name>sstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>
        <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>node-&gt;subPlan</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>sstate</name> <init>= <expr><operator>(</operator><name>SubPlanState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>splan</name> <init>= <expr><name><name>sstate</name><operator>-&gt;</operator><name>planstate</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>splan</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>extParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>UpdateChangedParamSet</name><argument_list>(<argument><expr><name>splan</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block>
        <comment type="block">/* Well. Now set chgParam for left/right trees. */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>UpdateChangedParamSet</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>righttree</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>UpdateChangedParamSet</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Call expression callbacks */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ps_ExprContext</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ReScanExprContext</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps_ExprContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* And do node-type-specific processing */</comment>
    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_ResultState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanResult</name><argument_list>(<argument><expr><operator>(</operator><name>ResultState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ProjectSetState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanProjectSet</name><argument_list>(<argument><expr><operator>(</operator><name>ProjectSetState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ModifyTableState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanModifyTable</name><argument_list>(<argument><expr><operator>(</operator><name>ModifyTableState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AppendState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanAppend</name><argument_list>(<argument><expr><operator>(</operator><name>AppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_MergeAppendState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanMergeAppend</name><argument_list>(<argument><expr><operator>(</operator><name>MergeAppendState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_RecursiveUnionState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanRecursiveUnion</name><argument_list>(<argument><expr><operator>(</operator><name>RecursiveUnionState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_BitmapAndState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanBitmapAnd</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapAndState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_BitmapOrState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanBitmapOr</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapOrState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SeqScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanSeqScan</name><argument_list>(<argument><expr><operator>(</operator><name>SeqScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SampleScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanSampleScan</name><argument_list>(<argument><expr><operator>(</operator><name>SampleScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_GatherState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanGather</name><argument_list>(<argument><expr><operator>(</operator><name>GatherState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_IndexScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>IndexScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_IndexOnlyScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanIndexOnlyScan</name><argument_list>(<argument><expr><operator>(</operator><name>IndexOnlyScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_BitmapIndexScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanBitmapIndexScan</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapIndexScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_BitmapHeapScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanBitmapHeapScan</name><argument_list>(<argument><expr><operator>(</operator><name>BitmapHeapScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_TidScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanTidScan</name><argument_list>(<argument><expr><operator>(</operator><name>TidScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SubqueryScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanSubqueryScan</name><argument_list>(<argument><expr><operator>(</operator><name>SubqueryScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_FunctionScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanFunctionScan</name><argument_list>(<argument><expr><operator>(</operator><name>FunctionScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_TableFuncScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanTableFuncScan</name><argument_list>(<argument><expr><operator>(</operator><name>TableFuncScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ValuesScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanValuesScan</name><argument_list>(<argument><expr><operator>(</operator><name>ValuesScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CteScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanCteScan</name><argument_list>(<argument><expr><operator>(</operator><name>CteScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_NamedTuplestoreScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanNamedTuplestoreScan</name><argument_list>(<argument><expr><operator>(</operator><name>NamedTuplestoreScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_WorkTableScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanWorkTableScan</name><argument_list>(<argument><expr><operator>(</operator><name>WorkTableScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ForeignScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanForeignScan</name><argument_list>(<argument><expr><operator>(</operator><name>ForeignScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGXC</name></cpp:ifdef>
        <case>case <expr><name>T_RemoteSubplanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanRemoteSubplan</name><argument_list>(<argument><expr><operator>(</operator><name>RemoteSubplanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_RemoteQueryState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanRemoteQuery</name><argument_list>(<argument><expr><operator>(</operator><name>RemoteQueryState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <case>case <expr><name>T_CustomScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanCustomScan</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_NestLoopState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanNestLoop</name><argument_list>(<argument><expr><operator>(</operator><name>NestLoopState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_MergeJoinState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanMergeJoin</name><argument_list>(<argument><expr><operator>(</operator><name>MergeJoinState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_HashJoinState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanHashJoin</name><argument_list>(<argument><expr><operator>(</operator><name>HashJoinState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_MaterialState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanMaterial</name><argument_list>(<argument><expr><operator>(</operator><name>MaterialState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SortState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanSort</name><argument_list>(<argument><expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_GroupState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanGroup</name><argument_list>(<argument><expr><operator>(</operator><name>GroupState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_AggState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanAgg</name><argument_list>(<argument><expr><operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_WindowAggState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanWindowAgg</name><argument_list>(<argument><expr><operator>(</operator><name>WindowAggState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_UniqueState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanUnique</name><argument_list>(<argument><expr><operator>(</operator><name>UniqueState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_HashState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanHash</name><argument_list>(<argument><expr><operator>(</operator><name>HashState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SetOpState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanSetOp</name><argument_list>(<argument><expr><operator>(</operator><name>SetOpState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_LockRowsState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanLockRows</name><argument_list>(<argument><expr><operator>(</operator><name>LockRowsState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_LimitState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecReScanLimit</name><argument_list>(<argument><expr><operator>(</operator><name>LimitState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>chgParam</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecMarkPos
 *
 * Marks the current scan position.
 *
 * NOTE: mark/restore capability is currently needed only for plan nodes
 * that are the immediate inner child of a MergeJoin node.  Since MergeJoin
 * requires sorted input, there is never any need to support mark/restore in
 * node types that cannot produce sorted output.  There are some cases in
 * which a node can pass through sorted data from its child; if we don't
 * implement mark/restore for such a node type, the planner compensates by
 * inserting a Material node above that node.
 */</comment>
<function><type><name>void</name></type>
<name>ExecMarkPos</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_IndexScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecIndexMarkPos</name><argument_list>(<argument><expr><operator>(</operator><name>IndexScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_IndexOnlyScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecIndexOnlyMarkPos</name><argument_list>(<argument><expr><operator>(</operator><name>IndexOnlyScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CustomScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecCustomMarkPos</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_MaterialState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecMaterialMarkPos</name><argument_list>(<argument><expr><operator>(</operator><name>MaterialState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SortState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecSortMarkPos</name><argument_list>(<argument><expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ResultState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecResultMarkPos</name><argument_list>(<argument><expr><operator>(</operator><name>ResultState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <comment type="block">/* don't make hard error unless caller asks to restore... */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * ExecRestrPos
 *
 * restores the scan position previously saved with ExecMarkPos()
 *
 * NOTE: the semantics of this are that the first ExecProcNode following
 * the restore operation will yield the same tuple as the first one following
 * the mark operation.  It is unspecified what happens to the plan node's
 * result TupleTableSlot.  (In most cases the result slot is unchanged by
 * a restore, but the node may choose to clear it or to load it with the
 * restored-to tuple.)    Hence the caller should discard any previously
 * returned TupleTableSlot after doing a restore.
 */</comment>
<function><type><name>void</name></type>
<name>ExecRestrPos</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_IndexScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecIndexRestrPos</name><argument_list>(<argument><expr><operator>(</operator><name>IndexScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_IndexOnlyScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecIndexOnlyRestrPos</name><argument_list>(<argument><expr><operator>(</operator><name>IndexOnlyScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_CustomScanState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecCustomRestrPos</name><argument_list>(<argument><expr><operator>(</operator><name>CustomScanState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_MaterialState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecMaterialRestrPos</name><argument_list>(<argument><expr><operator>(</operator><name>MaterialState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_SortState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecSortRestrPos</name><argument_list>(<argument><expr><operator>(</operator><name>SortState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>T_ResultState</name></expr>:</case>
            <expr_stmt><expr><call><name>ExecResultRestrPos</name><argument_list>(<argument><expr><operator>(</operator><name>ResultState</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * ExecSupportsMarkRestore - does a Path support mark/restore?
 *
 * This is used during planning and so must accept a Path, not a Plan.
 * We keep it here to be adjacent to the routines above, which also must
 * know which plan types support mark/restore.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecSupportsMarkRestore</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>pathnode</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <comment type="block">/*
     * For consistency with the routines above, we do not examine the nodeTag
     * but rather the pathtype, which is the Plan node type the Path would
     * produce.
     */</comment>
    <switch>switch <condition>(<expr><name><name>pathnode</name><operator>-&gt;</operator><name>pathtype</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_IndexScan</name></expr>:</case>
        <case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
        <case>case <expr><name>T_Material</name></expr>:</case>
        <case>case <expr><name>T_Sort</name></expr>:</case>
            <return>return <expr><name>true</name></expr>;</return>

        <case>case <expr><name>T_CustomScan</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>CustomPath</name> <modifier>*</modifier></type><name>customPath</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>CustomPath</name></expr></argument>, <argument><expr><name>pathnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>customPath</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CUSTOMPATH_SUPPORT_MARK_RESTORE</name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block>
        <case>case <expr><name>T_Result</name></expr>:</case>

            <comment type="block">/*
             * Result supports mark/restore iff it has a child plan that does.
             *
             * We have to be careful here because there is more than one Path
             * type that can produce a Result plan node.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>ProjectionPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>ExecSupportsMarkRestore</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ProjectionPath</name> <operator>*</operator><operator>)</operator> <name>pathnode</name><operator>)</operator><operator>-&gt;</operator><name>subpath</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>MinMaxAggPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if>    <comment type="block">/* childless Result */</comment>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>pathnode</name></expr></argument>, <argument><expr><name>ResultPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>false</name></expr>;</return>    <comment type="block">/* childless Result */</comment>
            </block_content>}</block></else></if_stmt>

        <default>default:</default>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecSupportsBackwardScan - does a plan type support backwards scanning?
 *
 * Ideally, all plan types would support backwards scan, but that seems
 * unlikely to happen soon.  In some cases, a plan node passes the backwards
 * scan down to its children, and so supports backwards scan only if its
 * children do.  Therefore, this routine must be passed a complete plan tree.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecSupportsBackwardScan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Parallel-aware nodes return a subset of the tuples in each worker, and
     * in general we can't expect to have enough bookkeeping state to know
     * which ones we returned in this worker as opposed to some other worker.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>parallel_aware</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_Result</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>ExecSupportsBackwardScan</name><argument_list>(<argument><expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>

        <case>case <expr><name>T_Append</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

                <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>((Append *) node)-&gt;appendplans</argument>)</argument_list></macro>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecSupportsBackwardScan</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
                </block_content>}</block>
                <comment type="block">/* need not check tlist because Append doesn't evaluate it */</comment>
                <return>return <expr><name>true</name></expr>;</return>
            </block_content>}</block>

        <case>case <expr><name>T_SampleScan</name></expr>:</case>
            <comment type="block">/* Simplify life for tablesample methods by disallowing this */</comment>
            <return>return <expr><name>false</name></expr>;</return>

        <case>case <expr><name>T_Gather</name></expr>:</case>
            <return>return <expr><name>false</name></expr>;</return>

        <case>case <expr><name>T_IndexScan</name></expr>:</case>
            <return>return <expr><call><name>IndexSupportsBackwardScan</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>IndexScan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>indexid</name></expr></argument>)</argument_list></call></expr>;</return>

        <case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
            <return>return <expr><call><name>IndexSupportsBackwardScan</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>indexid</name></expr></argument>)</argument_list></call></expr>;</return>

        <case>case <expr><name>T_SubqueryScan</name></expr>:</case>
            <return>return <expr><call><name>ExecSupportsBackwardScan</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>subplan</name></expr></argument>)</argument_list></call></expr>;</return>

        <case>case <expr><name>T_CustomScan</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>uint32</name></type>        <name>flags</name> <init>= <expr><operator>(</operator><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>flags</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>CUSTOMPATH_SUPPORT_BACKWARD_SCAN</name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block>
            <return>return <expr><name>false</name></expr>;</return>

        <case>case <expr><name>T_SeqScan</name></expr>:</case>
        <case>case <expr><name>T_TidScan</name></expr>:</case>
        <case>case <expr><name>T_FunctionScan</name></expr>:</case>
        <case>case <expr><name>T_ValuesScan</name></expr>:</case>
        <case>case <expr><name>T_CteScan</name></expr>:</case>
        <case>case <expr><name>T_Material</name></expr>:</case>
        <case>case <expr><name>T_Sort</name></expr>:</case>
            <return>return <expr><name>true</name></expr>;</return>

        <case>case <expr><name>T_LockRows</name></expr>:</case>
        <case>case <expr><name>T_Limit</name></expr>:</case>
            <return>return <expr><call><name>ExecSupportsBackwardScan</name><argument_list>(<argument><expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

        <default>default:</default>
            <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * An IndexScan or IndexOnlyScan node supports backward scan only if the
 * index's AM does.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IndexSupportsBackwardScan</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type>        <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type>    <name>ht_idxrel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Form_pg_class</name></type> <name>idxrelrec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IndexAmRoutine</name> <modifier>*</modifier></type><name>amroutine</name></decl>;</decl_stmt>

    <comment type="block">/* Fetch the pg_class tuple of the index relation */</comment>
    <expr_stmt><expr><name>ht_idxrel</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_idxrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>idxrelrec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_idxrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Fetch the index AM's API struct */</comment>
    <expr_stmt><expr><name>amroutine</name> <operator>=</operator> <call><name>GetIndexAmRoutineByAmId</name><argument_list>(<argument><expr><name><name>idxrelrec</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amcanbackward</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>amroutine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_idxrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecMaterializesOutput - does a plan type materialize its output?
 *
 * Returns true if the plan node type is one that automatically materializes
 * its output (typically by keeping it in a tuplestore).  For such plans,
 * a rescan without any parameter change will have zero startup cost and
 * very low per-tuple cost.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecMaterializesOutput</name><parameter_list>(<parameter><decl><type><name>NodeTag</name></type> <name>plantype</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <switch>switch <condition>(<expr><name>plantype</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_Material</name></expr>:</case>
        <case>case <expr><name>T_FunctionScan</name></expr>:</case>
        <case>case <expr><name>T_TableFuncScan</name></expr>:</case>
        <case>case <expr><name>T_CteScan</name></expr>:</case>
        <case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
        <case>case <expr><name>T_WorkTableScan</name></expr>:</case>
        <case>case <expr><name>T_Sort</name></expr>:</case>
            <return>return <expr><name>true</name></expr>;</return>

        <default>default:</default>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
</unit>
