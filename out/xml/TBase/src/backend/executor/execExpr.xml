<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/executor/execExpr.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * execExpr.c
 *      Expression evaluation infrastructure.
 *
 *    During executor startup, we compile each expression tree (which has
 *    previously been processed by the parser and planner) into an ExprState,
 *    using ExecInitExpr() et al.  This converts the tree into a flat array
 *    of ExprEvalSteps, which may be thought of as instructions in a program.
 *    At runtime, we'll execute steps, starting with the first, until we reach
 *    an EEOP_DONE opcode.
 *
 *    This file contains the "compilation" logic.  It is independent of the
 *    specific execution technology we use (switch statement, computed goto,
 *    JIT compilation, etc).
 *
 *    See src/backend/executor/README for some background, specifically the
 *    "Expression Trees and ExprState nodes", "Expression Initialization",
 *    and "Expression Evaluation" sections.
 *
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/executor/execExpr.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execExpr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeSubplan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct <name>LastAttnumInfo</name>
<block>{
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>last_inner</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>last_outer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>last_scan</name></decl>;</decl_stmt>
}</block></struct></type> <name>LastAttnumInfo</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecReadyExpr</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecInitExprRec</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
                <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resv</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExprEvalPushStep</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExprEvalStep</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecInitFunc</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
             <parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>inputcollid</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,
             <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecInitExprSlots</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>get_last_attnums_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>LastAttnumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecInitWholeRowVar</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>variable</name></decl></parameter>,
                    <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecInitArrayRef</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>ArrayRef</name> <modifier>*</modifier></type><name>aref</name></decl></parameter>,
                 <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
                 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resv</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isAssignmentIndirectionExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ExecInitCoerceToDomain</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>ctest</name></decl></parameter>,
                       <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
                       <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resv</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resnull</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * ExecInitExpr: prepare an expression tree for execution
 *
 * This function builds and returns an ExprState implementing the given
 * Expr node tree.  The return ExprState can then be handed to ExecEvalExpr
 * for execution.  Because the Expr tree itself is read-only as far as
 * ExecInitExpr and ExecEvalExpr are concerned, several different executions
 * of the same plan tree can occur concurrently.  (But note that an ExprState
 * does mutate at runtime, so it can't be re-used concurrently.)
 *
 * This must be called in a memory context that will last as long as repeated
 * executions of the expression are needed.  Typically the context will be
 * the same as the per-query context of the associated ExprContext.
 *
 * Any Aggref, WindowFunc, or SubPlan nodes found in the tree are added to
 * the lists of such nodes held by the parent PlanState (or more accurately,
 * the AggrefExprState etc. nodes created for them are added).
 *
 * Note: there is no ExecEndExpr function; we assume that any resource
 * cleanup needed will be handled by just releasing the memory context
 * in which the state tree is built.  Functions that require additional
 * cleanup work can register a shutdown callback in the ExprContext.
 *
 *    'node' is the root of the expression tree to compile.
 *    'parent' is the PlanState node that owns the expression.
 *
 * 'parent' may be NULL if we are preparing an expression that is not
 * associated with a plan tree.  (If so, it can't have aggs or subplans.)
 * Such cases should usually come through ExecPrepareExpr, not directly here.
 *
 * Also, if 'node' is NULL, we just return NULL.  This is convenient for some
 * callers that may or may not have an expression that needs to be compiled.
 * Note that a NULL ExprState pointer *cannot* be handed to ExecEvalExpr,
 * although ExecQual and ExecCheck will accept one (and treat it as "true").
 */</comment>
<function><type><name>ExprState</name> <modifier>*</modifier></type>
<name>ExecInitExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>scratch</name></decl>;</decl_stmt>

    <comment type="block">/* Special case: NULL expression produces a NULL ExprState pointer */</comment>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Initialize ExprState with empty step list */</comment>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExprState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>

    <comment type="block">/* Insert EEOP_*_FETCHSOME steps as needed */</comment>
    <expr_stmt><expr><call><name>ExecInitExprSlots</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Compile the expression proper */</comment>
    <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Finally, append a DONE step */</comment>
    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_DONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ExecReadyExpr</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecInitQual: prepare a qual for execution by ExecQual
 *
 * Prepares for the evaluation of a conjunctive boolean expression (qual list
 * with implicit AND semantics) that returns true if none of the
 * subexpressions are false.
 *
 * We must return true if the list is empty.  Since that's a very common case,
 * we optimize it a bit further by translating to a NULL ExprState pointer
 * rather than setting up an ExprState that computes constant TRUE.  (Some
 * especially hot-spot callers of ExecQual detect this and avoid calling
 * ExecQual at all.)
 *
 * If any of the subexpressions yield NULL, then the result of the conjunction
 * is false.  This makes ExecQual primarily useful for evaluating WHERE
 * clauses, since SQL specifies that tuples with null WHERE results do not
 * get selected.
 */</comment>
<function><type><name>ExprState</name> <modifier>*</modifier></type>
<name>ExecInitQual</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>scratch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>adjust_jumps</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* short-circuit (here and in ExecQual) for empty restriction list */</comment>
    <if_stmt><if>if <condition>(<expr><name>qual</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExprState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr>;</expr_stmt>
    <comment type="block">/* mark expression as to be used with ExecQual() */</comment>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>EEO_FLAG_IS_QUAL</name></expr>;</expr_stmt>

    <comment type="block">/* Insert EEOP_*_FETCHSOME steps as needed */</comment>
    <expr_stmt><expr><call><name>ExecInitExprSlots</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * ExecQual() needs to return false for an expression returning NULL. That
     * allows us to short-circuit the evaluation the first time a NULL is
     * encountered.  As qual evaluation is a hot-path this warrants using a
     * special opcode for qual evaluation that's simpler than BOOL_AND (which
     * has more complex NULL handling).
     */</comment>
    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_QUAL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * We can use ExprState's resvalue/resnull as target for each qual expr.
     */</comment>
    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resvalue</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resnull</name></name></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>qual</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* first evaluate expression */</comment>
        <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* then emit EEOP_QUAL to detect if it's false (or null) */</comment>
        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>qualexpr</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>adjust_jumps</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>adjust_jumps</name></expr></argument>,
                                   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* adjust jump targets */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>adjust_jumps</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>as</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>opcode</name></name> <operator>==</operator> <name>EEOP_QUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>qualexpr</name><operator>.</operator><name>jumpdone</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>qualexpr</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * At the end, we don't need to do anything more.  The last qual expr must
     * have yielded TRUE, and since its result is stored in the desired output
     * location, we're done.
     */</comment>
    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_DONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ExecReadyExpr</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecInitCheck: prepare a check constraint for execution by ExecCheck
 *
 * This is much like ExecInitQual/ExecQual, except that a null result from
 * the conjunction is treated as TRUE.  This behavior is appropriate for
 * evaluating CHECK constraints, since SQL specifies that NULL constraint
 * conditions are not failures.
 *
 * Note that like ExecInitQual, this expects input in implicit-AND format.
 * Users of ExecCheck that have expressions in normal explicit-AND format
 * can just apply ExecInitExpr to produce suitable input for ExecCheck.
 */</comment>
<function><type><name>ExprState</name> <modifier>*</modifier></type>
<name>ExecInitCheck</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* short-circuit (here and in ExecCheck) for empty restriction list */</comment>
    <if_stmt><if>if <condition>(<expr><name>qual</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Just convert the implicit-AND list to an explicit AND (if there's more
     * than one entry), and compile normally.  Unlike ExecQual, we can't
     * short-circuit on NULL results, so the regular AND behavior is needed.
     */</comment>
    <return>return <expr><call><name>ExecInitExpr</name><argument_list>(<argument><expr><call><name>make_ands_explicit</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Call ExecInitExpr() on a list of expressions, return a list of ExprStates.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ExecInitExprList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nodes</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>nodes</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *        ExecBuildProjectionInfo
 *
 * Build a ProjectionInfo node for evaluating the given tlist in the given
 * econtext, and storing the result into the tuple slot.  (Caller must have
 * ensured that tuple slot has a descriptor matching the tlist!)
 *
 * inputDesc can be NULL, but if it is not, we check to see whether simple
 * Vars in the tlist match the descriptor.  It is important to provide
 * inputDesc for relation-scan plan nodes, as a cross check that the relation
 * hasn't been changed since the plan was made.  At higher levels of a plan,
 * there is no need to recheck.
 *
 * This is implemented by internally building an ExprState that performs the
 * whole projection in one go.
 *
 * Caution: before PG v10, the targetList was a list of ExprStates; now it
 * should be the planner-created targetlist, since we do the compilation here.
 */</comment>
<function><type><name>ProjectionInfo</name> <modifier>*</modifier></type>
<name>ExecBuildProjectionInfo</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
                        <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>,
                        <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
                        <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,
                        <parameter><decl><type><name>TupleDesc</name></type> <name>inputDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ProjectionInfo</name> <modifier>*</modifier></type><name>projInfo</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ProjectionInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>scratch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>projInfo</name><operator>-&gt;</operator><name>pi_exprContext</name></name> <operator>=</operator> <name>econtext</name></expr>;</expr_stmt>
    <comment type="block">/* We embed ExprState into ProjectionInfo instead of doing extra palloc */</comment>
    <expr_stmt><expr><name><name>projInfo</name><operator>-&gt;</operator><name>pi_state</name><operator>.</operator><name>tag</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_ExprState</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <operator>&amp;</operator><name><name>projInfo</name><operator>-&gt;</operator><name>pi_state</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>targetList</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>resultslot</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

    <comment type="block">/* Insert EEOP_*_FETCHSOME steps as needed */</comment>
    <expr_stmt><expr><call><name>ExecInitExprSlots</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now compile each tlist column */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>targetList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Var</name>           <modifier>*</modifier></type><name>variable</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>        <name>isSafeVar</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * If tlist expression is a safe non-system Var, use the fast-path
         * ASSIGN_*_VAR opcodes.  "Safe" means that we don't need to apply
         * CheckVarSlotCompatibility() during plan startup.  If a source slot
         * was provided, we make the equivalent tests here; if a slot was not
         * provided, we assume that no check is needed because we're dealing
         * with a non-relation-scan-level expression.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
            <call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Non-system Var, but how safe is it? */</comment>
            <expr_stmt><expr><name>variable</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>variable</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>inputDesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>isSafeVar</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>    <comment type="block">/* can't check, just assume OK */</comment>
            <if type="elseif">else if <condition>(<expr><name>attnum</name> <operator>&lt;=</operator> <name><name>inputDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><name><name>inputDesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <comment type="block">/*
                 * If user attribute is dropped or has a type mismatch, don't
                 * use ASSIGN_*_VAR.  Instead let the normal expression
                 * machinery handle it (which'll possibly error out).
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>&amp;&amp;</operator> <name><name>variable</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>isSafeVar</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>isSafeVar</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Fast-path: just generate an EEOP_ASSIGN_*_VAR step */</comment>
            <switch>switch <condition>(<expr><name><name>variable</name><operator>-&gt;</operator><name>varno</name></name></expr>)</condition>
            <block>{<block_content>
                <case>case <expr><name>INNER_VAR</name></expr>:</case>
                    <comment type="block">/* get the tuple from the inner node */</comment>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ASSIGN_INNER_VAR</name></expr>;</expr_stmt>
                    <break>break;</break>

                <case>case <expr><name>OUTER_VAR</name></expr>:</case>
                    <comment type="block">/* get the tuple from the outer node */</comment>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ASSIGN_OUTER_VAR</name></expr>;</expr_stmt>
                    <break>break;</break>

                    <comment type="block">/* INDEX_VAR is handled by default case */</comment>

                <default>default:</default>
                    <comment type="block">/* get the tuple from the relation being scanned */</comment>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ASSIGN_SCAN_VAR</name></expr>;</expr_stmt>
                    <break>break;</break>
            </block_content>}</block></switch>

            <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>assign_var</name><operator>.</operator><name>attnum</name></name> <operator>=</operator> <name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>assign_var</name><operator>.</operator><name>resultnum</name></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * Otherwise, compile the column expression normally.
             *
             * We can't tell the expression to evaluate directly into the
             * result slot, as the result slot (and the exprstate for that
             * matter) can change between executions.  We instead evaluate
             * into the ExprState's resvalue/resnull and then move.
             */</comment>
            <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resvalue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>resnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Column might be referenced multiple times in upper nodes, so
             * force value to R/O - but only if it could be an expanded datum.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>get_typlen</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ASSIGN_TMP_MAKE_RO</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ASSIGN_TMP</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>assign_tmp</name><operator>.</operator><name>resultnum</name></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_DONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ExecReadyExpr</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>projInfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecPrepareExpr --- initialize for expression execution outside a normal
 * Plan tree context.
 *
 * This differs from ExecInitExpr in that we don't assume the caller is
 * already running in the EState's per-query context.  Also, we run the
 * passed expression tree through expression_planner() to prepare it for
 * execution.  (In ordinary Plan trees the regular planning process will have
 * made the appropriate transformations on expressions, but for standalone
 * expressions this won't have happened.)
 */</comment>
<function><type><name>ExprState</name> <modifier>*</modifier></type>
<name>ExecPrepareExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecPrepareQual --- initialize for qual execution outside a normal
 * Plan tree context.
 *
 * This differs from ExecInitQual in that we don't assume the caller is
 * already running in the EState's per-query context.  Also, we run the
 * passed expression tree through expression_planner() to prepare it for
 * execution.  (In ordinary Plan trees the regular planning process will have
 * made the appropriate transformations on expressions, but for standalone
 * expressions this won't have happened.)
 */</comment>
<function><type><name>ExprState</name> <modifier>*</modifier></type>
<name>ExecPrepareQual</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>qual</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecInitQual</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecPrepareCheck -- initialize check constraint for execution outside a
 * normal Plan tree context.
 *
 * See ExecPrepareExpr() and ExecInitCheck() for details.
 */</comment>
<function><type><name>ExprState</name> <modifier>*</modifier></type>
<name>ExecPrepareCheck</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>qual</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ExecInitCheck</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Call ExecPrepareExpr() on each member of a list of Exprs, and return
 * a list of ExprStates.
 *
 * See ExecPrepareExpr() for details.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>ExecPrepareExprList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nodes</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* Ensure that the list cell nodes are in the right context too */</comment>
    <expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>nodes</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecCheck - evaluate a check constraint
 *
 * For check constraints, a null result is taken as TRUE, ie the constraint
 * passes.
 *
 * The check constraint may have been prepared with ExecInitCheck
 * (possibly via ExecPrepareCheck) if the caller had it in implicit-AND
 * format, but a regular boolean expression prepared with ExecInitExpr or
 * ExecPrepareExpr works too.
 */</comment>
<function><type><name>bool</name></type>
<name>ExecCheck</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type>        <name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isnull</name></decl>;</decl_stmt>

    <comment type="block">/* short-circuit (here and in ExecInitCheck) for empty restriction list */</comment>
    <if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* verify that expression was not compiled using ExecInitQual */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>EEO_FLAG_IS_QUAL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare a compiled expression for execution.  This has to be called for
 * every ExprState before it can be executed.
 *
 * NB: While this currently only calls ExecReadyInterpretedExpr(),
 * this will likely get extended to further expression evaluation methods.
 * Therefore this should be used instead of directly calling
 * ExecReadyInterpretedExpr().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecReadyExpr</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ExecReadyInterpretedExpr</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Append the steps necessary for the evaluation of node to ExprState-&gt;steps,
 * possibly recursing into sub-expressions of node.
 *
 * node - expression to evaluate
 * parent - parent executor node (or NULL if a standalone expression)
 * state - ExprState to whose -&gt;steps to append the necessary operations
 * resv / resnull - where to store the result of the node into
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecInitExprRec</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
                <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resv</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resnull</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>scratch</name></decl>;</decl_stmt>

    <comment type="block">/* Guard against stack overflow due to overly complex expressions */</comment>
    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Step's output location is always what the caller gave us */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>resv</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>resnull</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <name>resv</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <name>resnull</name></expr>;</expr_stmt>

    <comment type="block">/* cases should be ordered as they are in enum NodeTag */</comment>
    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_Var</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Var</name>           <modifier>*</modifier></type><name>variable</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>variable</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* whole-row Var */</comment>
                    <expr_stmt><expr><call><name>ExecInitWholeRowVar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>, <argument><expr><name>variable</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name><name>variable</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* system column */</comment>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>attnum</name></name> <operator>=</operator> <name><name>variable</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name><name>variable</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</expr_stmt>
                    <switch>switch <condition>(<expr><name><name>variable</name><operator>-&gt;</operator><name>varno</name></name></expr>)</condition>
                    <block>{<block_content>
                        <case>case <expr><name>INNER_VAR</name></expr>:</case>
                            <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_INNER_SYSVAR</name></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><name>OUTER_VAR</name></expr>:</case>
                            <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_OUTER_SYSVAR</name></expr>;</expr_stmt>
                            <break>break;</break>

                            <comment type="block">/* INDEX_VAR is handled by default case */</comment>

                        <default>default:</default>
                            <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_SCAN_SYSVAR</name></expr>;</expr_stmt>
                            <break>break;</break>
                    </block_content>}</block></switch>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* regular user column */</comment>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>attnum</name></name> <operator>=</operator> <name><name>variable</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>var</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name><name>variable</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</expr_stmt>
                    <comment type="block">/* select EEOP_*_FIRST opcode to force one-time checks */</comment>
                    <switch>switch <condition>(<expr><name><name>variable</name><operator>-&gt;</operator><name>varno</name></name></expr>)</condition>
                    <block>{<block_content>
                        <case>case <expr><name>INNER_VAR</name></expr>:</case>
                            <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_INNER_VAR_FIRST</name></expr>;</expr_stmt>
                            <break>break;</break>
                        <case>case <expr><name>OUTER_VAR</name></expr>:</case>
                            <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_OUTER_VAR_FIRST</name></expr>;</expr_stmt>
                            <break>break;</break>

                            <comment type="block">/* INDEX_VAR is handled by default case */</comment>

                        <default>default:</default>
                            <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_SCAN_VAR_FIRST</name></expr>;</expr_stmt>
                            <break>break;</break>
                    </block_content>}</block></switch>
                </block_content>}</block></else></if_stmt>

                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_Const</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Const</name>       <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_CONST</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>constval</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>constval</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_Param</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Param</name>       <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <switch>switch <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>PARAM_EXEC</name></expr>:</case>
                        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_PARAM_EXEC</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>param</name><operator>.</operator><name>paramid</name></name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>param</name><operator>.</operator><name>paramtype</name></name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>PARAM_EXTERN</name></expr>:</case>
                        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_PARAM_EXTERN</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>param</name><operator>.</operator><name>paramid</name></name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>param</name><operator>.</operator><name>paramtype</name></name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name></expr>;</expr_stmt>
                        <break>break;</break>
                    <default>default:</default>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized paramkind: %d"</literal></expr></argument>,
                             <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                </block_content>}</block></switch>

                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_Aggref</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Aggref</name>       <modifier>*</modifier></type><name>aggref</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>AggrefExprState</name> <modifier>*</modifier></type><name>astate</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AggrefExprState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_AGGREF</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>aggref</name><operator>.</operator><name>astate</name></name> <operator>=</operator> <name>astate</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>astate</name><operator>-&gt;</operator><name>aggref</name></name> <operator>=</operator> <name>aggref</name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>parent</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>AggState</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>AggState</name>   <modifier>*</modifier></type><name>aggstate</name> <init>= <expr><operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator> <name>parent</name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggs</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>astate</name></expr></argument>, <argument><expr><name><name>aggstate</name><operator>-&gt;</operator><name>aggs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>aggstate</name><operator>-&gt;</operator><name>numaggs</name></name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* planner messed up */</comment>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Aggref found in non-Agg plan node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_GroupingFunc</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>GroupingFunc</name> <modifier>*</modifier></type><name>grp_node</name> <init>= <expr><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Agg</name>           <modifier>*</modifier></type><name>agg</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>parent</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>AggState</name></expr></argument>)</argument_list></call> <operator>||</operator>
                    <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>, <argument><expr><name>Agg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"GroupingFunc found in non-Agg plan node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_GROUPING_FUNC</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>grouping_func</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <operator>(</operator><name>AggState</name> <operator>*</operator><operator>)</operator> <name>parent</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>agg</name> <operator>=</operator> <operator>(</operator><name>Agg</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>parent</name><operator>-&gt;</operator><name>plan</name></name><operator>)</operator></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>grouping_func</name><operator>.</operator><name>clauses</name></name> <operator>=</operator> <name><name>grp_node</name><operator>-&gt;</operator><name>cols</name></name></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>grouping_func</name><operator>.</operator><name>clauses</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_WindowFunc</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>WindowFunc</name> <modifier>*</modifier></type><name>wfunc</name> <init>= <expr><operator>(</operator><name>WindowFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>WindowFuncExprState</name> <modifier>*</modifier></type><name>wfstate</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>WindowFuncExprState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>wfstate</name><operator>-&gt;</operator><name>wfunc</name></name> <operator>=</operator> <name>wfunc</name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>parent</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>WindowAggState</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>WindowAggState</name> <modifier>*</modifier></type><name>winstate</name> <init>= <expr><operator>(</operator><name>WindowAggState</name> <operator>*</operator><operator>)</operator> <name>parent</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type>            <name>nfuncs</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>funcs</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>wfstate</name></expr></argument>, <argument><expr><name><name>winstate</name><operator>-&gt;</operator><name>funcs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>nfuncs</name> <operator>=</operator> <operator>++</operator><name><name>winstate</name><operator>-&gt;</operator><name>numfuncs</name></name></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name><name>wfunc</name><operator>-&gt;</operator><name>winagg</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>winstate</name><operator>-&gt;</operator><name>numaggs</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="block">/* for now initialize agg using old style expressions */</comment>
                    <expr_stmt><expr><name><name>wfstate</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>ExecInitExprList</name><argument_list>(<argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>wfstate</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>=</operator> <call><name>ExecInitExpr</name><argument_list>(<argument><expr><name><name>wfunc</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>,
                                                      <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * Complain if the windowfunc's arguments contain any
                     * windowfuncs; nested window functions are semantically
                     * nonsensical.  (This should have been caught earlier,
                     * but we defend against it here anyway.)
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name>nfuncs</name> <operator>!=</operator> <name><name>winstate</name><operator>-&gt;</operator><name>numfuncs</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WINDOWING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"window function calls cannot be nested"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* planner messed up */</comment>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"WindowFunc found in non-WindowAgg plan node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_WINDOW_FUNC</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>window_func</name><operator>.</operator><name>wfstate</name></name> <operator>=</operator> <name>wfstate</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_ArrayRef</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ArrayRef</name>   <modifier>*</modifier></type><name>aref</name> <init>= <expr><operator>(</operator><name>ArrayRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>ExecInitArrayRef</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>, <argument><expr><name>aref</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_FuncExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>func</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>ExecInitFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                             <argument><expr><name><name>func</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>func</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>, <argument><expr><name><name>func</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
                             <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_OpExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>OpExpr</name>       <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>ExecInitFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                             <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
                             <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_DistinctExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>DistinctExpr</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>DistinctExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>ExecInitFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                             <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
                             <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Change opcode of call instruction to EEOP_DISTINCT.
                 *
                 * XXX: historically we've not called the function usage
                 * pgstat infrastructure - that seems inconsistent given that
                 * we do so for normal function *and* operator evaluation.  If
                 * we decided to do that here, we'd probably want separate
                 * opcodes for FUSAGE or not.
                 */</comment>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_DISTINCT</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_NullIfExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>NullIfExpr</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>NullIfExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>ExecInitFunc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                             <argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
                             <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Change opcode of call instruction to EEOP_NULLIF.
                 *
                 * XXX: historically we've not called the function usage
                 * pgstat infrastructure - that seems inconsistent given that
                 * we do so for normal function *and* operator evaluation.  If
                 * we decided to do that here, we'd probably want separate
                 * opcodes for FUSAGE or not.
                 */</comment>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_NULLIF</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>opexpr</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>scalararg</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>arrayarg</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>finfo</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>AclResult</name></type>    <name>aclresult</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>scalararg</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>arrayarg</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Check permission to call function */</comment>
                <expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>,
                                             <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
                                             <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>ACL_KIND_PROC</name></expr></argument>,
                                   <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <expr_stmt><expr><call><name>InvokeFunctionExecuteHook</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Set up the primary fmgr lookup information */</comment>
                <expr_stmt><expr><name>finfo</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>fcinfo</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FunctionCallInfoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
                                         <argument><expr><name><name>opexpr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Evaluate scalar directly into left function argument */</comment>
                <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>scalararg</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                                <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Evaluate array argument into our return value.  There's no
                 * danger in that, because the return value is guaranteed to
                 * be overwritten by EEOP_SCALARARRAYOP, and will not be
                 * passed to any other expression.
                 */</comment>
                <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>arrayarg</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* And perform the operation */</comment>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_SCALARARRAYOP</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>scalararrayop</name><operator>.</operator><name>element_type</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>scalararrayop</name><operator>.</operator><name>useOr</name></name> <operator>=</operator> <name><name>opexpr</name><operator>-&gt;</operator><name>useOr</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>scalararrayop</name><operator>.</operator><name>finfo</name></name> <operator>=</operator> <name>finfo</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>scalararrayop</name><operator>.</operator><name>fcinfo_data</name></name> <operator>=</operator> <name>fcinfo</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>scalararrayop</name><operator>.</operator><name>fn_addr</name></name> <operator>=</operator> <name><name>finfo</name><operator>-&gt;</operator><name>fn_addr</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_BoolExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>boolexpr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>nargs</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>boolexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>adjust_jumps</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>off</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

                <comment type="block">/* allocate scratch memory used by all steps of AND/OR */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>boolexpr</name><operator>-&gt;</operator><name>boolop</name></name> <operator>!=</operator> <name>NOT_EXPR</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>boolexpr</name><operator>.</operator><name>anynull</name></name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * For each argument evaluate the argument itself, then
                 * perform the bool operation's appropriate handling.
                 *
                 * We can evaluate each argument into our result area, since
                 * the short-circuiting logic means we only need to remember
                 * previous NULL values.
                 *
                 * AND/OR is split into separate STEP_FIRST (one) / STEP (zero
                 * or more) / STEP_LAST (one) steps, as each of those has to
                 * perform different work.  The FIRST/LAST split is valid
                 * because AND/OR have at least two arguments.
                 */</comment>
                <expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>boolexpr-&gt;args</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="block">/* Evaluate argument into our output variable */</comment>
                    <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* Perform the appropriate step type */</comment>
                    <switch>switch <condition>(<expr><name><name>boolexpr</name><operator>-&gt;</operator><name>boolop</name></name></expr>)</condition>
                    <block>{<block_content>
                        <case>case <expr><name>AND_EXPR</name></expr>:</case>
                            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><name>off</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_BOOL_AND_STEP_FIRST</name></expr>;</expr_stmt></block_content></block></if>
                            <if type="elseif">else if <condition>(<expr><name>off</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name>nargs</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_BOOL_AND_STEP_LAST</name></expr>;</expr_stmt></block_content></block></if>
                            <else>else<block type="pseudo"><block_content>
                                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_BOOL_AND_STEP</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                            <break>break;</break>
                        <case>case <expr><name>OR_EXPR</name></expr>:</case>
                            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <if_stmt><if>if <condition>(<expr><name>off</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_BOOL_OR_STEP_FIRST</name></expr>;</expr_stmt></block_content></block></if>
                            <if type="elseif">else if <condition>(<expr><name>off</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name>nargs</name></expr>)</condition><block type="pseudo"><block_content>
                                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_BOOL_OR_STEP_LAST</name></expr>;</expr_stmt></block_content></block></if>
                            <else>else<block type="pseudo"><block_content>
                                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_BOOL_OR_STEP</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                            <break>break;</break>
                        <case>case <expr><name>NOT_EXPR</name></expr>:</case>
                            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_BOOL_NOT_STEP</name></expr>;</expr_stmt>
                            <break>break;</break>
                        <default>default:</default>
                            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized boolop: %d"</literal></expr></argument>,
                                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>boolexpr</name><operator>-&gt;</operator><name>boolop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <break>break;</break>
                    </block_content>}</block></switch>

                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>boolexpr</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>adjust_jumps</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>adjust_jumps</name></expr></argument>,
                                               <argument><expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block>

                <comment type="block">/* adjust jump targets */</comment>
                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>adjust_jumps</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>as</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>boolexpr</name><operator>.</operator><name>jumpdone</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>boolexpr</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</expr_stmt>
                </block_content>}</block>

                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_SubPlan</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>SubPlanState</name> <modifier>*</modifier></type><name>sstate</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>parent</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SubPlan found with no parent plan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>sstate</name> <operator>=</operator> <call><name>ExecInitSubPlan</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* add SubPlanState nodes to parent-&gt;subPlan */</comment>
                <expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>subPlan</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>subPlan</name></name></expr></argument>, <argument><expr><name>sstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_SUBPLAN</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>subplan</name><operator>.</operator><name>sstate</name></name> <operator>=</operator> <name>sstate</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_AlternativeSubPlan</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>AlternativeSubPlan</name> <modifier>*</modifier></type><name>asplan</name> <init>= <expr><operator>(</operator><name>AlternativeSubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>AlternativeSubPlanState</name> <modifier>*</modifier></type><name>asstate</name></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>parent</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"AlternativeSubPlan found with no parent plan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>asstate</name> <operator>=</operator> <call><name>ExecInitAlternativeSubPlan</name><argument_list>(<argument><expr><name>asplan</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ALTERNATIVE_SUBPLAN</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>alternative_subplan</name><operator>.</operator><name>asstate</name></name> <operator>=</operator> <name>asstate</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_FieldSelect</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>FieldSelect</name> <modifier>*</modifier></type><name>fselect</name> <init>= <expr><operator>(</operator><name>FieldSelect</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* evaluate row/record argument into result area */</comment>
                <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>fselect</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* and extract field */</comment>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_FIELDSELECT</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldselect</name><operator>.</operator><name>fieldnum</name></name> <operator>=</operator> <name><name>fselect</name><operator>-&gt;</operator><name>fieldnum</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldselect</name><operator>.</operator><name>resulttype</name></name> <operator>=</operator> <name><name>fselect</name><operator>-&gt;</operator><name>resulttype</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldselect</name><operator>.</operator><name>argdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_FieldStore</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>FieldStore</name> <modifier>*</modifier></type><name>fstore</name> <init>= <expr><operator>(</operator><name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupDesc</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>TupleDesc</name>  <modifier>*</modifier></type><name>descp</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>ncolumns</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l1</name></decl>,
                           <decl><type ref="prev"><modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>

                <comment type="block">/* find out the number of columns in the composite type */</comment>
                <expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>ncolumns</name> <operator>=</operator> <name><name>tupDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>DecrTupleDescRefCount</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* create workspace for column values */</comment>
                <expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>nulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* create workspace for runtime tupdesc cache */</comment>
                <expr_stmt><expr><name>descp</name> <operator>=</operator> <operator>(</operator><name>TupleDesc</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleDesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>descp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <comment type="block">/* emit code to evaluate the composite input value */</comment>
                <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* next, deform the input tuple into our workspace */</comment>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_FIELDSTORE_DEFORM</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>fstore</name></name> <operator>=</operator> <name>fstore</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>argdesc</name></name> <operator>=</operator> <name>descp</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>values</name></name> <operator>=</operator> <name>values</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>nulls</name></name> <operator>=</operator> <name>nulls</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>ncolumns</name></name> <operator>=</operator> <name>ncolumns</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* evaluate new field values, store in workspace columns */</comment>
                <macro><name>forboth</name><argument_list>(<argument>l1</argument>, <argument>fstore-&gt;newvals</argument>, <argument>l2</argument>, <argument>fstore-&gt;fieldnums</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>fieldnum</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>save_innermost_caseval</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>save_innermost_casenull</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>fieldnum</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>fieldnum</name> <operator>&gt;</operator> <name>ncolumns</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"field number %d is out of range in FieldStore"</literal></expr></argument>,
                             <argument><expr><name>fieldnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="block">/*
                     * Use the CaseTestExpr mechanism to pass down the old
                     * value of the field being replaced; this is needed in
                     * case the newval is itself a FieldStore or ArrayRef that
                     * has to obtain and modify the old value.  It's safe to
                     * reuse the CASE mechanism because there cannot be a CASE
                     * between here and where the value would be needed, and a
                     * field assignment can't be within a CASE either.  (So
                     * saving and restoring innermost_caseval is just
                     * paranoia, but let's do it anyway.)
                     *
                     * Another non-obvious point is that it's safe to use the
                     * field's values[]/nulls[] entries as both the caseval
                     * source and the result address for this subexpression.
                     * That's okay only because (1) both FieldStore and
                     * ArrayRef evaluate their arg or refexpr inputs first,
                     * and (2) any such CaseTestExpr is directly the arg or
                     * refexpr input.  So any read of the caseval will occur
                     * before there's a chance to overwrite it.  Also, if
                     * multiple entries in the newvals/fieldnums lists target
                     * the same field, they'll effectively be applied
                     * left-to-right which is what we want.
                     */</comment>
                    <expr_stmt><expr><name>save_innermost_caseval</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_caseval</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>save_innermost_casenull</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_casenull</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_caseval</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>values</name><index>[<expr><name>fieldnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_casenull</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>nulls</name><index>[<expr><name>fieldnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name><name>values</name><index>[<expr><name>fieldnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name><name>nulls</name><index>[<expr><name>fieldnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_caseval</name></name> <operator>=</operator> <name>save_innermost_caseval</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_casenull</name></name> <operator>=</operator> <name>save_innermost_casenull</name></expr>;</expr_stmt>
                </block_content>}</block>

                <comment type="block">/* finally, form result tuple */</comment>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_FIELDSTORE_FORM</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>fstore</name></name> <operator>=</operator> <name>fstore</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>argdesc</name></name> <operator>=</operator> <name>descp</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>values</name></name> <operator>=</operator> <name>values</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>nulls</name></name> <operator>=</operator> <name>nulls</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fieldstore</name><operator>.</operator><name>ncolumns</name></name> <operator>=</operator> <name>ncolumns</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_RelabelType</name></expr>:</case>
            <block>{<block_content>
                <comment type="block">/* relabel doesn't need to do anything at runtime */</comment>
                <decl_stmt><decl><type><name>RelabelType</name> <modifier>*</modifier></type><name>relabel</name> <init>= <expr><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>relabel</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>CoerceViaIO</name> <modifier>*</modifier></type><name>iocoerce</name> <init>= <expr><operator>(</operator><name>CoerceViaIO</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>iofunc</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type>        <name>typisvarlena</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>typioparam</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo_in</name></decl>;</decl_stmt>

                <comment type="block">/* evaluate argument into step's result area */</comment>
                <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Prepare both output and input function calls, to be
                 * evaluated inside a single evaluation step for speed - this
                 * can be a very common operation.
                 *
                 * We don't check permissions here as a type's input/output
                 * function are assumed to be executable by everyone.
                 */</comment>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_IOCOERCE</name></expr>;</expr_stmt>

                <comment type="block">/* lookup the source type's output function */</comment>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>finfo_out</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>fcinfo_data_out</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FunctionCallInfoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>iocoerce</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>iofunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>iofunc</name></expr></argument>, <argument><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>finfo_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>finfo_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>fcinfo_data_out</name></name></expr></argument>,
                                         <argument><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>finfo_out</name></name></expr></argument>,
                                         <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* lookup the result type's input function */</comment>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>finfo_in</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>fcinfo_data_in</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FunctionCallInfoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>getTypeInputInfo</name><argument_list>(<argument><expr><name><name>iocoerce</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>,
                                 <argument><expr><operator>&amp;</operator><name>iofunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>iofunc</name></expr></argument>, <argument><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>finfo_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>finfo_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>fcinfo_data_in</name></name></expr></argument>,
                                         <argument><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>finfo_in</name></name></expr></argument>,
                                         <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * We can preload the second and third arguments for the input
                 * function, since they're constants.
                 */</comment>
                <expr_stmt><expr><name>fcinfo_in</name> <operator>=</operator> <name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>iocoerce</name><operator>.</operator><name>fcinfo_data_in</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>fcinfo_in</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typioparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>fcinfo_in</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>fcinfo_in</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>fcinfo_in</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>acoerce</name> <init>= <expr><operator>(</operator><name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type>            <name>resultelemtype</name></decl>;</decl_stmt>

                <comment type="block">/* evaluate argument into step's result area */</comment>
                <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>acoerce</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>resultelemtype</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name><name>acoerce</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>resultelemtype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"target type is not an array"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <comment type="block">/* Arrays over domains aren't supported yet */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>getBaseType</name><argument_list>(<argument><expr><name>resultelemtype</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>resultelemtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ARRAYCOERCE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arraycoerce</name><operator>.</operator><name>coerceexpr</name></name> <operator>=</operator> <name>acoerce</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arraycoerce</name><operator>.</operator><name>resultelemtype</name></name> <operator>=</operator> <name>resultelemtype</name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>acoerce</name><operator>-&gt;</operator><name>elemfuncid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>AclResult</name></type>    <name>aclresult</name></decl>;</decl_stmt>

                    <comment type="block">/* Check permission to call function */</comment>
                    <expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name><name>acoerce</name><operator>-&gt;</operator><name>elemfuncid</name></name></expr></argument>,
                                                 <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
                                                 <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>ACL_KIND_PROC</name></expr></argument>,
                                       <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name><name>acoerce</name><operator>-&gt;</operator><name>elemfuncid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <expr_stmt><expr><call><name>InvokeFunctionExecuteHook</name><argument_list>(<argument><expr><name><name>acoerce</name><operator>-&gt;</operator><name>elemfuncid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* Set up the primary fmgr lookup information */</comment>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arraycoerce</name><operator>.</operator><name>elemfunc</name></name> <operator>=</operator>
                        <operator>(</operator><name>FmgrInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name><name>acoerce</name><operator>-&gt;</operator><name>elemfuncid</name></name></expr></argument>,
                              <argument><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arraycoerce</name><operator>.</operator><name>elemfunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>acoerce</name></expr></argument>,
                                       <argument><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arraycoerce</name><operator>.</operator><name>elemfunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* Set up workspace for array_map */</comment>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arraycoerce</name><operator>.</operator><name>amstate</name></name> <operator>=</operator>
                        <operator>(</operator><name>ArrayMapState</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArrayMapState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* Don't need workspace if there's no conversion func */</comment>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arraycoerce</name><operator>.</operator><name>elemfunc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arraycoerce</name><operator>.</operator><name>amstate</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_ConvertRowtypeExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>convert</name> <init>= <expr><operator>(</operator><name>ConvertRowtypeExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* evaluate argument into step's result area */</comment>
                <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>convert</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* and push conversion step */</comment>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_CONVERT_ROWTYPE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>convert_rowtype</name><operator>.</operator><name>convert</name></name> <operator>=</operator> <name>convert</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>convert_rowtype</name><operator>.</operator><name>indesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>convert_rowtype</name><operator>.</operator><name>outdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>convert_rowtype</name><operator>.</operator><name>map</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>convert_rowtype</name><operator>.</operator><name>initialized</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

            <comment type="block">/* note that CaseWhen expressions are handled within this block */</comment>
        <case>case <expr><name>T_CaseExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>CaseExpr</name>   <modifier>*</modifier></type><name>caseExpr</name> <init>= <expr><operator>(</operator><name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>adjust_jumps</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>caseval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>casenull</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * If there's a test expression, we have to evaluate it and
                 * save the value where the CaseTestExpr placeholders can find
                 * it.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>caseExpr</name><operator>-&gt;</operator><name>arg</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Evaluate testexpr into caseval/casenull workspace */</comment>
                    <expr_stmt><expr><name>caseval</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>casenull</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>caseExpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                                    <argument><expr><name>caseval</name></expr></argument>, <argument><expr><name>casenull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * Since value might be read multiple times, force to R/O
                     * - but only if it could be an expanded datum.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>get_typlen</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>caseExpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* change caseval in-place */</comment>
                        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_MAKE_READONLY</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <name>caseval</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <name>casenull</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>make_readonly</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>caseval</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>make_readonly</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <name>casenull</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/* restore normal settings of scratch fields */</comment>
                        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <name>resv</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <name>resnull</name></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * Prepare to evaluate each of the WHEN clauses in turn; as
                 * soon as one is true we return the value of the
                 * corresponding THEN clause.  If none are true then we return
                 * the value of the ELSE clause, or NULL if there is none.
                 */</comment>
                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>caseExpr-&gt;args</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>CaseWhen</name>   <modifier>*</modifier></type><name>when</name> <init>= <expr><operator>(</operator><name>CaseWhen</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>save_innermost_caseval</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>save_innermost_casenull</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type>            <name>whenstep</name></decl>;</decl_stmt>

                    <comment type="block">/*
                     * Make testexpr result available to CaseTestExpr nodes
                     * within the condition.  We must save and restore prior
                     * setting of innermost_caseval fields, in case this node
                     * is itself within a larger CASE.
                     *
                     * If there's no test expression, we don't actually need
                     * to save and restore these fields; but it's less code to
                     * just do so unconditionally.
                     */</comment>
                    <expr_stmt><expr><name>save_innermost_caseval</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_caseval</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>save_innermost_casenull</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_casenull</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_caseval</name></name> <operator>=</operator> <name>caseval</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_casenull</name></name> <operator>=</operator> <name>casenull</name></expr>;</expr_stmt>

                    <comment type="block">/* evaluate condition into CASE's result variables */</comment>
                    <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>when</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_caseval</name></name> <operator>=</operator> <name>save_innermost_caseval</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_casenull</name></name> <operator>=</operator> <name>save_innermost_casenull</name></expr>;</expr_stmt>

                    <comment type="block">/* If WHEN result isn't true, jump to next CASE arm */</comment>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_JUMP_IF_NOT_TRUE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* computed later */</comment>
                    <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>whenstep</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

                    <comment type="block">/*
                     * If WHEN result is true, evaluate THEN result, storing
                     * it into the CASE's result variables.
                     */</comment>
                    <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>when</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* Emit JUMP step to jump to end of CASE's code */</comment>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_JUMP</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* computed later */</comment>
                    <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * Don't know address for that jump yet, compute once the
                     * whole CASE expression is built.
                     */</comment>
                    <expr_stmt><expr><name>adjust_jumps</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>adjust_jumps</name></expr></argument>,
                                               <argument><expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * But we can set WHEN test's jump target now, to make it
                     * jump to the next WHEN subexpression or the ELSE.
                     */</comment>
                    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><name>whenstep</name></expr>]</index></name><operator>.</operator><name><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</expr_stmt>
                </block_content>}</block>

                <comment type="block">/* transformCaseExpr always adds a default */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>caseExpr</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* evaluate ELSE expr into CASE's result variables */</comment>
                <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>caseExpr</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                                <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* adjust jump targets */</comment>
                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>adjust_jumps</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>as</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>opcode</name></name> <operator>==</operator> <name>EEOP_JUMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</expr_stmt>
                </block_content>}</block>

                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
            <block>{<block_content>
                <comment type="block">/*
                 * Read from location identified by innermost_caseval.  Note
                 * that innermost_caseval could be NULL, if this node isn't
                 * actually within a CASE structure; some parts of the system
                 * abuse CaseTestExpr to cause a read of a value externally
                 * supplied in econtext-&gt;caseValue_datum.  We'll take care of
                 * that scenario at runtime.
                 */</comment>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_CASE_TESTVAL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>casetest</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_caseval</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>casetest</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_casenull</name></name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_ArrayExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ArrayExpr</name>  <modifier>*</modifier></type><name>arrayexpr</name> <init>= <expr><operator>(</operator><name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>nelems</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>arrayexpr</name><operator>-&gt;</operator><name>elements</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>elemoff</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * Evaluate by computing each element, and then forming the
                 * array.  Elements are computed into scratch arrays
                 * associated with the ARRAYEXPR step.
                 */</comment>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ARRAYEXPR</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elemvalues</name></name> <operator>=</operator>
                    <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elemnulls</name></name> <operator>=</operator>
                    <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>nelems</name></name> <operator>=</operator> <name>nelems</name></expr>;</expr_stmt>

                <comment type="block">/* fill remaining fields of step */</comment>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>multidims</name></name> <operator>=</operator> <name><name>arrayexpr</name><operator>-&gt;</operator><name>multidims</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elemtype</name></name> <operator>=</operator> <name><name>arrayexpr</name><operator>-&gt;</operator><name>element_typeid</name></name></expr>;</expr_stmt>

                <comment type="block">/* do one-time catalog lookup for type info */</comment>
                <expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name><name>arrayexpr</name><operator>-&gt;</operator><name>element_typeid</name></name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elemlength</name></name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elembyval</name></name></expr></argument>,
                                     <argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elemalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* prepare to evaluate all arguments */</comment>
                <expr_stmt><expr><name>elemoff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>arrayexpr-&gt;elements</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elemvalues</name><index>[<expr><name>elemoff</name></expr>]</index></name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>arrayexpr</name><operator>.</operator><name>elemnulls</name><index>[<expr><name>elemoff</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>elemoff</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block>

                <comment type="block">/* and then collect all into an array */</comment>
                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_RowExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>rowexpr</name> <init>= <expr><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>nelems</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Form_pg_attribute</name> <modifier>*</modifier></type><name>attrs</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

                <comment type="block">/* Build tupdesc to describe result tuples */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_typeid</name></name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* generic record, use types of given expressions */</comment>
                    <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>ExecTypeFromExprList</name><argument_list>(<argument><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* it's been cast to a named type, use that */</comment>
                    <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc_copy</name><argument_list>(<argument><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>row_typeid</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <comment type="block">/* In either case, adopt RowExpr's column aliases */</comment>
                <expr_stmt><expr><call><name>ExecTypeSetColNames</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name><name>rowexpr</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* Bless the tupdesc in case it's now of type RECORD */</comment>
                <expr_stmt><expr><call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * In the named-type case, the tupdesc could have more columns
                 * than are in the args list, since the type might have had
                 * columns added since the ROW() was parsed.  We want those
                 * extra columns to go to nulls, so we make sure that the
                 * workspace arrays are large enough and then initialize any
                 * extra columns to read as NULLs.
                 */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nelems</name> <operator>&lt;=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>nelems</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>nelems</name></expr></argument>, <argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Evaluate by first building datums for each field, and then
                 * a final step forming the composite datum.
                 */</comment>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ROW</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>row</name><operator>.</operator><name>tupdesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

                <comment type="block">/* space for the individual field datums */</comment>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>row</name><operator>.</operator><name>elemvalues</name></name> <operator>=</operator>
                    <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>row</name><operator>.</operator><name>elemnulls</name></name> <operator>=</operator>
                    <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* as explained above, make sure any extra columns are null */</comment>
                <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>row</name><operator>.</operator><name>elemnulls</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Set up evaluation, skipping any deleted columns */</comment>
                <expr_stmt><expr><name>attrs</name> <operator>=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>rowexpr-&gt;args</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>attisdropped</name></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * Guard against ALTER COLUMN TYPE on rowtype since
                         * the RowExpr was created.  XXX should we check
                         * typmod too?    Not sure we can be sure it'll be the
                         * same.
                         */</comment>
                        <if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>e</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ROW() column has type %s instead of type %s"</literal></expr></argument>,
                                            <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="block">/*
                         * Ignore original expression and insert a NULL. We
                         * don't really care what type of NULL it is, so
                         * always make an int4 NULL.
                         */</comment>
                        <expr_stmt><expr><name>e</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>

                    <comment type="block">/* Evaluate column expr into appropriate workspace slot */</comment>
                    <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>row</name><operator>.</operator><name>elemvalues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>row</name><operator>.</operator><name>elemnulls</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block>

                <comment type="block">/* And finally build the row value */</comment>
                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>rcexpr</name> <init>= <expr><operator>(</operator><name>RowCompareExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>nopers</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>opnos</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>adjust_jumps</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l_left_expr</name></decl>,
                           <decl><type ref="prev"><modifier>*</modifier></type><name>l_right_expr</name></decl>,
                           <decl><type ref="prev"><modifier>*</modifier></type><name>l_opno</name></decl>,
                           <decl><type ref="prev"><modifier>*</modifier></type><name>l_opfamily</name></decl>,
                           <decl><type ref="prev"><modifier>*</modifier></type><name>l_inputcollid</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>off</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * Iterate over each field, prepare comparisons.  To handle
                 * NULL results, prepare jumps to after the expression.  If a
                 * comparison yields a != 0 result, jump to the final step.
                 */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>largs</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>nopers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>rargs</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>nopers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>opfamilies</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>nopers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>inputcollids</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>nopers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <for>for <control>(<init><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator>
                     <expr><name>l_left_expr</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>largs</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator>
                     <expr><name>l_right_expr</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>rargs</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator>
                     <expr><name>l_opno</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>opnos</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator>
                     <expr><name>l_opfamily</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>opfamilies</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator>
                     <expr><name>l_inputcollid</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>inputcollids</name></name></expr></argument>)</argument_list></call></expr>;</init>
                     <condition><expr><name>off</name> <operator>&lt;</operator> <name>nopers</name></expr>;</condition>
                     <incr><expr><name>off</name><operator>++</operator></expr><operator>,</operator>
                     <expr><name>l_left_expr</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>l_left_expr</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
                     <expr><name>l_right_expr</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>l_right_expr</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
                     <expr><name>l_opno</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>l_opno</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
                     <expr><name>l_opfamily</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>l_opfamily</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
                     <expr><name>l_inputcollid</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>l_inputcollid</name></expr></argument>)</argument_list></call></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>left_expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l_left_expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>right_expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l_right_expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Oid</name></type>            <name>opno</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l_opno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Oid</name></type>            <name>opfamily</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l_opfamily</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Oid</name></type>            <name>inputcollid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l_inputcollid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type>            <name>strategy</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Oid</name></type>            <name>lefttype</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Oid</name></type>            <name>righttype</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Oid</name></type>            <name>proc</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>finfo</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>get_op_opfamily_properties</name><argument_list>(<argument><expr><name>opno</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                               <argument><expr><operator>&amp;</operator><name>strategy</name></expr></argument>,
                                               <argument><expr><operator>&amp;</operator><name>lefttype</name></expr></argument>,
                                               <argument><expr><operator>&amp;</operator><name>righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
                                             <argument><expr><name>lefttype</name></expr></argument>,
                                             <argument><expr><name>righttype</name></expr></argument>,
                                             <argument><expr><name>BTORDER_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing support function %d(%u,%u) in opfamily %u"</literal></expr></argument>,
                             <argument><expr><name>BTORDER_PROC</name></expr></argument>, <argument><expr><name>lefttype</name></expr></argument>, <argument><expr><name>righttype</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                    <comment type="block">/* Set up the primary fmgr lookup information */</comment>
                    <expr_stmt><expr><name>finfo</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>fcinfo</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FunctionCallInfoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
                                             <argument><expr><name>inputcollid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * If we enforced permissions checks on index support
                     * functions, we'd need to make a check here.  But the
                     * index support machinery doesn't do that, and thus
                     * neither does this code.
                     */</comment>

                    <comment type="block">/* evaluate left and right args directly into fcinfo */</comment>
                    <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>left_expr</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>right_expr</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ROWCOMPARE_STEP</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>finfo</name></name> <operator>=</operator> <name>finfo</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>fcinfo_data</name></name> <operator>=</operator> <name>fcinfo</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>fn_addr</name></name> <operator>=</operator> <name><name>finfo</name><operator>-&gt;</operator><name>fn_addr</name></name></expr>;</expr_stmt>
                    <comment type="block">/* jump targets filled below */</comment>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>jumpnull</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>adjust_jumps</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>adjust_jumps</name></expr></argument>,
                                               <argument><expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>

                <comment type="block">/*
                 * We could have a zero-column rowtype, in which case the rows
                 * necessarily compare equal.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>nopers</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_CONST</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>constval</name><operator>.</operator><name>value</name></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>constval</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* Finally, examine the last comparison result */</comment>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ROWCOMPARE_FINAL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>rowcompare_final</name><operator>.</operator><name>rctype</name></name> <operator>=</operator> <name><name>rcexpr</name><operator>-&gt;</operator><name>rctype</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* adjust jump targetss */</comment>
                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>adjust_jumps</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>as</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>opcode</name></name> <operator>==</operator> <name>EEOP_ROWCOMPARE_STEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>jumpdone</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>jumpnull</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* jump to comparison evaluation */</comment>
                    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                    <comment type="block">/* jump to the following expression */</comment>
                    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>rowcompare_step</name><operator>.</operator><name>jumpnull</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</expr_stmt>
                </block_content>}</block>

                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>coalesce</name> <init>= <expr><operator>(</operator><name>CoalesceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>adjust_jumps</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

                <comment type="block">/* We assume there's at least one arg */</comment>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>coalesce</name><operator>-&gt;</operator><name>args</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Prepare evaluation of all coalesced arguments, after each
                 * one push a step that short-circuits if not null.
                 */</comment>
                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>coalesce-&gt;args</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="block">/* evaluate argument, directly into result datum */</comment>
                    <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* if it's not null, skip to end of COALESCE expr */</comment>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_JUMP_IF_NOT_NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* adjust later */</comment>
                    <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>adjust_jumps</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>adjust_jumps</name></expr></argument>,
                                               <argument><expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block>

                <comment type="block">/*
                 * No need to add a constant NULL return - we only can get to
                 * the end of the expression if a NULL already is being
                 * returned.
                 */</comment>

                <comment type="block">/* adjust jump targets */</comment>
                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>adjust_jumps</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>as</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>opcode</name></name> <operator>==</operator> <name>EEOP_JUMP_IF_NOT_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</expr_stmt>
                </block_content>}</block>

                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>MinMaxExpr</name> <modifier>*</modifier></type><name>minmaxexpr</name> <init>= <expr><operator>(</operator><name>MinMaxExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>nelems</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>minmaxexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>finfo</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>off</name></decl>;</decl_stmt>

                <comment type="block">/* Look up the btree comparison function for the datatype */</comment>
                <expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>minmaxexpr</name><operator>-&gt;</operator><name>minmaxtype</name></name></expr></argument>,
                                             <argument><expr><name>TYPECACHE_CMP_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not identify a comparison function for type %s"</literal></expr></argument>,
                                    <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>minmaxexpr</name><operator>-&gt;</operator><name>minmaxtype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * If we enforced permissions checks on index support
                 * functions, we'd need to make a check here.  But the index
                 * support machinery doesn't do that, and thus neither does
                 * this code.
                 */</comment>

                <comment type="block">/* Perform function lookup */</comment>
                <expr_stmt><expr><name>finfo</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>fcinfo</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FunctionCallInfoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc</name></name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>finfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
                                         <argument><expr><name><name>minmaxexpr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_MINMAX</name></expr>;</expr_stmt>
                <comment type="block">/* allocate space to store arguments */</comment>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>minmax</name><operator>.</operator><name>values</name></name> <operator>=</operator>
                    <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>minmax</name><operator>.</operator><name>nulls</name></name> <operator>=</operator>
                    <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nelems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>minmax</name><operator>.</operator><name>nelems</name></name> <operator>=</operator> <name>nelems</name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>minmax</name><operator>.</operator><name>op</name></name> <operator>=</operator> <name><name>minmaxexpr</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>minmax</name><operator>.</operator><name>finfo</name></name> <operator>=</operator> <name>finfo</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>minmax</name><operator>.</operator><name>fcinfo_data</name></name> <operator>=</operator> <name>fcinfo</name></expr>;</expr_stmt>

                <comment type="block">/* evaluate expressions into minmax-&gt;values/nulls */</comment>
                <expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>minmaxexpr-&gt;args</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>minmax</name><operator>.</operator><name>values</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>minmax</name><operator>.</operator><name>nulls</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block>

                <comment type="block">/* and push the final comparison */</comment>
                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>SQLValueFunction</name> <modifier>*</modifier></type><name>svf</name> <init>= <expr><operator>(</operator><name>SQLValueFunction</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_SQLVALUEFUNCTION</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>sqlvaluefunction</name><operator>.</operator><name>svf</name></name> <operator>=</operator> <name>svf</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_XmlExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>XmlExpr</name>    <modifier>*</modifier></type><name>xexpr</name> <init>= <expr><operator>(</operator><name>XmlExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>nnamed</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>named_args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>nargs</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type>            <name>off</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_XMLEXPR</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>xexpr</name></name> <operator>=</operator> <name>xexpr</name></expr>;</expr_stmt>

                <comment type="block">/* allocate space for storing all the arguments */</comment>
                <if_stmt><if>if <condition>(<expr><name>nnamed</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>named_argvalue</name></name> <operator>=</operator>
                        <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nnamed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>named_argnull</name></name> <operator>=</operator>
                        <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nnamed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>named_argvalue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>named_argnull</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>nargs</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argvalue</name></name> <operator>=</operator>
                        <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argnull</name></name> <operator>=</operator>
                        <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argvalue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argnull</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <comment type="block">/* prepare argument execution */</comment>
                <expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>xexpr-&gt;named_args</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>named_argvalue</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>named_argnull</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block>

                <expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>xexpr-&gt;args</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argvalue</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>xmlexpr</name><operator>.</operator><name>argnull</name><index>[<expr><name>off</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt>
                </block_content>}</block>

                <comment type="block">/* and evaluate the actual XML expression */</comment>
                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_NullTest</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>ntest</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>==</operator> <name>IS_NULL</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>ntest</name><operator>-&gt;</operator><name>argisrow</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_NULLTEST_ROWISNULL</name></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_NULLTEST_ISNULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>==</operator> <name>IS_NOT_NULL</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>ntest</name><operator>-&gt;</operator><name>argisrow</name></name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_NULLTEST_ROWISNOTNULL</name></expr>;</expr_stmt></block_content></block></if>
                    <else>else<block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_NULLTEST_ISNOTNULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized nulltesttype: %d"</literal></expr></argument>,
                         <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>ntest</name><operator>-&gt;</operator><name>nulltesttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
                <comment type="block">/* initialize cache in case it's a row test */</comment>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>nulltest_row</name><operator>.</operator><name>argdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <comment type="block">/* first evaluate argument into result variable */</comment>
                <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>ntest</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                                <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* then push the test of that argument */</comment>
                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_BooleanTest</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>btest</name> <init>= <expr><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/*
                 * Evaluate argument, directly into result datum.  That's ok,
                 * because resv/resnull is definitely not used anywhere else,
                 * and will get overwritten by the below EEOP_BOOLTEST_IS_*
                 * step.
                 */</comment>
                <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>btest</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <switch>switch <condition>(<expr><name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name></expr>)</condition>
                <block>{<block_content>
                    <case>case <expr><name>IS_TRUE</name></expr>:</case>
                        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_BOOLTEST_IS_TRUE</name></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>IS_NOT_TRUE</name></expr>:</case>
                        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_BOOLTEST_IS_NOT_TRUE</name></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>IS_FALSE</name></expr>:</case>
                        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_BOOLTEST_IS_FALSE</name></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>IS_NOT_FALSE</name></expr>:</case>
                        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_BOOLTEST_IS_NOT_FALSE</name></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>IS_UNKNOWN</name></expr>:</case>
                        <comment type="block">/* Same as scalar IS NULL test */</comment>
                        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_NULLTEST_ISNULL</name></expr>;</expr_stmt>
                        <break>break;</break>
                    <case>case <expr><name>IS_NOT_UNKNOWN</name></expr>:</case>
                        <comment type="block">/* Same as scalar IS NOT NULL test */</comment>
                        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_NULLTEST_ISNOTNULL</name></expr>;</expr_stmt>
                        <break>break;</break>
                    <default>default:</default>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized booltesttype: %d"</literal></expr></argument>,
                             <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></switch>

                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>ctest</name> <init>= <expr><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>ExecInitCoerceToDomain</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>, <argument><expr><name>ctest</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                                       <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
            <block>{<block_content>
                <comment type="block">/*
                 * Read from location identified by innermost_domainval.  Note
                 * that innermost_domainval could be NULL, if we're compiling
                 * a standalone domain check rather than one embedded in a
                 * larger expression.  In that case we must read from
                 * econtext-&gt;domainValue_datum.  We'll take care of that
                 * scenario at runtime.
                 */</comment>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_DOMAIN_TESTVAL</name></expr>;</expr_stmt>
                <comment type="block">/* we share instruction union variant with case testval */</comment>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>casetest</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_domainval</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>casetest</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_domainnull</name></name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
            <block>{<block_content>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_CURRENTOFEXPR</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <case>case <expr><name>T_NextValueExpr</name></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>NextValueExpr</name> <modifier>*</modifier></type><name>nve</name> <init>= <expr><operator>(</operator><name>NextValueExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_NEXTVALUEEXPR</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>nextvalueexpr</name><operator>.</operator><name>seqid</name></name> <operator>=</operator> <name><name>nve</name><operator>-&gt;</operator><name>seqid</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>nextvalueexpr</name><operator>.</operator><name>seqtypid</name></name> <operator>=</operator> <name><name>nve</name><operator>-&gt;</operator><name>typeId</name></name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
                 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Add another expression evaluation step to ExprState-&gt;steps.
 *
 * Note that this potentially re-allocates es-&gt;steps, therefore no pointer
 * into that array may be used while the expression is still being built.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExprEvalPushStep</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>es</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExprEvalStep</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>steps_alloc</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>steps_alloc</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>steps</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExprEvalStep</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>es</name><operator>-&gt;</operator><name>steps_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>es</name><operator>-&gt;</operator><name>steps_alloc</name></name> <operator>==</operator> <name><name>es</name><operator>-&gt;</operator><name>steps_len</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>steps_alloc</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>es</name><operator>-&gt;</operator><name>steps</name></name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>es</name><operator>-&gt;</operator><name>steps</name></name></expr></argument>,
                             <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExprEvalStep</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>es</name><operator>-&gt;</operator><name>steps_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>es</name><operator>-&gt;</operator><name>steps</name><index>[<expr><name><name>es</name><operator>-&gt;</operator><name>steps_len</name></name><operator>++</operator></expr>]</index></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ExprEvalStep</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Perform setup necessary for the evaluation of a function-like expression,
 * appending argument evaluation steps to the steps list in *state, and
 * setting up *scratch so it is ready to be pushed.
 *
 * *scratch is not pushed here, so that callers may override the opcode,
 * which is useful for function-like cases like DISTINCT.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecInitFunc</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>,
             <parameter><decl><type><name>Oid</name></type> <name>inputcollid</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>nargs</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AclResult</name></type>    <name>aclresult</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FmgrInfo</name>   <modifier>*</modifier></type><name>flinfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>argno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* Check permission to call function */</comment>
    <expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_proc_aclcheck</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>ACL_KIND_PROC</name></expr></argument>, <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>InvokeFunctionExecuteHook</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Safety check on nargs.  Under normal circumstances this should never
     * fail, as parser should check sooner.  But possibly it might fail if
     * server has been compiled with FUNC_MAX_ARGS smaller than some functions
     * declared in pg_proc?
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <name>FUNC_MAX_ARGS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_ARGUMENTS</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"cannot pass more than %d argument to a function"</literal></expr></argument>,
                               <argument><expr><literal type="string">"cannot pass more than %d arguments to a function"</literal></expr></argument>,
                               <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>,
                               <argument><expr><name>FUNC_MAX_ARGS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Allocate function lookup data and parameter workspace for this call */</comment>
    <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>finfo</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FmgrInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fcinfo_data</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FunctionCallInfoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>flinfo</name> <operator>=</operator> <name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>finfo</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>fcinfo</name> <operator>=</operator> <name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fcinfo_data</name></name></expr>;</expr_stmt>

    <comment type="block">/* Set up the primary fmgr lookup information */</comment>
    <expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>, <argument><expr><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fmgr_info_set_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>flinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Initialize function call parameter structure too */</comment>
    <expr_stmt><expr><call><name>InitFunctionCallInfoData</name><argument_list>(<argument><expr><operator>*</operator><name>fcinfo</name></expr></argument>, <argument><expr><name>flinfo</name></expr></argument>,
                             <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>inputcollid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Keep extra copies of this info to save an indirection at runtime */</comment>
    <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>fn_addr</name></name> <operator>=</operator> <name><name>flinfo</name><operator>-&gt;</operator><name>fn_addr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>func</name><operator>.</operator><name>nargs</name></name> <operator>=</operator> <name>nargs</name></expr>;</expr_stmt>

    <comment type="block">/* We only support non-set functions here */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_retset</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <ternary><condition><expr><name>parent</name></expr> ?</condition><then> <expr><call><name>executor_errposition</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>state</name></name></expr></argument>,
                                               <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Build code to evaluate arguments directly into the fcinfo struct */</comment>
    <expr_stmt><expr><name>argno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>args</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Don't evaluate const arguments every round; especially
             * interesting for constants in comparisons.
             */</comment>
            <decl_stmt><decl><type><name>Const</name>       <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><name>argno</name></expr>]</index></name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><name>argno</name></expr>]</index></name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><name>argno</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><name>argno</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>argno</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* Insert appropriate opcode depending on strictness and stats level */</comment>
    <if_stmt><if>if <condition>(<expr><name>pgstat_track_functions</name> <operator>&lt;=</operator> <name><name>flinfo</name><operator>-&gt;</operator><name>fn_stats</name></name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_strict</name></name> <operator>&amp;&amp;</operator> <name>nargs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_FUNCEXPR_STRICT</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_FUNCEXPR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>flinfo</name><operator>-&gt;</operator><name>fn_strict</name></name> <operator>&amp;&amp;</operator> <name>nargs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_FUNCEXPR_STRICT_FUSAGE</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_FUNCEXPR_FUSAGE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add expression steps deforming the ExprState's inner/outer/scan slots
 * as much as required by the expression.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecInitExprSlots</name><parameter_list>(<parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>LastAttnumInfo</name></type> <name>info</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>scratch</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Figure out which attributes we're going to need.
     */</comment>
    <expr_stmt><expr><call><name>get_last_attnums_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Emit steps as needed */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>last_inner</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_INNER_FETCHSOME</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>last_var</name></name> <operator>=</operator> <name><name>info</name><operator>.</operator><name>last_inner</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>last_outer</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_OUTER_FETCHSOME</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>last_var</name></name> <operator>=</operator> <name><name>info</name><operator>.</operator><name>last_outer</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>info</name><operator>.</operator><name>last_scan</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_SCAN_FETCHSOME</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scratch</name><operator>.</operator><name>d</name><operator>.</operator><name>fetch</name><operator>.</operator><name>last_var</name></name> <operator>=</operator> <name><name>info</name><operator>.</operator><name>last_scan</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_last_attnums_walker: expression walker for ExecInitExprSlots
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>get_last_attnums_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>LastAttnumInfo</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Var</name>           <modifier>*</modifier></type><name>variable</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attnum</name> <init>= <expr><name><name>variable</name><operator>-&gt;</operator><name>varattno</name></name></expr></init></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name><name>variable</name><operator>-&gt;</operator><name>varno</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>INNER_VAR</name></expr>:</case>
                <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>last_inner</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>last_inner</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>OUTER_VAR</name></expr>:</case>
                <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>last_outer</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>last_outer</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

                <comment type="block">/* INDEX_VAR is handled by default case */</comment>

            <default>default:</default>
                <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>last_scan</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>last_scan</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Don't examine the arguments or filters of Aggrefs or WindowFuncs,
     * because those do not represent expressions to be evaluated within the
     * calling expression's econtext.  GroupingFunc arguments are never
     * evaluated at all.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>get_last_attnums_walker</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>info</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare step for the evaluation of a whole-row variable.
 * The caller still has to push the step.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecInitWholeRowVar</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>variable</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* fill in all but the target */</comment>
    <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_WHOLEROW</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>var</name></name> <operator>=</operator> <name>variable</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>first</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>slow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>tupdesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* filled at runtime */</comment>
    <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>junkFilter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * If the input tuple came from a subquery, it might contain "resjunk"
     * columns (such as GROUP BY or ORDER BY columns), which we don't want to
     * keep in the whole-row result.  We can get rid of such columns by
     * passing the tuple through a JunkFilter --- but to make one, we have to
     * lay our hands on the subquery's targetlist.  Fortunately, there are not
     * very many cases where this can happen, and we can identify all of them
     * by examining our parent PlanState.  We assume this is not an issue in
     * standalone expressions that don't have parent plans.  (Whole-row Vars
     * can occur in such expressions, but they will always be referencing
     * table rows.)
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>parent</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>PlanState</name>  <modifier>*</modifier></type><name>subplan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>T_SubqueryScanState</name></expr>:</case>
                <expr_stmt><expr><name>subplan</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SubqueryScanState</name> <operator>*</operator><operator>)</operator> <name>parent</name><operator>)</operator><operator>-&gt;</operator><name>subplan</name></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>T_CteScanState</name></expr>:</case>
                <expr_stmt><expr><name>subplan</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>CteScanState</name> <operator>*</operator><operator>)</operator> <name>parent</name><operator>)</operator><operator>-&gt;</operator><name>cteplanstate</name></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <break>break;</break>
        </block_content>}</block></switch>

        <if_stmt><if>if <condition>(<expr><name>subplan</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>bool</name></type>        <name>junk_filter_needed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>

            <comment type="block">/* Detect whether subplan tlist actually has any junk columns */</comment>
            <macro><name>foreach</name><argument_list>(<argument>tlist</argument>, <argument>subplan-&gt;plan-&gt;targetlist</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>junk_filter_needed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>

            <comment type="block">/* If so, build the junkfilter now */</comment>
            <if_stmt><if>if <condition>(<expr><name>junk_filter_needed</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>wholerow</name><operator>.</operator><name>junkFilter</name></name> <operator>=</operator>
                    <call><name>ExecInitJunkFilter</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>plan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>,
                                       <argument><expr><call><name>ExecGetResultType</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>tdhasoid</name></expr></argument>,
                                       <argument><expr><call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare evaluation of an ArrayRef expression.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecInitArrayRef</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>ArrayRef</name> <modifier>*</modifier></type><name>aref</name></decl></parameter>, <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,
                 <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resv</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resnull</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>bool</name></type>        <name>isAssignment</name> <init>= <expr><operator>(</operator><name><name>aref</name><operator>-&gt;</operator><name>refassgnexpr</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArrayRefState</name> <modifier>*</modifier></type><name>arefstate</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ArrayRefState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>adjust_jumps</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Fill constant fields of ArrayRefState */</comment>
    <expr_stmt><expr><name><name>arefstate</name><operator>-&gt;</operator><name>isassignment</name></name> <operator>=</operator> <name>isAssignment</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refelemtype</name></name> <operator>=</operator> <name><name>aref</name><operator>-&gt;</operator><name>refelemtype</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>arefstate</name><operator>-&gt;</operator><name>refattrlength</name></name> <operator>=</operator> <call><name>get_typlen</name><argument_list>(<argument><expr><name><name>aref</name><operator>-&gt;</operator><name>refarraytype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name><name>aref</name><operator>-&gt;</operator><name>refelemtype</name></name></expr></argument>,
                         <argument><expr><operator>&amp;</operator><name><name>arefstate</name><operator>-&gt;</operator><name>refelemlength</name></name></expr></argument>,
                         <argument><expr><operator>&amp;</operator><name><name>arefstate</name><operator>-&gt;</operator><name>refelembyval</name></name></expr></argument>,
                         <argument><expr><operator>&amp;</operator><name><name>arefstate</name><operator>-&gt;</operator><name>refelemalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Evaluate array input.  It's safe to do so into resv/resnull, because we
     * won't use that as target for any of the other subexpressions, and it'll
     * be overwritten by the final EEOP_ARRAYREF_FETCH/ASSIGN step, which is
     * pushed last.
     */</comment>
    <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>aref</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If refexpr yields NULL, and it's a fetch, then result is NULL.  We can
     * implement this with just JUMP_IF_NULL, since we evaluated the array
     * into the desired target location.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>isAssignment</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_JUMP_IF_NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* adjust later */</comment>
        <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>adjust_jumps</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>adjust_jumps</name></expr></argument>,
                                   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Verify subscript list lengths are within limit */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>aref</name><operator>-&gt;</operator><name>refupperindexpr</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAXDIM</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of array dimensions (%d) exceeds the maximum allowed (%d)"</literal></expr></argument>,
                        <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>aref</name><operator>-&gt;</operator><name>refupperindexpr</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAXDIM</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>aref</name><operator>-&gt;</operator><name>reflowerindexpr</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAXDIM</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of array dimensions (%d) exceeds the maximum allowed (%d)"</literal></expr></argument>,
                        <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>aref</name><operator>-&gt;</operator><name>reflowerindexpr</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAXDIM</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Evaluate upper subscripts */</comment>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>aref-&gt;refupperindexpr</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* When slicing, individual subscript bounds can be omitted */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>e</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>arefstate</name><operator>-&gt;</operator><name>upperprovided</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>arefstate</name><operator>-&gt;</operator><name>upperprovided</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <comment type="block">/* Each subscript is evaluated into subscriptvalue/subscriptnull */</comment>
        <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name><name>arefstate</name><operator>-&gt;</operator><name>subscriptvalue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arefstate</name><operator>-&gt;</operator><name>subscriptnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* ... and then ARRAYREF_SUBSCRIPT saves it into step's workspace */</comment>
        <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ARRAYREF_SUBSCRIPT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayref_subscript</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>arefstate</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayref_subscript</name><operator>.</operator><name>off</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayref_subscript</name><operator>.</operator><name>isupper</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayref_subscript</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* adjust later */</comment>
        <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>adjust_jumps</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>adjust_jumps</name></expr></argument>,
                                   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><name><name>arefstate</name><operator>-&gt;</operator><name>numupper</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

    <comment type="block">/* Evaluate lower subscripts similarly */</comment>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>aref-&gt;reflowerindexpr</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name>       <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* When slicing, individual subscript bounds can be omitted */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>e</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>arefstate</name><operator>-&gt;</operator><name>lowerprovided</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>arefstate</name><operator>-&gt;</operator><name>lowerprovided</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <comment type="block">/* Each subscript is evaluated into subscriptvalue/subscriptnull */</comment>
        <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name><name>arefstate</name><operator>-&gt;</operator><name>subscriptvalue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arefstate</name><operator>-&gt;</operator><name>subscriptnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* ... and then ARRAYREF_SUBSCRIPT saves it into step's workspace */</comment>
        <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ARRAYREF_SUBSCRIPT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayref_subscript</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>arefstate</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayref_subscript</name><operator>.</operator><name>off</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayref_subscript</name><operator>.</operator><name>isupper</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayref_subscript</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>    <comment type="block">/* adjust later */</comment>
        <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>adjust_jumps</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>adjust_jumps</name></expr></argument>,
                                   <argument><expr><name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>
    <expr_stmt><expr><name><name>arefstate</name><operator>-&gt;</operator><name>numlower</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

    <comment type="block">/* Should be impossible if parser is sane, but check anyway: */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>arefstate</name><operator>-&gt;</operator><name>numlower</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
        <name><name>arefstate</name><operator>-&gt;</operator><name>numupper</name></name> <operator>!=</operator> <name><name>arefstate</name><operator>-&gt;</operator><name>numlower</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"upper and lower index lists are not same length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>isAssignment</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>save_innermost_caseval</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>save_innermost_casenull</name></decl>;</decl_stmt>

        <comment type="block">/*
         * We might have a nested-assignment situation, in which the
         * refassgnexpr is itself a FieldStore or ArrayRef that needs to
         * obtain and modify the previous value of the array element or slice
         * being replaced.  If so, we have to extract that value from the
         * array and pass it down via the CaseTestExpr mechanism.  It's safe
         * to reuse the CASE mechanism because there cannot be a CASE between
         * here and where the value would be needed, and an array assignment
         * can't be within a CASE either.  (So saving and restoring
         * innermost_caseval is just paranoia, but let's do it anyway.)
         *
         * Since fetching the old element might be a nontrivial expense, do it
         * only if the argument actually needs it.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>isAssignmentIndirectionExpr</name><argument_list>(<argument><expr><name><name>aref</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ARRAYREF_OLD</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayref</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>arefstate</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* ARRAYREF_OLD puts extracted value into prevvalue/prevnull */</comment>
        <expr_stmt><expr><name>save_innermost_caseval</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_caseval</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>save_innermost_casenull</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_casenull</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_caseval</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>arefstate</name><operator>-&gt;</operator><name>prevvalue</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_casenull</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>arefstate</name><operator>-&gt;</operator><name>prevnull</name></name></expr>;</expr_stmt>

        <comment type="block">/* evaluate replacement value into replacevalue/replacenull */</comment>
        <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>aref</name><operator>-&gt;</operator><name>refassgnexpr</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                        <argument><expr><operator>&amp;</operator><name><name>arefstate</name><operator>-&gt;</operator><name>replacevalue</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>arefstate</name><operator>-&gt;</operator><name>replacenull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_caseval</name></name> <operator>=</operator> <name>save_innermost_caseval</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_casenull</name></name> <operator>=</operator> <name>save_innermost_casenull</name></expr>;</expr_stmt>

        <comment type="block">/* and perform the assignment */</comment>
        <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ARRAYREF_ASSIGN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayref</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>arefstate</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* array fetch is much simpler */</comment>
        <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_ARRAYREF_FETCH</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayref</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>arefstate</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* adjust jump targets */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>adjust_jumps</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>as</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>steps</name><index>[<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>opcode</name></name> <operator>==</operator> <name>EEOP_ARRAYREF_SUBSCRIPT</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayref_subscript</name><operator>.</operator><name>jumpdone</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>arrayref_subscript</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>opcode</name></name> <operator>==</operator> <name>EEOP_JUMP_IF_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>as</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>jump</name><operator>.</operator><name>jumpdone</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>steps_len</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Helper for preparing ArrayRef expressions for evaluation: is expr a nested
 * FieldStore or ArrayRef that needs the old element value passed down?
 *
 * (We could use this in FieldStore too, but in that case passing the old
 * value is so cheap there's no need.)
 *
 * Note: it might seem that this needs to recurse, but it does not; the
 * CaseTestExpr, if any, will be directly the arg or refexpr of the top-level
 * node.  Nested-assignment situations give rise to expression trees in which
 * each level of assignment has its own CaseTestExpr, and the recursive
 * structure appears within the newvals or refassgnexpr field.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isAssignmentIndirectionExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* just paranoia */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>FieldStore</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>FieldStore</name> <modifier>*</modifier></type><name>fstore</name> <init>= <expr><operator>(</operator><name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>fstore</name><operator>-&gt;</operator><name>arg</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>fstore</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>ArrayRef</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ArrayRef</name>   <modifier>*</modifier></type><name>arrayRef</name> <init>= <expr><operator>(</operator><name>ArrayRef</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>arrayRef</name><operator>-&gt;</operator><name>refexpr</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>arrayRef</name><operator>-&gt;</operator><name>refexpr</name></name></expr></argument>, <argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare evaluation of a CoerceToDomain expression.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ExecInitCoerceToDomain</name><parameter_list>(<parameter><decl><type><name>ExprEvalStep</name> <modifier>*</modifier></type><name>scratch</name></decl></parameter>, <parameter><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>ctest</name></decl></parameter>,
                       <parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>ExprState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
                       <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>resv</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>resnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExprEvalStep</name></type> <name>scratch2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DomainConstraintRef</name> <modifier>*</modifier></type><name>constraint_ref</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>domainval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>domainnull</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name>       <modifier>*</modifier></type><name>save_innermost_domainval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name>       <modifier>*</modifier></type><name>save_innermost_domainnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>resulttype</name></name> <operator>=</operator> <name><name>ctest</name><operator>-&gt;</operator><name>resulttype</name></name></expr>;</expr_stmt>
    <comment type="block">/* we'll allocate workspace only if needed */</comment>
    <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>checkvalue</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>checknull</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Evaluate argument - it's fine to directly store it into resv/resnull,
     * if there's constraint failures there'll be errors, otherwise it's what
     * needs to be returned.
     */</comment>
    <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>ctest</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>resv</name></expr></argument>, <argument><expr><name>resnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Note: if the argument is of varlena type, it could be a R/W expanded
     * object.  We want to return the R/W pointer as the final result, but we
     * have to pass a R/O pointer as the value to be tested by any functions
     * in check expressions.  We don't bother to emit a MAKE_READONLY step
     * unless there's actually at least one check expression, though.  Until
     * we've tested that, domainval/domainnull are NULL.
     */</comment>

    <comment type="block">/*
     * Collect the constraints associated with the domain.
     *
     * Note: before PG v10 we'd recheck the set of constraints during each
     * evaluation of the expression.  Now we bake them into the ExprState
     * during executor initialization.  That means we don't need typcache.c to
     * provide compiled exprs.
     */</comment>
    <expr_stmt><expr><name>constraint_ref</name> <operator>=</operator> <operator>(</operator><name>DomainConstraintRef</name> <operator>*</operator><operator>)</operator>
        <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DomainConstraintRef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>InitDomainConstraintRef</name><argument_list>(<argument><expr><name><name>ctest</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>,
                            <argument><expr><name>constraint_ref</name></expr></argument>,
                            <argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                            <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Compile code to check each domain constraint.  NOTNULL constraints can
     * just be applied on the resv/resnull value, but for CHECK constraints we
     * need more pushups.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>constraint_ref-&gt;constraints</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>DomainConstraintState</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>DomainConstraintState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>constraintname</name></name> <operator>=</operator> <name><name>con</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>constrainttype</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>DOM_CONSTRAINT_NOTNULL</name></expr>:</case>
                <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_DOMAIN_NOTNULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>DOM_CONSTRAINT_CHECK</name></expr>:</case>
                <comment type="block">/* Allocate workspace for CHECK output if we didn't yet */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>checkvalue</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>checkvalue</name></name> <operator>=</operator>
                        <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>checknull</name></name> <operator>=</operator>
                        <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * If first time through, determine where CoerceToDomainValue
                 * nodes should read from.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>domainval</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/*
                     * Since value might be read multiple times, force to R/O
                     * - but only if it could be an expanded datum.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><call><name>get_typlen</name><argument_list>(<argument><expr><name><name>ctest</name><operator>-&gt;</operator><name>resulttype</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* Yes, so make output workspace for MAKE_READONLY */</comment>
                        <expr_stmt><expr><name>domainval</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>domainnull</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/* Emit MAKE_READONLY */</comment>
                        <expr_stmt><expr><name><name>scratch2</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_MAKE_READONLY</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>scratch2</name><operator>.</operator><name>resvalue</name></name> <operator>=</operator> <name>domainval</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>scratch2</name><operator>.</operator><name>resnull</name></name> <operator>=</operator> <name>domainnull</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>scratch2</name><operator>.</operator><name>d</name><operator>.</operator><name>make_readonly</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>resv</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>scratch2</name><operator>.</operator><name>d</name><operator>.</operator><name>make_readonly</name><operator>.</operator><name>isnull</name></name> <operator>=</operator> <name>resnull</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scratch2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <comment type="block">/* No, so it's fine to read from resv/resnull */</comment>
                        <expr_stmt><expr><name>domainval</name> <operator>=</operator> <name>resv</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>domainnull</name> <operator>=</operator> <name>resnull</name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * Set up value to be returned by CoerceToDomainValue nodes.
                 * We must save and restore innermost_domainval/null fields,
                 * in case this node is itself within a check expression for
                 * another domain.
                 */</comment>
                <expr_stmt><expr><name>save_innermost_domainval</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_domainval</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>save_innermost_domainnull</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>innermost_domainnull</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_domainval</name></name> <operator>=</operator> <name>domainval</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_domainnull</name></name> <operator>=</operator> <name>domainnull</name></expr>;</expr_stmt>

                <comment type="block">/* evaluate check expression value */</comment>
                <expr_stmt><expr><call><name>ExecInitExprRec</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>check_expr</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>state</name></expr></argument>,
                                <argument><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>checkvalue</name></name></expr></argument>,
                                <argument><expr><name><name>scratch</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>domaincheck</name><operator>.</operator><name>checknull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_domainval</name></name> <operator>=</operator> <name>save_innermost_domainval</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>innermost_domainnull</name></name> <operator>=</operator> <name>save_innermost_domainnull</name></expr>;</expr_stmt>

                <comment type="block">/* now test result */</comment>
                <expr_stmt><expr><name><name>scratch</name><operator>-&gt;</operator><name>opcode</name></name> <operator>=</operator> <name>EEOP_DOMAIN_CHECK</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ExprEvalPushStep</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized constraint type: %d"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>con</name><operator>-&gt;</operator><name>constrainttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block>
</block_content>}</block></function>
</unit>
