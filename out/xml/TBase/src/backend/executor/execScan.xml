<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/executor/execScan.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * execScan.c
 *      This code provides support for generalized relation scans. ExecScan
 *      is passed a node and a pointer to a function to "do the right thing"
 *      and return a tuple from the relation. ExecScan then does the tedious
 *      stuff - checking the qualification and projecting the tuple
 *      appropriately.
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/executor/execScan.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/mls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datamask.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"audit/audit_fga.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgxc/shardmap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/nodelock.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>tlist_matches_tupdesc</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>ps</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * ExecScanFetch -- fetch next potential tuple
 *
 * This routine is concerned with substituting a test tuple if we are
 * inside an EvalPlanQual recheck.  If we aren't, just execute
 * the access method's next-tuple routine.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecScanFetch</name><parameter_list>(<parameter><decl><type><name>ScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
              <parameter><decl><type><name>ExecScanAccessMtd</name></type> <name>accessMtd</name></decl></parameter>,
              <parameter><decl><type><name>ExecScanRecheckMtd</name></type> <name>recheckMtd</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>EState</name>       <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTuple</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We are inside an EvalPlanQual recheck.  Return the test tuple if
         * one is available, after rechecking any access-method-specific
         * conditions.
         */</comment>
        <decl_stmt><decl><type><name>Index</name></type>        <name>scanrelid</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>scanrelid</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>scanrelid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss_ScanTupleSlot</name></name></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * This is a ForeignScan or CustomScan which has pushed down a
             * join to the remote side.  The recheck method is responsible not
             * only for rechecking the scan/join quals but also for storing
             * the correct tuple in the slot.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call>(<modifier>*</modifier><name>recheckMtd</name>) <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* would not be returned by scan */</comment>
            <return>return <expr><name>slot</name></expr>;</return>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTupleSet</name><index>[<expr><name>scanrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss_ScanTupleSlot</name></name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Return empty slot if we already returned a tuple */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqScanDone</name><index>[<expr><name>scanrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
            <comment type="block">/* Else mark to remember that we shouldn't return more */</comment>
            <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqScanDone</name><index>[<expr><name>scanrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <comment type="block">/* Return empty slot if we haven't got a test tuple */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTuple</name><index>[<expr><name>scanrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

            <comment type="block">/* Store test tuple in the plan node's scan slot */</comment>
            <expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqTuple</name><index>[<expr><name>scanrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
                           <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Check if it meets the access-method conditions */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call>(<modifier>*</modifier><name>recheckMtd</name>) <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>    <comment type="block">/* would not be returned by scan */</comment>

            <return>return <expr><name>slot</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Run the node-type-specific access method function to get the next tuple
     */</comment>
    <return>return <expr><call>(<modifier>*</modifier><name>accessMtd</name>) <argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecScan
 *
 *        Scans the relation using the 'access method' indicated and
 *        returns the next qualifying tuple in the direction specified
 *        in the global variable ExecDirection.
 *        The access method returns the next tuple and ExecScan() is
 *        responsible for checking the tuple returned against the qual-clause.
 *
 *        A 'recheck method' must also be provided that can check an
 *        arbitrary tuple of the relation against any qual conditions
 *        that are implemented internal to the access method.
 *
 *        Conditions:
 *          -- the "cursor" maintained by the AMI is positioned at the tuple
 *             returned previously.
 *
 *        Initial States:
 *          -- the relation indicated is opened for scanning so that the
 *             "cursor" is positioned before the first qualifying tuple.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecScan</name><parameter_list>(<parameter><decl><type><name>ScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
         <parameter><decl><type><name>ExecScanAccessMtd</name></type> <name>accessMtd</name></decl></parameter>,    <comment type="block">/* function returning a tuple */</comment>
         <parameter><decl><type><name>ExecScanRecheckMtd</name></type> <name>recheckMtd</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ProjectionInfo</name> <modifier>*</modifier></type><name>projInfo</name></decl>;</decl_stmt>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
	<decl_stmt><decl><type><name>ShardID</name></type> 	<name>shardid</name> <init>= <expr><name>InvalidShardID</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>      <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd_type</name> <init>= <expr><literal type="string">"SELECT"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CmdType</name></type>    <name>commandType</name> <init>= <expr><name>CMD_SELECT</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_plannedstmt</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>commandType</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name><operator>-&gt;</operator><name>es_plannedstmt</name><operator>-&gt;</operator><name>commandType</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Fetch data from node
     */</comment>
    <expr_stmt><expr><name>qual</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>qual</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>projInfo</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>econtext</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__COLD_HOT__</name></cpp:ifdef>
    <comment type="block">/* prune hot data only if select */</comment>
    <if_stmt><if>if <condition>(<expr><name>commandType</name> <operator>==</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>inited</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>inited</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>g_EnableColdHotVisible</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ScanNeedExecute</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss_currentRelation</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If we have neither a qual to check nor a projection to do, just skip
     * all the overhead and return the raw scan tuple.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>qual</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>projInfo</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>audit_fga_qual</name></name> <operator>&amp;&amp;</operator> <name>enable_fga</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>qual</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>projInfo</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <block>{<block_content>

<label><name>next_record</name>:</label>
        
        <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
        <block>{<block_content>
            <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecScanFetch</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>accessMtd</name></expr></argument>, <argument><expr><name>recheckMtd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>g_enable_user_authority_force_check</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>SKIP_TUPLE</name> <operator>==</operator> <call><name>ExecCheckPgclassAuthority</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <goto>goto <name>next_record</name>;</goto>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><call><name>MlsExecCheck</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if<condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>datamask_scan_key_contain_mask</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
            <comment type="block">/* update shard statistic info about select if needed */</comment>
            <if_stmt><if>if <condition>(<expr><name>g_StatShardInfo</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>IS_PGXC_DATANODE</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SeqScanState</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SampleScanState</name></expr></argument>)</argument_list></call> <operator>||</operator>
                    <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>IndexScanState</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>BitmapHeapScanState</name></expr></argument>)</argument_list></call> <operator>||</operator>
                    <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>TidScanState</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>HeapTuple</name></type> <name>tup</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>UpdateShardStatistic</name><argument_list>(<argument><expr><name>CMD_SELECT</name></expr></argument>, <argument><expr><call><name>HeapTupleGetShardId</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>LightLockCheck</name><argument_list>(<argument><expr><name>commandType</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><call><name>HeapTupleGetShardId</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            
            <return>return <expr><name>slot</name></expr>;</return>
        </block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <return>return <expr><call><name>ExecScanFetch</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>accessMtd</name></expr></argument>, <argument><expr><name>recheckMtd</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        
    </block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Reset per-tuple memory context to free any expression evaluation
     * storage allocated in the previous tuple cycle.
     */</comment>
    <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * get a tuple from the access method.  Loop until we obtain a tuple that
     * passes the qualification.
     */</comment>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecScanFetch</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>accessMtd</name></expr></argument>, <argument><expr><name>recheckMtd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * if the slot returned by the accessMtd contains NULL, then it means
         * there is nothing more to scan so we just return an empty slot,
         * being careful to use the projection result slot so it has correct
         * tupleDesc.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>projInfo</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>projInfo</name><operator>-&gt;</operator><name>pi_state</name><operator>.</operator><name>resultslot</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <return>return <expr><name>slot</name></expr>;</return></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
		<expr_stmt><expr><name>shardid</name> <operator>=</operator> <name>InvalidShardID</name></expr>;</expr_stmt>
        <comment type="block">/* update shard statistic info about select if needed */</comment>
        <if_stmt><if>if <condition>(<expr><name>g_StatShardInfo</name> <operator>&amp;&amp;</operator> <name>IS_PGXC_DATANODE</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SeqScanState</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SampleScanState</name></expr></argument>)</argument_list></call> <operator>||</operator>
                <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>IndexScanState</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>BitmapHeapScanState</name></expr></argument>)</argument_list></call> <operator>||</operator>
                <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>TidScanState</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>HeapTuple</name></type> <name>tup</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>tts_tuple</name></name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>UpdateShardStatistic</name><argument_list>(<argument><expr><name>CMD_SELECT</name></expr></argument>, <argument><expr><call><name>HeapTupleGetShardId</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>shardid</name> <operator>=</operator> <call><name>HeapTupleGetShardId</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * place the current tuple into the expr context
         */</comment>
        <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name>g_enable_user_authority_force_check</name></expr> )</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>SKIP_TUPLE</name> <operator>==</operator> <call><name>ExecCheckPgclassAuthority</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>MlsExecCheck</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/*
         * check that the current tuple satisfies the qual-clause
         *
         * check for non-null qual here to avoid a function call to ExecQual()
         * when the qual is null ... saves only a few cycles, but they add up
         * ...
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>qual</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>ExecQual</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__AUDIT_FGA__</name></cpp:ifdef>
            <if_stmt><if>if <condition>(<expr><name>enable_fga</name> <operator>&amp;&amp;</operator> <name>g_commandTag</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>g_commandTag</name></expr></argument>, <argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <macro><name>foreach</name> <argument_list>(<argument>item</argument>, <argument>node-&gt;ps.audit_fga_qual</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>audit_fga_policy_state</name> <modifier>*</modifier></type><name>audit_fga_qual</name> <init>= <expr><operator>(</operator><name>audit_fga_policy_state</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if_stmt><if>if <condition>(<expr><name>audit_fga_qual</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if<condition>(<expr><call><name>ExecQual</name><argument_list>(<argument><expr><name><name>audit_fga_qual</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>audit_fga_log_policy_info_2</name><argument_list>(<argument><expr><name>audit_fga_qual</name></expr></argument>, <argument><expr><name>cmd_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>audit_fga_qual</name></name> <operator>=</operator> <call><name>list_delete</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>audit_fga_qual</name></name></expr></argument>, <argument><expr><name>audit_fga_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block></if></if_stmt>   
                </block_content>}</block>
            </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__TBASE__</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>IS_PGXC_DATANODE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>LightLockCheck</name><argument_list>(<argument><expr><name>commandType</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>shardid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/*             * Found a satisfactory scan tuple.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>projInfo</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Form a projection tuple, store it in the result tuple slot
                 * and return it.
                 */</comment>
                <return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name>projInfo</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * Here, we aren't projecting, so just return scan tuple.
                 */</comment>
                <return>return <expr><name>slot</name></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>InstrCountFiltered1</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/*
         * Tuple fails qual, so free per-tuple memory and try again.
         */</comment>
        <expr_stmt><expr><call><name>ResetExprContext</name><argument_list>(<argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * ExecAssignScanProjectionInfo
 *        Set up projection info for a scan node, if necessary.
 *
 * We can avoid a projection step if the requested tlist exactly matches
 * the underlying tuple type.  If so, we just set ps_ProjInfo to NULL.
 * Note that this case occurs not only for simple "SELECT * FROM ...", but
 * also in most cases where there are joins or other processing nodes above
 * the scan node, because the planner will preferentially generate a matching
 * tlist.
 *
 * ExecAssignScanType must have been called already.
 */</comment>
<function><type><name>void</name></type>
<name>ExecAssignScanProjectionInfo</name><parameter_list>(<parameter><decl><type><name>ScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Scan</name>       <modifier>*</modifier></type><name>scan</name> <init>= <expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ExecAssignScanProjectionInfoWithVarno</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>scanrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ExecAssignScanProjectionInfoWithVarno
 *        As above, but caller can specify varno expected in Vars in the tlist.
 */</comment>
<function><type><name>void</name></type>
<name>ExecAssignScanProjectionInfoWithVarno</name><parameter_list>(<parameter><decl><type><name>ScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Scan</name>       <modifier>*</modifier></type><name>scan</name> <init>= <expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>tlist_matches_tupdesc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>,
                              <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
                              <argument><expr><name>varno</name></expr></argument>,
                              <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss_ScanTupleSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecAssignProjectionInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ps</name></name></expr></argument>,
                                 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss_ScanTupleSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>tlist_matches_tupdesc</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>ps</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>numattrs</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>attrno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>hasoid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tlist_item</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Check the tlist attributes */</comment>
    <for>for <control>(<init><expr><name>attrno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attrno</name> <operator>&lt;=</operator> <name>numattrs</name></expr>;</condition> <incr><expr><name>attrno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>attrno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Var</name>           <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>tlist_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>        <comment type="block">/* tlist too short */</comment>
        <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tlist_item</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>expr</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>var</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>        <comment type="block">/* tlist item not a Var */</comment>
        <comment type="block">/* if these Asserts fail, planner messed up */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>!=</operator> <name>attrno</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>        <comment type="block">/* out of order */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>att_tup</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>        <comment type="block">/* table contains dropped columns */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MLS_</name></cpp:ifdef>
        <if_stmt><if>if <condition>(<expr><name><name>att_tup</name><operator>-&gt;</operator><name>atthasmissing</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>       <comment type="block">/* table contains cols with missing values */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="block">/*
         * Note: usually the Var's type should match the tupdesc exactly, but
         * in situations involving unions of columns that have different
         * typmods, the Var may have come from above the union and hence have
         * typmod -1.  This is a legitimate situation since the Var still
         * describes the column, just not as exactly as the tupdesc does. We
         * could change the planner to prevent it, but it'd then insert
         * projection steps just to convert from specific typmod to typmod -1,
         * which is pretty silly.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>vartype</name></name> <operator>!=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>||</operator>
            <operator>(</operator><name><name>var</name><operator>-&gt;</operator><name>vartypmod</name></name> <operator>!=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>&amp;&amp;</operator>
             <name><name>var</name><operator>-&gt;</operator><name>vartypmod</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>        <comment type="block">/* type mismatch */</comment>

        <expr_stmt><expr><name>tlist_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>tlist_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>tlist_item</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>            <comment type="block">/* tlist too long */</comment>

    <comment type="block">/*
     * If the plan context requires a particular hasoid setting, then that has
     * to match, too.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ExecContextForcesOids</name><argument_list>(<argument><expr><name>ps</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hasoid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <name>hasoid</name> <operator>!=</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecScanReScan
 *
 * This must be called within the ReScan function of any plan node type
 * that uses ExecScan().
 */</comment>
<function><type><name>void</name></type>
<name>ExecScanReScan</name><parameter_list>(<parameter><decl><type><name>ScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>EState</name>       <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Rescan EvalPlanQual tuple if we're inside an EvalPlanQual recheck */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqScanDone</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Index</name></type>        <name>scanrelid</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>scanrelid</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>scanrelid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqScanDone</name><index>[<expr><name>scanrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>relids</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>rtindex</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * If an FDW or custom scan provider has replaced the join with a
             * scan, there are multiple RTIs; reset the epqScanDone flag for
             * all of them.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>ForeignScan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>relids</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>fs_relids</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>, <argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>relids</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name><operator>)</operator><operator>-&gt;</operator><name>custom_relids</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected scan node: %d"</literal></expr></argument>,
                     <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <while>while <condition>(<expr><operator>(</operator><name>rtindex</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>relids</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rtindex</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_epqScanDone</name><index>[<expr><name>rtindex</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></while>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
