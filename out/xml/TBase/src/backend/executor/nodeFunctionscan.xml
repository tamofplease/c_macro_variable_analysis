<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TBase/src/backend/executor/nodeFunctionscan.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * nodeFunctionscan.c
 *      Support routines for scanning RangeFunctions (functions in rangetable).
 *
 * Portions Copyright (c) 1996-2017, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *      src/backend/executor/nodeFunctionscan.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<comment type="block">/*
 * INTERFACE ROUTINES
 *        ExecFunctionScan        scans a function.
 *        ExecFunctionNext        retrieve next tuple in sequential order.
 *        ExecInitFunctionScan    creates and initializes a functionscan node.
 *        ExecEndFunctionScan        releases any storage allocated.
 *        ExecReScanFunctionScan    rescans the function
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeFunctionscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Runtime data for each function being scanned.
 */</comment>
<typedef>typedef <type><struct>struct <name>FunctionScanPerFuncState</name>
<block>{
    <decl_stmt><decl><type><name>SetExprState</name> <modifier>*</modifier></type><name>setexpr</name></decl>;</decl_stmt>        <comment type="block">/* state of the expression being evaluated */</comment>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>        <comment type="block">/* desc of the function result type */</comment>
    <decl_stmt><decl><type><name>int</name></type>            <name>colcount</name></decl>;</decl_stmt>        <comment type="block">/* expected number of result columns */</comment>
    <decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tstore</name></decl>;</decl_stmt>    <comment type="block">/* holds the function result set */</comment>
    <decl_stmt><decl><type><name>int64</name></type>        <name>rowcount</name></decl>;</decl_stmt>        <comment type="block">/* # of rows in result set, -1 if not known */</comment>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>func_slot</name></decl>;</decl_stmt>    <comment type="block">/* function result slot (or NULL) */</comment>
}</block></struct></type> <name>FunctionScanPerFuncState</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>FunctionNext</name><parameter_list>(<parameter><decl><type><name>FunctionScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ----------------------------------------------------------------
 *                        Scan Support
 * ----------------------------------------------------------------
 */</comment>
<comment type="block">/* ----------------------------------------------------------------
 *        FunctionNext
 *
 *        This is a workhorse for ExecFunctionScan
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>FunctionNext</name><parameter_list>(<parameter><decl><type><name>FunctionScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>EState</name>       <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ScanDirection</name></type> <name>direction</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>scanslot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>alldone</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type>        <name>oldpos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>funcno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>att</name></decl>;</decl_stmt>

    <comment type="block">/*
     * get information from the estate and scan state
     */</comment>
    <expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>direction</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_direction</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>scanslot</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>simple</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Fast path for the trivial case: the function return type and scan
         * result type are the same, so we fetch the function result straight
         * into the scan result slot. No need to update ordinality or
         * rowcounts either.
         */</comment>
        <decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tstore</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>funcstates</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tstore</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * If first time through, read all tuples from function and put them
         * in a tuplestore. Subsequent calls just fetch tuples from
         * tuplestore.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>tstore</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>funcstates</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tstore</name> <operator>=</operator> <name>tstore</name> <operator>=</operator>
                <call><name>ExecMakeTableFunctionResult</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>funcstates</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>setexpr</name></expr></argument>,
                                            <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></argument>,
                                            <argument><expr><name><name>node</name><operator>-&gt;</operator><name>argcontext</name></name></expr></argument>,
                                            <argument><expr><name><name>node</name><operator>-&gt;</operator><name>funcstates</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tupdesc</name></expr></argument>,
                                            <argument><expr><name><name>node</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_BACKWARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * paranoia - cope if the function, which may have constructed the
             * tuplestore itself, didn't leave it pointing at the start. This
             * call is fast, so the overhead shouldn't be an issue.
             */</comment>
            <expr_stmt><expr><call><name>tuplestore_rescan</name><argument_list>(<argument><expr><name>tstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Get the next tuple from tuplestore.
         */</comment>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name>tstore</name></expr></argument>,
                                       <argument><expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><name>false</name></expr></argument>,
                                       <argument><expr><name>scanslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>scanslot</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Increment or decrement ordinal counter before checking for end-of-data,
     * so that we can move off either end of the result by 1 (and no more than
     * 1) without losing correct count.  See PortalRunSelect for why we can
     * assume that we won't be called repeatedly in the end-of-data state.
     */</comment>
    <expr_stmt><expr><name>oldpos</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ordinal</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ordinal</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ordinal</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Main loop over functions.
     *
     * We fetch the function results into func_slots (which match the function
     * return types), and then copy the values to scanslot (which matches the
     * scan result type), setting the ordinal column (if any) as well.
     */</comment>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>scanslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>att</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>alldone</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>funcno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>funcno</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nfuncs</name></name></expr>;</condition> <incr><expr><name>funcno</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>FunctionScanPerFuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>funcstates</name><index>[<expr><name>funcno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

        <comment type="block">/*
         * If first time through, read all tuples from function and put them
         * in a tuplestore. Subsequent calls just fetch tuples from
         * tuplestore.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>tstore</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>tstore</name></name> <operator>=</operator>
                <call><name>ExecMakeTableFunctionResult</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>setexpr</name></name></expr></argument>,
                                            <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></argument>,
                                            <argument><expr><name><name>node</name><operator>-&gt;</operator><name>argcontext</name></name></expr></argument>,
                                            <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>,
                                            <argument><expr><name><name>node</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_BACKWARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * paranoia - cope if the function, which may have constructed the
             * tuplestore itself, didn't leave it pointing at the start. This
             * call is fast, so the overhead shouldn't be an issue.
             */</comment>
            <expr_stmt><expr><call><name>tuplestore_rescan</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>tstore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Get the next tuple from tuplestore.
         *
         * If we have a rowcount for the function, and we know the previous
         * read position was out of bounds, don't try the read. This allows
         * backward scan to work when there are mixed row counts present.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>rowcount</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>fs</name><operator>-&gt;</operator><name>rowcount</name></name> <operator>&lt;</operator> <name>oldpos</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>func_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>tuplestore_gettupleslot</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>tstore</name></name></expr></argument>,
                                           <argument><expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><name>false</name></expr></argument>,
                                           <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>func_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>func_slot</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If we ran out of data for this function in the forward
             * direction then we now know how many rows it returned. We need
             * to know this in order to handle backwards scans. The row count
             * we store is actually 1+ the actual number, because we have to
             * position the tuplestore 1 off its end sometimes.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>ScanDirectionIsForward</name><argument_list>(<argument><expr><name>direction</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>fs</name><operator>-&gt;</operator><name>rowcount</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>rowcount</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ordinal</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/*
             * populate the result cols with nulls
             */</comment>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fs</name><operator>-&gt;</operator><name>colcount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>scanslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>att</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scanslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>att</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>att</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * we have a result, so just copy it to the result cols.
             */</comment>
            <expr_stmt><expr><call><name>slot_getallattrs</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>func_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fs</name><operator>-&gt;</operator><name>colcount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>scanslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>att</name></expr>]</index></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>func_slot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>scanslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>att</name></expr>]</index></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>func_slot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>att</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block></for>

            <comment type="block">/*
             * We're not done until every function result is exhausted; we pad
             * the shorter results with nulls until then.
             */</comment>
            <expr_stmt><expr><name>alldone</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * ordinal col is always last, per spec.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ordinality</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>scanslot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>att</name></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatumFast</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ordinal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scanslot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>att</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If alldone, we just return the previously-cleared scanslot.  Otherwise,
     * finish creating the virtual tuple.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>alldone</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>scanslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>scanslot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FunctionRecheck -- access method routine to recheck a tuple in EvalPlanQual
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>FunctionRecheck</name><parameter_list>(<parameter><decl><type><name>FunctionScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* nothing to check */</comment>
    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecFunctionScan(node)
 *
 *        Scans the function sequentially and returns the next qualifying
 *        tuple.
 *        We call the ExecScan() routine and pass it the appropriate
 *        access method functions.
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>ExecFunctionScan</name><parameter_list>(<parameter><decl><type><name>PlanState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FunctionScanState</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>FunctionScanState</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>ExecScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>,
                    <argument><expr><operator>(</operator><name>ExecScanAccessMtd</name><operator>)</operator> <name>FunctionNext</name></expr></argument>,
                    <argument><expr><operator>(</operator><name>ExecScanRecheckMtd</name><operator>)</operator> <name>FunctionRecheck</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecInitFunctionScan
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>FunctionScanState</name> <modifier>*</modifier></type>
<name>ExecInitFunctionScan</name><parameter_list>(<parameter><decl><type><name>FunctionScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>FunctionScanState</name> <modifier>*</modifier></type><name>scanstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>nfuncs</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>scan_tupdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>,
                <decl><type ref="prev"/><name>natts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/* check for unsupported flags */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>eflags</name> <operator>&amp;</operator> <name>EXEC_FLAG_MARK</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * FunctionScan should not have any children.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>outerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>innerPlan</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * create new ScanState for node
     */</comment>
    <expr_stmt><expr><name>scanstate</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>FunctionScanState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ExecProcNode</name></name> <operator>=</operator> <name>ExecFunctionScan</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>eflags</name></name> <operator>=</operator> <name>eflags</name></expr>;</expr_stmt>

    <comment type="block">/*
     * are we adding an ordinality column?
     */</comment>
    <expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ordinality</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>funcordinality</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>nfuncs</name></name> <operator>=</operator> <name>nfuncs</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>nfuncs</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>funcordinality</name></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>simple</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>simple</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * Ordinal 0 represents the "before the first row" position.
     *
     * We need to track ordinal position even when not adding an ordinality
     * column to the result, in order to handle backwards scanning properly
     * with multiple functions with different result sizes. (We can't position
     * any individual function's tuplestore any more than 1 place beyond its
     * end, so when scanning backwards, we need to know when to start
     * including the function in the scan again.)
     */</comment>
    <expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ordinal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Miscellaneous initialization
     *
     * create expression context for node
     */</comment>
    <expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * tuple table initialization
     */</comment>
    <expr_stmt><expr><call><name>ExecInitResultTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecInitScanTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * initialize child expressions
     */</comment>
    <expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>qual</name></name> <operator>=</operator>
        <call><name>ExecInitQual</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>PlanState</name> <operator>*</operator><operator>)</operator> <name>scanstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>funcstates</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nfuncs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FunctionScanPerFuncState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>natts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>node-&gt;functions</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>funcexpr</name> <init>= <expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type>            <name>colcount</name> <init>= <expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccolcount</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>FunctionScanPerFuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><operator>&amp;</operator><name><name>scanstate</name><operator>-&gt;</operator><name>funcstates</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TypeFuncClass</name></type> <name>functypclass</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type>            <name>funcrettype</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>setexpr</name></name> <operator>=</operator>
            <call><name>ExecInitTableFunctionResult</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>funcexpr</name></expr></argument>,
                                        <argument><expr><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Don't allocate the tuplestores; the actual calls to the functions
         * do that.  NULL means that we have not called the function yet (or
         * need to call it again after a rescan).
         */</comment>
        <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>tstore</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>rowcount</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

        <comment type="block">/*
         * Now determine if the function returns a simple or composite type,
         * and build an appropriate tupdesc.  Note that in the composite case,
         * the function may now return more columns than it did when the plan
         * was made; we have to ignore any columns beyond "colcount".
         */</comment>
        <expr_stmt><expr><name>functypclass</name> <operator>=</operator> <call><name>get_expr_result_type</name><argument_list>(<argument><expr><name>funcexpr</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>funcrettype</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Composite data type, e.g. a table's row type */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>&gt;=</operator> <name>colcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Must copy it out of typcache for safety */</comment>
            <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_SCALAR</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Base data type, i.e. scalar */</comment>
            <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>,
                               <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>,
                               <argument><expr><name>NULL</name></expr></argument>,    <comment type="block">/* don't care about the name here */</comment>
                               <argument><expr><name>funcrettype</name></expr></argument>,
                               <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                               <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>TupleDescInitEntryCollation</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>,
                                        <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>,
                                        <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><name>funcexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>functypclass</name> <operator>==</operator> <name>TYPEFUNC_RECORD</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>BuildDescFromLists</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccolnames</name></name></expr></argument>,
                                         <argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccoltypes</name></name></expr></argument>,
                                         <argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccoltypmods</name></name></expr></argument>,
                                         <argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccolcollations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * For RECORD results, make sure a typmod has been assigned.  (The
             * function should do this for itself, but let's cover things in
             * case it doesn't.)
             */</comment>
            <expr_stmt><expr><call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* crummy error message, but parser should have caught this */</comment>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"function in FROM has unsupported return type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>tupdesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>colcount</name></name> <operator>=</operator> <name>colcount</name></expr>;</expr_stmt>

        <comment type="block">/*
         * We only need separate slots for the function results if we are
         * doing ordinality or multiple functions; otherwise, we'll fetch
         * function results directly into the scan slot.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>scanstate</name><operator>-&gt;</operator><name>simple</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>func_slot</name></name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ExecSetSlotDescriptor</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>func_slot</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>func_slot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>natts</name> <operator>+=</operator> <name>colcount</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Create the combined TupleDesc
     *
     * If there is just one function without ordinality, the scan result
     * tupdesc is the same as the function result tupdesc --- except that we
     * may stuff new names into it below, so drop any rowtype label.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>scanstate</name><operator>-&gt;</operator><name>simple</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>scan_tupdesc</name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name><name>scanstate</name><operator>-&gt;</operator><name>funcstates</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scan_tupdesc</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>=</operator> <name>RECORDOID</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scan_tupdesc</name><operator>-&gt;</operator><name>tdtypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>AttrNumber</name></type>    <name>attno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>funcordinality</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>natts</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>scan_tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>natts</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nfuncs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>TupleDesc</name></type>    <name>tupdesc</name> <init>= <expr><name><name>scanstate</name><operator>-&gt;</operator><name>funcstates</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tupdesc</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>colcount</name> <init>= <expr><name><name>scanstate</name><operator>-&gt;</operator><name>funcstates</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>colcount</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type>            <name>j</name></decl>;</decl_stmt>

            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>colcount</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>TupleDescCopyEntry</name><argument_list>(<argument><expr><name>scan_tupdesc</name></expr></argument>, <argument><expr><operator>++</operator><name>attno</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
        </block_content>}</block></for>

        <comment type="block">/* If doing ordinality, add a column of type "bigint" at the end */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>funcordinality</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>scan_tupdesc</name></expr></argument>,
                               <argument><expr><operator>++</operator><name>attno</name></expr></argument>,
                               <argument><expr><name>NULL</name></expr></argument>,    <comment type="block">/* don't care about the name here */</comment>
                               <argument><expr><name>INT8OID</name></expr></argument>,
                               <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                               <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attno</name> <operator>==</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>ExecAssignScanType</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>, <argument><expr><name>scan_tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize result tuple type and projection info.
     */</comment>
    <expr_stmt><expr><call><name>ExecAssignResultTypeFromTL</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecAssignScanProjectionInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scanstate</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create a memory context that ExecMakeTableFunctionResult can use to
     * evaluate function arguments in.  We can't use the per-tuple context for
     * this because it gets reset too often; but we don't want to leak
     * evaluation results into the query-lifespan context either.  We just
     * need one context, because we evaluate each function separately.
     */</comment>
    <expr_stmt><expr><name><name>scanstate</name><operator>-&gt;</operator><name>argcontext</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                                                  <argument><expr><literal type="string">"Table function arguments"</literal></expr></argument>,
                                                  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>scanstate</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecEndFunctionScan
 *
 *        frees any storage allocated through C routines.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecEndFunctionScan</name><parameter_list>(<parameter><decl><type><name>FunctionScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Free the exprcontext
     */</comment>
    <expr_stmt><expr><call><name>ExecFreeExprContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * clean out the tuple table
     */</comment>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Release slots and tuplestore resources
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nfuncs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>FunctionScanPerFuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>funcstates</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>func_slot</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>func_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>tstore</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>funcstates</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>tstore</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *        ExecReScanFunctionScan
 *
 *        Rescans the relation.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>ExecReScanFunctionScan</name><parameter_list>(<parameter><decl><type><name>FunctionScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content><comment type="line">// #lizard forgives</comment>
    <decl_stmt><decl><type><name>FunctionScan</name> <modifier>*</modifier></type><name>scan</name> <init>= <expr><operator>(</operator><name>FunctionScan</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>plan</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>            <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>chgparam</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>chgParam</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ResultTupleSlot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nfuncs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>FunctionScanPerFuncState</name> <modifier>*</modifier></type><name>fs</name> <init>= <expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>funcstates</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>func_slot</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>func_slot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><call><name>ExecScanReScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Here we have a choice whether to drop the tuplestores (and recompute
     * the function outputs) or just rescan them.  We must recompute if an
     * expression contains changed parameters, else we rescan.
     *
     * XXX maybe we should recompute if the function is volatile?  But in
     * general the executor doesn't conditionalize its actions on that.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>chgparam</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>scan-&gt;functions</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>bms_overlap</name><argument_list>(<argument><expr><name>chgparam</name></expr></argument>, <argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcparams</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>funcstates</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tstore</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>tuplestore_end</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>funcstates</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>funcstates</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tstore</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>funcstates</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rowcount</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Reset ordinality counter */</comment>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ordinal</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* Make sure we rewind any remaining tuplestores */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nfuncs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>funcstates</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tstore</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>tuplestore_rescan</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>funcstates</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>tstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>
</unit>
